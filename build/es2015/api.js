(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.io = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var url = _dereq_('./url');
var parser = _dereq_('socket.io-parser');
var Manager = _dereq_('./manager');
var debug = _dereq_('debug')('socket.io-client');

/**
 * Module exports.
 */

module.exports = exports = lookup;

/**
 * Managers cache.
 */

var cache = exports.managers = {};

/**
 * Looks up an existing `Manager` for multiplexing.
 * If the user summons:
 *
 *   `io('http://localhost/a');`
 *   `io('http://localhost/b');`
 *
 * We reuse the existing instance based on same scheme/port/host,
 * and we initialize sockets for each namespace.
 *
 * @api public
 */

function lookup(uri, opts) {
  if (typeof uri == 'object') {
    opts = uri;
    uri = undefined;
  }

  opts = opts || {};

  var parsed = url(uri);
  var source = parsed.source;
  var id = parsed.id;
  var path = parsed.path;
  var sameNamespace = cache[id] && path in cache[id].nsps;
  var newConnection = opts.forceNew || opts['force new connection'] ||
                      false === opts.multiplex || sameNamespace;

  var io;

  if (newConnection) {
    debug('ignoring socket cache for %s', source);
    io = Manager(source, opts);
  } else {
    if (!cache[id]) {
      debug('new io instance for %s', source);
      cache[id] = Manager(source, opts);
    }
    io = cache[id];
  }

  return io.socket(parsed.path);
}

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = parser.protocol;

/**
 * `connect`.
 *
 * @param {String} uri
 * @api public
 */

exports.connect = lookup;

/**
 * Expose constructors for standalone build.
 *
 * @api public
 */

exports.Manager = _dereq_('./manager');
exports.Socket = _dereq_('./socket');

},{"./manager":2,"./socket":4,"./url":5,"debug":14,"socket.io-parser":40}],2:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var eio = _dereq_('engine.io-client');
var Socket = _dereq_('./socket');
var Emitter = _dereq_('component-emitter');
var parser = _dereq_('socket.io-parser');
var on = _dereq_('./on');
var bind = _dereq_('component-bind');
var debug = _dereq_('debug')('socket.io-client:manager');
var indexOf = _dereq_('indexof');
var Backoff = _dereq_('backo2');

/**
 * IE6+ hasOwnProperty
 */

var has = Object.prototype.hasOwnProperty;

/**
 * Module exports
 */

module.exports = Manager;

/**
 * `Manager` constructor.
 *
 * @param {String} engine instance or engine uri/opts
 * @param {Object} options
 * @api public
 */

function Manager(uri, opts){
  if (!(this instanceof Manager)) return new Manager(uri, opts);
  if (uri && ('object' == typeof uri)) {
    opts = uri;
    uri = undefined;
  }
  opts = opts || {};

  opts.path = opts.path || '/socket.io';
  this.nsps = {};
  this.subs = [];
  this.opts = opts;
  this.reconnection(opts.reconnection !== false);
  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
  this.reconnectionDelay(opts.reconnectionDelay || 1000);
  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
  this.randomizationFactor(opts.randomizationFactor || 0.5);
  this.backoff = new Backoff({
    min: this.reconnectionDelay(),
    max: this.reconnectionDelayMax(),
    jitter: this.randomizationFactor()
  });
  this.timeout(null == opts.timeout ? 20000 : opts.timeout);
  this.readyState = 'closed';
  this.uri = uri;
  this.connecting = [];
  this.lastPing = null;
  this.encoding = false;
  this.packetBuffer = [];
  this.encoder = new parser.Encoder();
  this.decoder = new parser.Decoder();
  this.autoConnect = opts.autoConnect !== false;
  if (this.autoConnect) this.open();
}

/**
 * Propagate given event to sockets and emit on `this`
 *
 * @api private
 */

Manager.prototype.emitAll = function() {
  this.emit.apply(this, arguments);
  for (var nsp in this.nsps) {
    if (has.call(this.nsps, nsp)) {
      this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
    }
  }
};

/**
 * Update `socket.id` of all sockets
 *
 * @api private
 */

Manager.prototype.updateSocketIds = function(){
  for (var nsp in this.nsps) {
    if (has.call(this.nsps, nsp)) {
      this.nsps[nsp].id = this.engine.id;
    }
  }
};

/**
 * Mix in `Emitter`.
 */

Emitter(Manager.prototype);

/**
 * Sets the `reconnection` config.
 *
 * @param {Boolean} true/false if it should automatically reconnect
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnection = function(v){
  if (!arguments.length) return this._reconnection;
  this._reconnection = !!v;
  return this;
};

/**
 * Sets the reconnection attempts config.
 *
 * @param {Number} max reconnection attempts before giving up
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionAttempts = function(v){
  if (!arguments.length) return this._reconnectionAttempts;
  this._reconnectionAttempts = v;
  return this;
};

/**
 * Sets the delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelay = function(v){
  if (!arguments.length) return this._reconnectionDelay;
  this._reconnectionDelay = v;
  this.backoff && this.backoff.setMin(v);
  return this;
};

Manager.prototype.randomizationFactor = function(v){
  if (!arguments.length) return this._randomizationFactor;
  this._randomizationFactor = v;
  this.backoff && this.backoff.setJitter(v);
  return this;
};

/**
 * Sets the maximum delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelayMax = function(v){
  if (!arguments.length) return this._reconnectionDelayMax;
  this._reconnectionDelayMax = v;
  this.backoff && this.backoff.setMax(v);
  return this;
};

/**
 * Sets the connection timeout. `false` to disable
 *
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.timeout = function(v){
  if (!arguments.length) return this._timeout;
  this._timeout = v;
  return this;
};

/**
 * Starts trying to reconnect if reconnection is enabled and we have not
 * started reconnecting yet
 *
 * @api private
 */

Manager.prototype.maybeReconnectOnOpen = function() {
  // Only try to reconnect if it's the first time we're connecting
  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
    // keeps reconnection from firing twice for the same reconnection loop
    this.reconnect();
  }
};


/**
 * Sets the current transport `socket`.
 *
 * @param {Function} optional, callback
 * @return {Manager} self
 * @api public
 */

Manager.prototype.open =
Manager.prototype.connect = function(fn){
  debug('readyState %s', this.readyState);
  if (~this.readyState.indexOf('open')) return this;

  debug('opening %s', this.uri);
  this.engine = eio(this.uri, this.opts);
  var socket = this.engine;
  var self = this;
  this.readyState = 'opening';
  this.skipReconnect = false;

  // emit `open`
  var openSub = on(socket, 'open', function() {
    self.onopen();
    fn && fn();
  });

  // emit `connect_error`
  var errorSub = on(socket, 'error', function(data){
    debug('connect_error');
    self.cleanup();
    self.readyState = 'closed';
    self.emitAll('connect_error', data);
    if (fn) {
      var err = new Error('Connection error');
      err.data = data;
      fn(err);
    } else {
      // Only do this if there is no fn to handle the error
      self.maybeReconnectOnOpen();
    }
  });

  // emit `connect_timeout`
  if (false !== this._timeout) {
    var timeout = this._timeout;
    debug('connect attempt will timeout after %d', timeout);

    // set timer
    var timer = setTimeout(function(){
      debug('connect attempt timed out after %d', timeout);
      openSub.destroy();
      socket.close();
      socket.emit('error', 'timeout');
      self.emitAll('connect_timeout', timeout);
    }, timeout);

    this.subs.push({
      destroy: function(){
        clearTimeout(timer);
      }
    });
  }

  this.subs.push(openSub);
  this.subs.push(errorSub);

  return this;
};

/**
 * Called upon transport open.
 *
 * @api private
 */

Manager.prototype.onopen = function(){
  debug('open');

  // clear old subs
  this.cleanup();

  // mark as open
  this.readyState = 'open';
  this.emit('open');

  // add new subs
  var socket = this.engine;
  this.subs.push(on(socket, 'data', bind(this, 'ondata')));
  this.subs.push(on(socket, 'ping', bind(this, 'onping')));
  this.subs.push(on(socket, 'pong', bind(this, 'onpong')));
  this.subs.push(on(socket, 'error', bind(this, 'onerror')));
  this.subs.push(on(socket, 'close', bind(this, 'onclose')));
  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));
};

/**
 * Called upon a ping.
 *
 * @api private
 */

Manager.prototype.onping = function(){
  this.lastPing = new Date;
  this.emitAll('ping');
};

/**
 * Called upon a packet.
 *
 * @api private
 */

Manager.prototype.onpong = function(){
  this.emitAll('pong', new Date - this.lastPing);
};

/**
 * Called with data.
 *
 * @api private
 */

Manager.prototype.ondata = function(data){
  this.decoder.add(data);
};

/**
 * Called when parser fully decodes a packet.
 *
 * @api private
 */

Manager.prototype.ondecoded = function(packet) {
  this.emit('packet', packet);
};

/**
 * Called upon socket error.
 *
 * @api private
 */

Manager.prototype.onerror = function(err){
  debug('error', err);
  this.emitAll('error', err);
};

/**
 * Creates a new socket for the given `nsp`.
 *
 * @return {Socket}
 * @api public
 */

Manager.prototype.socket = function(nsp){
  var socket = this.nsps[nsp];
  if (!socket) {
    socket = new Socket(this, nsp);
    this.nsps[nsp] = socket;
    var self = this;
    socket.on('connecting', onConnecting);
    socket.on('connect', function(){
      socket.id = self.engine.id;
    });

    if (this.autoConnect) {
      // manually call here since connecting evnet is fired before listening
      onConnecting();
    }
  }

  function onConnecting() {
    if (!~indexOf(self.connecting, socket)) {
      self.connecting.push(socket);
    }
  }

  return socket;
};

/**
 * Called upon a socket close.
 *
 * @param {Socket} socket
 */

Manager.prototype.destroy = function(socket){
  var index = indexOf(this.connecting, socket);
  if (~index) this.connecting.splice(index, 1);
  if (this.connecting.length) return;

  this.close();
};

/**
 * Writes a packet.
 *
 * @param {Object} packet
 * @api private
 */

Manager.prototype.packet = function(packet){
  debug('writing packet %j', packet);
  var self = this;

  if (!self.encoding) {
    // encode, then write to engine with result
    self.encoding = true;
    this.encoder.encode(packet, function(encodedPackets) {
      for (var i = 0; i < encodedPackets.length; i++) {
        self.engine.write(encodedPackets[i], packet.options);
      }
      self.encoding = false;
      self.processPacketQueue();
    });
  } else { // add packet to the queue
    self.packetBuffer.push(packet);
  }
};

/**
 * If packet buffer is non-empty, begins encoding the
 * next packet in line.
 *
 * @api private
 */

Manager.prototype.processPacketQueue = function() {
  if (this.packetBuffer.length > 0 && !this.encoding) {
    var pack = this.packetBuffer.shift();
    this.packet(pack);
  }
};

/**
 * Clean up transport subscriptions and packet buffer.
 *
 * @api private
 */

Manager.prototype.cleanup = function(){
  debug('cleanup');

  var sub;
  while (sub = this.subs.shift()) sub.destroy();

  this.packetBuffer = [];
  this.encoding = false;
  this.lastPing = null;

  this.decoder.destroy();
};

/**
 * Close the current socket.
 *
 * @api private
 */

Manager.prototype.close =
Manager.prototype.disconnect = function(){
  debug('disconnect');
  this.skipReconnect = true;
  this.reconnecting = false;
  if ('opening' == this.readyState) {
    // `onclose` will not fire because
    // an open event never happened
    this.cleanup();
  }
  this.backoff.reset();
  this.readyState = 'closed';
  if (this.engine) this.engine.close();
};

/**
 * Called upon engine close.
 *
 * @api private
 */

Manager.prototype.onclose = function(reason){
  debug('onclose');

  this.cleanup();
  this.backoff.reset();
  this.readyState = 'closed';
  this.emit('close', reason);

  if (this._reconnection && !this.skipReconnect) {
    this.reconnect();
  }
};

/**
 * Attempt a reconnection.
 *
 * @api private
 */

Manager.prototype.reconnect = function(){
  if (this.reconnecting || this.skipReconnect) return this;

  var self = this;

  if (this.backoff.attempts >= this._reconnectionAttempts) {
    debug('reconnect failed');
    this.backoff.reset();
    this.emitAll('reconnect_failed');
    this.reconnecting = false;
  } else {
    var delay = this.backoff.duration();
    debug('will wait %dms before reconnect attempt', delay);

    this.reconnecting = true;
    var timer = setTimeout(function(){
      if (self.skipReconnect) return;

      debug('attempting reconnect');
      self.emitAll('reconnect_attempt', self.backoff.attempts);
      self.emitAll('reconnecting', self.backoff.attempts);

      // check again for the case socket closed in above events
      if (self.skipReconnect) return;

      self.open(function(err){
        if (err) {
          debug('reconnect attempt error');
          self.reconnecting = false;
          self.reconnect();
          self.emitAll('reconnect_error', err.data);
        } else {
          debug('reconnect success');
          self.onreconnect();
        }
      });
    }, delay);

    this.subs.push({
      destroy: function(){
        clearTimeout(timer);
      }
    });
  }
};

/**
 * Called upon successful reconnect.
 *
 * @api private
 */

Manager.prototype.onreconnect = function(){
  var attempt = this.backoff.attempts;
  this.reconnecting = false;
  this.backoff.reset();
  this.updateSocketIds();
  this.emitAll('reconnect', attempt);
};

},{"./on":3,"./socket":4,"backo2":8,"component-bind":11,"component-emitter":12,"debug":14,"engine.io-client":16,"indexof":32,"socket.io-parser":40}],3:[function(_dereq_,module,exports){

/**
 * Module exports.
 */

module.exports = on;

/**
 * Helper for subscriptions.
 *
 * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
 * @param {String} event name
 * @param {Function} callback
 * @api public
 */

function on(obj, ev, fn) {
  obj.on(ev, fn);
  return {
    destroy: function(){
      obj.removeListener(ev, fn);
    }
  };
}

},{}],4:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var parser = _dereq_('socket.io-parser');
var Emitter = _dereq_('component-emitter');
var toArray = _dereq_('to-array');
var on = _dereq_('./on');
var bind = _dereq_('component-bind');
var debug = _dereq_('debug')('socket.io-client:socket');
var hasBin = _dereq_('has-binary');

/**
 * Module exports.
 */

module.exports = exports = Socket;

/**
 * Internal events (blacklisted).
 * These events can't be emitted by the user.
 *
 * @api private
 */

var events = {
  connect: 1,
  connect_error: 1,
  connect_timeout: 1,
  connecting: 1,
  disconnect: 1,
  error: 1,
  reconnect: 1,
  reconnect_attempt: 1,
  reconnect_failed: 1,
  reconnect_error: 1,
  reconnecting: 1,
  ping: 1,
  pong: 1
};

/**
 * Shortcut to `Emitter#emit`.
 */

var emit = Emitter.prototype.emit;

/**
 * `Socket` constructor.
 *
 * @api public
 */

function Socket(io, nsp){
  this.io = io;
  this.nsp = nsp;
  this.json = this; // compat
  this.ids = 0;
  this.acks = {};
  this.receiveBuffer = [];
  this.sendBuffer = [];
  this.connected = false;
  this.disconnected = true;
  if (this.io.autoConnect) this.open();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Subscribe to open, close and packet events
 *
 * @api private
 */

Socket.prototype.subEvents = function() {
  if (this.subs) return;

  var io = this.io;
  this.subs = [
    on(io, 'open', bind(this, 'onopen')),
    on(io, 'packet', bind(this, 'onpacket')),
    on(io, 'close', bind(this, 'onclose'))
  ];
};

/**
 * "Opens" the socket.
 *
 * @api public
 */

Socket.prototype.open =
Socket.prototype.connect = function(){
  if (this.connected) return this;

  this.subEvents();
  this.io.open(); // ensure open
  if ('open' == this.io.readyState) this.onopen();
  this.emit('connecting');
  return this;
};

/**
 * Sends a `message` event.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.send = function(){
  var args = toArray(arguments);
  args.unshift('message');
  this.emit.apply(this, args);
  return this;
};

/**
 * Override `emit`.
 * If the event is in `events`, it's emitted normally.
 *
 * @param {String} event name
 * @return {Socket} self
 * @api public
 */

Socket.prototype.emit = function(ev){
  if (events.hasOwnProperty(ev)) {
    emit.apply(this, arguments);
    return this;
  }

  var args = toArray(arguments);
  var parserType = parser.EVENT; // default
  if (hasBin(args)) { parserType = parser.BINARY_EVENT; } // binary
  var packet = { type: parserType, data: args };

  packet.options = {};
  packet.options.compress = !this.flags || false !== this.flags.compress;

  // event ack callback
  if ('function' == typeof args[args.length - 1]) {
    debug('emitting packet with ack id %d', this.ids);
    this.acks[this.ids] = args.pop();
    packet.id = this.ids++;
  }

  if (this.connected) {
    this.packet(packet);
  } else {
    this.sendBuffer.push(packet);
  }

  delete this.flags;

  return this;
};

/**
 * Sends a packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.packet = function(packet){
  packet.nsp = this.nsp;
  this.io.packet(packet);
};

/**
 * Called upon engine `open`.
 *
 * @api private
 */

Socket.prototype.onopen = function(){
  debug('transport is open - connecting');

  // write connect packet if necessary
  if ('/' != this.nsp) {
    this.packet({ type: parser.CONNECT });
  }
};

/**
 * Called upon engine `close`.
 *
 * @param {String} reason
 * @api private
 */

Socket.prototype.onclose = function(reason){
  debug('close (%s)', reason);
  this.connected = false;
  this.disconnected = true;
  delete this.id;
  this.emit('disconnect', reason);
};

/**
 * Called with socket packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onpacket = function(packet){
  if (packet.nsp != this.nsp) return;

  switch (packet.type) {
    case parser.CONNECT:
      this.onconnect();
      break;

    case parser.EVENT:
      this.onevent(packet);
      break;

    case parser.BINARY_EVENT:
      this.onevent(packet);
      break;

    case parser.ACK:
      this.onack(packet);
      break;

    case parser.BINARY_ACK:
      this.onack(packet);
      break;

    case parser.DISCONNECT:
      this.ondisconnect();
      break;

    case parser.ERROR:
      this.emit('error', packet.data);
      break;
  }
};

/**
 * Called upon a server event.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onevent = function(packet){
  var args = packet.data || [];
  debug('emitting event %j', args);

  if (null != packet.id) {
    debug('attaching ack callback to event');
    args.push(this.ack(packet.id));
  }

  if (this.connected) {
    emit.apply(this, args);
  } else {
    this.receiveBuffer.push(args);
  }
};

/**
 * Produces an ack callback to emit with an event.
 *
 * @api private
 */

Socket.prototype.ack = function(id){
  var self = this;
  var sent = false;
  return function(){
    // prevent double callbacks
    if (sent) return;
    sent = true;
    var args = toArray(arguments);
    debug('sending ack %j', args);

    var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;
    self.packet({
      type: type,
      id: id,
      data: args
    });
  };
};

/**
 * Called upon a server acknowlegement.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onack = function(packet){
  var ack = this.acks[packet.id];
  if ('function' == typeof ack) {
    debug('calling ack %s with %j', packet.id, packet.data);
    ack.apply(this, packet.data);
    delete this.acks[packet.id];
  } else {
    debug('bad ack %s', packet.id);
  }
};

/**
 * Called upon server connect.
 *
 * @api private
 */

Socket.prototype.onconnect = function(){
  this.connected = true;
  this.disconnected = false;
  this.emit('connect');
  this.emitBuffered();
};

/**
 * Emit buffered events (received and emitted).
 *
 * @api private
 */

Socket.prototype.emitBuffered = function(){
  var i;
  for (i = 0; i < this.receiveBuffer.length; i++) {
    emit.apply(this, this.receiveBuffer[i]);
  }
  this.receiveBuffer = [];

  for (i = 0; i < this.sendBuffer.length; i++) {
    this.packet(this.sendBuffer[i]);
  }
  this.sendBuffer = [];
};

/**
 * Called upon server disconnect.
 *
 * @api private
 */

Socket.prototype.ondisconnect = function(){
  debug('server disconnect (%s)', this.nsp);
  this.destroy();
  this.onclose('io server disconnect');
};

/**
 * Called upon forced client/server side disconnections,
 * this method ensures the manager stops tracking us and
 * that reconnections don't get triggered for this.
 *
 * @api private.
 */

Socket.prototype.destroy = function(){
  if (this.subs) {
    // clean subscriptions to avoid reconnections
    for (var i = 0; i < this.subs.length; i++) {
      this.subs[i].destroy();
    }
    this.subs = null;
  }

  this.io.destroy(this);
};

/**
 * Disconnects the socket manually.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.close =
Socket.prototype.disconnect = function(){
  if (this.connected) {
    debug('performing disconnect (%s)', this.nsp);
    this.packet({ type: parser.DISCONNECT });
  }

  // remove socket from pool
  this.destroy();

  if (this.connected) {
    // fire events
    this.onclose('io client disconnect');
  }
  return this;
};

/**
 * Sets the compress flag.
 *
 * @param {Boolean} if `true`, compresses the sending data
 * @return {Socket} self
 * @api public
 */

Socket.prototype.compress = function(compress){
  this.flags = this.flags || {};
  this.flags.compress = compress;
  return this;
};

},{"./on":3,"component-bind":11,"component-emitter":12,"debug":14,"has-binary":30,"socket.io-parser":40,"to-array":43}],5:[function(_dereq_,module,exports){
(function (global){

/**
 * Module dependencies.
 */

var parseuri = _dereq_('parseuri');
var debug = _dereq_('debug')('socket.io-client:url');

/**
 * Module exports.
 */

module.exports = url;

/**
 * URL parser.
 *
 * @param {String} url
 * @param {Object} An object meant to mimic window.location.
 *                 Defaults to window.location.
 * @api public
 */

function url(uri, loc){
  var obj = uri;

  // default to window.location
  var loc = loc || global.location;
  if (null == uri) uri = loc.protocol + '//' + loc.host;

  // relative path support
  if ('string' == typeof uri) {
    if ('/' == uri.charAt(0)) {
      if ('/' == uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.host + uri;
      }
    }

    if (!/^(https?|wss?):\/\//.test(uri)) {
      debug('protocol-less url %s', uri);
      if ('undefined' != typeof loc) {
        uri = loc.protocol + '//' + uri;
      } else {
        uri = 'https://' + uri;
      }
    }

    // parse
    debug('parse %s', uri);
    obj = parseuri(uri);
  }

  // make sure we treat `localhost:80` and `localhost` equally
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = '80';
    }
    else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = '443';
    }
  }

  obj.path = obj.path || '/';

  var ipv6 = obj.host.indexOf(':') !== -1;
  var host = ipv6 ? '[' + obj.host + ']' : obj.host;

  // define unique id
  obj.id = obj.protocol + '://' + host + ':' + obj.port;
  // define href
  obj.href = obj.protocol + '://' + host + (loc && loc.port == obj.port ? '' : (':' + obj.port));

  return obj;
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {})
},{"debug":14,"parseuri":38}],6:[function(_dereq_,module,exports){
module.exports = after

function after(count, callback, err_cb) {
    var bail = false
    err_cb = err_cb || noop
    proxy.count = count

    return (count === 0) ? callback() : proxy

    function proxy(err, result) {
        if (proxy.count <= 0) {
            throw new Error('after called too many times')
        }
        --proxy.count

        // after first error, rest are passed to err_cb
        if (err) {
            bail = true
            callback(err)
            // future error callbacks will go to error handler
            callback = err_cb
        } else if (proxy.count === 0 && !bail) {
            callback(null, result)
        }
    }
}

function noop() {}

},{}],7:[function(_dereq_,module,exports){
/**
 * An abstraction for slicing an arraybuffer even when
 * ArrayBuffer.prototype.slice is not supported
 *
 * @api public
 */

module.exports = function(arraybuffer, start, end) {
  var bytes = arraybuffer.byteLength;
  start = start || 0;
  end = end || bytes;

  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }

  if (start < 0) { start += bytes; }
  if (end < 0) { end += bytes; }
  if (end > bytes) { end = bytes; }

  if (start >= bytes || start >= end || bytes === 0) {
    return new ArrayBuffer(0);
  }

  var abv = new Uint8Array(arraybuffer);
  var result = new Uint8Array(end - start);
  for (var i = start, ii = 0; i < end; i++, ii++) {
    result[ii] = abv[i];
  }
  return result.buffer;
};

},{}],8:[function(_dereq_,module,exports){

/**
 * Expose `Backoff`.
 */

module.exports = Backoff;

/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */

function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 10000;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}

/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */

Backoff.prototype.duration = function(){
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand =  Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};

/**
 * Reset the number of attempts.
 *
 * @api public
 */

Backoff.prototype.reset = function(){
  this.attempts = 0;
};

/**
 * Set the minimum duration
 *
 * @api public
 */

Backoff.prototype.setMin = function(min){
  this.ms = min;
};

/**
 * Set the maximum duration
 *
 * @api public
 */

Backoff.prototype.setMax = function(max){
  this.max = max;
};

/**
 * Set the jitter
 *
 * @api public
 */

Backoff.prototype.setJitter = function(jitter){
  this.jitter = jitter;
};


},{}],9:[function(_dereq_,module,exports){
/*
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */
(function(){
  "use strict";

  var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

  // Use a lookup table to find the index.
  var lookup = new Uint8Array(256);
  for (var i = 0; i < chars.length; i++) {
    lookup[chars.charCodeAt(i)] = i;
  }

  exports.encode = function(arraybuffer) {
    var bytes = new Uint8Array(arraybuffer),
    i, len = bytes.length, base64 = "";

    for (i = 0; i < len; i+=3) {
      base64 += chars[bytes[i] >> 2];
      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
      base64 += chars[bytes[i + 2] & 63];
    }

    if ((len % 3) === 2) {
      base64 = base64.substring(0, base64.length - 1) + "=";
    } else if (len % 3 === 1) {
      base64 = base64.substring(0, base64.length - 2) + "==";
    }

    return base64;
  };

  exports.decode =  function(base64) {
    var bufferLength = base64.length * 0.75,
    len = base64.length, i, p = 0,
    encoded1, encoded2, encoded3, encoded4;

    if (base64[base64.length - 1] === "=") {
      bufferLength--;
      if (base64[base64.length - 2] === "=") {
        bufferLength--;
      }
    }

    var arraybuffer = new ArrayBuffer(bufferLength),
    bytes = new Uint8Array(arraybuffer);

    for (i = 0; i < len; i+=4) {
      encoded1 = lookup[base64.charCodeAt(i)];
      encoded2 = lookup[base64.charCodeAt(i+1)];
      encoded3 = lookup[base64.charCodeAt(i+2)];
      encoded4 = lookup[base64.charCodeAt(i+3)];

      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
    }

    return arraybuffer;
  };
})();

},{}],10:[function(_dereq_,module,exports){
(function (global){
/**
 * Create a blob builder even when vendor prefixes exist
 */

var BlobBuilder = global.BlobBuilder
  || global.WebKitBlobBuilder
  || global.MSBlobBuilder
  || global.MozBlobBuilder;

/**
 * Check if Blob constructor is supported
 */

var blobSupported = (function() {
  try {
    var a = new Blob(['hi']);
    return a.size === 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if Blob constructor supports ArrayBufferViews
 * Fails in Safari 6, so we need to map to ArrayBuffers there.
 */

var blobSupportsArrayBufferView = blobSupported && (function() {
  try {
    var b = new Blob([new Uint8Array([1,2])]);
    return b.size === 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if BlobBuilder is supported
 */

var blobBuilderSupported = BlobBuilder
  && BlobBuilder.prototype.append
  && BlobBuilder.prototype.getBlob;

/**
 * Helper function that maps ArrayBufferViews to ArrayBuffers
 * Used by BlobBuilder constructor and old browsers that didn't
 * support it in the Blob constructor.
 */

function mapArrayBufferViews(ary) {
  for (var i = 0; i < ary.length; i++) {
    var chunk = ary[i];
    if (chunk.buffer instanceof ArrayBuffer) {
      var buf = chunk.buffer;

      // if this is a subarray, make a copy so we only
      // include the subarray region from the underlying buffer
      if (chunk.byteLength !== buf.byteLength) {
        var copy = new Uint8Array(chunk.byteLength);
        copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));
        buf = copy.buffer;
      }

      ary[i] = buf;
    }
  }
}

function BlobBuilderConstructor(ary, options) {
  options = options || {};

  var bb = new BlobBuilder();
  mapArrayBufferViews(ary);

  for (var i = 0; i < ary.length; i++) {
    bb.append(ary[i]);
  }

  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();
};

function BlobConstructor(ary, options) {
  mapArrayBufferViews(ary);
  return new Blob(ary, options || {});
};

module.exports = (function() {
  if (blobSupported) {
    return blobSupportsArrayBufferView ? global.Blob : BlobConstructor;
  } else if (blobBuilderSupported) {
    return BlobBuilderConstructor;
  } else {
    return undefined;
  }
})();

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {})
},{}],11:[function(_dereq_,module,exports){
/**
 * Slice reference.
 */

var slice = [].slice;

/**
 * Bind `obj` to `fn`.
 *
 * @param {Object} obj
 * @param {Function|String} fn or string
 * @return {Function}
 * @api public
 */

module.exports = function(obj, fn){
  if ('string' == typeof fn) fn = obj[fn];
  if ('function' != typeof fn) throw new Error('bind() requires a function');
  var args = slice.call(arguments, 2);
  return function(){
    return fn.apply(obj, args.concat(slice.call(arguments)));
  }
};

},{}],12:[function(_dereq_,module,exports){

/**
 * Expose `Emitter`.
 */

module.exports = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],13:[function(_dereq_,module,exports){

module.exports = function(a, b){
  var fn = function(){};
  fn.prototype = b.prototype;
  a.prototype = new fn;
  a.prototype.constructor = a;
};
},{}],14:[function(_dereq_,module,exports){

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = _dereq_('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // is webkit? http://stackoverflow.com/a/16459606/376773
  return ('WebkitAppearance' in document.documentElement.style) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (window.console && (console.firebug || (console.exception && console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  return JSON.stringify(v);
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs() {
  var args = arguments;
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return args;

  var c = 'color: ' + this.color;
  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
  return args;
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}
  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage(){
  try {
    return window.localStorage;
  } catch (e) {}
}

},{"./debug":15}],15:[function(_dereq_,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = _dereq_('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */

exports.formatters = {};

/**
 * Previously assigned color.
 */

var prevColor = 0;

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */

function selectColor() {
  return exports.colors[prevColor++ % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function debug(namespace) {

  // define the `disabled` version
  function disabled() {
  }
  disabled.enabled = false;

  // define the `enabled` version
  function enabled() {

    var self = enabled;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // add the `color` if not set
    if (null == self.useColors) self.useColors = exports.useColors();
    if (null == self.color && self.useColors) self.color = selectColor();

    var args = Array.prototype.slice.call(arguments);

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %o
      args = ['%o'].concat(args);
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    if ('function' === typeof exports.formatArgs) {
      args = exports.formatArgs.apply(self, args);
    }
    var logFn = enabled.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }
  enabled.enabled = true;

  var fn = exports.enabled(namespace) ? enabled : disabled;

  fn.namespace = namespace;

  return fn;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  var split = (namespaces || '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":35}],16:[function(_dereq_,module,exports){

module.exports =  _dereq_('./lib/');

},{"./lib/":17}],17:[function(_dereq_,module,exports){

module.exports = _dereq_('./socket');

/**
 * Exports parser
 *
 * @api public
 *
 */
module.exports.parser = _dereq_('engine.io-parser');

},{"./socket":18,"engine.io-parser":27}],18:[function(_dereq_,module,exports){
(function (global){
/**
 * Module dependencies.
 */

var transports = _dereq_('./transports');
var Emitter = _dereq_('component-emitter');
var debug = _dereq_('debug')('engine.io-client:socket');
var index = _dereq_('indexof');
var parser = _dereq_('engine.io-parser');
var parseuri = _dereq_('parseuri');
var parsejson = _dereq_('parsejson');
var parseqs = _dereq_('parseqs');

/**
 * Module exports.
 */

module.exports = Socket;

/**
 * Noop function.
 *
 * @api private
 */

function noop(){}

/**
 * Socket constructor.
 *
 * @param {String|Object} uri or options
 * @param {Object} options
 * @api public
 */

function Socket(uri, opts){
  if (!(this instanceof Socket)) return new Socket(uri, opts);

  opts = opts || {};

  if (uri && 'object' == typeof uri) {
    opts = uri;
    uri = null;
  }

  if (uri) {
    uri = parseuri(uri);
    opts.hostname = uri.host;
    opts.secure = uri.protocol == 'https' || uri.protocol == 'wss';
    opts.port = uri.port;
    if (uri.query) opts.query = uri.query;
  } else if (opts.host) {
    opts.hostname = parseuri(opts.host).host;
  }

  this.secure = null != opts.secure ? opts.secure :
    (global.location && 'https:' == location.protocol);

  if (opts.hostname && !opts.port) {
    // if no port is specified manually, use the protocol default
    opts.port = this.secure ? '443' : '80';
  }

  this.agent = opts.agent || false;
  this.hostname = opts.hostname ||
    (global.location ? location.hostname : 'localhost');
  this.port = opts.port || (global.location && location.port ?
       location.port :
       (this.secure ? 443 : 80));
  this.query = opts.query || {};
  if ('string' == typeof this.query) this.query = parseqs.decode(this.query);
  this.upgrade = false !== opts.upgrade;
  this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
  this.forceJSONP = !!opts.forceJSONP;
  this.jsonp = false !== opts.jsonp;
  this.forceBase64 = !!opts.forceBase64;
  this.enablesXDR = !!opts.enablesXDR;
  this.timestampParam = opts.timestampParam || 't';
  this.timestampRequests = opts.timestampRequests;
  this.transports = opts.transports || ['polling', 'websocket'];
  this.readyState = '';
  this.writeBuffer = [];
  this.policyPort = opts.policyPort || 843;
  this.rememberUpgrade = opts.rememberUpgrade || false;
  this.binaryType = null;
  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
  this.perMessageDeflate = false !== opts.perMessageDeflate ? (opts.perMessageDeflate || {}) : false;

  if (true === this.perMessageDeflate) this.perMessageDeflate = {};
  if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {
    this.perMessageDeflate.threshold = 1024;
  }

  // SSL options for Node.js client
  this.pfx = opts.pfx || null;
  this.key = opts.key || null;
  this.passphrase = opts.passphrase || null;
  this.cert = opts.cert || null;
  this.ca = opts.ca || null;
  this.ciphers = opts.ciphers || null;
  this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? true : opts.rejectUnauthorized;

  // other options for Node.js client
  var freeGlobal = typeof global == 'object' && global;
  if (freeGlobal.global === freeGlobal) {
    if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {
      this.extraHeaders = opts.extraHeaders;
    }
  }

  this.open();
}

Socket.priorWebsocketSuccess = false;

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Protocol version.
 *
 * @api public
 */

Socket.protocol = parser.protocol; // this is an int

/**
 * Expose deps for legacy compatibility
 * and standalone browser access.
 */

Socket.Socket = Socket;
Socket.Transport = _dereq_('./transport');
Socket.transports = _dereq_('./transports');
Socket.parser = _dereq_('engine.io-parser');

/**
 * Creates transport of the given type.
 *
 * @param {String} transport name
 * @return {Transport}
 * @api private
 */

Socket.prototype.createTransport = function (name) {
  debug('creating transport "%s"', name);
  var query = clone(this.query);

  // append engine.io protocol identifier
  query.EIO = parser.protocol;

  // transport name
  query.transport = name;

  // session id if we already have one
  if (this.id) query.sid = this.id;

  var transport = new transports[name]({
    agent: this.agent,
    hostname: this.hostname,
    port: this.port,
    secure: this.secure,
    path: this.path,
    query: query,
    forceJSONP: this.forceJSONP,
    jsonp: this.jsonp,
    forceBase64: this.forceBase64,
    enablesXDR: this.enablesXDR,
    timestampRequests: this.timestampRequests,
    timestampParam: this.timestampParam,
    policyPort: this.policyPort,
    socket: this,
    pfx: this.pfx,
    key: this.key,
    passphrase: this.passphrase,
    cert: this.cert,
    ca: this.ca,
    ciphers: this.ciphers,
    rejectUnauthorized: this.rejectUnauthorized,
    perMessageDeflate: this.perMessageDeflate,
    extraHeaders: this.extraHeaders
  });

  return transport;
};

function clone (obj) {
  var o = {};
  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      o[i] = obj[i];
    }
  }
  return o;
}

/**
 * Initializes transport to use and starts probe.
 *
 * @api private
 */
Socket.prototype.open = function () {
  var transport;
  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') != -1) {
    transport = 'websocket';
  } else if (0 === this.transports.length) {
    // Emit error on next tick so it can be listened to
    var self = this;
    setTimeout(function() {
      self.emit('error', 'No transports available');
    }, 0);
    return;
  } else {
    transport = this.transports[0];
  }
  this.readyState = 'opening';

  // Retry with the next transport if the transport is disabled (jsonp: false)
  try {
    transport = this.createTransport(transport);
  } catch (e) {
    this.transports.shift();
    this.open();
    return;
  }

  transport.open();
  this.setTransport(transport);
};

/**
 * Sets the current transport. Disables the existing one (if any).
 *
 * @api private
 */

Socket.prototype.setTransport = function(transport){
  debug('setting transport %s', transport.name);
  var self = this;

  if (this.transport) {
    debug('clearing existing transport %s', this.transport.name);
    this.transport.removeAllListeners();
  }

  // set up transport
  this.transport = transport;

  // set up transport listeners
  transport
  .on('drain', function(){
    self.onDrain();
  })
  .on('packet', function(packet){
    self.onPacket(packet);
  })
  .on('error', function(e){
    self.onError(e);
  })
  .on('close', function(){
    self.onClose('transport close');
  });
};

/**
 * Probes a transport.
 *
 * @param {String} transport name
 * @api private
 */

Socket.prototype.probe = function (name) {
  debug('probing transport "%s"', name);
  var transport = this.createTransport(name, { probe: 1 })
    , failed = false
    , self = this;

  Socket.priorWebsocketSuccess = false;

  function onTransportOpen(){
    if (self.onlyBinaryUpgrades) {
      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
      failed = failed || upgradeLosesBinary;
    }
    if (failed) return;

    debug('probe transport "%s" opened', name);
    transport.send([{ type: 'ping', data: 'probe' }]);
    transport.once('packet', function (msg) {
      if (failed) return;
      if ('pong' == msg.type && 'probe' == msg.data) {
        debug('probe transport "%s" pong', name);
        self.upgrading = true;
        self.emit('upgrading', transport);
        if (!transport) return;
        Socket.priorWebsocketSuccess = 'websocket' == transport.name;

        debug('pausing current transport "%s"', self.transport.name);
        self.transport.pause(function () {
          if (failed) return;
          if ('closed' == self.readyState) return;
          debug('changing transport and sending upgrade packet');

          cleanup();

          self.setTransport(transport);
          transport.send([{ type: 'upgrade' }]);
          self.emit('upgrade', transport);
          transport = null;
          self.upgrading = false;
          self.flush();
        });
      } else {
        debug('probe transport "%s" failed', name);
        var err = new Error('probe error');
        err.transport = transport.name;
        self.emit('upgradeError', err);
      }
    });
  }

  function freezeTransport() {
    if (failed) return;

    // Any callback called by transport should be ignored since now
    failed = true;

    cleanup();

    transport.close();
    transport = null;
  }

  //Handle any error that happens while probing
  function onerror(err) {
    var error = new Error('probe error: ' + err);
    error.transport = transport.name;

    freezeTransport();

    debug('probe transport "%s" failed because of error: %s', name, err);

    self.emit('upgradeError', error);
  }

  function onTransportClose(){
    onerror("transport closed");
  }

  //When the socket is closed while we're probing
  function onclose(){
    onerror("socket closed");
  }

  //When the socket is upgraded while we're probing
  function onupgrade(to){
    if (transport && to.name != transport.name) {
      debug('"%s" works - aborting "%s"', to.name, transport.name);
      freezeTransport();
    }
  }

  //Remove all listeners on the transport and on self
  function cleanup(){
    transport.removeListener('open', onTransportOpen);
    transport.removeListener('error', onerror);
    transport.removeListener('close', onTransportClose);
    self.removeListener('close', onclose);
    self.removeListener('upgrading', onupgrade);
  }

  transport.once('open', onTransportOpen);
  transport.once('error', onerror);
  transport.once('close', onTransportClose);

  this.once('close', onclose);
  this.once('upgrading', onupgrade);

  transport.open();

};

/**
 * Called when connection is deemed open.
 *
 * @api public
 */

Socket.prototype.onOpen = function () {
  debug('socket open');
  this.readyState = 'open';
  Socket.priorWebsocketSuccess = 'websocket' == this.transport.name;
  this.emit('open');
  this.flush();

  // we check for `readyState` in case an `open`
  // listener already closed the socket
  if ('open' == this.readyState && this.upgrade && this.transport.pause) {
    debug('starting upgrade probes');
    for (var i = 0, l = this.upgrades.length; i < l; i++) {
      this.probe(this.upgrades[i]);
    }
  }
};

/**
 * Handles a packet.
 *
 * @api private
 */

Socket.prototype.onPacket = function (packet) {
  if ('opening' == this.readyState || 'open' == this.readyState) {
    debug('socket receive: type "%s", data "%s"', packet.type, packet.data);

    this.emit('packet', packet);

    // Socket is live - any packet counts
    this.emit('heartbeat');

    switch (packet.type) {
      case 'open':
        this.onHandshake(parsejson(packet.data));
        break;

      case 'pong':
        this.setPing();
        this.emit('pong');
        break;

      case 'error':
        var err = new Error('server error');
        err.code = packet.data;
        this.onError(err);
        break;

      case 'message':
        this.emit('data', packet.data);
        this.emit('message', packet.data);
        break;
    }
  } else {
    debug('packet received with socket readyState "%s"', this.readyState);
  }
};

/**
 * Called upon handshake completion.
 *
 * @param {Object} handshake obj
 * @api private
 */

Socket.prototype.onHandshake = function (data) {
  this.emit('handshake', data);
  this.id = data.sid;
  this.transport.query.sid = data.sid;
  this.upgrades = this.filterUpgrades(data.upgrades);
  this.pingInterval = data.pingInterval;
  this.pingTimeout = data.pingTimeout;
  this.onOpen();
  // In case open handler closes socket
  if  ('closed' == this.readyState) return;
  this.setPing();

  // Prolong liveness of socket on heartbeat
  this.removeListener('heartbeat', this.onHeartbeat);
  this.on('heartbeat', this.onHeartbeat);
};

/**
 * Resets ping timeout.
 *
 * @api private
 */

Socket.prototype.onHeartbeat = function (timeout) {
  clearTimeout(this.pingTimeoutTimer);
  var self = this;
  self.pingTimeoutTimer = setTimeout(function () {
    if ('closed' == self.readyState) return;
    self.onClose('ping timeout');
  }, timeout || (self.pingInterval + self.pingTimeout));
};

/**
 * Pings server every `this.pingInterval` and expects response
 * within `this.pingTimeout` or closes connection.
 *
 * @api private
 */

Socket.prototype.setPing = function () {
  var self = this;
  clearTimeout(self.pingIntervalTimer);
  self.pingIntervalTimer = setTimeout(function () {
    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);
    self.ping();
    self.onHeartbeat(self.pingTimeout);
  }, self.pingInterval);
};

/**
* Sends a ping packet.
*
* @api private
*/

Socket.prototype.ping = function () {
  var self = this;
  this.sendPacket('ping', function(){
    self.emit('ping');
  });
};

/**
 * Called on `drain` event
 *
 * @api private
 */

Socket.prototype.onDrain = function() {
  this.writeBuffer.splice(0, this.prevBufferLen);

  // setting prevBufferLen = 0 is very important
  // for example, when upgrading, upgrade packet is sent over,
  // and a nonzero prevBufferLen could cause problems on `drain`
  this.prevBufferLen = 0;

  if (0 === this.writeBuffer.length) {
    this.emit('drain');
  } else {
    this.flush();
  }
};

/**
 * Flush write buffers.
 *
 * @api private
 */

Socket.prototype.flush = function () {
  if ('closed' != this.readyState && this.transport.writable &&
    !this.upgrading && this.writeBuffer.length) {
    debug('flushing %d packets in socket', this.writeBuffer.length);
    this.transport.send(this.writeBuffer);
    // keep track of current length of writeBuffer
    // splice writeBuffer and callbackBuffer on `drain`
    this.prevBufferLen = this.writeBuffer.length;
    this.emit('flush');
  }
};

/**
 * Sends a message.
 *
 * @param {String} message.
 * @param {Function} callback function.
 * @param {Object} options.
 * @return {Socket} for chaining.
 * @api public
 */

Socket.prototype.write =
Socket.prototype.send = function (msg, options, fn) {
  this.sendPacket('message', msg, options, fn);
  return this;
};

/**
 * Sends a packet.
 *
 * @param {String} packet type.
 * @param {String} data.
 * @param {Object} options.
 * @param {Function} callback function.
 * @api private
 */

Socket.prototype.sendPacket = function (type, data, options, fn) {
  if('function' == typeof data) {
    fn = data;
    data = undefined;
  }

  if ('function' == typeof options) {
    fn = options;
    options = null;
  }

  if ('closing' == this.readyState || 'closed' == this.readyState) {
    return;
  }

  options = options || {};
  options.compress = false !== options.compress;

  var packet = {
    type: type,
    data: data,
    options: options
  };
  this.emit('packetCreate', packet);
  this.writeBuffer.push(packet);
  if (fn) this.once('flush', fn);
  this.flush();
};

/**
 * Closes the connection.
 *
 * @api private
 */

Socket.prototype.close = function () {
  if ('opening' == this.readyState || 'open' == this.readyState) {
    this.readyState = 'closing';

    var self = this;

    if (this.writeBuffer.length) {
      this.once('drain', function() {
        if (this.upgrading) {
          waitForUpgrade();
        } else {
          close();
        }
      });
    } else if (this.upgrading) {
      waitForUpgrade();
    } else {
      close();
    }
  }

  function close() {
    self.onClose('forced close');
    debug('socket closing - telling transport to close');
    self.transport.close();
  }

  function cleanupAndClose() {
    self.removeListener('upgrade', cleanupAndClose);
    self.removeListener('upgradeError', cleanupAndClose);
    close();
  }

  function waitForUpgrade() {
    // wait for upgrade to finish since we can't send packets while pausing a transport
    self.once('upgrade', cleanupAndClose);
    self.once('upgradeError', cleanupAndClose);
  }

  return this;
};

/**
 * Called upon transport error
 *
 * @api private
 */

Socket.prototype.onError = function (err) {
  debug('socket error %j', err);
  Socket.priorWebsocketSuccess = false;
  this.emit('error', err);
  this.onClose('transport error', err);
};

/**
 * Called upon transport close.
 *
 * @api private
 */

Socket.prototype.onClose = function (reason, desc) {
  if ('opening' == this.readyState || 'open' == this.readyState || 'closing' == this.readyState) {
    debug('socket close with reason: "%s"', reason);
    var self = this;

    // clear timers
    clearTimeout(this.pingIntervalTimer);
    clearTimeout(this.pingTimeoutTimer);

    // stop event from firing again for transport
    this.transport.removeAllListeners('close');

    // ensure transport won't stay open
    this.transport.close();

    // ignore further transport communication
    this.transport.removeAllListeners();

    // set ready state
    this.readyState = 'closed';

    // clear session id
    this.id = null;

    // emit close event
    this.emit('close', reason, desc);

    // clean buffers after, so users can still
    // grab the buffers on `close` event
    self.writeBuffer = [];
    self.prevBufferLen = 0;
  }
};

/**
 * Filters upgrades, returning only those matching client transports.
 *
 * @param {Array} server upgrades
 * @api private
 *
 */

Socket.prototype.filterUpgrades = function (upgrades) {
  var filteredUpgrades = [];
  for (var i = 0, j = upgrades.length; i<j; i++) {
    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
  }
  return filteredUpgrades;
};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {})
},{"./transport":19,"./transports":20,"component-emitter":26,"debug":14,"engine.io-parser":27,"indexof":32,"parsejson":36,"parseqs":37,"parseuri":38}],19:[function(_dereq_,module,exports){
/**
 * Module dependencies.
 */

var parser = _dereq_('engine.io-parser');
var Emitter = _dereq_('component-emitter');

/**
 * Module exports.
 */

module.exports = Transport;

/**
 * Transport abstract constructor.
 *
 * @param {Object} options.
 * @api private
 */

function Transport (opts) {
  this.path = opts.path;
  this.hostname = opts.hostname;
  this.port = opts.port;
  this.secure = opts.secure;
  this.query = opts.query;
  this.timestampParam = opts.timestampParam;
  this.timestampRequests = opts.timestampRequests;
  this.readyState = '';
  this.agent = opts.agent || false;
  this.socket = opts.socket;
  this.enablesXDR = opts.enablesXDR;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;

  // other options for Node.js client
  this.extraHeaders = opts.extraHeaders;
}

/**
 * Mix in `Emitter`.
 */

Emitter(Transport.prototype);

/**
 * Emits an error.
 *
 * @param {String} str
 * @return {Transport} for chaining
 * @api public
 */

Transport.prototype.onError = function (msg, desc) {
  var err = new Error(msg);
  err.type = 'TransportError';
  err.description = desc;
  this.emit('error', err);
  return this;
};

/**
 * Opens the transport.
 *
 * @api public
 */

Transport.prototype.open = function () {
  if ('closed' == this.readyState || '' == this.readyState) {
    this.readyState = 'opening';
    this.doOpen();
  }

  return this;
};

/**
 * Closes the transport.
 *
 * @api private
 */

Transport.prototype.close = function () {
  if ('opening' == this.readyState || 'open' == this.readyState) {
    this.doClose();
    this.onClose();
  }

  return this;
};

/**
 * Sends multiple packets.
 *
 * @param {Array} packets
 * @api private
 */

Transport.prototype.send = function(packets){
  if ('open' == this.readyState) {
    this.write(packets);
  } else {
    throw new Error('Transport not open');
  }
};

/**
 * Called upon open
 *
 * @api private
 */

Transport.prototype.onOpen = function () {
  this.readyState = 'open';
  this.writable = true;
  this.emit('open');
};

/**
 * Called with data.
 *
 * @param {String} data
 * @api private
 */

Transport.prototype.onData = function(data){
  var packet = parser.decodePacket(data, this.socket.binaryType);
  this.onPacket(packet);
};

/**
 * Called with a decoded packet.
 */

Transport.prototype.onPacket = function (packet) {
  this.emit('packet', packet);
};

/**
 * Called upon close.
 *
 * @api private
 */

Transport.prototype.onClose = function () {
  this.readyState = 'closed';
  this.emit('close');
};

},{"component-emitter":26,"engine.io-parser":27}],20:[function(_dereq_,module,exports){
(function (global){
/**
 * Module dependencies
 */

var XMLHttpRequest = _dereq_('xmlhttprequest-ssl');
var XHR = _dereq_('./polling-xhr');
var JSONP = _dereq_('./polling-jsonp');
var websocket = _dereq_('./websocket');

/**
 * Export transports.
 */

exports.polling = polling;
exports.websocket = websocket;

/**
 * Polling transport polymorphic constructor.
 * Decides on xhr vs jsonp based on feature detection.
 *
 * @api private
 */

function polling(opts){
  var xhr;
  var xd = false;
  var xs = false;
  var jsonp = false !== opts.jsonp;

  if (global.location) {
    var isSSL = 'https:' == location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    xd = opts.hostname != location.hostname || port != opts.port;
    xs = opts.secure != isSSL;
  }

  opts.xdomain = xd;
  opts.xscheme = xs;
  xhr = new XMLHttpRequest(opts);

  if ('open' in xhr && !opts.forceJSONP) {
    return new XHR(opts);
  } else {
    if (!jsonp) throw new Error('JSONP disabled');
    return new JSONP(opts);
  }
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {})
},{"./polling-jsonp":21,"./polling-xhr":22,"./websocket":24,"xmlhttprequest-ssl":25}],21:[function(_dereq_,module,exports){
(function (global){

/**
 * Module requirements.
 */

var Polling = _dereq_('./polling');
var inherit = _dereq_('component-inherit');

/**
 * Module exports.
 */

module.exports = JSONPPolling;

/**
 * Cached regular expressions.
 */

var rNewline = /\n/g;
var rEscapedNewline = /\\n/g;

/**
 * Global JSONP callbacks.
 */

var callbacks;

/**
 * Callbacks count.
 */

var index = 0;

/**
 * Noop.
 */

function empty () { }

/**
 * JSONP Polling constructor.
 *
 * @param {Object} opts.
 * @api public
 */

function JSONPPolling (opts) {
  Polling.call(this, opts);

  this.query = this.query || {};

  // define global callbacks array if not present
  // we do this here (lazily) to avoid unneeded global pollution
  if (!callbacks) {
    // we need to consider multiple engines in the same page
    if (!global.___eio) global.___eio = [];
    callbacks = global.___eio;
  }

  // callback identifier
  this.index = callbacks.length;

  // add callback to jsonp global
  var self = this;
  callbacks.push(function (msg) {
    self.onData(msg);
  });

  // append to query string
  this.query.j = this.index;

  // prevent spurious errors from being emitted when the window is unloaded
  if (global.document && global.addEventListener) {
    global.addEventListener('beforeunload', function () {
      if (self.script) self.script.onerror = empty;
    }, false);
  }
}

/**
 * Inherits from Polling.
 */

inherit(JSONPPolling, Polling);

/*
 * JSONP only supports binary as base64 encoded strings
 */

JSONPPolling.prototype.supportsBinary = false;

/**
 * Closes the socket.
 *
 * @api private
 */

JSONPPolling.prototype.doClose = function () {
  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  if (this.form) {
    this.form.parentNode.removeChild(this.form);
    this.form = null;
    this.iframe = null;
  }

  Polling.prototype.doClose.call(this);
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

JSONPPolling.prototype.doPoll = function () {
  var self = this;
  var script = document.createElement('script');

  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  script.async = true;
  script.src = this.uri();
  script.onerror = function(e){
    self.onError('jsonp poll error',e);
  };

  var insertAt = document.getElementsByTagName('script')[0];
  if (insertAt) {
    insertAt.parentNode.insertBefore(script, insertAt);
  }
  else {
    (document.head || document.body).appendChild(script);
  }
  this.script = script;

  var isUAgecko = 'undefined' != typeof navigator && /gecko/i.test(navigator.userAgent);
  
  if (isUAgecko) {
    setTimeout(function () {
      var iframe = document.createElement('iframe');
      document.body.appendChild(iframe);
      document.body.removeChild(iframe);
    }, 100);
  }
};

/**
 * Writes with a hidden iframe.
 *
 * @param {String} data to send
 * @param {Function} called upon flush.
 * @api private
 */

JSONPPolling.prototype.doWrite = function (data, fn) {
  var self = this;

  if (!this.form) {
    var form = document.createElement('form');
    var area = document.createElement('textarea');
    var id = this.iframeId = 'eio_iframe_' + this.index;
    var iframe;

    form.className = 'socketio';
    form.style.position = 'absolute';
    form.style.top = '-1000px';
    form.style.left = '-1000px';
    form.target = id;
    form.method = 'POST';
    form.setAttribute('accept-charset', 'utf-8');
    area.name = 'd';
    form.appendChild(area);
    document.body.appendChild(form);

    this.form = form;
    this.area = area;
  }

  this.form.action = this.uri();

  function complete () {
    initIframe();
    fn();
  }

  function initIframe () {
    if (self.iframe) {
      try {
        self.form.removeChild(self.iframe);
      } catch (e) {
        self.onError('jsonp polling iframe removal error', e);
      }
    }

    try {
      // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
      var html = '<iframe src="javascript:0" name="'+ self.iframeId +'">';
      iframe = document.createElement(html);
    } catch (e) {
      iframe = document.createElement('iframe');
      iframe.name = self.iframeId;
      iframe.src = 'javascript:0';
    }

    iframe.id = self.iframeId;

    self.form.appendChild(iframe);
    self.iframe = iframe;
  }

  initIframe();

  // escape \n to prevent it from being converted into \r\n by some UAs
  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
  data = data.replace(rEscapedNewline, '\\\n');
  this.area.value = data.replace(rNewline, '\\n');

  try {
    this.form.submit();
  } catch(e) {}

  if (this.iframe.attachEvent) {
    this.iframe.onreadystatechange = function(){
      if (self.iframe.readyState == 'complete') {
        complete();
      }
    };
  } else {
    this.iframe.onload = complete;
  }
};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {})
},{"./polling":23,"component-inherit":13}],22:[function(_dereq_,module,exports){
(function (global){
/**
 * Module requirements.
 */

var XMLHttpRequest = _dereq_('xmlhttprequest-ssl');
var Polling = _dereq_('./polling');
var Emitter = _dereq_('component-emitter');
var inherit = _dereq_('component-inherit');
var debug = _dereq_('debug')('engine.io-client:polling-xhr');

/**
 * Module exports.
 */

module.exports = XHR;
module.exports.Request = Request;

/**
 * Empty function
 */

function empty(){}

/**
 * XHR Polling constructor.
 *
 * @param {Object} opts
 * @api public
 */

function XHR(opts){
  Polling.call(this, opts);

  if (global.location) {
    var isSSL = 'https:' == location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    this.xd = opts.hostname != global.location.hostname ||
      port != opts.port;
    this.xs = opts.secure != isSSL;
  } else {
    this.extraHeaders = opts.extraHeaders;
  }
}

/**
 * Inherits from Polling.
 */

inherit(XHR, Polling);

/**
 * XHR supports binary
 */

XHR.prototype.supportsBinary = true;

/**
 * Creates a request.
 *
 * @param {String} method
 * @api private
 */

XHR.prototype.request = function(opts){
  opts = opts || {};
  opts.uri = this.uri();
  opts.xd = this.xd;
  opts.xs = this.xs;
  opts.agent = this.agent || false;
  opts.supportsBinary = this.supportsBinary;
  opts.enablesXDR = this.enablesXDR;

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  // other options for Node.js client
  opts.extraHeaders = this.extraHeaders;

  return new Request(opts);
};

/**
 * Sends data.
 *
 * @param {String} data to send.
 * @param {Function} called upon flush.
 * @api private
 */

XHR.prototype.doWrite = function(data, fn){
  var isBinary = typeof data !== 'string' && data !== undefined;
  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });
  var self = this;
  req.on('success', fn);
  req.on('error', function(err){
    self.onError('xhr post error', err);
  });
  this.sendXhr = req;
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

XHR.prototype.doPoll = function(){
  debug('xhr poll');
  var req = this.request();
  var self = this;
  req.on('data', function(data){
    self.onData(data);
  });
  req.on('error', function(err){
    self.onError('xhr poll error', err);
  });
  this.pollXhr = req;
};

/**
 * Request constructor
 *
 * @param {Object} options
 * @api public
 */

function Request(opts){
  this.method = opts.method || 'GET';
  this.uri = opts.uri;
  this.xd = !!opts.xd;
  this.xs = !!opts.xs;
  this.async = false !== opts.async;
  this.data = undefined != opts.data ? opts.data : null;
  this.agent = opts.agent;
  this.isBinary = opts.isBinary;
  this.supportsBinary = opts.supportsBinary;
  this.enablesXDR = opts.enablesXDR;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;

  // other options for Node.js client
  this.extraHeaders = opts.extraHeaders;

  this.create();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Request.prototype);

/**
 * Creates the XHR object and sends the request.
 *
 * @api private
 */

Request.prototype.create = function(){
  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  var xhr = this.xhr = new XMLHttpRequest(opts);
  var self = this;

  try {
    debug('xhr open %s: %s', this.method, this.uri);
    xhr.open(this.method, this.uri, this.async);
    try {
      if (this.extraHeaders) {
        xhr.setDisableHeaderCheck(true);
        for (var i in this.extraHeaders) {
          if (this.extraHeaders.hasOwnProperty(i)) {
            xhr.setRequestHeader(i, this.extraHeaders[i]);
          }
        }
      }
    } catch (e) {}
    if (this.supportsBinary) {
      // This has to be done after open because Firefox is stupid
      // http://stackoverflow.com/questions/13216903/get-binary-data-with-xmlhttprequest-in-a-firefox-extension
      xhr.responseType = 'arraybuffer';
    }

    if ('POST' == this.method) {
      try {
        if (this.isBinary) {
          xhr.setRequestHeader('Content-type', 'application/octet-stream');
        } else {
          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
        }
      } catch (e) {}
    }

    // ie6 check
    if ('withCredentials' in xhr) {
      xhr.withCredentials = true;
    }

    if (this.hasXDR()) {
      xhr.onload = function(){
        self.onLoad();
      };
      xhr.onerror = function(){
        self.onError(xhr.responseText);
      };
    } else {
      xhr.onreadystatechange = function(){
        if (4 != xhr.readyState) return;
        if (200 == xhr.status || 1223 == xhr.status) {
          self.onLoad();
        } else {
          // make sure the `error` event handler that's user-set
          // does not throw in the same tick and gets caught here
          setTimeout(function(){
            self.onError(xhr.status);
          }, 0);
        }
      };
    }

    debug('xhr data %s', this.data);
    xhr.send(this.data);
  } catch (e) {
    // Need to defer since .create() is called directly fhrom the constructor
    // and thus the 'error' event can only be only bound *after* this exception
    // occurs.  Therefore, also, we cannot throw here at all.
    setTimeout(function() {
      self.onError(e);
    }, 0);
    return;
  }

  if (global.document) {
    this.index = Request.requestsCount++;
    Request.requests[this.index] = this;
  }
};

/**
 * Called upon successful response.
 *
 * @api private
 */

Request.prototype.onSuccess = function(){
  this.emit('success');
  this.cleanup();
};

/**
 * Called if we have data.
 *
 * @api private
 */

Request.prototype.onData = function(data){
  this.emit('data', data);
  this.onSuccess();
};

/**
 * Called upon error.
 *
 * @api private
 */

Request.prototype.onError = function(err){
  this.emit('error', err);
  this.cleanup(true);
};

/**
 * Cleans up house.
 *
 * @api private
 */

Request.prototype.cleanup = function(fromError){
  if ('undefined' == typeof this.xhr || null === this.xhr) {
    return;
  }
  // xmlhttprequest
  if (this.hasXDR()) {
    this.xhr.onload = this.xhr.onerror = empty;
  } else {
    this.xhr.onreadystatechange = empty;
  }

  if (fromError) {
    try {
      this.xhr.abort();
    } catch(e) {}
  }

  if (global.document) {
    delete Request.requests[this.index];
  }

  this.xhr = null;
};

/**
 * Called upon load.
 *
 * @api private
 */

Request.prototype.onLoad = function(){
  var data;
  try {
    var contentType;
    try {
      contentType = this.xhr.getResponseHeader('Content-Type').split(';')[0];
    } catch (e) {}
    if (contentType === 'application/octet-stream') {
      data = this.xhr.response;
    } else {
      if (!this.supportsBinary) {
        data = this.xhr.responseText;
      } else {
        try {
          data = String.fromCharCode.apply(null, new Uint8Array(this.xhr.response));
        } catch (e) {
          var ui8Arr = new Uint8Array(this.xhr.response);
          var dataArray = [];
          for (var idx = 0, length = ui8Arr.length; idx < length; idx++) {
            dataArray.push(ui8Arr[idx]);
          }

          data = String.fromCharCode.apply(null, dataArray);
        }
      }
    }
  } catch (e) {
    this.onError(e);
  }
  if (null != data) {
    this.onData(data);
  }
};

/**
 * Check if it has XDomainRequest.
 *
 * @api private
 */

Request.prototype.hasXDR = function(){
  return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;
};

/**
 * Aborts the request.
 *
 * @api public
 */

Request.prototype.abort = function(){
  this.cleanup();
};

/**
 * Aborts pending requests when unloading the window. This is needed to prevent
 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
 * emitted.
 */

if (global.document) {
  Request.requestsCount = 0;
  Request.requests = {};
  if (global.attachEvent) {
    global.attachEvent('onunload', unloadHandler);
  } else if (global.addEventListener) {
    global.addEventListener('beforeunload', unloadHandler, false);
  }
}

function unloadHandler() {
  for (var i in Request.requests) {
    if (Request.requests.hasOwnProperty(i)) {
      Request.requests[i].abort();
    }
  }
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {})
},{"./polling":23,"component-emitter":26,"component-inherit":13,"debug":14,"xmlhttprequest-ssl":25}],23:[function(_dereq_,module,exports){
/**
 * Module dependencies.
 */

var Transport = _dereq_('../transport');
var parseqs = _dereq_('parseqs');
var parser = _dereq_('engine.io-parser');
var inherit = _dereq_('component-inherit');
var yeast = _dereq_('yeast');
var debug = _dereq_('debug')('engine.io-client:polling');

/**
 * Module exports.
 */

module.exports = Polling;

/**
 * Is XHR2 supported?
 */

var hasXHR2 = (function() {
  var XMLHttpRequest = _dereq_('xmlhttprequest-ssl');
  var xhr = new XMLHttpRequest({ xdomain: false });
  return null != xhr.responseType;
})();

/**
 * Polling interface.
 *
 * @param {Object} opts
 * @api private
 */

function Polling(opts){
  var forceBase64 = (opts && opts.forceBase64);
  if (!hasXHR2 || forceBase64) {
    this.supportsBinary = false;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(Polling, Transport);

/**
 * Transport name.
 */

Polling.prototype.name = 'polling';

/**
 * Opens the socket (triggers polling). We write a PING message to determine
 * when the transport is open.
 *
 * @api private
 */

Polling.prototype.doOpen = function(){
  this.poll();
};

/**
 * Pauses polling.
 *
 * @param {Function} callback upon buffers are flushed and transport is paused
 * @api private
 */

Polling.prototype.pause = function(onPause){
  var pending = 0;
  var self = this;

  this.readyState = 'pausing';

  function pause(){
    debug('paused');
    self.readyState = 'paused';
    onPause();
  }

  if (this.polling || !this.writable) {
    var total = 0;

    if (this.polling) {
      debug('we are currently polling - waiting to pause');
      total++;
      this.once('pollComplete', function(){
        debug('pre-pause polling complete');
        --total || pause();
      });
    }

    if (!this.writable) {
      debug('we are currently writing - waiting to pause');
      total++;
      this.once('drain', function(){
        debug('pre-pause writing complete');
        --total || pause();
      });
    }
  } else {
    pause();
  }
};

/**
 * Starts polling cycle.
 *
 * @api public
 */

Polling.prototype.poll = function(){
  debug('polling');
  this.polling = true;
  this.doPoll();
  this.emit('poll');
};

/**
 * Overloads onData to detect payloads.
 *
 * @api private
 */

Polling.prototype.onData = function(data){
  var self = this;
  debug('polling got data %s', data);
  var callback = function(packet, index, total) {
    // if its the first message we consider the transport open
    if ('opening' == self.readyState) {
      self.onOpen();
    }

    // if its a close packet, we close the ongoing requests
    if ('close' == packet.type) {
      self.onClose();
      return false;
    }

    // otherwise bypass onData and handle the message
    self.onPacket(packet);
  };

  // decode payload
  parser.decodePayload(data, this.socket.binaryType, callback);

  // if an event did not trigger closing
  if ('closed' != this.readyState) {
    // if we got data we're not polling
    this.polling = false;
    this.emit('pollComplete');

    if ('open' == this.readyState) {
      this.poll();
    } else {
      debug('ignoring poll - transport state "%s"', this.readyState);
    }
  }
};

/**
 * For polling, send a close packet.
 *
 * @api private
 */

Polling.prototype.doClose = function(){
  var self = this;

  function close(){
    debug('writing close packet');
    self.write([{ type: 'close' }]);
  }

  if ('open' == this.readyState) {
    debug('transport open - closing');
    close();
  } else {
    // in case we're trying to close while
    // handshaking is in progress (GH-164)
    debug('transport not open - deferring close');
    this.once('open', close);
  }
};

/**
 * Writes a packets payload.
 *
 * @param {Array} data packets
 * @param {Function} drain callback
 * @api private
 */

Polling.prototype.write = function(packets){
  var self = this;
  this.writable = false;
  var callbackfn = function() {
    self.writable = true;
    self.emit('drain');
  };

  var self = this;
  parser.encodePayload(packets, this.supportsBinary, function(data) {
    self.doWrite(data, callbackfn);
  });
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

Polling.prototype.uri = function(){
  var query = this.query || {};
  var schema = this.secure ? 'https' : 'http';
  var port = '';

  // cache busting is forced
  if (false !== this.timestampRequests) {
    query[this.timestampParam] = yeast();
  }

  if (!this.supportsBinary && !query.sid) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // avoid port if default for schema
  if (this.port && (('https' == schema && this.port != 443) ||
     ('http' == schema && this.port != 80))) {
    port = ':' + this.port;
  }

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  var ipv6 = this.hostname.indexOf(':') !== -1;
  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
};

},{"../transport":19,"component-inherit":13,"debug":14,"engine.io-parser":27,"parseqs":37,"xmlhttprequest-ssl":25,"yeast":45}],24:[function(_dereq_,module,exports){
(function (global){
/**
 * Module dependencies.
 */

var Transport = _dereq_('../transport');
var parser = _dereq_('engine.io-parser');
var parseqs = _dereq_('parseqs');
var inherit = _dereq_('component-inherit');
var yeast = _dereq_('yeast');
var debug = _dereq_('debug')('engine.io-client:websocket');
var BrowserWebSocket = global.WebSocket || global.MozWebSocket;

/**
 * Get either the `WebSocket` or `MozWebSocket` globals
 * in the browser or try to resolve WebSocket-compatible
 * interface exposed by `ws` for Node-like environment.
 */

var WebSocket = BrowserWebSocket;
if (!WebSocket && typeof window === 'undefined') {
  try {
    WebSocket = _dereq_('ws');
  } catch (e) { }
}

/**
 * Module exports.
 */

module.exports = WS;

/**
 * WebSocket transport constructor.
 *
 * @api {Object} connection options
 * @api public
 */

function WS(opts){
  var forceBase64 = (opts && opts.forceBase64);
  if (forceBase64) {
    this.supportsBinary = false;
  }
  this.perMessageDeflate = opts.perMessageDeflate;
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(WS, Transport);

/**
 * Transport name.
 *
 * @api public
 */

WS.prototype.name = 'websocket';

/*
 * WebSockets support binary
 */

WS.prototype.supportsBinary = true;

/**
 * Opens socket.
 *
 * @api private
 */

WS.prototype.doOpen = function(){
  if (!this.check()) {
    // let probe timeout
    return;
  }

  var self = this;
  var uri = this.uri();
  var protocols = void(0);
  var opts = {
    agent: this.agent,
    perMessageDeflate: this.perMessageDeflate
  };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;
  if (this.extraHeaders) {
    opts.headers = this.extraHeaders;
  }

  this.ws = BrowserWebSocket ? new WebSocket(uri) : new WebSocket(uri, protocols, opts);

  if (this.ws.binaryType === undefined) {
    this.supportsBinary = false;
  }

  if (this.ws.supports && this.ws.supports.binary) {
    this.supportsBinary = true;
    this.ws.binaryType = 'buffer';
  } else {
    this.ws.binaryType = 'arraybuffer';
  }

  this.addEventListeners();
};

/**
 * Adds event listeners to the socket
 *
 * @api private
 */

WS.prototype.addEventListeners = function(){
  var self = this;

  this.ws.onopen = function(){
    self.onOpen();
  };
  this.ws.onclose = function(){
    self.onClose();
  };
  this.ws.onmessage = function(ev){
    self.onData(ev.data);
  };
  this.ws.onerror = function(e){
    self.onError('websocket error', e);
  };
};

/**
 * Override `onData` to use a timer on iOS.
 * See: https://gist.github.com/mloughran/2052006
 *
 * @api private
 */

if ('undefined' != typeof navigator
  && /iPad|iPhone|iPod/i.test(navigator.userAgent)) {
  WS.prototype.onData = function(data){
    var self = this;
    setTimeout(function(){
      Transport.prototype.onData.call(self, data);
    }, 0);
  };
}

/**
 * Writes data to socket.
 *
 * @param {Array} array of packets.
 * @api private
 */

WS.prototype.write = function(packets){
  var self = this;
  this.writable = false;

  // encodePacket efficient as it uses WS framing
  // no need for encodePayload
  var total = packets.length;
  for (var i = 0, l = total; i < l; i++) {
    (function(packet) {
      parser.encodePacket(packet, self.supportsBinary, function(data) {
        if (!BrowserWebSocket) {
          // always create a new object (GH-437)
          var opts = {};
          if (packet.options) {
            opts.compress = packet.options.compress;
          }

          if (self.perMessageDeflate) {
            var len = 'string' == typeof data ? global.Buffer.byteLength(data) : data.length;
            if (len < self.perMessageDeflate.threshold) {
              opts.compress = false;
            }
          }
        }

        //Sometimes the websocket has already been closed but the browser didn't
        //have a chance of informing us about it yet, in that case send will
        //throw an error
        try {
          if (BrowserWebSocket) {
            // TypeError is thrown when passing the second argument on Safari
            self.ws.send(data);
          } else {
            self.ws.send(data, opts);
          }
        } catch (e){
          debug('websocket closed before onclose event');
        }

        --total || done();
      });
    })(packets[i]);
  }

  function done(){
    self.emit('flush');

    // fake drain
    // defer to next tick to allow Socket to clear writeBuffer
    setTimeout(function(){
      self.writable = true;
      self.emit('drain');
    }, 0);
  }
};

/**
 * Called upon close
 *
 * @api private
 */

WS.prototype.onClose = function(){
  Transport.prototype.onClose.call(this);
};

/**
 * Closes socket.
 *
 * @api private
 */

WS.prototype.doClose = function(){
  if (typeof this.ws !== 'undefined') {
    this.ws.close();
  }
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

WS.prototype.uri = function(){
  var query = this.query || {};
  var schema = this.secure ? 'wss' : 'ws';
  var port = '';

  // avoid port if default for schema
  if (this.port && (('wss' == schema && this.port != 443)
    || ('ws' == schema && this.port != 80))) {
    port = ':' + this.port;
  }

  // append timestamp to URI
  if (this.timestampRequests) {
    query[this.timestampParam] = yeast();
  }

  // communicate binary support capabilities
  if (!this.supportsBinary) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  var ipv6 = this.hostname.indexOf(':') !== -1;
  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
};

/**
 * Feature detection for WebSocket.
 *
 * @return {Boolean} whether this transport is available.
 * @api public
 */

WS.prototype.check = function(){
  return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);
};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {})
},{"../transport":19,"component-inherit":13,"debug":14,"engine.io-parser":27,"parseqs":37,"ws":undefined,"yeast":45}],25:[function(_dereq_,module,exports){
// browser shim for xmlhttprequest module
var hasCORS = _dereq_('has-cors');

module.exports = function(opts) {
  var xdomain = opts.xdomain;

  // scheme must be same when usign XDomainRequest
  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
  var xscheme = opts.xscheme;

  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
  // https://github.com/Automattic/engine.io-client/pull/217
  var enablesXDR = opts.enablesXDR;

  // XMLHttpRequest can be disabled on IE
  try {
    if ('undefined' != typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e) { }

  // Use XDomainRequest for IE8 if enablesXDR is true
  // because loading bar keeps flashing when using jsonp-polling
  // https://github.com/yujiosaka/socke.io-ie8-loading-example
  try {
    if ('undefined' != typeof XDomainRequest && !xscheme && enablesXDR) {
      return new XDomainRequest();
    }
  } catch (e) { }

  if (!xdomain) {
    try {
      return new ActiveXObject('Microsoft.XMLHTTP');
    } catch(e) { }
  }
}

},{"has-cors":31}],26:[function(_dereq_,module,exports){

/**
 * Expose `Emitter`.
 */

module.exports = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks[event] = this._callbacks[event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  var self = this;
  this._callbacks = this._callbacks || {};

  function on() {
    self.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks[event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks[event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks[event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks[event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],27:[function(_dereq_,module,exports){
(function (global){
/**
 * Module dependencies.
 */

var keys = _dereq_('./keys');
var hasBinary = _dereq_('has-binary');
var sliceBuffer = _dereq_('arraybuffer.slice');
var base64encoder = _dereq_('base64-arraybuffer');
var after = _dereq_('after');
var utf8 = _dereq_('utf8');

/**
 * Check if we are running an android browser. That requires us to use
 * ArrayBuffer with polling transports...
 *
 * http://ghinda.net/jpeg-blob-ajax-android/
 */

var isAndroid = navigator.userAgent.match(/Android/i);

/**
 * Check if we are running in PhantomJS.
 * Uploading a Blob with PhantomJS does not work correctly, as reported here:
 * https://github.com/ariya/phantomjs/issues/11395
 * @type boolean
 */
var isPhantomJS = /PhantomJS/i.test(navigator.userAgent);

/**
 * When true, avoids using Blobs to encode payloads.
 * @type boolean
 */
var dontSendBlobs = isAndroid || isPhantomJS;

/**
 * Current protocol version.
 */

exports.protocol = 3;

/**
 * Packet types.
 */

var packets = exports.packets = {
    open:     0    // non-ws
  , close:    1    // non-ws
  , ping:     2
  , pong:     3
  , message:  4
  , upgrade:  5
  , noop:     6
};

var packetslist = keys(packets);

/**
 * Premade error packet.
 */

var err = { type: 'error', data: 'parser error' };

/**
 * Create a blob api even for blob builder when vendor prefixes exist
 */

var Blob = _dereq_('blob');

/**
 * Encodes a packet.
 *
 *     <packet type id> [ <data> ]
 *
 * Example:
 *
 *     5hello world
 *     3
 *     4
 *
 * Binary is encoded in an identical principle
 *
 * @api private
 */

exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
  if ('function' == typeof supportsBinary) {
    callback = supportsBinary;
    supportsBinary = false;
  }

  if ('function' == typeof utf8encode) {
    callback = utf8encode;
    utf8encode = null;
  }

  var data = (packet.data === undefined)
    ? undefined
    : packet.data.buffer || packet.data;

  if (global.ArrayBuffer && data instanceof ArrayBuffer) {
    return encodeArrayBuffer(packet, supportsBinary, callback);
  } else if (Blob && data instanceof global.Blob) {
    return encodeBlob(packet, supportsBinary, callback);
  }

  // might be an object with { base64: true, data: dataAsBase64String }
  if (data && data.base64) {
    return encodeBase64Object(packet, callback);
  }

  // Sending data as a utf-8 string
  var encoded = packets[packet.type];

  // data fragment is optional
  if (undefined !== packet.data) {
    encoded += utf8encode ? utf8.encode(String(packet.data)) : String(packet.data);
  }

  return callback('' + encoded);

};

function encodeBase64Object(packet, callback) {
  // packet data is an object { base64: true, data: dataAsBase64String }
  var message = 'b' + exports.packets[packet.type] + packet.data.data;
  return callback(message);
}

/**
 * Encode packet helpers for binary types
 */

function encodeArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var data = packet.data;
  var contentArray = new Uint8Array(data);
  var resultBuffer = new Uint8Array(1 + data.byteLength);

  resultBuffer[0] = packets[packet.type];
  for (var i = 0; i < contentArray.length; i++) {
    resultBuffer[i+1] = contentArray[i];
  }

  return callback(resultBuffer.buffer);
}

function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var fr = new FileReader();
  fr.onload = function() {
    packet.data = fr.result;
    exports.encodePacket(packet, supportsBinary, true, callback);
  };
  return fr.readAsArrayBuffer(packet.data);
}

function encodeBlob(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  if (dontSendBlobs) {
    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
  }

  var length = new Uint8Array(1);
  length[0] = packets[packet.type];
  var blob = new Blob([length.buffer, packet.data]);

  return callback(blob);
}

/**
 * Encodes a packet with binary data in a base64 string
 *
 * @param {Object} packet, has `type` and `data`
 * @return {String} base64 encoded message
 */

exports.encodeBase64Packet = function(packet, callback) {
  var message = 'b' + exports.packets[packet.type];
  if (Blob && packet.data instanceof global.Blob) {
    var fr = new FileReader();
    fr.onload = function() {
      var b64 = fr.result.split(',')[1];
      callback(message + b64);
    };
    return fr.readAsDataURL(packet.data);
  }

  var b64data;
  try {
    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
  } catch (e) {
    // iPhone Safari doesn't let you apply with typed arrays
    var typed = new Uint8Array(packet.data);
    var basic = new Array(typed.length);
    for (var i = 0; i < typed.length; i++) {
      basic[i] = typed[i];
    }
    b64data = String.fromCharCode.apply(null, basic);
  }
  message += global.btoa(b64data);
  return callback(message);
};

/**
 * Decodes a packet. Changes format to Blob if requested.
 *
 * @return {Object} with `type` and `data` (if any)
 * @api private
 */

exports.decodePacket = function (data, binaryType, utf8decode) {
  // String data
  if (typeof data == 'string' || data === undefined) {
    if (data.charAt(0) == 'b') {
      return exports.decodeBase64Packet(data.substr(1), binaryType);
    }

    if (utf8decode) {
      try {
        data = utf8.decode(data);
      } catch (e) {
        return err;
      }
    }
    var type = data.charAt(0);

    if (Number(type) != type || !packetslist[type]) {
      return err;
    }

    if (data.length > 1) {
      return { type: packetslist[type], data: data.substring(1) };
    } else {
      return { type: packetslist[type] };
    }
  }

  var asArray = new Uint8Array(data);
  var type = asArray[0];
  var rest = sliceBuffer(data, 1);
  if (Blob && binaryType === 'blob') {
    rest = new Blob([rest]);
  }
  return { type: packetslist[type], data: rest };
};

/**
 * Decodes a packet encoded in a base64 string
 *
 * @param {String} base64 encoded message
 * @return {Object} with `type` and `data` (if any)
 */

exports.decodeBase64Packet = function(msg, binaryType) {
  var type = packetslist[msg.charAt(0)];
  if (!global.ArrayBuffer) {
    return { type: type, data: { base64: true, data: msg.substr(1) } };
  }

  var data = base64encoder.decode(msg.substr(1));

  if (binaryType === 'blob' && Blob) {
    data = new Blob([data]);
  }

  return { type: type, data: data };
};

/**
 * Encodes multiple messages (payload).
 *
 *     <length>:data
 *
 * Example:
 *
 *     11:hello world2:hi
 *
 * If any contents are binary, they will be encoded as base64 strings. Base64
 * encoded strings are marked with a b before the length specifier
 *
 * @param {Array} packets
 * @api private
 */

exports.encodePayload = function (packets, supportsBinary, callback) {
  if (typeof supportsBinary == 'function') {
    callback = supportsBinary;
    supportsBinary = null;
  }

  var isBinary = hasBinary(packets);

  if (supportsBinary && isBinary) {
    if (Blob && !dontSendBlobs) {
      return exports.encodePayloadAsBlob(packets, callback);
    }

    return exports.encodePayloadAsArrayBuffer(packets, callback);
  }

  if (!packets.length) {
    return callback('0:');
  }

  function setLengthHeader(message) {
    return message.length + ':' + message;
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, !isBinary ? false : supportsBinary, true, function(message) {
      doneCallback(null, setLengthHeader(message));
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(results.join(''));
  });
};

/**
 * Async array map using after
 */

function map(ary, each, done) {
  var result = new Array(ary.length);
  var next = after(ary.length, done);

  var eachWithIndex = function(i, el, cb) {
    each(el, function(error, msg) {
      result[i] = msg;
      cb(error, result);
    });
  };

  for (var i = 0; i < ary.length; i++) {
    eachWithIndex(i, ary[i], next);
  }
}

/*
 * Decodes data when a payload is maybe expected. Possible binary contents are
 * decoded from their base64 representation
 *
 * @param {String} data, callback method
 * @api public
 */

exports.decodePayload = function (data, binaryType, callback) {
  if (typeof data != 'string') {
    return exports.decodePayloadAsBinary(data, binaryType, callback);
  }

  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var packet;
  if (data == '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

  var length = ''
    , n, msg;

  for (var i = 0, l = data.length; i < l; i++) {
    var chr = data.charAt(i);

    if (':' != chr) {
      length += chr;
    } else {
      if ('' == length || (length != (n = Number(length)))) {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }

      msg = data.substr(i + 1, n);

      if (length != msg.length) {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }

      if (msg.length) {
        packet = exports.decodePacket(msg, binaryType, true);

        if (err.type == packet.type && err.data == packet.data) {
          // parser error in individual packet - ignoring payload
          return callback(err, 0, 1);
        }

        var ret = callback(packet, i + n, l);
        if (false === ret) return;
      }

      // advance cursor
      i += n;
      length = '';
    }
  }

  if (length != '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

};

/**
 * Encodes multiple messages (payload) as binary.
 *
 * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
 * 255><data>
 *
 * Example:
 * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
 *
 * @param {Array} packets
 * @return {ArrayBuffer} encoded payload
 * @api private
 */

exports.encodePayloadAsArrayBuffer = function(packets, callback) {
  if (!packets.length) {
    return callback(new ArrayBuffer(0));
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(data) {
      return doneCallback(null, data);
    });
  }

  map(packets, encodeOne, function(err, encodedPackets) {
    var totalLength = encodedPackets.reduce(function(acc, p) {
      var len;
      if (typeof p === 'string'){
        len = p.length;
      } else {
        len = p.byteLength;
      }
      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
    }, 0);

    var resultArray = new Uint8Array(totalLength);

    var bufferIndex = 0;
    encodedPackets.forEach(function(p) {
      var isString = typeof p === 'string';
      var ab = p;
      if (isString) {
        var view = new Uint8Array(p.length);
        for (var i = 0; i < p.length; i++) {
          view[i] = p.charCodeAt(i);
        }
        ab = view.buffer;
      }

      if (isString) { // not true binary
        resultArray[bufferIndex++] = 0;
      } else { // true binary
        resultArray[bufferIndex++] = 1;
      }

      var lenStr = ab.byteLength.toString();
      for (var i = 0; i < lenStr.length; i++) {
        resultArray[bufferIndex++] = parseInt(lenStr[i]);
      }
      resultArray[bufferIndex++] = 255;

      var view = new Uint8Array(ab);
      for (var i = 0; i < view.length; i++) {
        resultArray[bufferIndex++] = view[i];
      }
    });

    return callback(resultArray.buffer);
  });
};

/**
 * Encode as Blob
 */

exports.encodePayloadAsBlob = function(packets, callback) {
  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(encoded) {
      var binaryIdentifier = new Uint8Array(1);
      binaryIdentifier[0] = 1;
      if (typeof encoded === 'string') {
        var view = new Uint8Array(encoded.length);
        for (var i = 0; i < encoded.length; i++) {
          view[i] = encoded.charCodeAt(i);
        }
        encoded = view.buffer;
        binaryIdentifier[0] = 0;
      }

      var len = (encoded instanceof ArrayBuffer)
        ? encoded.byteLength
        : encoded.size;

      var lenStr = len.toString();
      var lengthAry = new Uint8Array(lenStr.length + 1);
      for (var i = 0; i < lenStr.length; i++) {
        lengthAry[i] = parseInt(lenStr[i]);
      }
      lengthAry[lenStr.length] = 255;

      if (Blob) {
        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
        doneCallback(null, blob);
      }
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(new Blob(results));
  });
};

/*
 * Decodes data when a payload is maybe expected. Strings are decoded by
 * interpreting each byte as a key code for entries marked to start with 0. See
 * description of encodePayloadAsBinary
 *
 * @param {ArrayBuffer} data, callback method
 * @api public
 */

exports.decodePayloadAsBinary = function (data, binaryType, callback) {
  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var bufferTail = data;
  var buffers = [];

  var numberTooLong = false;
  while (bufferTail.byteLength > 0) {
    var tailArray = new Uint8Array(bufferTail);
    var isString = tailArray[0] === 0;
    var msgLength = '';

    for (var i = 1; ; i++) {
      if (tailArray[i] == 255) break;

      if (msgLength.length > 310) {
        numberTooLong = true;
        break;
      }

      msgLength += tailArray[i];
    }

    if(numberTooLong) return callback(err, 0, 1);

    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
    msgLength = parseInt(msgLength);

    var msg = sliceBuffer(bufferTail, 0, msgLength);
    if (isString) {
      try {
        msg = String.fromCharCode.apply(null, new Uint8Array(msg));
      } catch (e) {
        // iPhone Safari doesn't let you apply to typed arrays
        var typed = new Uint8Array(msg);
        msg = '';
        for (var i = 0; i < typed.length; i++) {
          msg += String.fromCharCode(typed[i]);
        }
      }
    }

    buffers.push(msg);
    bufferTail = sliceBuffer(bufferTail, msgLength);
  }

  var total = buffers.length;
  buffers.forEach(function(buffer, i) {
    callback(exports.decodePacket(buffer, binaryType, true), i, total);
  });
};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {})
},{"./keys":28,"after":6,"arraybuffer.slice":7,"base64-arraybuffer":9,"blob":10,"has-binary":29,"utf8":44}],28:[function(_dereq_,module,exports){

/**
 * Gets the keys for an object.
 *
 * @return {Array} keys
 * @api private
 */

module.exports = Object.keys || function keys (obj){
  var arr = [];
  var has = Object.prototype.hasOwnProperty;

  for (var i in obj) {
    if (has.call(obj, i)) {
      arr.push(i);
    }
  }
  return arr;
};

},{}],29:[function(_dereq_,module,exports){
(function (global){

/*
 * Module requirements.
 */

var isArray = _dereq_('isarray');

/**
 * Module exports.
 */

module.exports = hasBinary;

/**
 * Checks for binary data.
 *
 * Right now only Buffer and ArrayBuffer are supported..
 *
 * @param {Object} anything
 * @api public
 */

function hasBinary(data) {

  function _hasBinary(obj) {
    if (!obj) return false;

    if ( (global.Buffer && global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||
         (global.Blob && obj instanceof Blob) ||
         (global.File && obj instanceof File)
        ) {
      return true;
    }

    if (isArray(obj)) {
      for (var i = 0; i < obj.length; i++) {
          if (_hasBinary(obj[i])) {
              return true;
          }
      }
    } else if (obj && 'object' == typeof obj) {
      if (obj.toJSON) {
        obj = obj.toJSON();
      }

      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {
          return true;
        }
      }
    }

    return false;
  }

  return _hasBinary(data);
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {})
},{"isarray":33}],30:[function(_dereq_,module,exports){
(function (global){

/*
 * Module requirements.
 */

var isArray = _dereq_('isarray');

/**
 * Module exports.
 */

module.exports = hasBinary;

/**
 * Checks for binary data.
 *
 * Right now only Buffer and ArrayBuffer are supported..
 *
 * @param {Object} anything
 * @api public
 */

function hasBinary(data) {

  function _hasBinary(obj) {
    if (!obj) return false;

    if ( (global.Buffer && global.Buffer.isBuffer && global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||
         (global.Blob && obj instanceof Blob) ||
         (global.File && obj instanceof File)
        ) {
      return true;
    }

    if (isArray(obj)) {
      for (var i = 0; i < obj.length; i++) {
          if (_hasBinary(obj[i])) {
              return true;
          }
      }
    } else if (obj && 'object' == typeof obj) {
      // see: https://github.com/Automattic/has-binary/pull/4
      if (obj.toJSON && 'function' == typeof obj.toJSON) {
        obj = obj.toJSON();
      }

      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {
          return true;
        }
      }
    }

    return false;
  }

  return _hasBinary(data);
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {})
},{"isarray":33}],31:[function(_dereq_,module,exports){

/**
 * Module exports.
 *
 * Logic borrowed from Modernizr:
 *
 *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
 */

try {
  module.exports = typeof XMLHttpRequest !== 'undefined' &&
    'withCredentials' in new XMLHttpRequest();
} catch (err) {
  // if XMLHttp support is disabled in IE then it will throw
  // when trying to create
  module.exports = false;
}

},{}],32:[function(_dereq_,module,exports){

var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};
},{}],33:[function(_dereq_,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},{}],34:[function(_dereq_,module,exports){
(function (global){
/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */
;(function () {
  // Detect the `define` function exposed by asynchronous module loaders. The
  // strict `define` check is necessary for compatibility with `r.js`.
  var isLoader = typeof define === "function" && define.amd;

  // A set of types used to distinguish objects from primitives.
  var objectTypes = {
    "function": true,
    "object": true
  };

  // Detect the `exports` object exposed by CommonJS implementations.
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  // Use the `global` object exposed by Node (including Browserify via
  // `insert-module-globals`), Narwhal, and Ringo as the default context,
  // and the `window` object in browsers. Rhino exports a `global` function
  // instead.
  var root = objectTypes[typeof window] && window || this,
      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == "object" && global;

  if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal || freeGlobal["self"] === freeGlobal)) {
    root = freeGlobal;
  }

  // Public: Initializes JSON 3 using the given `context` object, attaching the
  // `stringify` and `parse` functions to the specified `exports` object.
  function runInContext(context, exports) {
    context || (context = root["Object"]());
    exports || (exports = root["Object"]());

    // Native constructor aliases.
    var Number = context["Number"] || root["Number"],
        String = context["String"] || root["String"],
        Object = context["Object"] || root["Object"],
        Date = context["Date"] || root["Date"],
        SyntaxError = context["SyntaxError"] || root["SyntaxError"],
        TypeError = context["TypeError"] || root["TypeError"],
        Math = context["Math"] || root["Math"],
        nativeJSON = context["JSON"] || root["JSON"];

    // Delegate to the native `stringify` and `parse` implementations.
    if (typeof nativeJSON == "object" && nativeJSON) {
      exports.stringify = nativeJSON.stringify;
      exports.parse = nativeJSON.parse;
    }

    // Convenience aliases.
    var objectProto = Object.prototype,
        getClass = objectProto.toString,
        isProperty, forEach, undef;

    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
    var isExtended = new Date(-3509827334573292);
    try {
      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
      // results for certain dates in Opera >= 10.53.
      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
        // Safari < 2.0.2 stores the internal millisecond time value correctly,
        // but clips the values returned by the date methods to the range of
        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
    } catch (exception) {}

    // Internal: Determines whether the native `JSON.stringify` and `parse`
    // implementations are spec-compliant. Based on work by Ken Snyder.
    function has(name) {
      if (has[name] !== undef) {
        // Return cached feature test result.
        return has[name];
      }
      var isSupported;
      if (name == "bug-string-char-index") {
        // IE <= 7 doesn't support accessing string characters using square
        // bracket notation. IE 8 only supports this for primitives.
        isSupported = "a"[0] != "a";
      } else if (name == "json") {
        // Indicates whether both `JSON.stringify` and `JSON.parse` are
        // supported.
        isSupported = has("json-stringify") && has("json-parse");
      } else {
        var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
        // Test `JSON.stringify`.
        if (name == "json-stringify") {
          var stringify = exports.stringify, stringifySupported = typeof stringify == "function" && isExtended;
          if (stringifySupported) {
            // A test function object with a custom `toJSON` method.
            (value = function () {
              return 1;
            }).toJSON = value;
            try {
              stringifySupported =
                // Firefox 3.1b1 and b2 serialize string, number, and boolean
                // primitives as object literals.
                stringify(0) === "0" &&
                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
                // literals.
                stringify(new Number()) === "0" &&
                stringify(new String()) == '""' &&
                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
                // does not define a canonical JSON representation (this applies to
                // objects with `toJSON` properties as well, *unless* they are nested
                // within an object or array).
                stringify(getClass) === undef &&
                // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
                // FF 3.1b3 pass this test.
                stringify(undef) === undef &&
                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
                // respectively, if the value is omitted entirely.
                stringify() === undef &&
                // FF 3.1b1, 2 throw an error if the given value is not a number,
                // string, array, object, Boolean, or `null` literal. This applies to
                // objects with custom `toJSON` methods as well, unless they are nested
                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
                // methods entirely.
                stringify(value) === "1" &&
                stringify([value]) == "[1]" &&
                // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
                // `"[null]"`.
                stringify([undef]) == "[null]" &&
                // YUI 3.0.0b1 fails to serialize `null` literals.
                stringify(null) == "null" &&
                // FF 3.1b1, 2 halts serialization if an array contains a function:
                // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
                // elides non-JSON values from objects and arrays, unless they
                // define custom `toJSON` methods.
                stringify([undef, getClass, null]) == "[null,null,null]" &&
                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
                // where character escape codes are expected (e.g., `\b` => `\u0008`).
                stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
                stringify(null, value) === "1" &&
                stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
                // serialize extended years.
                stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
                // The milliseconds are optional in ES 5, but required in 5.1.
                stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
                // four-digit years instead of six-digit years. Credits: @Yaffle.
                stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
                // values less than 1000. Credits: @Yaffle.
                stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
            } catch (exception) {
              stringifySupported = false;
            }
          }
          isSupported = stringifySupported;
        }
        // Test `JSON.parse`.
        if (name == "json-parse") {
          var parse = exports.parse;
          if (typeof parse == "function") {
            try {
              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
              // Conforming implementations should also coerce the initial argument to
              // a string prior to parsing.
              if (parse("0") === 0 && !parse(false)) {
                // Simple parsing test.
                value = parse(serialized);
                var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
                if (parseSupported) {
                  try {
                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                    parseSupported = !parse('"\t"');
                  } catch (exception) {}
                  if (parseSupported) {
                    try {
                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading
                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                      // certain octal literals.
                      parseSupported = parse("01") !== 1;
                    } catch (exception) {}
                  }
                  if (parseSupported) {
                    try {
                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                      // points. These environments, along with FF 3.1b1 and 2,
                      // also allow trailing commas in JSON objects and arrays.
                      parseSupported = parse("1.") !== 1;
                    } catch (exception) {}
                  }
                }
              }
            } catch (exception) {
              parseSupported = false;
            }
          }
          isSupported = parseSupported;
        }
      }
      return has[name] = !!isSupported;
    }

    if (!has("json")) {
      // Common `[[Class]]` name aliases.
      var functionClass = "[object Function]",
          dateClass = "[object Date]",
          numberClass = "[object Number]",
          stringClass = "[object String]",
          arrayClass = "[object Array]",
          booleanClass = "[object Boolean]";

      // Detect incomplete support for accessing string characters by index.
      var charIndexBuggy = has("bug-string-char-index");

      // Define additional utility methods if the `Date` methods are buggy.
      if (!isExtended) {
        var floor = Math.floor;
        // A mapping between the months of the year and the number of days between
        // January 1st and the first of the respective month.
        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
        // Internal: Calculates the number of days between the Unix epoch and the
        // first day of the given month.
        var getDay = function (year, month) {
          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
        };
      }

      // Internal: Determines if a property is a direct property of the given
      // object. Delegates to the native `Object#hasOwnProperty` method.
      if (!(isProperty = objectProto.hasOwnProperty)) {
        isProperty = function (property) {
          var members = {}, constructor;
          if ((members.__proto__ = null, members.__proto__ = {
            // The *proto* property cannot be set multiple times in recent
            // versions of Firefox and SeaMonkey.
            "toString": 1
          }, members).toString != getClass) {
            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
            // supports the mutable *proto* property.
            isProperty = function (property) {
              // Capture and break the object's prototype chain (see section 8.6.2
              // of the ES 5.1 spec). The parenthesized expression prevents an
              // unsafe transformation by the Closure Compiler.
              var original = this.__proto__, result = property in (this.__proto__ = null, this);
              // Restore the original prototype chain.
              this.__proto__ = original;
              return result;
            };
          } else {
            // Capture a reference to the top-level `Object` constructor.
            constructor = members.constructor;
            // Use the `constructor` property to simulate `Object#hasOwnProperty` in
            // other environments.
            isProperty = function (property) {
              var parent = (this.constructor || constructor).prototype;
              return property in this && !(property in parent && this[property] === parent[property]);
            };
          }
          members = null;
          return isProperty.call(this, property);
        };
      }

      // Internal: Normalizes the `for...in` iteration algorithm across
      // environments. Each enumerated key is yielded to a `callback` function.
      forEach = function (object, callback) {
        var size = 0, Properties, members, property;

        // Tests for bugs in the current environment's `for...in` algorithm. The
        // `valueOf` property inherits the non-enumerable flag from
        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
        (Properties = function () {
          this.valueOf = 0;
        }).prototype.valueOf = 0;

        // Iterate over a new instance of the `Properties` class.
        members = new Properties();
        for (property in members) {
          // Ignore all properties inherited from `Object.prototype`.
          if (isProperty.call(members, property)) {
            size++;
          }
        }
        Properties = members = null;

        // Normalize the iteration algorithm.
        if (!size) {
          // A list of non-enumerable properties inherited from `Object.prototype`.
          members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
          // properties.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, length;
            var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;
            for (property in object) {
              // Gecko <= 1.0 enumerates the `prototype` property of functions under
              // certain conditions; IE does not.
              if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
                callback(property);
              }
            }
            // Manually invoke the callback for each non-enumerable property.
            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
          };
        } else if (size == 2) {
          // Safari <= 2.0.4 enumerates shadowed properties twice.
          forEach = function (object, callback) {
            // Create a set of iterated properties.
            var members = {}, isFunction = getClass.call(object) == functionClass, property;
            for (property in object) {
              // Store each property name to prevent double enumeration. The
              // `prototype` property of functions is not enumerated due to cross-
              // environment inconsistencies.
              if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
                callback(property);
              }
            }
          };
        } else {
          // No bugs detected; use the standard `for...in` algorithm.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, isConstructor;
            for (property in object) {
              if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
                callback(property);
              }
            }
            // Manually invoke the callback for the `constructor` property due to
            // cross-environment inconsistencies.
            if (isConstructor || isProperty.call(object, (property = "constructor"))) {
              callback(property);
            }
          };
        }
        return forEach(object, callback);
      };

      // Public: Serializes a JavaScript `value` as a JSON string. The optional
      // `filter` argument may specify either a function that alters how object and
      // array members are serialized, or an array of strings and numbers that
      // indicates which properties should be serialized. The optional `width`
      // argument may be either a string or number that specifies the indentation
      // level of the output.
      if (!has("json-stringify")) {
        // Internal: A map of control characters and their escaped equivalents.
        var Escapes = {
          92: "\\\\",
          34: '\\"',
          8: "\\b",
          12: "\\f",
          10: "\\n",
          13: "\\r",
          9: "\\t"
        };

        // Internal: Converts `value` into a zero-padded string such that its
        // length is at least equal to `width`. The `width` must be <= 6.
        var leadingZeroes = "000000";
        var toPaddedString = function (width, value) {
          // The `|| 0` expression is necessary to work around a bug in
          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
          return (leadingZeroes + (value || 0)).slice(-width);
        };

        // Internal: Double-quotes a string `value`, replacing all ASCII control
        // characters (characters with code unit values between 0 and 31) with
        // their escaped equivalents. This is an implementation of the
        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
        var unicodePrefix = "\\u00";
        var quote = function (value) {
          var result = '"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;
          var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);
          for (; index < length; index++) {
            var charCode = value.charCodeAt(index);
            // If the character is a control character, append its Unicode or
            // shorthand escape sequence; otherwise, append the character as-is.
            switch (charCode) {
              case 8: case 9: case 10: case 12: case 13: case 34: case 92:
                result += Escapes[charCode];
                break;
              default:
                if (charCode < 32) {
                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                  break;
                }
                result += useCharIndex ? symbols[index] : value.charAt(index);
            }
          }
          return result + '"';
        };

        // Internal: Recursively serializes an object. Implements the
        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
          try {
            // Necessary for host object support.
            value = object[property];
          } catch (exception) {}
          if (typeof value == "object" && value) {
            className = getClass.call(value);
            if (className == dateClass && !isProperty.call(value, "toJSON")) {
              if (value > -1 / 0 && value < 1 / 0) {
                // Dates are serialized according to the `Date#toJSON` method
                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
                // for the ISO 8601 date time string format.
                if (getDay) {
                  // Manually compute the year, month, date, hours, minutes,
                  // seconds, and milliseconds if the `getUTC*` methods are
                  // buggy. Adapted from @Yaffle's `date-shim` project.
                  date = floor(value / 864e5);
                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
                  date = 1 + date - getDay(year, month);
                  // The `time` value specifies the time within the day (see ES
                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                  // to compute `A modulo B`, as the `%` operator does not
                  // correspond to the `modulo` operation for negative numbers.
                  time = (value % 864e5 + 864e5) % 864e5;
                  // The hours, minutes, seconds, and milliseconds are obtained by
                  // decomposing the time within the day. See section 15.9.1.10.
                  hours = floor(time / 36e5) % 24;
                  minutes = floor(time / 6e4) % 60;
                  seconds = floor(time / 1e3) % 60;
                  milliseconds = time % 1e3;
                } else {
                  year = value.getUTCFullYear();
                  month = value.getUTCMonth();
                  date = value.getUTCDate();
                  hours = value.getUTCHours();
                  minutes = value.getUTCMinutes();
                  seconds = value.getUTCSeconds();
                  milliseconds = value.getUTCMilliseconds();
                }
                // Serialize extended years correctly.
                value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
                  "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
                  // Months, dates, hours, minutes, and seconds should have two
                  // digits; milliseconds should have three.
                  "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
                  // Milliseconds are optional in ES 5.0, but required in 5.1.
                  "." + toPaddedString(3, milliseconds) + "Z";
              } else {
                value = null;
              }
            } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
              // ignores all `toJSON` methods on these objects unless they are
              // defined directly on an instance.
              value = value.toJSON(property);
            }
          }
          if (callback) {
            // If a replacement function was provided, call it to obtain the value
            // for serialization.
            value = callback.call(object, property, value);
          }
          if (value === null) {
            return "null";
          }
          className = getClass.call(value);
          if (className == booleanClass) {
            // Booleans are represented literally.
            return "" + value;
          } else if (className == numberClass) {
            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
            // `"null"`.
            return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
          } else if (className == stringClass) {
            // Strings are double-quoted and escaped.
            return quote("" + value);
          }
          // Recursively serialize objects and arrays.
          if (typeof value == "object") {
            // Check for cyclic structures. This is a linear search; performance
            // is inversely proportional to the number of unique nested objects.
            for (length = stack.length; length--;) {
              if (stack[length] === value) {
                // Cyclic structures cannot be serialized by `JSON.stringify`.
                throw TypeError();
              }
            }
            // Add the object to the stack of traversed objects.
            stack.push(value);
            results = [];
            // Save the current indentation level and indent one additional level.
            prefix = indentation;
            indentation += whitespace;
            if (className == arrayClass) {
              // Recursively serialize array elements.
              for (index = 0, length = value.length; index < length; index++) {
                element = serialize(index, value, callback, properties, whitespace, indentation, stack);
                results.push(element === undef ? "null" : element);
              }
              result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
            } else {
              // Recursively serialize object members. Members are selected from
              // either a user-specified list of property names, or the object
              // itself.
              forEach(properties || value, function (property) {
                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
                if (element !== undef) {
                  // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
                  // is not the empty string, let `member` {quote(property) + ":"}
                  // be the concatenation of `member` and the `space` character."
                  // The "`space` character" refers to the literal space
                  // character, not the `space` {width} argument provided to
                  // `JSON.stringify`.
                  results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
                }
              });
              result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
            }
            // Remove the object from the traversed object stack.
            stack.pop();
            return result;
          }
        };

        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
        exports.stringify = function (source, filter, width) {
          var whitespace, callback, properties, className;
          if (objectTypes[typeof filter] && filter) {
            if ((className = getClass.call(filter)) == functionClass) {
              callback = filter;
            } else if (className == arrayClass) {
              // Convert the property names array into a makeshift set.
              properties = {};
              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
            }
          }
          if (width) {
            if ((className = getClass.call(width)) == numberClass) {
              // Convert the `width` to an integer and create a string containing
              // `width` number of space characters.
              if ((width -= width % 1) > 0) {
                for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
              }
            } else if (className == stringClass) {
              whitespace = width.length <= 10 ? width : width.slice(0, 10);
            }
          }
          // Opera <= 7.54u2 discards the values associated with empty string keys
          // (`""`) only if they are used directly within an object member list
          // (e.g., `!("" in { "": 1})`).
          return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
        };
      }

      // Public: Parses a JSON source string.
      if (!has("json-parse")) {
        var fromCharCode = String.fromCharCode;

        // Internal: A map of escaped control characters and their unescaped
        // equivalents.
        var Unescapes = {
          92: "\\",
          34: '"',
          47: "/",
          98: "\b",
          116: "\t",
          110: "\n",
          102: "\f",
          114: "\r"
        };

        // Internal: Stores the parser state.
        var Index, Source;

        // Internal: Resets the parser state and throws a `SyntaxError`.
        var abort = function () {
          Index = Source = null;
          throw SyntaxError();
        };

        // Internal: Returns the next token, or `"$"` if the parser has reached
        // the end of the source string. A token may be a string, number, `null`
        // literal, or Boolean literal.
        var lex = function () {
          var source = Source, length = source.length, value, begin, position, isSigned, charCode;
          while (Index < length) {
            charCode = source.charCodeAt(Index);
            switch (charCode) {
              case 9: case 10: case 13: case 32:
                // Skip whitespace tokens, including tabs, carriage returns, line
                // feeds, and space characters.
                Index++;
                break;
              case 123: case 125: case 91: case 93: case 58: case 44:
                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
                // the current position.
                value = charIndexBuggy ? source.charAt(Index) : source[Index];
                Index++;
                return value;
              case 34:
                // `"` delimits a JSON string; advance to the next character and
                // begin parsing the string. String tokens are prefixed with the
                // sentinel `@` character to distinguish them from punctuators and
                // end-of-string tokens.
                for (value = "@", Index++; Index < length;) {
                  charCode = source.charCodeAt(Index);
                  if (charCode < 32) {
                    // Unescaped ASCII control characters (those with a code unit
                    // less than the space character) are not permitted.
                    abort();
                  } else if (charCode == 92) {
                    // A reverse solidus (`\`) marks the beginning of an escaped
                    // control character (including `"`, `\`, and `/`) or Unicode
                    // escape sequence.
                    charCode = source.charCodeAt(++Index);
                    switch (charCode) {
                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
                        // Revive escaped control characters.
                        value += Unescapes[charCode];
                        Index++;
                        break;
                      case 117:
                        // `\u` marks the beginning of a Unicode escape sequence.
                        // Advance to the first character and validate the
                        // four-digit code point.
                        begin = ++Index;
                        for (position = Index + 4; Index < position; Index++) {
                          charCode = source.charCodeAt(Index);
                          // A valid sequence comprises four hexdigits (case-
                          // insensitive) that form a single hexadecimal value.
                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                            // Invalid Unicode escape sequence.
                            abort();
                          }
                        }
                        // Revive the escaped character.
                        value += fromCharCode("0x" + source.slice(begin, Index));
                        break;
                      default:
                        // Invalid escape sequence.
                        abort();
                    }
                  } else {
                    if (charCode == 34) {
                      // An unescaped double-quote character marks the end of the
                      // string.
                      break;
                    }
                    charCode = source.charCodeAt(Index);
                    begin = Index;
                    // Optimize for the common case where a string is valid.
                    while (charCode >= 32 && charCode != 92 && charCode != 34) {
                      charCode = source.charCodeAt(++Index);
                    }
                    // Append the string as-is.
                    value += source.slice(begin, Index);
                  }
                }
                if (source.charCodeAt(Index) == 34) {
                  // Advance to the next character and return the revived string.
                  Index++;
                  return value;
                }
                // Unterminated string.
                abort();
              default:
                // Parse numbers and literals.
                begin = Index;
                // Advance past the negative sign, if one is specified.
                if (charCode == 45) {
                  isSigned = true;
                  charCode = source.charCodeAt(++Index);
                }
                // Parse an integer or floating-point value.
                if (charCode >= 48 && charCode <= 57) {
                  // Leading zeroes are interpreted as octal literals.
                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
                    // Illegal octal literal.
                    abort();
                  }
                  isSigned = false;
                  // Parse the integer component.
                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
                  // Floats cannot contain a leading decimal point; however, this
                  // case is already accounted for by the parser.
                  if (source.charCodeAt(Index) == 46) {
                    position = ++Index;
                    // Parse the decimal component.
                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal trailing decimal.
                      abort();
                    }
                    Index = position;
                  }
                  // Parse exponents. The `e` denoting the exponent is
                  // case-insensitive.
                  charCode = source.charCodeAt(Index);
                  if (charCode == 101 || charCode == 69) {
                    charCode = source.charCodeAt(++Index);
                    // Skip past the sign following the exponent, if one is
                    // specified.
                    if (charCode == 43 || charCode == 45) {
                      Index++;
                    }
                    // Parse the exponential component.
                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal empty exponent.
                      abort();
                    }
                    Index = position;
                  }
                  // Coerce the parsed value to a JavaScript number.
                  return +source.slice(begin, Index);
                }
                // A negative sign may only precede numbers.
                if (isSigned) {
                  abort();
                }
                // `true`, `false`, and `null` literals.
                if (source.slice(Index, Index + 4) == "true") {
                  Index += 4;
                  return true;
                } else if (source.slice(Index, Index + 5) == "false") {
                  Index += 5;
                  return false;
                } else if (source.slice(Index, Index + 4) == "null") {
                  Index += 4;
                  return null;
                }
                // Unrecognized token.
                abort();
            }
          }
          // Return the sentinel `$` character if the parser has reached the end
          // of the source string.
          return "$";
        };

        // Internal: Parses a JSON `value` token.
        var get = function (value) {
          var results, hasMembers;
          if (value == "$") {
            // Unexpected end of input.
            abort();
          }
          if (typeof value == "string") {
            if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
              // Remove the sentinel `@` character.
              return value.slice(1);
            }
            // Parse object and array literals.
            if (value == "[") {
              // Parses a JSON array, returning a new JavaScript array.
              results = [];
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing square bracket marks the end of the array literal.
                if (value == "]") {
                  break;
                }
                // If the array literal contains elements, the current token
                // should be a comma separating the previous element from the
                // next.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "]") {
                      // Unexpected trailing `,` in array literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each array element.
                    abort();
                  }
                }
                // Elisions and leading commas are not permitted.
                if (value == ",") {
                  abort();
                }
                results.push(get(value));
              }
              return results;
            } else if (value == "{") {
              // Parses a JSON object, returning a new JavaScript object.
              results = {};
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing curly brace marks the end of the object literal.
                if (value == "}") {
                  break;
                }
                // If the object literal contains members, the current token
                // should be a comma separator.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "}") {
                      // Unexpected trailing `,` in object literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each object member.
                    abort();
                  }
                }
                // Leading commas are not permitted, object property names must be
                // double-quoted strings, and a `:` must separate each property
                // name and value.
                if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
                  abort();
                }
                results[value.slice(1)] = get(lex());
              }
              return results;
            }
            // Unexpected token encountered.
            abort();
          }
          return value;
        };

        // Internal: Updates a traversed object member.
        var update = function (source, property, callback) {
          var element = walk(source, property, callback);
          if (element === undef) {
            delete source[property];
          } else {
            source[property] = element;
          }
        };

        // Internal: Recursively traverses a parsed JSON object, invoking the
        // `callback` function for each value. This is an implementation of the
        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
        var walk = function (source, property, callback) {
          var value = source[property], length;
          if (typeof value == "object" && value) {
            // `forEach` can't be used to traverse an array in Opera <= 8.54
            // because its `Object#hasOwnProperty` implementation returns `false`
            // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
            if (getClass.call(value) == arrayClass) {
              for (length = value.length; length--;) {
                update(value, length, callback);
              }
            } else {
              forEach(value, function (property) {
                update(value, property, callback);
              });
            }
          }
          return callback.call(source, property, value);
        };

        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
        exports.parse = function (source, callback) {
          var result, value;
          Index = 0;
          Source = "" + source;
          result = get(lex());
          // If a JSON string contains multiple tokens, it is invalid.
          if (lex() != "$") {
            abort();
          }
          // Reset the parser state.
          Index = Source = null;
          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
        };
      }
    }

    exports["runInContext"] = runInContext;
    return exports;
  }

  if (freeExports && !isLoader) {
    // Export for CommonJS environments.
    runInContext(root, freeExports);
  } else {
    // Export for web browsers and JavaScript engines.
    var nativeJSON = root.JSON,
        previousJSON = root["JSON3"],
        isRestored = false;

    var JSON3 = runInContext(root, (root["JSON3"] = {
      // Public: Restores the original value of the global `JSON` object and
      // returns a reference to the `JSON3` object.
      "noConflict": function () {
        if (!isRestored) {
          isRestored = true;
          root.JSON = nativeJSON;
          root["JSON3"] = previousJSON;
          nativeJSON = previousJSON = null;
        }
        return JSON3;
      }
    }));

    root.JSON = {
      "parse": JSON3.parse,
      "stringify": JSON3.stringify
    };
  }

  // Export for asynchronous module loaders.
  if (isLoader) {
    define(function () {
      return JSON3;
    });
  }
}).call(this);

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {})
},{}],35:[function(_dereq_,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options){
  options = options || {};
  if ('string' == typeof val) return parse(val);
  return options.long
    ? long(val)
    : short(val);
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = '' + str;
  if (str.length > 10000) return;
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
  if (!match) return;
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function short(ms) {
  if (ms >= d) return Math.round(ms / d) + 'd';
  if (ms >= h) return Math.round(ms / h) + 'h';
  if (ms >= m) return Math.round(ms / m) + 'm';
  if (ms >= s) return Math.round(ms / s) + 's';
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function long(ms) {
  return plural(ms, d, 'day')
    || plural(ms, h, 'hour')
    || plural(ms, m, 'minute')
    || plural(ms, s, 'second')
    || ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) return;
  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],36:[function(_dereq_,module,exports){
(function (global){
/**
 * JSON parse.
 *
 * @see Based on jQuery#parseJSON (MIT) and JSON2
 * @api private
 */

var rvalidchars = /^[\],:{}\s]*$/;
var rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
var rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
var rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g;
var rtrimLeft = /^\s+/;
var rtrimRight = /\s+$/;

module.exports = function parsejson(data) {
  if ('string' != typeof data || !data) {
    return null;
  }

  data = data.replace(rtrimLeft, '').replace(rtrimRight, '');

  // Attempt to parse using the native JSON parser first
  if (global.JSON && JSON.parse) {
    return JSON.parse(data);
  }

  if (rvalidchars.test(data.replace(rvalidescape, '@')
      .replace(rvalidtokens, ']')
      .replace(rvalidbraces, ''))) {
    return (new Function('return ' + data))();
  }
};
}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {})
},{}],37:[function(_dereq_,module,exports){
/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */

exports.encode = function (obj) {
  var str = '';

  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length) str += '&';
      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
    }
  }

  return str;
};

/**
 * Parses a simple querystring into an object
 *
 * @param {String} qs
 * @api private
 */

exports.decode = function(qs){
  var qry = {};
  var pairs = qs.split('&');
  for (var i = 0, l = pairs.length; i < l; i++) {
    var pair = pairs[i].split('=');
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
};

},{}],38:[function(_dereq_,module,exports){
/**
 * Parses an URI
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */

var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

var parts = [
    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
];

module.exports = function parseuri(str) {
    var src = str,
        b = str.indexOf('['),
        e = str.indexOf(']');

    if (b != -1 && e != -1) {
        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
    }

    var m = re.exec(str || ''),
        uri = {},
        i = 14;

    while (i--) {
        uri[parts[i]] = m[i] || '';
    }

    if (b != -1 && e != -1) {
        uri.source = src;
        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
        uri.ipv6uri = true;
    }

    return uri;
};

},{}],39:[function(_dereq_,module,exports){
(function (global){
/*global Blob,File*/

/**
 * Module requirements
 */

var isArray = _dereq_('isarray');
var isBuf = _dereq_('./is-buffer');

/**
 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
 * Anything with blobs or files should be fed through removeBlobs before coming
 * here.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @api public
 */

exports.deconstructPacket = function(packet){
  var buffers = [];
  var packetData = packet.data;

  function _deconstructPacket(data) {
    if (!data) return data;

    if (isBuf(data)) {
      var placeholder = { _placeholder: true, num: buffers.length };
      buffers.push(data);
      return placeholder;
    } else if (isArray(data)) {
      var newData = new Array(data.length);
      for (var i = 0; i < data.length; i++) {
        newData[i] = _deconstructPacket(data[i]);
      }
      return newData;
    } else if ('object' == typeof data && !(data instanceof Date)) {
      var newData = {};
      for (var key in data) {
        newData[key] = _deconstructPacket(data[key]);
      }
      return newData;
    }
    return data;
  }

  var pack = packet;
  pack.data = _deconstructPacket(packetData);
  pack.attachments = buffers.length; // number of binary 'attachments'
  return {packet: pack, buffers: buffers};
};

/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @api public
 */

exports.reconstructPacket = function(packet, buffers) {
  var curPlaceHolder = 0;

  function _reconstructPacket(data) {
    if (data && data._placeholder) {
      var buf = buffers[data.num]; // appropriate buffer (should be natural order anyway)
      return buf;
    } else if (isArray(data)) {
      for (var i = 0; i < data.length; i++) {
        data[i] = _reconstructPacket(data[i]);
      }
      return data;
    } else if (data && 'object' == typeof data) {
      for (var key in data) {
        data[key] = _reconstructPacket(data[key]);
      }
      return data;
    }
    return data;
  }

  packet.data = _reconstructPacket(packet.data);
  packet.attachments = undefined; // no longer useful
  return packet;
};

/**
 * Asynchronously removes Blobs or Files from data via
 * FileReader's readAsArrayBuffer method. Used before encoding
 * data as msgpack. Calls callback with the blobless data.
 *
 * @param {Object} data
 * @param {Function} callback
 * @api private
 */

exports.removeBlobs = function(data, callback) {
  function _removeBlobs(obj, curKey, containingObject) {
    if (!obj) return obj;

    // convert any blob
    if ((global.Blob && obj instanceof Blob) ||
        (global.File && obj instanceof File)) {
      pendingBlobs++;

      // async filereader
      var fileReader = new FileReader();
      fileReader.onload = function() { // this.result == arraybuffer
        if (containingObject) {
          containingObject[curKey] = this.result;
        }
        else {
          bloblessData = this.result;
        }

        // if nothing pending its callback time
        if(! --pendingBlobs) {
          callback(bloblessData);
        }
      };

      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
    } else if (isArray(obj)) { // handle array
      for (var i = 0; i < obj.length; i++) {
        _removeBlobs(obj[i], i, obj);
      }
    } else if (obj && 'object' == typeof obj && !isBuf(obj)) { // and object
      for (var key in obj) {
        _removeBlobs(obj[key], key, obj);
      }
    }
  }

  var pendingBlobs = 0;
  var bloblessData = data;
  _removeBlobs(bloblessData);
  if (!pendingBlobs) {
    callback(bloblessData);
  }
};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {})
},{"./is-buffer":41,"isarray":33}],40:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var debug = _dereq_('debug')('socket.io-parser');
var json = _dereq_('json3');
var isArray = _dereq_('isarray');
var Emitter = _dereq_('component-emitter');
var binary = _dereq_('./binary');
var isBuf = _dereq_('./is-buffer');

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = 4;

/**
 * Packet types.
 *
 * @api public
 */

exports.types = [
  'CONNECT',
  'DISCONNECT',
  'EVENT',
  'ACK',
  'ERROR',
  'BINARY_EVENT',
  'BINARY_ACK'
];

/**
 * Packet type `connect`.
 *
 * @api public
 */

exports.CONNECT = 0;

/**
 * Packet type `disconnect`.
 *
 * @api public
 */

exports.DISCONNECT = 1;

/**
 * Packet type `event`.
 *
 * @api public
 */

exports.EVENT = 2;

/**
 * Packet type `ack`.
 *
 * @api public
 */

exports.ACK = 3;

/**
 * Packet type `error`.
 *
 * @api public
 */

exports.ERROR = 4;

/**
 * Packet type 'binary event'
 *
 * @api public
 */

exports.BINARY_EVENT = 5;

/**
 * Packet type `binary ack`. For acks with binary arguments.
 *
 * @api public
 */

exports.BINARY_ACK = 6;

/**
 * Encoder constructor.
 *
 * @api public
 */

exports.Encoder = Encoder;

/**
 * Decoder constructor.
 *
 * @api public
 */

exports.Decoder = Decoder;

/**
 * A socket.io Encoder instance
 *
 * @api public
 */

function Encoder() {}

/**
 * Encode a packet as a single string if non-binary, or as a
 * buffer sequence, depending on packet type.
 *
 * @param {Object} obj - packet object
 * @param {Function} callback - function to handle encodings (likely engine.write)
 * @return Calls callback with Array of encodings
 * @api public
 */

Encoder.prototype.encode = function(obj, callback){
  debug('encoding packet %j', obj);

  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
    encodeAsBinary(obj, callback);
  }
  else {
    var encoding = encodeAsString(obj);
    callback([encoding]);
  }
};

/**
 * Encode packet as string.
 *
 * @param {Object} packet
 * @return {String} encoded
 * @api private
 */

function encodeAsString(obj) {
  var str = '';
  var nsp = false;

  // first is type
  str += obj.type;

  // attachments if we have them
  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
    str += obj.attachments;
    str += '-';
  }

  // if we have a namespace other than `/`
  // we append it followed by a comma `,`
  if (obj.nsp && '/' != obj.nsp) {
    nsp = true;
    str += obj.nsp;
  }

  // immediately followed by the id
  if (null != obj.id) {
    if (nsp) {
      str += ',';
      nsp = false;
    }
    str += obj.id;
  }

  // json data
  if (null != obj.data) {
    if (nsp) str += ',';
    str += json.stringify(obj.data);
  }

  debug('encoded %j as %s', obj, str);
  return str;
}

/**
 * Encode packet as 'buffer sequence' by removing blobs, and
 * deconstructing packet into object with placeholders and
 * a list of buffers.
 *
 * @param {Object} packet
 * @return {Buffer} encoded
 * @api private
 */

function encodeAsBinary(obj, callback) {

  function writeEncoding(bloblessData) {
    var deconstruction = binary.deconstructPacket(bloblessData);
    var pack = encodeAsString(deconstruction.packet);
    var buffers = deconstruction.buffers;

    buffers.unshift(pack); // add packet info to beginning of data list
    callback(buffers); // write all the buffers
  }

  binary.removeBlobs(obj, writeEncoding);
}

/**
 * A socket.io Decoder instance
 *
 * @return {Object} decoder
 * @api public
 */

function Decoder() {
  this.reconstructor = null;
}

/**
 * Mix in `Emitter` with Decoder.
 */

Emitter(Decoder.prototype);

/**
 * Decodes an ecoded packet string into packet JSON.
 *
 * @param {String} obj - encoded packet
 * @return {Object} packet
 * @api public
 */

Decoder.prototype.add = function(obj) {
  var packet;
  if ('string' == typeof obj) {
    packet = decodeString(obj);
    if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) { // binary packet's json
      this.reconstructor = new BinaryReconstructor(packet);

      // no attachments, labeled binary but no binary data to follow
      if (this.reconstructor.reconPack.attachments === 0) {
        this.emit('decoded', packet);
      }
    } else { // non-binary full packet
      this.emit('decoded', packet);
    }
  }
  else if (isBuf(obj) || obj.base64) { // raw binary data
    if (!this.reconstructor) {
      throw new Error('got binary data when not reconstructing a packet');
    } else {
      packet = this.reconstructor.takeBinaryData(obj);
      if (packet) { // received final buffer
        this.reconstructor = null;
        this.emit('decoded', packet);
      }
    }
  }
  else {
    throw new Error('Unknown type: ' + obj);
  }
};

/**
 * Decode a packet String (JSON data)
 *
 * @param {String} str
 * @return {Object} packet
 * @api private
 */

function decodeString(str) {
  var p = {};
  var i = 0;

  // look up type
  p.type = Number(str.charAt(0));
  if (null == exports.types[p.type]) return error();

  // look up attachments if type binary
  if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {
    var buf = '';
    while (str.charAt(++i) != '-') {
      buf += str.charAt(i);
      if (i == str.length) break;
    }
    if (buf != Number(buf) || str.charAt(i) != '-') {
      throw new Error('Illegal attachments');
    }
    p.attachments = Number(buf);
  }

  // look up namespace (if any)
  if ('/' == str.charAt(i + 1)) {
    p.nsp = '';
    while (++i) {
      var c = str.charAt(i);
      if (',' == c) break;
      p.nsp += c;
      if (i == str.length) break;
    }
  } else {
    p.nsp = '/';
  }

  // look up id
  var next = str.charAt(i + 1);
  if ('' !== next && Number(next) == next) {
    p.id = '';
    while (++i) {
      var c = str.charAt(i);
      if (null == c || Number(c) != c) {
        --i;
        break;
      }
      p.id += str.charAt(i);
      if (i == str.length) break;
    }
    p.id = Number(p.id);
  }

  // look up json data
  if (str.charAt(++i)) {
    try {
      p.data = json.parse(str.substr(i));
    } catch(e){
      return error();
    }
  }

  debug('decoded %s as %j', str, p);
  return p;
}

/**
 * Deallocates a parser's resources
 *
 * @api public
 */

Decoder.prototype.destroy = function() {
  if (this.reconstructor) {
    this.reconstructor.finishedReconstruction();
  }
};

/**
 * A manager of a binary event's 'buffer sequence'. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 * @api private
 */

function BinaryReconstructor(packet) {
  this.reconPack = packet;
  this.buffers = [];
}

/**
 * Method to be called when binary data received from connection
 * after a BINARY_EVENT packet.
 *
 * @param {Buffer | ArrayBuffer} binData - the raw binary data received
 * @return {null | Object} returns null if more binary data is expected or
 *   a reconstructed packet object if all buffers have been received.
 * @api private
 */

BinaryReconstructor.prototype.takeBinaryData = function(binData) {
  this.buffers.push(binData);
  if (this.buffers.length == this.reconPack.attachments) { // done with buffer list
    var packet = binary.reconstructPacket(this.reconPack, this.buffers);
    this.finishedReconstruction();
    return packet;
  }
  return null;
};

/**
 * Cleans up binary packet reconstruction variables.
 *
 * @api private
 */

BinaryReconstructor.prototype.finishedReconstruction = function() {
  this.reconPack = null;
  this.buffers = [];
};

function error(data){
  return {
    type: exports.ERROR,
    data: 'parser error'
  };
}

},{"./binary":39,"./is-buffer":41,"component-emitter":42,"debug":14,"isarray":33,"json3":34}],41:[function(_dereq_,module,exports){
(function (global){

module.exports = isBuf;

/**
 * Returns true if obj is a buffer or an arraybuffer.
 *
 * @api private
 */

function isBuf(obj) {
  return (global.Buffer && global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer && obj instanceof ArrayBuffer);
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {})
},{}],42:[function(_dereq_,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"dup":26}],43:[function(_dereq_,module,exports){
module.exports = toArray

function toArray(list, index) {
    var array = []

    index = index || 0

    for (var i = index || 0; i < list.length; i++) {
        array[i - index] = list[i]
    }

    return array
}

},{}],44:[function(_dereq_,module,exports){
(function (global){
/*! https://mths.be/utf8js v2.0.0 by @mathias */
;(function(root) {

	// Detect free variables `exports`
	var freeExports = typeof exports == 'object' && exports;

	// Detect free variable `module`
	var freeModule = typeof module == 'object' && module &&
		module.exports == freeExports && module;

	// Detect free variable `global`, from Node.js or Browserified code,
	// and use it as `root`
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/*--------------------------------------------------------------------------*/

	var stringFromCharCode = String.fromCharCode;

	// Taken from https://mths.be/punycode
	function ucs2decode(string) {
		var output = [];
		var counter = 0;
		var length = string.length;
		var value;
		var extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	// Taken from https://mths.be/punycode
	function ucs2encode(array) {
		var length = array.length;
		var index = -1;
		var value;
		var output = '';
		while (++index < length) {
			value = array[index];
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
		}
		return output;
	}

	function checkScalarValue(codePoint) {
		if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
			throw Error(
				'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +
				' is not a scalar value'
			);
		}
	}
	/*--------------------------------------------------------------------------*/

	function createByte(codePoint, shift) {
		return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
	}

	function encodeCodePoint(codePoint) {
		if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
			return stringFromCharCode(codePoint);
		}
		var symbol = '';
		if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
			symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
		}
		else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
			checkScalarValue(codePoint);
			symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
			symbol += createByte(codePoint, 6);
		}
		else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
			symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
			symbol += createByte(codePoint, 12);
			symbol += createByte(codePoint, 6);
		}
		symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
		return symbol;
	}

	function utf8encode(string) {
		var codePoints = ucs2decode(string);
		var length = codePoints.length;
		var index = -1;
		var codePoint;
		var byteString = '';
		while (++index < length) {
			codePoint = codePoints[index];
			byteString += encodeCodePoint(codePoint);
		}
		return byteString;
	}

	/*--------------------------------------------------------------------------*/

	function readContinuationByte() {
		if (byteIndex >= byteCount) {
			throw Error('Invalid byte index');
		}

		var continuationByte = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		if ((continuationByte & 0xC0) == 0x80) {
			return continuationByte & 0x3F;
		}

		// If we end up here, it’s not a continuation byte
		throw Error('Invalid continuation byte');
	}

	function decodeSymbol() {
		var byte1;
		var byte2;
		var byte3;
		var byte4;
		var codePoint;

		if (byteIndex > byteCount) {
			throw Error('Invalid byte index');
		}

		if (byteIndex == byteCount) {
			return false;
		}

		// Read first byte
		byte1 = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		// 1-byte sequence (no continuation bytes)
		if ((byte1 & 0x80) == 0) {
			return byte1;
		}

		// 2-byte sequence
		if ((byte1 & 0xE0) == 0xC0) {
			var byte2 = readContinuationByte();
			codePoint = ((byte1 & 0x1F) << 6) | byte2;
			if (codePoint >= 0x80) {
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 3-byte sequence (may include unpaired surrogates)
		if ((byte1 & 0xF0) == 0xE0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
			if (codePoint >= 0x0800) {
				checkScalarValue(codePoint);
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 4-byte sequence
		if ((byte1 & 0xF8) == 0xF0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			byte4 = readContinuationByte();
			codePoint = ((byte1 & 0x0F) << 0x12) | (byte2 << 0x0C) |
				(byte3 << 0x06) | byte4;
			if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
				return codePoint;
			}
		}

		throw Error('Invalid UTF-8 detected');
	}

	var byteArray;
	var byteCount;
	var byteIndex;
	function utf8decode(byteString) {
		byteArray = ucs2decode(byteString);
		byteCount = byteArray.length;
		byteIndex = 0;
		var codePoints = [];
		var tmp;
		while ((tmp = decodeSymbol()) !== false) {
			codePoints.push(tmp);
		}
		return ucs2encode(codePoints);
	}

	/*--------------------------------------------------------------------------*/

	var utf8 = {
		'version': '2.0.0',
		'encode': utf8encode,
		'decode': utf8decode
	};

	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define(function() {
			return utf8;
		});
	}	else if (freeExports && !freeExports.nodeType) {
		if (freeModule) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = utf8;
		} else { // in Narwhal or RingoJS v0.7.0-
			var object = {};
			var hasOwnProperty = object.hasOwnProperty;
			for (var key in utf8) {
				hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.utf8 = utf8;
	}

}(this));

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {})
},{}],45:[function(_dereq_,module,exports){
'use strict';

var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('')
  , length = 64
  , map = {}
  , seed = 0
  , i = 0
  , prev;

/**
 * Return a string representing the specified number.
 *
 * @param {Number} num The number to convert.
 * @returns {String} The string representation of the number.
 * @api public
 */
function encode(num) {
  var encoded = '';

  do {
    encoded = alphabet[num % length] + encoded;
    num = Math.floor(num / length);
  } while (num > 0);

  return encoded;
}

/**
 * Return the integer value specified by the given string.
 *
 * @param {String} str The string to convert.
 * @returns {Number} The integer value represented by the string.
 * @api public
 */
function decode(str) {
  var decoded = 0;

  for (i = 0; i < str.length; i++) {
    decoded = decoded * length + map[str.charAt(i)];
  }

  return decoded;
}

/**
 * Yeast: A tiny growing id generator.
 *
 * @returns {String} A unique id.
 * @api public
 */
function yeast() {
  var now = encode(+new Date());

  if (now !== prev) return seed = 0, prev = now;
  return now +'.'+ encode(seed++);
}

//
// Map each character to its index.
//
for (; i < length; i++) map[alphabet[i]] = i;

//
// Expose the `yeast`, `encode` and `decode` functions.
//
yeast.encode = encode;
yeast.decode = decode;
module.exports = yeast;

},{}]},{},[1])(1)
});

var globals = {};

if (typeof window !== 'undefined') {
	globals.window = window;
}

if (typeof document !== 'undefined') {
	globals.document = document;
}

/**
 * A collection of core utility functions.
 * @const
 */
class core$1 {
	/**
	 * When defining a class Foo with an abstract method bar(), you can do:
	 * Foo.prototype.bar = core.abstractMethod
	 *
	 * Now if a subclass of Foo fails to override bar(), an error will be thrown
	 * when bar() is invoked.
	 *
	 * @type {!Function}
	 * @throws {Error} when invoked to indicate the method should be overridden.
	 */
	static abstractMethod() {
		throw Error('Unimplemented abstract method');
	}

	/**
	 * Loops constructor super classes collecting its properties values. If
	 * property is not available on the super class `undefined` will be
	 * collected as value for the class hierarchy position.
	 * @param {!function()} constructor Class constructor.
	 * @param {string} propertyName Property name to be collected.
	 * @return {Array.<*>} Array of collected values.
	 * TODO(*): Rethink superclass loop.
	 */
	static collectSuperClassesProperty(constructor, propertyName) {
		var propertyValues = [constructor[propertyName]];
		while (constructor.__proto__ && !constructor.__proto__.isPrototypeOf(Function)) {
			constructor = constructor.__proto__;
			propertyValues.push(constructor[propertyName]);
		}
		return propertyValues;
	}

	/**
	 * Gets the name of the given function. If the current browser doesn't
	 * support the `name` property, this will calculate it from the function's
	 * content string.
	 * @param {!function()} fn
	 * @return {string}
	 */
	static getFunctionName(fn) {
		if (!fn.name) {
			var str = fn.toString();
			fn.name = str.substring(9, str.indexOf('('));
		}
		return fn.name;
	}

	/**
	 * Gets an unique id. If `opt_object` argument is passed, the object is
	 * mutated with an unique id. Consecutive calls with the same object
	 * reference won't mutate the object again, instead the current object uid
	 * returns. See {@link core.UID_PROPERTY}.
	 * @param {Object=} opt_object Optional object to be mutated with the uid. If
	 *     not specified this method only returns the uid.
	 * @param {boolean=} opt_noInheritance Optional flag indicating if this
	 *     object's uid property can be inherited from parents or not.
	 * @throws {Error} when invoked to indicate the method should be overridden.
	 */
	static getUid(opt_object, opt_noInheritance) {
		if (opt_object) {
			var id = opt_object[core$1.UID_PROPERTY];
			if (opt_noInheritance && !opt_object.hasOwnProperty(core$1.UID_PROPERTY)) {
				id = null;
			}
			return id || (opt_object[core$1.UID_PROPERTY] = core$1.uniqueIdCounter_++);
		}
		return core$1.uniqueIdCounter_++;
	}

	/**
	 * The identity function. Returns its first argument.
	 * @param {*=} opt_returnValue The single value that will be returned.
	 * @return {?} The first argument.
	 */
	static identityFunction(opt_returnValue) {
		return opt_returnValue;
	}

	/**
	 * Returns true if the specified value is a boolean.
	 * @param {?} val Variable to test.
	 * @return {boolean} Whether variable is boolean.
	 */
	static isBoolean(val) {
		return typeof val === 'boolean';
	}

	/**
	 * Returns true if the specified value is not undefined.
	 * @param {?} val Variable to test.
	 * @return {boolean} Whether variable is defined.
	 */
	static isDef(val) {
		return val !== undefined;
	}

	/**
	 * Returns true if value is not undefined or null.
	 * @param {*} val
	 * @return {boolean}
	 */
	static isDefAndNotNull(val) {
		return core$1.isDef(val) && !core$1.isNull(val);
	}

	/**
	 * Returns true if value is a document.
	 * @param {*} val
	 * @return {boolean}
	 */
	static isDocument(val) {
		return val && typeof val === 'object' && val.nodeType === 9;
	}

	/**
	 * Returns true if value is a dom element.
	 * @param {*} val
	 * @return {boolean}
	 */
	static isElement(val) {
		return val && typeof val === 'object' && val.nodeType === 1;
	}

	/**
	 * Returns true if the specified value is a function.
	 * @param {?} val Variable to test.
	 * @return {boolean} Whether variable is a function.
	 */
	static isFunction(val) {
		return typeof val === 'function';
	}

	/**
	 * Returns true if value is null.
	 * @param {*} val
	 * @return {boolean}
	 */
	static isNull(val) {
		return val === null;
	}

	/**
	 * Returns true if the specified value is a number.
	 * @param {?} val Variable to test.
	 * @return {boolean} Whether variable is a number.
	 */
	static isNumber(val) {
		return typeof val === 'number';
	}

	/**
	 * Returns true if value is a window.
	 * @param {*} val
	 * @return {boolean}
	 */
	static isWindow(val) {
		return val !== null && val === val.window;
	}

	/**
	 * Returns true if the specified value is an object. This includes arrays
	 * and functions.
	 * @param {?} val Variable to test.
	 * @return {boolean} Whether variable is an object.
	 */
	static isObject(val) {
		var type = typeof val;
		return type === 'object' && val !== null || type === 'function';
	}

	/**
	 * Returns true if value is a Promise.
	 * @param {*} val
	 * @return {boolean}
	 */
	static isPromise(val) {
		return val && typeof val === 'object' && typeof val.then === 'function';
	}

	/**
	 * Returns true if value is a string.
	 * @param {*} val
	 * @return {boolean}
	 */
	static isString(val) {
		return typeof val === 'string' || val instanceof String;
	}

	/**
	 * Merges the values of a static property a class with the values of that
	 * property for all its super classes, and stores it as a new static
	 * property of that class. If the static property already existed, it won't
	 * be recalculated.
	 * @param {!function()} constructor Class constructor.
	 * @param {string} propertyName Property name to be collected.
	 * @param {function(*, *):*=} opt_mergeFn Function that receives an array filled
	 *   with the values of the property for the current class and all its super classes.
	 *   Should return the merged value to be stored on the current class.
	 * @return {boolean} Returns true if merge happens, false otherwise.
	 */
	static mergeSuperClassesProperty(constructor, propertyName, opt_mergeFn) {
		var mergedName = propertyName + '_MERGED';
		if (constructor.hasOwnProperty(mergedName)) {
			return false;
		}

		var merged = core$1.collectSuperClassesProperty(constructor, propertyName);
		if (opt_mergeFn) {
			merged = opt_mergeFn(merged);
		}
		constructor[mergedName] = merged;
		return true;
	}

	/**
	 * Null function used for default values of callbacks, etc.
	 * @return {void} Nothing.
	 */
	static nullFunction() {}
}

/**
 * Unique id property prefix.
 * @type {String}
 * @protected
 */
core$1.UID_PROPERTY = 'core_' + ((Math.random() * 1e9) >>> 0);

/**
 * Counter for unique id.
 * @type {Number}
 * @private
 */
core$1.uniqueIdCounter_ = 1;

class array {
	/**
	 * Checks if the given arrays have the same content.
	 * @param {!Array<*>} arr1
	 * @param {!Array<*>} arr2
	 * @return {boolean}
	 */
	static equal(arr1, arr2) {
		if (arr1.length !== arr2.length) {
			return false;
		}
		for (var i = 0; i < arr1.length; i++) {
			if (arr1[i] !== arr2[i]) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Returns the first value in the given array that isn't undefined.
	 * @param {!Array} arr
	 * @return {*}
	 */
	static firstDefinedValue(arr) {
		for (var i = 0; i < arr.length; i++) {
			if (arr[i] !== undefined) {
				return arr[i];
			}
		}
	}

	/**
	 * Transforms the input nested array to become flat.
	 * @param {Array.<*|Array.<*>>} arr Nested array to flatten.
	 * @param {Array.<*>} opt_output Optional output array.
	 * @return {Array.<*>} Flat array.
	 */
	static flatten(arr, opt_output) {
		var output = opt_output || [];
		for (var i = 0; i < arr.length; i++) {
			if (Array.isArray(arr[i])) {
				array.flatten(arr[i], output);
			} else {
				output.push(arr[i]);
			}
		}
		return output;
	}

	/**
	 * Removes the first occurrence of a particular value from an array.
	 * @param {Array.<T>} arr Array from which to remove value.
	 * @param {T} obj Object to remove.
	 * @return {boolean} True if an element was removed.
	 * @template T
	 */
	static remove(arr, obj) {
		var i = arr.indexOf(obj);
		var rv;
		if ( (rv = i >= 0) ) {
			array.removeAt(arr, i);
		}
		return rv;
	}

	/**
	 * Removes from an array the element at index i
	 * @param {Array} arr Array or array like object from which to remove value.
	 * @param {number} i The index to remove.
	 * @return {boolean} True if an element was removed.
	 */
	static removeAt(arr, i) {
		return Array.prototype.splice.call(arr, i, 1).length === 1;
	}

	/**
	 * Slices the given array, just like Array.prototype.slice, but this
	 * is faster and working on all array-like objects (like arguments).
	 * @param {!Object} arr Array-like object to slice.
	 * @param {number} start The index that should start the slice.
	 * @param {number=} opt_end The index where the slice should end, not
	 *   included in the final array. If not given, all elements after the
	 *   start index will be included.
	 * @return {!Array}
	 */
	static slice(arr, start, opt_end) {
		var sliced = [];
		var end = core$1.isDef(opt_end) ? opt_end : arr.length;
		for (var i = start; i < end; i++) {
			sliced.push(arr[i]);
		}
		return sliced;
	}
}

/*!
 * Polyfill from Google's Closure Library.
 * Copyright 2013 The Closure Library Authors. All Rights Reserved.
 */

var async = {};


/**
 * Throw an item without interrupting the current execution context.  For
 * example, if processing a group of items in a loop, sometimes it is useful
 * to report an error while still allowing the rest of the batch to be
 * processed.
 * @param {*} exception
 */
async.throwException = function(exception) {
	// Each throw needs to be in its own context.
	async.nextTick(function() {
		throw exception;
	});
};


/**
 * Fires the provided callback just before the current callstack unwinds, or as
 * soon as possible after the current JS execution context.
 * @param {function(this:THIS)} callback
 * @param {THIS=} opt_context Object to use as the "this value" when calling
 *     the provided function.
 * @template THIS
 */
async.run = function(callback, opt_context) {
	if (!async.run.workQueueScheduled_) {
		// Nothing is currently scheduled, schedule it now.
		async.nextTick(async.run.processWorkQueue);
		async.run.workQueueScheduled_ = true;
	}

	async.run.workQueue_.push(
		new async.run.WorkItem_(callback, opt_context));
};


/** @private {boolean} */
async.run.workQueueScheduled_ = false;


/** @private {!Array.<!async.run.WorkItem_>} */
async.run.workQueue_ = [];

/**
 * Run any pending async.run work items. This function is not intended
 * for general use, but for use by entry point handlers to run items ahead of
 * async.nextTick.
 */
async.run.processWorkQueue = function() {
	// NOTE: additional work queue items may be pushed while processing.
	while (async.run.workQueue_.length) {
		// Don't let the work queue grow indefinitely.
		var workItems = async.run.workQueue_;
		async.run.workQueue_ = [];
		for (var i = 0; i < workItems.length; i++) {
			var workItem = workItems[i];
			try {
				workItem.fn.call(workItem.scope);
			} catch (e) {
				async.throwException(e);
			}
		}
	}

	// There are no more work items, reset the work queue.
	async.run.workQueueScheduled_ = false;
};


/**
 * @constructor
 * @final
 * @struct
 * @private
 *
 * @param {function()} fn
 * @param {Object|null|undefined} scope
 */
async.run.WorkItem_ = function(fn, scope) {
	/** @const */
	this.fn = fn;
	/** @const */
	this.scope = scope;
};


/**
 * Fires the provided callbacks as soon as possible after the current JS
 * execution context. setTimeout(…, 0) always takes at least 5ms for legacy
 * reasons.
 * @param {function(this:SCOPE)} callback Callback function to fire as soon as
 *     possible.
 * @param {SCOPE=} opt_context Object in whose scope to call the listener.
 * @template SCOPE
 */
async.nextTick = function(callback, opt_context) {
	var cb = callback;
	if (opt_context) {
		cb = callback.bind(opt_context);
	}
	cb = async.nextTick.wrapCallback_(cb);
	// Introduced and currently only supported by IE10.
	// Verify if variable is defined on the current runtime (i.e., node, browser).
	// Can't use typeof enclosed in a function (such as core.isFunction) or an
	// exception will be thrown when the function is called on an environment
	// where the variable is undefined.
	if (typeof setImmediate === 'function') {
		setImmediate(cb);
		return;
	}
	// Look for and cache the custom fallback version of setImmediate.
	if (!async.nextTick.setImmediate_) {
		async.nextTick.setImmediate_ = async.nextTick.getSetImmediateEmulator_();
	}
	async.nextTick.setImmediate_(cb);
};


/**
 * Cache for the setImmediate implementation.
 * @type {function(function())}
 * @private
 */
async.nextTick.setImmediate_ = null;


/**
 * Determines the best possible implementation to run a function as soon as
 * the JS event loop is idle.
 * @return {function(function())} The "setImmediate" implementation.
 * @private
 */
async.nextTick.getSetImmediateEmulator_ = function() {
	// Create a private message channel and use it to postMessage empty messages
	// to ourselves.
	var Channel;

	// Verify if variable is defined on the current runtime (i.e., node, browser).
	// Can't use typeof enclosed in a function (such as core.isFunction) or an
	// exception will be thrown when the function is called on an environment
	// where the variable is undefined.
	if (typeof MessageChannel === 'function') {
		Channel = MessageChannel;
	}

	// If MessageChannel is not available and we are in a browser, implement
	// an iframe based polyfill in browsers that have postMessage and
	// document.addEventListener. The latter excludes IE8 because it has a
	// synchronous postMessage implementation.
	if (typeof Channel === 'undefined' && typeof window !== 'undefined' &&
		window.postMessage && window.addEventListener) {
		/** @constructor */
		Channel = function() {
			// Make an empty, invisible iframe.
			var iframe = document.createElement('iframe');
			iframe.style.display = 'none';
			iframe.src = '';
			document.documentElement.appendChild(iframe);
			var win = iframe.contentWindow;
			var doc = win.document;
			doc.open();
			doc.write('');
			doc.close();
			var message = 'callImmediate' + Math.random();
			var origin = win.location.protocol + '//' + win.location.host;
			var onmessage = function(e) {
				// Validate origin and message to make sure that this message was
				// intended for us.
				if (e.origin !== origin && e.data !== message) {
					return;
				}
				this.port1.onmessage();
			}.bind(this);
			win.addEventListener('message', onmessage, false);
			this.port1 = {};
			this.port2 = {
				postMessage: function() {
					win.postMessage(message, origin);
				}
			};
		};
	}
	if (typeof Channel !== 'undefined') {
		var channel = new Channel();
		// Use a fifo linked list to call callbacks in the right order.
		var head = {};
		var tail = head;
		channel.port1.onmessage = function() {
			head = head.next;
			var cb = head.cb;
			head.cb = null;
			cb();
		};
		return function(cb) {
			tail.next = {
				cb: cb
			};
			tail = tail.next;
			channel.port2.postMessage(0);
		};
	}
	// Implementation for IE6-8: Script elements fire an asynchronous
	// onreadystatechange event when inserted into the DOM.
	if (typeof document !== 'undefined' && 'onreadystatechange' in
		document.createElement('script')) {
		return function(cb) {
			var script = document.createElement('script');
			script.onreadystatechange = function() {
				// Clean up and call the callback.
				script.onreadystatechange = null;
				script.parentNode.removeChild(script);
				script = null;
				cb();
				cb = null;
			};
			document.documentElement.appendChild(script);
		};
	}
	// Fall back to setTimeout with 0. In browsers this creates a delay of 5ms
	// or more.
	return function(cb) {
		setTimeout(cb, 0);
	};
};


/**
 * Helper function that is overrided to protect callbacks with entry point
 * monitor if the application monitors entry points.
 * @param {function()} callback Callback function to fire as soon as possible.
 * @return {function()} The wrapped callback.
 * @private
 */
async.nextTick.wrapCallback_ = function(opt_returnValue) {
	return opt_returnValue;
};

/**
 * Disposable utility. When inherited provides the `dispose` function to its
 * subclass, which is responsible for disposing of any object references
 * when an instance won't be used anymore. Subclasses should override
 * `disposeInternal` to implement any specific disposing logic.
 * @constructor
 */
class Disposable {
	constructor() {
		/**
		 * Flag indicating if this instance has already been disposed.
		 * @type {boolean}
		 * @protected
		 */
		this.disposed_ = false;
	}

	/**
	 * Disposes of this instance's object references. Calls `disposeInternal`.
	 */
	dispose() {
		if (!this.disposed_) {
			this.disposeInternal();
			this.disposed_ = true;
		}
	}

	/**
	 * Subclasses should override this method to implement any specific
	 * disposing logic (like clearing references and calling `dispose` on other
	 * disposables).
	 */
	disposeInternal() {}

	/**
	 * Checks if this instance has already been disposed.
	 * @return {boolean}
	 */
	isDisposed() {
		return this.disposed_;
	}
}

class string {
	/**
	 * Removes the breaking spaces from the left and right of the string and
	 * collapses the sequences of breaking spaces in the middle into single spaces.
	 * The original and the result strings render the same way in HTML.
	 * @param {string} str A string in which to collapse spaces.
	 * @return {string} Copy of the string with normalized breaking spaces.
	 */
	static collapseBreakingSpaces(str) {
		return str.replace(/[\t\r\n ]+/g, ' ').replace(/^[\t\r\n ]+|[\t\r\n ]+$/g, '');
	}

	/**
	* Escapes characters in the string that are not safe to use in a RegExp.
	* @param {*} str The string to escape. If not a string, it will be casted
	*     to one.
	* @return {string} A RegExp safe, escaped copy of {@code s}.
	*/
	static escapeRegex(str) {
		return String(str)
			.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1')
			.replace(/\x08/g, '\\x08');
	}

	/**
	* Returns a string with at least 64-bits of randomness.
	* @return {string} A random string, e.g. sn1s7vb4gcic.
	*/
	static getRandomString() {
		var x = 2147483648;
		return Math.floor(Math.random() * x).toString(36) +
			Math.abs(Math.floor(Math.random() * x) ^ Date.now()).toString(36);
	}

	/**
	 * Calculates the hashcode for a string. The hashcode value is computed by
	 * the sum algorithm: s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]. A nice
	 * property of using 31 prime is that the multiplication can be replaced by
	 * a shift and a subtraction for better performance: 31*i == (i<<5)-i.
	 * Modern VMs do this sort of optimization automatically.
	 * @param {String} val Target string.
	 * @return {Number} Returns the string hashcode.
	 */
	static hashCode(val) {
		var hash = 0;
		for (var i = 0, len = val.length; i < len; i++) {
			hash = 31 * hash + val.charCodeAt(i);
			hash %= 0x100000000;
		}
		return hash;
	}

	/**
	 * Replaces interval into the string with specified value, e.g.
	 * `replaceInterval("abcde", 1, 4, "")` returns "ae".
	 * @param {string} str The input string.
	 * @param {Number} start Start interval position to be replaced.
	 * @param {Number} end End interval position to be replaced.
	 * @param {string} value The value that replaces the specified interval.
	 * @return {string}
	 */
	static replaceInterval(str, start, end, value) {
		return str.substring(0, start) + value + str.substring(end);
	}
}

/**
 * Class responsible for storing an object that will be printed as JSON
 * when the `toString` method is called.
 */
class Embodied {
	/**
	 * Constructs a Embodied instance.
	 * @constructor
	 */
	constructor() {
		this.body_ = {};
	}

	/**
	 * Gets the json object that represents this instance.
	 * @return {!Object}
	 */
	body() {
		return this.body_;
	}

	/**
	 * If the given object is an instance of Embodied, this will
	 * return its body content. Otherwise this will return the
	 * original object.
	 * @param {*} obj
	 * @return {*}
	 * @static
	 */
	static toBody(obj) {
		return (obj instanceof Embodied) ? obj.body() : obj;
	}

	/**
	 * Gets the json string that represents this instance.
	 * @return {string}
	 */
	toString() {
		return JSON.stringify(this.body());
	}
}

/**
 * Class responsible for storing and handling the body contents
 * of a Filter instance.
 */
class FilterBody {
	/**
	 * Constructs a {@link FilterBody} instance.
	 * @param {string} field The name of the field to filter by.
	 * @param {*} operatorOrValue If a third param is given, this should
	 *   be the filter's operator (like ">="). Otherwise, this will be
	 *   used as the filter's value, and the filter's operator will be "=".
	 * @param {*=} opt_value The filter's value.
	 * @constructor
	 */
	constructor(field, operatorOrValue, opt_value) {
		var obj = {
			operator: core$1.isDef(opt_value) ? operatorOrValue : '='
		};

		var value = core$1.isDef(opt_value) ? opt_value : operatorOrValue;

		if (core$1.isDefAndNotNull(value)) {
			if (value instanceof Embodied) {
				value = value.body();
			}
			obj.value = value;
		}

		if (core$1.isDefAndNotNull(field)) {
			this.createBody_(field, obj);
		} else {
			this.createBody_('and', []);
		}

	}

	/**
	 * Composes the current filter with the given operator.
	 * @param {string} operator
	 * @param {Filter=} opt_filter Another filter to compose this filter with,
	 *   if the operator is not unary.
	 */
	add(operator, opt_filter) {
		if (opt_filter) {
			this.addArrayOperator_(operator, opt_filter);
		} else {
			this.createBody_(operator, this.body_);
		}
	}

	/**
	 * Composes the current filter with an operator that stores its values in an array.
	 * @param {string} operator
	 * @param {!Filter} filter
	 * @protected
	 */
	addArrayOperator_(operator, filter) {
		if (!(this.body_[operator] instanceof Array)) {
			this.createBody_(operator, [this.body_]);
		}
		this.body_[operator].push(filter.body());
	}

	/**
	 * Adds filters to be composed with this filter body using the given operator.
	 * @param {string} operator
	 * @param {...*} filters A variable amount of filters to be composed.
	 */
	addMany(operator, ...filters) {
		for (var i = 0; i < filters.length; i++) {
			this.add(operator, filters[i]);
		}
	}

	/**
	 * Creates a new body object, setting the requestd key to the given value.
	 * @param {string} key The key to set in the new body object
	 * @param {*} value The value the requested key should have in the new body object.
	 * @protected
	 */
	createBody_(key, value) {
		this.body_ = {};
		this.body_[key] = value;
	}

	/**
	 * Gets the json object that represents this filter's body.
	 * @return {!Object}
	 */
	getObject() {
		return this.body_;
	}
}

/**
 * Class responsible for building different types of geometric
 * shapes.
 */
class Geo {
	/**
	 * Creates a new {@link BoundingBox} instance.
	 * @param {*} upperLeft The upper left point.
	 * @param {*} lowerRight The lower right point.
	 * @return {!BoundingBox}
	 * @static
	 */
	static boundingBox(upperLeft, lowerRight) {
		return new Geo.BoundingBox(upperLeft, lowerRight);
	}

	/**
	 * Creates a new {@link Circle} instance.
	 * @param {*} center The circle's center coordinate.
	 * @param {string} radius The circle's radius.
	 * @return {!Circle}
	 * @static
	 */
	static circle(center, radius) {
		return new Geo.Circle(center, radius);
	}

	/**
	 * Creates a new {@link Line} instance.
	 * @param {...*} points This line's points.
	 * @return {!Line}
	 * @static
	 */
	static line(...points) {
		return new Geo.Line(...points);
	}

	/**
	 * Creates a new {@link Point} instance.
	 * @param {number} lat The latitude coordinate
	 * @param {number} lon The longitude coordinate
	 * @return {!Point}
	 * @static
	 */
	static point(lat, lon) {
		return new Geo.Point(lat, lon);
	}

	/**
	 * Creates a new {@link Polygon} instance.
	 * @param {...*} points This polygon's points.
	 * @return {!Polygon}
	 * @static
	 */
	static polygon(...points) {
		return new Geo.Polygon(...points);
	}
}

/**
 * Class that represents a point coordinate.
 * @extends {Embodied}
 */
class Point extends Embodied {
	/**
	 * Constructs a {@link Point} instance.
	 * @param {number} lat The latitude coordinate
	 * @param {number} lon The longitude coordinate
	 * @constructor
	 */
	constructor(lat, lon) {
		super();
		this.body_ = [lat, lon];
	}
}
Geo.Point = Point;

/**
 * Class that represents a line.
 * @extends {Embodied}
 */
class Line extends Embodied {
	/**
	 * Constructs a {@link Line} instance.
	 * @param {...*} points This line's points.
	 * @constructor
	 */
	constructor(...points) {
		super();
		this.body_ = {
			type: 'linestring',
			coordinates: points.map(point => Embodied.toBody(point))
		};
	}
}
Geo.Line = Line;

/**
 * Class that represents a bounding box.
 * @extends {Embodied}
 */
class BoundingBox extends Embodied {
	/**
	 * Constructs a {@link BoundingBox} instance.
	 * @param {*} upperLeft The upper left point.
	 * @param {*} lowerRight The lower right point.
	 * @constructor
	 */
	constructor(upperLeft, lowerRight) {
		super();
		this.body_ = {
			type: 'envelope',
			coordinates: [Embodied.toBody(upperLeft), Embodied.toBody(lowerRight)]
		};
	}

	/**
	 * Gets this bounding box's points.
	 * @return {!Array}
	 */
	getPoints() {
		return this.body_.coordinates;
	}
}
Geo.BoundingBox = BoundingBox;

/**
 * Class that represents a circle.
 * @extends {Embodied}
 */
class Circle extends Embodied {
	/**
	 * Constructs a {@link Circle} instance.
	 * @param {*} center The circle's center coordinate.
	 * @param {string} radius The circle's radius.
	 * @constructor
	 */
	constructor(center, radius) {
		super();
		this.body_ = {
			type: 'circle',
			coordinates: Embodied.toBody(center),
			radius: radius
		};
	}

	/**
	 * Gets this circle's center coordinate.
	 * @return {*}
	 */
	getCenter() {
		return this.body_.coordinates;
	}

	/**
	 * Gets this circle's radius.
	 * @return {string}
	 */
	getRadius() {
		return this.body_.radius;
	}
}
Geo.Circle = Circle;

/**
 * Class that represents a polygon.
 * @extends {Embodied}
 */
class Polygon extends Embodied {
	/**
	 * Constructs a {@link Polygon} instance.
	 * @param {...*} points This polygon's points.
	 * @constructor
	 */
	constructor(...points) {
		super();
		this.body_ = {
			type: 'polygon',
			coordinates: []
		};
		this.addCoordinates_(...points);
	}

	/**
	 * Adds the given points as coordinates for this polygon.
	 * @param {...*} points
	 * @protected
	 */
	addCoordinates_(...points) {
		this.body_.coordinates.push(points.map(point => Embodied.toBody(point)));
	}

	/**
	 * Adds the given points as a hole inside this polygon.
	 * @param  {...*} points
	 * @chainnable
	 */
	hole(...points) {
		this.addCoordinates_(...points);
		return this;
	}
}
Geo.Polygon = Polygon;

/**
 * Class responsible for building range objects to be used by `Filter`.
 * @extends {Embodied}
 */
class Range extends Embodied {
	/**
	 * Constructs a {@link Range} instance.
	 * @param {*} from
	 * @param {*} opt_to
	 * @constructor
	 */
	constructor(from, opt_to) {
		super();
		if (core$1.isDefAndNotNull(from)) {
			this.body_.from = from;
		}
		if (core$1.isDefAndNotNull(opt_to)) {
			this.body_.to = opt_to;
		}
	}

	/**
	 * Constructs a {@link Range} instance.
	 * @param {*} from
	 * @return {!Range}
	 * @static
	 */
	static from(from) {
		return new Range(from);
	}

	/**
	 * Constructs a {@link Range} instance.
	 * @param {*} from
	 * @param {*} to
	 * @return {!Range}
	 * @static
	 */
	static range(from, to) {
		return new Range(from, to);
	}

	/**
	 * Constructs a {@link Range} instance.
	 * @param {*} to
	 * @return {!Range}
	 * @static
	 */
	static to(to) {
		return new Range(null, to);
	}
}

/**
 * Class responsible for building filters.
 * @extends {Embodied}
 */
class Filter extends Embodied {
	/**
	 * Constructs a {@link Filter} instance.
	 * @param {string} field The name of the field to filter by.
	 * @param {*} operatorOrValue If a third param is given, this should
	 *   be the filter's operator (like ">="). Otherwise, this will be
	 *   used as the filter's value, and the filter's operator will be "=".
	 * @param {*=} opt_value The filter's value.
	 * @constructor
	 */
	constructor(field, operatorOrValue, opt_value) {
		super();
		this.body_ = new FilterBody(field, operatorOrValue, opt_value);
	}

	/**
	 * Adds a filter to be composed with this filter using the given operator.
	 * @param {string} operator
	 * @param {!Filter|string} fieldOrFilter Either a {@link Filter} instance or the
	 *   name of the field to filter by.
	 * @param {*=} opt_operatorOrValue Either the field's operator or its value.
	 * @param {*=} opt_value The filter's value.
	 * @chainnable
	 */
	add(operator, fieldOrFilter, opt_operatorOrValue, opt_value) {
		var filter = fieldOrFilter ? Filter.toFilter(fieldOrFilter, opt_operatorOrValue, opt_value) : null;
		this.body_.add(operator, filter);
		return this;
	}

	/**
	 * Adds filters to be composed with this filter using the given operator.
	 * @param {string} operator
	 * @param {...*} filters A variable amount of filters to be composed.
	 * @chainnable
	 */
	addMany(operator, ...filters) {
		this.body_.addMany(operator, ...filters);
		return this;
	}

	/**
	 * Adds a filter to be composed with this filter using the "and" operator.
	 * @param {!Filter|string} fieldOrFilter Either a {@link Filter} instance or the
	 *   name of the field to filter by.
	 * @param {*=} opt_operatorOrValue Either the field's operator or its value.
	 * @param {*=} opt_value The filter's value.
	 * @chainnable
	 */
	and(fieldOrFilter, opt_operatorOrValue, opt_value) {
		return this.add('and', fieldOrFilter, opt_operatorOrValue, opt_value);
	}

	/**
	 * Returns a {@link Filter} instance that uses the "any" operator.
	 * @param {string} field The name of the field to filter by.
	 * @param {!(Array|...*)} values A variable amount of values to be used with
	 *   the "none" operator. Can be passed either as a single array or as
	 *   separate params.
	 * @return {!Filter}
	 * @static
	 */
	static any(field) {
		var values = Array.prototype.slice.call(arguments, 1);
		if (values.length === 1 && values[0] instanceof Array) {
			values = values[0];
		}
		return new Filter(field, 'any', values);
	}

	/**
	 * Returns a {@link Filter} instance that uses the "gp" operator.
	 * This is a special use case of `Filter.polygon` for bounding
	 * boxes.
	 * @param {string} field The field's name.
	 * @param {*} boxOrUpperLeft Either a `Geo.BoundingBox` instance, or
	 *   a bounding box's upper left coordinate.
	 * @param {*=} opt_lowerRight A bounding box's lower right coordinate.
	 * @return {!Filter}
	 * @static
	 */
	static boundingBox(field, boxOrUpperLeft, opt_lowerRight) {
		if (boxOrUpperLeft instanceof Geo.BoundingBox) {
			return Filter.polygon(field, ...boxOrUpperLeft.getPoints());
		} else {
			return Filter.polygon(field, boxOrUpperLeft, opt_lowerRight);
		}
	}

	/**
	 * Gets the json object that represents this filter.
	 * @return {!Object}
	 */
	body() {
		return this.body_.getObject();
	}

	/**
	 * Returns a {@link Filter} instance that uses the "gd" operator.
	 * @param {string} field The field's name.
	 * @param {*} locationOrCircle Either a `Geo.Circle` instance or a coordinate.
	 * @param {Range|string=} opt_rangeOrDistance Either a `Range` instance or
	 *   the distance value.
	 * @return {!Filter}
	 * @static
	 */
	static distance(field, locationOrCircle, opt_rangeOrDistance) {
		var location = locationOrCircle;
		var range = opt_rangeOrDistance;
		if (locationOrCircle instanceof Geo.Circle) {
			location = locationOrCircle.getCenter();
			range = Range.to(locationOrCircle.getRadius());
		} else if (!(opt_rangeOrDistance instanceof Range)) {
			range = Range.to(opt_rangeOrDistance);
		}
		return Filter.distanceInternal_(field, location, range);
	}

	/**
	 * Returns a {@link Filter} instance that uses the "gd" operator. This
	 * is just an internal helper used by `Filter.distance`.
	 * @param {string} field The field's name.
	 * @param {*} location A location coordinate.
	 * @param {Range} range A `Range` instance.
	 * @return {!Filter}
	 * @protected
	 * @static
	 */
	static distanceInternal_(field, location, range) {
		var value = {
			location: Embodied.toBody(location)
		};
		range = range.body();
		if (range.from) {
			value.min = range.from;
		}
		if (range.to) {
			value.max = range.to;
		}
		return Filter.field(field, 'gd', value);
	}

	/**
	 * Returns a {@link Filter} instance that uses the "=" operator.
	 * @param {string} field The name of the field to filter by.
	 * @param {*} value The filter's value.
	 * @return {!Filter}
   * @static
	 */
	static equal(field, value) {
		return new Filter(field, '=', value);
	}

	/**
	 * Returns a {@link Filter} instance that uses the "exists" operator.
	 * @param {string} field The field's name.
	 * @return {!Filter}
	 * @static
	 */
	static exists(field) {
		return Filter.field(field, 'exists', null);
	}

	/**
	 * Returns a {@link Filter} instance that uses the "fuzzy" operator.
	 * @param {string} fieldOrQuery If no second string argument is given, this
	 *   should be the query string, in which case all fields will be matched.
	 *   Otherwise, this should be the name of the field to match.
	 * @param {string|number=} opt_queryOrFuzziness If this is a string, it should
	 *   be the query, otherwise it should be the fuzziness value.
	 * @param {number=} opt_fuzziness The fuzziness value.
	 * @return {!Filter}
	 * @static
	 */
	static fuzzy(fieldOrQuery, opt_queryOrFuzziness, opt_fuzziness) {
		return Filter.fuzzyInternal_('fuzzy', fieldOrQuery, opt_queryOrFuzziness, opt_fuzziness);
	}

	/**
	 * Returns a {@link Filter} instance that uses the given fuzzy operator. This
	 * is an internal implementation used by the `Filter.fuzzy` method.
	 * @param {string} operator The fuzzy operator.
	 * @param {string} fieldOrQuery If no second string argument is given, this
	 *   should be the query string, in which case all fields will be matched.
	 *   Otherwise, this should be the name of the field to match.
	 * @param {string|number=} opt_queryOrFuzziness If this is a string, it should
	 *   be the query, otherwise it should be the fuzziness value.
	 * @param {number=} opt_fuzziness The fuzziness value.
	 * @return {!Filter}
	 * @protected
	 * @static
	 */
	static fuzzyInternal_(operator, fieldOrQuery, opt_queryOrFuzziness, opt_fuzziness) {
		var arg2IsString = core$1.isString(opt_queryOrFuzziness);

		var value = {
			query: arg2IsString ? opt_queryOrFuzziness : fieldOrQuery
		};
		var fuzziness = arg2IsString ? opt_fuzziness : opt_queryOrFuzziness;
		if (fuzziness) {
			value.fuzziness = fuzziness;
		}

		var field = arg2IsString ? fieldOrQuery : Filter.ALL;
		return Filter.field(field, operator, value);
	}

	/**
	 * Returns a {@link Filter} instance that uses the ">" operator.
	 * @param {string} field The name of the field to filter by.
	 * @param {*} value The filter's value.
	 * @return {!Filter}
   * @static
	 */
	static gt(field, value) {
		return new Filter(field, '>', value);
	}

	/**
	 * Returns a {@link Filter} instance that uses the ">=" operator.
	 * @param {string} field The name of the field to filter by.
	 * @param {*} value The filter's value.
	 * @return {!Filter}
   * @static
	 */
	static gte(field, value) {
		return new Filter(field, '>=', value);
	}

	/**
	 * Returns a {@link Filter} instance that uses the "match" operator.
	 * @param {string} fieldOrQuery If no second string argument is given, this
	 *   should be the query string, in which case all fields will be matched.
	 *   Otherwise, this should be the name of the field to match.
	 * @param {string=} opt_query The query string.
	 * @return {!Filter}
	 * @static
	 */
	static match(fieldOrQuery, opt_query) {
		var field = core$1.isString(opt_query) ? fieldOrQuery : Filter.ALL;
		var query = core$1.isString(opt_query) ? opt_query : fieldOrQuery;
		return Filter.field(field, 'match', query);
	}

	/**
	 * Returns a {@link Filter} instance that uses the "missing" operator.
	 * @param {string} field The field's name.
	 * @return {!Filter}
	 * @static
	 */
	static missing(field) {
		return Filter.field(field, 'missing', null);
	}

	/**
	 * Returns a {@link Filter} instance that uses the "phrase" operator.
	 * @param {string} fieldOrQuery If no second string argument is given, this
	 *   should be the query string, in which case all fields will be matched.
	 *   Otherwise, this should be the name of the field to match.
	 * @param {string=} opt_query The query string.
	 * @return {!Filter}
	 * @static
	 */
	static phrase(fieldOrQuery, opt_query) {
		var field = core$1.isString(opt_query) ? fieldOrQuery : Filter.ALL;
		var query = core$1.isString(opt_query) ? opt_query : fieldOrQuery;
		return Filter.field(field, 'phrase', query);
	}

	/**
	 * Returns a {@link Filter} instance that uses the "gp" operator.
	 * @param {string} field The name of the field.
	 * @param {...!Object} points Objects representing points in the polygon.
	 * @return {!Filter}
	 * @static
	 */
	static polygon(field, ...points) {
		points = points.map(point => Embodied.toBody(point));
		return Filter.field(field, 'gp', points);
	}

	/**
	 * Returns a {@link Filter} instance that uses the "prefix" operator.
	 * @param {string} fieldOrQuery If no second argument is given, this should
	 *   be the query string, in which case all fields will be matched. Otherwise,
	 *   this should be the name of the field to match.
	 * @param {string=} opt_query The query string.
	 * @return {!Filter}
	 * @static
	 */
	static prefix(fieldOrQuery, opt_query) {
		var field = opt_query ? fieldOrQuery : Filter.ALL;
		var query = opt_query ? opt_query : fieldOrQuery;
		return Filter.field(field, 'prefix', query);
	}

	/**
	 * Returns a {@link Filter} instance that uses the "range" operator.
	 * @param {string} field The field's name.
	 * @param {*} rangeOrMin Either a `Range` instance or a the range's min value.
	 * @param {*=} opt_max The range's max value.
	 * @return {!Filter}
	 * @static
	 */
	static range(field, rangeOrMin, opt_max) {
		var range = rangeOrMin;
		if (!(range instanceof Range)) {
			range = Range.range(rangeOrMin, opt_max);
		}
		return Filter.field(field, 'range', range);
	}

	/**
	 * Returns a {@link Filter} instance that uses the "~" operator.
	 * @param {string} field The name of the field to filter by.
	 * @param {*} value The filter's value.
	 * @return {!Filter}
   * @static
	 */
	static regex(field, value) {
		return new Filter(field, '~', value);
	}

	/**
	 * Returns a {@link Filter} instance that uses the "gs" operator.
	 * @param {string} field The field's name.
	 * @param {...!Object} shapes Objects representing shapes.
	 * @return {!Filter}
	 * @static
	 */
	static shape(field, ...shapes) {
		shapes = shapes.map(shape => Embodied.toBody(shape));
		var value = {
			type: 'geometrycollection',
			geometries: shapes
		};
		return Filter.field(field, 'gs', value);
	}

	/**
	 * Returns a {@link Filter} instance that uses the "similar" operator.
	 * @param {string} fieldOrQuery If no second string argument is given, this
	 *   should be the query string, in which case all fields will be matched.
	 *   Otherwise, this should be the name of the field to match.
	 * @param {?string} query The query string.
	 * @return {!Filter}
	 * @static
	 */
	static similar(fieldOrQuery, query) {
		var field = core$1.isString(query) ? fieldOrQuery : Filter.ALL;
		var value = {
			query: core$1.isString(query) ? query : fieldOrQuery
		};
		return Filter.field(field, 'similar', value);
	}

	/**
	 * Returns a {@link Filter} instance that uses the "<" operator.
	 * @param {string} field The name of the field to filter by.
	 * @param {*} value The filter's value.
	 * @return {!Filter}
   * @static
	 */
	static lt(field, value) {
		return new Filter(field, '<', value);
	}

	/**
	 * Returns a {@link Filter} instance that uses the "<=" operator.
	 * @param {string} field The name of the field to filter by.
	 * @param {*} value The filter's value.
	 * @return {!Filter}
   * @static
	 */
	static lte(field, value) {
		return new Filter(field, '<=', value);
	}

	/**
	 * Returns a {@link Filter} instance that uses the "none" operator.
	 * @param {string} field The name of the field to filter by.
	 * @param {!(Array|...*)} value A variable amount of values to be used with
	 * the "none" operator. Can be passed either as a single array or as
	 * separate params.
	 * @return {!Filter}
	 * @static
	 */
	static none(field) {
		var values = Array.prototype.slice.call(arguments, 1);
		if (values.length === 1 && values[0] instanceof Array) {
			values = values[0];
		}
		return new Filter(field, 'none', values);
	}

	/**
	 * Returns a {@link Filter} instance that uses the "!=" operator.
	 * @param {string} field The name of the field to filter by.
	 * @param {*} value The filter's value.
	 * @return {!Filter}
	 * @static
	 */
	static notEqual(field, value) {
		return new Filter(field, '!=', value);
	}

	/**
	 * Returns a {@link Filter} instance that uses the "not" operator.
	 * @param {!Filter|string} fieldOrFilter Either a {@link Filter} instance or
	 * the name of the field to filter by.
	 * @param {*=} opt_operatorOrValue Either the field's operator or its value.
	 * @param {*=} opt_value The filter's value.
	 * @return {!Filter}
	 * @static
	 */
	static not(fieldOrFilter, opt_operatorOrValue, opt_value) {
		return Filter.toFilter(fieldOrFilter, opt_operatorOrValue, opt_value).add('not');
	}

	/**
	 * Returns a {@link Filter} instance.
	 * @param {string} field The name of the field to filter by.
	 * @param {*} operatorOrValue If a third param is given, this should be the
	 * filter's operator (like ">="). Otherwise, this will be used as the
	 * filter's value, and the filter's operator will be "=".
	 * @param {*=} opt_value The filter's value.
	 * @return {!Filter}
	 * @static
	 */
	static field(field, operatorOrValue, opt_value) {
		return new Filter(field, operatorOrValue, opt_value);
	}

	/**
	 * Adds a filter to be composed with this filter using the "or" operator.
	 * @param {!Filter|string} fieldOrFilter Either a {@link Filter} instance or
	 * the name of the field to filter by.
	 * @param {*=} opt_operatorOrValue Either the field's operator or its value.
	 * @param {*=} opt_value The filter's value.
	 * @chainnable
	 */
	or(fieldOrFilter, opt_operatorOrValue, opt_value) {
		return this.add('or', fieldOrFilter, opt_operatorOrValue, opt_value);
	}

	/**
	 * Converts the given arguments into a {@link Filter} instance.
	 * @param {!Filter|string} fieldOrFilter Either a {@link Filter} instance or
	 * the name of the field to filter by.
	 * @param {*=} opt_operatorOrValue Either the field's operator or its value.
	 * @param {*=} opt_value The filter's value.
	 * @return {!Filter}
	 */
	static toFilter(fieldOrFilter, opt_operatorOrValue, opt_value) {
		var filter = fieldOrFilter;
		if (!(filter instanceof Filter)) {
			filter = Filter.field(fieldOrFilter, opt_operatorOrValue, opt_value);
		}
		return filter;
	}
}

/**
 * String constant that represents all fields.
 * @type {string}
 * @static
 */
Filter.ALL = '*';

/**
 * Parses the given uri string into an object.
 * @param {*=} opt_uri Optional string URI to parse
 */
function parseFromAnchor(opt_uri) {
	var link = document.createElement('a');
	link.href = opt_uri;
	return {
		hash: link.hash,
		hostname: link.hostname,
		password: link.password,
		pathname: link.pathname[0] === '/' ? link.pathname : '/' + link.pathname,
		port: link.port,
		protocol: link.protocol,
		search: link.search,
		username: link.username
	};
}

/**
 * Parses the given uri string into an object. The URL function will be used
 * when present, otherwise we'll fall back to the anchor node element.
 * @param {*=} opt_uri Optional string URI to parse
 */
function parse(opt_uri) {
	if (core$1.isFunction(URL) && URL.length) {
		return new URL(opt_uri);
	} else {
		return parseFromAnchor(opt_uri);
	}
}

/**
 * A cached reference to the create function.
 */
var create = Object.create;

/**
 * Case insensitive string Multimap implementation. Allows multiple values for
 * the same key name.
 * @extends {Disposable}
 */
class MultiMap extends Disposable {
	constructor() {
		super();
		this.keys = create(null);
		this.values = create(null);
	}

	/**
	 * Adds value to a key name.
	 * @param {string} name
	 * @param {*} value
	 * @chainable
	 */
	add(name, value) {
		this.keys[name.toLowerCase()] = name;
		this.values[name.toLowerCase()] = this.values[name.toLowerCase()] || [];
		this.values[name.toLowerCase()].push(value);
		return this;
	}

	/**
	 * Clears map names and values.
	 * @chainable
	 */
	clear() {
		this.keys = create(null);
		this.values = create(null);
		return this;
	}

	/**
	 * Checks if map contains a value to the key name.
	 * @param {string} name
	 * @return {boolean}
	 * @chainable
	 */
	contains(name) {
		return name.toLowerCase() in this.values;
	}

	/**
	 * @inheritDoc
	 */
	disposeInternal() {
		this.values = null;
	}

	/**
	 * Creates a `MultiMap` instance from the given object.
	 * @param {!Object} obj
	 * @return {!MultiMap}
	 */
	static fromObject(obj) {
		var map = new MultiMap();
		var keys = Object.keys(obj);
		for (var i = 0; i < keys.length; i++) {
			map.set(keys[i], obj[keys[i]]);
		}
		return map;
	}

	/**
	 * Gets the first added value from a key name.
	 * @param {string} name
	 * @return {*}
	 * @chainable
	 */
	get(name) {
		var values = this.values[name.toLowerCase()];
		if (values) {
			return values[0];
		}
	}

	/**
	 * Gets all values from a key name.
	 * @param {string} name
	 * @return {Array.<*>}
	 */
	getAll(name) {
		return this.values[name.toLowerCase()];
	}

	/**
	 * Returns true if the map is empty, false otherwise.
	 * @return {boolean}
	 */
	isEmpty() {
		return this.size() === 0;
	}

	/**
	 * Gets array of key names.
	 * @return {Array.<string>}
	 */
	names() {
		return Object.keys(this.values).map((key) => this.keys[key]);
	}

	/**
	 * Removes all values from a key name.
	 * @param {string} name
	 * @chainable
	 */
	remove(name) {
		delete this.keys[name.toLowerCase()];
		delete this.values[name.toLowerCase()];
		return this;
	}

	/**
	 * Sets the value of a key name. Relevant to replace the current values with
	 * a new one.
	 * @param {string} name
	 * @param {*} value
	 * @chainable
	 */
	set(name, value) {
		this.keys[name.toLowerCase()] = name;
		this.values[name.toLowerCase()] = [value];
		return this;
	}

	/**
	 * Gets the size of the map key names.
	 * @return {number}
	 */
	size() {
		return this.names().length;
	}

	/**
	 * Returns the parsed values as a string.
	 * @return {string}
	 */
	toString() {
		return JSON.stringify(this.values);
	}
}

/**
 * Asserts that child has no parent.
 * @param {TreeNode} child A child.
 * @private
 */
const assertChildHasNoParent = function(child) {
	if (child.getParent()) {
		throw new Error('Cannot add child with parent.');
	}
};

var parseFn_ = parse;

class Uri {

	/**
	 * This class contains setters and getters for the parts of the URI.
	 * The following figure displays an example URIs and their component parts.
	 *
	 *                                  path
	 *	                             ┌───┴────┐
	 *	  abc://example.com:123/path/data?key=value#fragid1
	 *	  └┬┘   └────┬────┘ └┬┘           └───┬───┘ └──┬──┘
	 * protocol  hostname  port            search    hash
	 *          └──────┬───────┘
	 *                host
	 *
	 * @param {*=} opt_uri Optional string URI to parse
	 * @constructor
	 */
	constructor(opt_uri = '') {
		this.url = Uri.parse(this.maybeAddProtocolAndHostname_(opt_uri));
	}

	/**
	 * Adds parameters to uri from a <code>MultiMap</code> as source.
	 * @param {MultiMap} multimap The <code>MultiMap</code> containing the
	 *   parameters.
	 * @protected
	 * @chainable
	 */
	addParametersFromMultiMap(multimap) {
		multimap.names().forEach((name) => {
			multimap.getAll(name).forEach((value) => {
				this.addParameterValue(name, value);
			});
		});
		return this;
	}

	/**
	 * Adds the value of the named query parameters.
	 * @param {string} key The parameter to set.
	 * @param {*} value The new value. Will be explicitly casted to String.
	 * @chainable
	 */
	addParameterValue(name, value) {
		this.ensureQueryInitialized_();
		if (core$1.isDef(value)) {
			value = String(value);
		}
		this.query.add(name, value);
		return this;
	}

	/**
	 * Adds the values of the named query parameter.
	 * @param {string} key The parameter to set.
	 * @param {*} value The new value.
	 * @chainable
	 */
	addParameterValues(name, values) {
		values.forEach((value) => this.addParameterValue(name, value));
		return this;
	}

	/**
	 * Ensures query internal map is initialized and synced with initial value
	 * extracted from URI search part.
	 * @protected
	 */
	ensureQueryInitialized_() {
		if (this.query) {
			return;
		}
		this.query = new MultiMap();
		var search = this.url.search;
		if (search) {
			search.substring(1).split('&').forEach((param) => {
				var [key, value] = param.split('=');
				if (core$1.isDef(value)) {
					value = Uri.urlDecode(value);
				}
				this.addParameterValue(key, value);
			});
		}
	}

	/**
	 * Gets the hash part of uri.
	 * @return {string}
	 */
	getHash() {
		return this.url.hash || '';
	}

	/**
	 * Gets the host part of uri. E.g. <code>[hostname]:[port]</code>.
	 * @return {string}
	 */
	getHost() {
		var host = this.getHostname();
		if (host) {
			var port = this.getPort();
			if (port && port !== '80') {
				host += ':' + port;
			}
		}
		return host;
	}

	/**
	 * Gets the hostname part of uri without protocol and port.
	 * @return {string}
	 */
	getHostname() {
		var hostname = this.url.hostname;
		if (hostname === Uri.HOSTNAME_PLACEHOLDER) {
			return '';
		}
		return hostname;
	}

	/**
	 * Gets the origin part of uri. E.g. <code>http://[hostname]:[port]</code>.
	 * @return {string}
	 */
	getOrigin() {
		var host = this.getHost();
		if (host) {
			return this.getProtocol() + '//' + host;
		}
		return '';
	}

	/**
	 * Returns the first value for a given parameter or undefined if the given
	 * parameter name does not appear in the query string.
	 * @param {string} paramName Unescaped parameter name.
	 * @return {string|undefined} The first value for a given parameter or
	 *   undefined if the given parameter name does not appear in the query
	 *   string.
	 */
	getParameterValue(name) {
		this.ensureQueryInitialized_();
		return this.query.get(name);
	}

	/**
	 * Returns the value<b>s</b> for a given parameter as a list of decoded
	 * query parameter values.
	 * @param {string} name The parameter to get values for.
	 * @return {!Array<?>} The values for a given parameter as a list of decoded
	 *   query parameter values.
	 */
	getParameterValues(name) {
		this.ensureQueryInitialized_();
		return this.query.getAll(name);
	}

	/**
	 * Returns the name<b>s</b> of the parameters.
	 * @return {!Array<string>} The names for the parameters as a list of
	 *   strings.
	 */
	getParameterNames() {
		this.ensureQueryInitialized_();
		return this.query.names();
	}

	/**
	 * Gets the function currently being used to parse URIs.
	 * @return {!function()}
	 */
	static getParseFn() {
		return parseFn_;
	}

	/**
	 * Gets the pathname part of uri.
	 * @return {string}
	 */
	getPathname() {
		return this.url.pathname;
	}

	/**
	 * Gets the port number part of uri as string.
	 * @return {string}
	 */
	getPort() {
		return this.url.port;
	}

	/**
	 * Gets the protocol part of uri. E.g. <code>http:</code>.
	 * @return {string}
	 */
	getProtocol() {
		return this.url.protocol;
	}

	/**
	 * Gets the search part of uri. Search value is retrieved from query
	 * parameters.
	 * @return {string}
	 */
	getSearch() {
		var search = '';
		var querystring = '';
		this.getParameterNames().forEach((name) => {
			this.getParameterValues(name).forEach((value) => {
				querystring += name;
				if (core$1.isDef(value)) {
					querystring += '=' + encodeURIComponent(value);
				}
				querystring += '&';
			});
		});
		querystring = querystring.slice(0, -1);
		if (querystring) {
			search += '?' + querystring;
		}
		return search;
	}

	/**
	 * Checks if uri contains the parameter.
	 * @param {string} name
	 * @return {boolean}
	 */
	hasParameter(name) {
		this.ensureQueryInitialized_();
		return this.query.contains(name);
	}

	/**
	 * Makes this URL unique by adding a random param to it. Useful for avoiding
	 * cache.
	 */
	makeUnique() {
		this.setParameterValue(Uri.RANDOM_PARAM, string.getRandomString());
		return this;
	}

	/**
	 * Maybe adds protocol and a hostname placeholder on a parial URI if needed.
	 * Relevent for compatibility with <code>URL</code> native object.
	 * @param {string=} opt_uri
	 * @return {string} URI with protocol and hostname placeholder.
	 */
	maybeAddProtocolAndHostname_(opt_uri) {
		var url = opt_uri;
		if (opt_uri.indexOf('://') === -1 &&
			opt_uri.indexOf('javascript:') !== 0) { // jshint ignore:line

			url = Uri.DEFAULT_PROTOCOL;
			if (opt_uri[0] !== '/' || opt_uri[1] !== '/') {
				url += '//';
			}

			switch (opt_uri.charAt(0)) {
				case '.':
				case '?':
				case '#':
					url += Uri.HOSTNAME_PLACEHOLDER;
					url += '/';
					url += opt_uri;
					break;
				case '':
				case '/':
					if (opt_uri[1] !== '/') {
						url += Uri.HOSTNAME_PLACEHOLDER;
					}
					url += opt_uri;
					break;
				default:
					url += opt_uri;
			}
		}
		return url;
	}

	/**
	 * Normalizes the parsed object to be in the expected standard.
	 * @param {!Object}
	 */
	static normalizeObject(parsed) {
		var length = parsed.pathname ? parsed.pathname.length : 0;
		if (length > 1 && parsed.pathname[length - 1] === '/') {
			parsed.pathname = parsed.pathname.substr(0, length - 1);
		}
		return parsed;
	}

	/**
	 * Parses the given uri string into an object.
	 * @param {*=} opt_uri Optional string URI to parse
	 */
	static parse(opt_uri) {
		return Uri.normalizeObject(parseFn_(opt_uri));
	}

	/**
	 * Removes the named query parameter.
	 * @param {string} name The parameter to remove.
	 * @chainable
	 */
	removeParameter(name) {
		this.ensureQueryInitialized_();
		this.query.remove(name);
		return this;
	}

	/**
	 * Removes uniqueness parameter of the uri.
	 * @chainable
	 */
	removeUnique() {
		this.removeParameter(Uri.RANDOM_PARAM);
		return this;
	}

	/**
	 * Sets the hash.
	 * @param {string} hash
	 * @chainable
	 */
	setHash(hash) {
		this.url.hash = hash;
		return this;
	}

	/**
	 * Sets the hostname.
	 * @param {string} hostname
	 * @chainable
	 */
	setHostname(hostname) {
		this.url.hostname = hostname;
		return this;
	}

	/**
	 * Sets the value of the named query parameters, clearing previous values
	 * for that key.
	 * @param {string} key The parameter to set.
	 * @param {*} value The new value.
	 * @chainable
	 */
	setParameterValue(name, value) {
		this.removeParameter(name);
		this.addParameterValue(name, value);
		return this;
	}

	/**
	 * Sets the values of the named query parameters, clearing previous values
	 * for that key.
	 * @param {string} key The parameter to set.
	 * @param {*} value The new value.
	 * @chainable
	 */
	setParameterValues(name, values) {
		this.removeParameter(name);
		values.forEach((value) => this.addParameterValue(name, value));
		return this;
	}

	/**
	 * Sets the pathname.
	 * @param {string} pathname
	 * @chainable
	 */
	setPathname(pathname) {
		this.url.pathname = pathname;
		return this;
	}

	/**
	 * Sets the port number.
	 * @param {*} port Port number.
	 * @chainable
	 */
	setPort(port) {
		this.url.port = port;
		return this;
	}

	/**
	 * Sets the function that will be used for parsing the original string uri
	 * into an object.
	 * @param {!function()} parseFn
	 */
	static setParseFn(parseFn) {
		parseFn_ = parseFn;
	}

	/**
	 * Sets the protocol. If missing <code>http:</code> is used as default.
	 * @param {string} protocol
	 * @chainable
	 */
	setProtocol(protocol) {
		this.url.protocol = protocol;
		if (this.url.protocol[this.url.protocol.length - 1] !== ':') {
			this.url.protocol += ':';
		}
		return this;
	}

	/**
	 * @return {string} The string form of the url.
	 * @override
	 */
	toString() {
		var href = '';
		var host = this.getHost();
		if (host) {
			href += this.getProtocol() + '//';
		}
		href += host + this.getPathname() + this.getSearch() + this.getHash();
		return href;
	}

	/**
	 * Joins the given paths.
	 * @param {string} basePath
	 * @param {...string} ...paths Any number of paths to be joined with the base url.
	 * @static
	 */
	static joinPaths(basePath, ...paths) {
		if (basePath.charAt(basePath.length - 1) === '/') {
			basePath = basePath.substring(0, basePath.length - 1);
		}
		paths = paths.map(path => path.charAt(0) === '/' ? path.substring(1) : path);
		return [basePath].concat(paths).join('/').replace(/\/$/, '');
	}

	/**
	 * URL-decodes the string. We need to specially handle '+'s because
	 * the javascript library doesn't convert them to spaces.
	 * @param {string} str The string to url decode.
	 * @return {string} The decoded {@code str}.
	 */
	static urlDecode(str) {
		return decodeURIComponent(str.replace(/\+/g, ' '));
	}

}

/**
 * Default protocol value.
 * @type {string}
 * @default http:
 * @static
 */
Uri.DEFAULT_PROTOCOL = 'http:';

/**
 * Hostname placeholder. Relevant to internal usage only.
 * @type {string}
 * @static
 */
Uri.HOSTNAME_PLACEHOLDER = 'hostname' + Date.now();

/**
 * Name used by the param generated by `makeUnique`.
 * @type {string}
 * @static
 */
Uri.RANDOM_PARAM = 'zx';

function assertBrowserEnvironment() {
	if (!globals.window) {
		throw new Error('Sign-in type not supported in this environment');
	}
}

function assertDefAndNotNull(value, errorMessage) {
	if (!core$1.isDefAndNotNull(value)) {
		throw new Error(errorMessage);
	}
}

function assertFunction(value, errorMessage) {
	if (!core$1.isFunction(value)) {
		throw new Error(errorMessage);
	}
}

function assertObject(value, errorMessage) {
	if (!core$1.isObject(value)) {
		throw new Error(errorMessage);
	}
}

function assertResponseSucceeded(response) {
	if (!response.succeeded()) {
		throw response.body();
	}
	return response;
}

function assertUserSignedIn(user) {
	if (!core$1.isDefAndNotNull(user)) {
		throw new Error('You must be signed-in to perform this operation');
	}
}

function assertUriWithNoPath(url, message) {
	var uri = new Uri(url);
	if (uri.getPathname().length > 1) {
		throw new Error(message);
	}
}

/**
 * Class responsible for storing authorization information.
 */
class Auth {
	/**
	 * Constructs an {@link Auth} instance.
	 * @param {string} tokenOrEmail Either the authorization token, or
	 *   the username.
	 * @param {string=} opt_password If a username is given as the first param,
	 *   this should be the password.
	 * @constructor
	 */
	constructor(tokenOrEmail, opt_password = null) {
		this.token = core$1.isString(opt_password) ? null : tokenOrEmail;
		this.email = core$1.isString(opt_password) ? tokenOrEmail : null;
		this.password = opt_password;

		this.createdAt = null;
		this.id = null;
		this.name = null;
		this.photoUrl = null;
		this.wedeployClient = null;
	}

	/**
	 * Constructs an {@link Auth} instance.
	 * @param {string} tokenOrUsername Either the authorization token, or
	 *   the username.
	 * @param {string=} opt_password If a username is given as the first param,
	 *   this should be the password.
	 * @return {!Auth}
	 */
	static create(tokenOrUsername, opt_password) {
		return new Auth(tokenOrUsername, opt_password);
	}

	/**
	 * Gets the created at date.
	 * @return {string}
	 */
	getCreatedAt() {
		return this.createdAt;
	}

	/**
	 * Gets the email.
	 * @return {string}
	 */
	getEmail() {
		return this.email;
	}

	/**
	 * Gets the id.
	 * @return {string}
	 */
	getId() {
		return this.id;
	}

	/**
	 * Gets the name.
	 * @return {string}
	 */
	getName() {
		return this.name;
	}

	/**
	 * Gets the password.
	 * @return {string}
	 */
	getPassword() {
		return this.password;
	}

	/**
	 * Gets the photo url.
	 * @return {string}
	 */
	getPhotoUrl() {
		return this.photoUrl;
	}

	/**
	 * Gets the token.
	 * @return {string}
	 */
	getToken() {
		return this.token;
	}

	/**
	 * Checks if created at is set.
	 * @return {boolean}
	 */
	hasCreatedAt() {
		return core$1.isDefAndNotNull(this.createdAt);
	}

	/**
	 * Checks if the email is set.
	 * @return {boolean}
	 */
	hasEmail() {
		return core$1.isDefAndNotNull(this.email);
	}

	/**
	 * Checks if the id is set.
	 * @return {boolean}
	 */
	hasId() {
		return core$1.isDefAndNotNull(this.id);
	}

	/**
	 * Checks if the name is set.
	 * @return {boolean}
	 */
	hasName() {
		return core$1.isDefAndNotNull(this.name);
	}

	/**
	 * Checks if the password is set.
	 * @return {boolean}
	 */
	hasPassword() {
		return core$1.isDefAndNotNull(this.password);
	}

	/**
	 * Checks if the photo url is set.
	 * @return {boolean}
	 */
	hasPhotoUrl() {
		return core$1.isDefAndNotNull(this.photoUrl);
	}

	/**
	 * Checks if the token is set.
	 * @return {boolean}
	 */
	hasToken() {
		return core$1.isDefAndNotNull(this.token);
	}

	/**
	 * Sets created at.
	 * @param {string} createdAt
	 */
	setCreatedAt(createdAt) {
		this.createdAt = createdAt;
	}

	/**
	 * Sets the email.
	 * @param {string} email
	 */
	setEmail(email) {
		this.email = email;
	}

	/**
	 * Sets the id.
	 * @param {string} id
	 */
	setId(id) {
		this.id = id;
	}

	/**
	 * Sets the name.
	 * @param {string} name
	 */
	setName(name) {
		this.name = name;
	}

	/**
	 * Sets the password.
	 * @param {string} password
	 */
	setPassword(password) {
		this.password = password;
	}

	/**
	 * Sets the photo url.
	 * @param {string} photoUrl
	 */
	setPhotoUrl(photoUrl) {
		this.photoUrl = photoUrl;
	}

	/**
	 * Sets the token.
	 * @param {string} token
	 */
	setToken(token) {
		this.token = token;
	}

	setWedeployClient(wedeployClient) {
		this.wedeployClient = wedeployClient;
	}

	/**
	 * Updates the user.
	 * @param {!object} data
	 * @return {CompletableFuture}
	 */
	updateUser(data) {
		assertObject(data, 'User data must be specified as object');
		return this.wedeployClient
			.url(this.wedeployClient.authUrl_)
			.path('/users')
			.auth(this)
			.patch(data)
			.then(response => assertResponseSucceeded(response));
	}

	/**
	 * Deletes the current user.
	 * @return {CompletableFuture}
	 */
	deleteUser() {
		assertDefAndNotNull(this.id, 'Cannot delete user without id');
		return this.wedeployClient
			.url(this.wedeployClient.authUrl_)
			.path('/users', this.id)
			.auth(this)
			.delete()
			.then(response => assertResponseSucceeded(response));
	}
}

class ApiHelper {

	/**
	 * Constructs an {@link ApiHelper} instance.
	 * @constructor
	 */
	constructor(wedeployClient) {
		assertDefAndNotNull(wedeployClient, 'WeDeploy client reference must be specified');
		this.wedeployClient = wedeployClient;
	}

	/**
	 * Adds authorization information to this request.
	 * @param {!Auth|string} authOrTokenOrEmail Either an {@link Auth} instance,
	 * an authorization token, or the email.
	 * @param {string=} opt_password If a email is given as the first param,
	 * this should be the password.
	 * @chainable
	 */
	auth(authOrTokenOrEmail, opt_password) {
		this.helperAuthScope = authOrTokenOrEmail;
		if (!(this.helperAuthScope instanceof Auth)) {
			this.helperAuthScope = Auth.create(authOrTokenOrEmail, opt_password);
		}
		return this;
	}

}

/**
 * Class responsible for encapsulate provider information.
 */
class AuthProvider {
	/**
	 * Constructs an {@link AuthProvider} instance.
	 * @constructor
	 */
	constructor() {
		this.provider = null;
		this.providerScope = null;
		this.redirectUri = null;
		this.scope = null;
	}

	/**
	 * Checks if provider is defined and not null.
	 * @return {boolean}
	 */
	hasProvider() {
		return core$1.isDefAndNotNull(this.provider);
	}

	/**
	 * Checks if scope is defined and not null.
	 * @return {boolean}
	 */
	hasProviderScope() {
		return core$1.isDefAndNotNull(this.providerScope);
	}

	/**
	 * Checks if redirect uri is defined and not null.
	 * @return {boolean}
	 */
	hasRedirectUri() {
		return core$1.isDefAndNotNull(this.redirectUri);
	}

	/**
	 * Checks if scope is defined and not null.
	 * @return {boolean}
	 */
	hasScope() {
		return core$1.isDefAndNotNull(this.scope);
	}

	/**
	 * Makes authorization url.
	 * @return {string=} Authorization url.
	 */
	makeAuthorizationUrl(opt_authUrl) {
		var uri = new Uri(opt_authUrl);

		uri.setPathname('/oauth/authorize');

		if (this.hasProvider()) {
			uri.setParameterValue('provider', this.getProvider());
		}
		if (this.hasProviderScope()) {
			uri.setParameterValue('provider_scope', this.getProviderScope());
		}
		if (this.hasRedirectUri()) {
			uri.setParameterValue('redirect_uri', this.getRedirectUri());
		}
		if (this.hasScope()) {
			uri.setParameterValue('scope', this.getScope());
		}

		return uri.toString();
	}

	/**
	 * Gets provider name.
	 * @return {string=} Provider name.
	 */
	getProvider() {
		return this.provider;
	}

	/**
	 * Gets provider scope.
	 * @return {string=} String with scopes.
	 */
	getProviderScope() {
		return this.providerScope;
	}

	/**
	 * Gets redirect uri.
	 * @return {string=}.
	 */
	getRedirectUri() {
		return this.redirectUri;
	}

	/**
	 * Gets scope.
	 * @return {string=} String with scopes.
	 */
	getScope() {
		return this.scope;
	}

	/**
	 * Sets provider scope.
	 * @param {string=} scope Scope string. Separate by space for multiple
	 *   scopes, e.g. "scope1 scope2".
	 */
	setProviderScope(providerScope) {
		assertStringIfDefAndNotNull(providerScope, 'Provider scope must be a string');
		this.providerScope = providerScope;
	}

	/**
	 * Sets redirect uri.
	 * @param {string=} redirectUri.
	 */
	setRedirectUri(redirectUri) {
		assertStringIfDefAndNotNull(redirectUri, 'Redirect uri must be a string');
		this.redirectUri = redirectUri;
	}

	/**
	 * Sets scope.
	 * @param {string=} scope Scope string. Separate by space for multiple
	 *   scopes, e.g. "scope1 scope2".
	 */
	setScope(scope) {
		assertStringIfDefAndNotNull(scope, 'Scope must be a string');
		this.scope = scope;
	}
}

function assertStringIfDefAndNotNull(value, errorMessage) {
	if (core$1.isDefAndNotNull(value) && !core$1.isString(value)) {
		throw new Error(errorMessage);
	}
}

/**
 * Facebook auth provider implementation.
 */
class FacebookAuthProvider extends AuthProvider {
	/**
	 * Constructs an {@link FacebookAuthProvider} instance.
	 * @constructor
	 */
	constructor() {
		super();
		this.provider = FacebookAuthProvider.PROVIDER;
	}
}

FacebookAuthProvider.PROVIDER = 'facebook';

/**
 * Github auth provider implementation.
 */
class GithubAuthProvider extends AuthProvider {
	/**
	 * Constructs an {@link GithubAuthProvider} instance.
	 * @constructor
	 */
	constructor() {
		super();
		this.provider = GithubAuthProvider.PROVIDER;
	}
}

GithubAuthProvider.PROVIDER = 'github';

/**
 * Google auth provider implementation.
 */
class GoogleAuthProvider extends AuthProvider {
	/**
	 * Constructs an {@link GoogleAuthProvider} instance.
	 * @constructor
	 */
	constructor() {
		super();
		this.provider = GoogleAuthProvider.PROVIDER;
	}
}

GoogleAuthProvider.PROVIDER = 'google';

/* jshint ignore:start */

/**
 * Abstract interface for storing and retrieving data using some persistence
 * mechanism.
 * @constructor
 */
class StorageMechanism {
	/**
	 * Clear all items from the data storage.
	 */
	clear() {
		throw Error('Unimplemented abstract method');
	}

	/**
	 * Sets an item in the data storage.
	 * @param {string} key The key to set.
	 * @param {*} value The value to serialize to a string and save.
	 */
	set(key, value) {
		throw Error('Unimplemented abstract method');
	}

	/**
	 * Gets an item from the data storage.
	 * @param {string} key The key to get.
	 * @return {*} Deserialized value or undefined if not found.
	 */
	get(key) {
		throw Error('Unimplemented abstract method');
	}

	/**
	 * Checks if this mechanism is supported in the current environment.
	 * Subclasses should override this when necessary.
	 */
	static isSupported() {
		return true;
	}

	/**
	 * Returns the list of keys stored in the Storage object.
	 * @param {!Array<string>} keys
	 */
	keys() {
		throw Error('Unimplemented abstract method');
	}

	/**
	 * Removes an item from the data storage.
	 * @param {string} key The key to remove.
	 */
	remove(key) {
		throw Error('Unimplemented abstract method');
	}

	/**
	 * Returns the number of data items stored in the Storage object.
	 * @return {number}
	 */
	size() {
		throw Error('Unimplemented abstract method');
	}
}



/* jshint ignore:end */

class Storage {

	/**
	 * Provides a convenient API for data persistence using a selected data
	 * storage mechanism.
	 * @param {!StorageMechanism} mechanism The underlying storage mechanism.
	 * @constructor
	 */
	constructor(mechanism) {
		assertMechanismDefAndNotNull(mechanism);
		assertMechanismIntanceOf(mechanism);

		/**
		 * The mechanism used to persist key-value pairs.
		 * @type {StorageMechanism}
		 * @protected
		 */
		this.mechanism = mechanism;
	}

	/**
	 * Clear all items from the data storage.
	 */
	clear() {
		this.mechanism.clear();
	}

	/**
	 * Sets an item in the data storage.
	 * @param {string} key The key to set.
	 * @param {*} value The value to serialize to a string and save.
	 */
	set(key, value) {
		if (!core$1.isDef(value)) {
			this.mechanism.remove(key);
			return;
		}
		this.mechanism.set(key, JSON.stringify(value));
	}

	/**
	 * Gets an item from the data storage.
	 * @param {string} key The key to get.
	 * @return {*} Deserialized value or undefined if not found.
	 */
	get(key) {
		var json;
		try {
			json = this.mechanism.get(key);
		} catch (e) {
			return undefined;
		}
		if (core$1.isNull(json)) {
			return undefined;
		}
		try {
			return JSON.parse(json);
		} catch (e) {
			throw Storage.ErrorCode.INVALID_VALUE;
		}
	}

	/**
	 * Returns the list of keys stored in the Storage object.
	 * @param {!Array<string>} keys
	 */
	keys() {
		return this.mechanism.keys();
	}

	/**
	 * Removes an item from the data storage.
	 * @param {string} key The key to remove.
	 */
	remove(key) {
		this.mechanism.remove(key);
	}

	/**
	 * Returns the number of data items stored in the Storage object.
	 * @return {number}
	 */
	size() {
		return this.mechanism.size();
	}

	/**
	 * Returns the list of values stored in the Storage object.
	 * @param {!Array<string>} values
	 */
	values() {
		return this.keys().map((key) => this.get(key));
	}
}

/**
 * Errors thrown by the storage.
 * @enum {string}
 */
Storage.ErrorCode = {
	INVALID_VALUE: 'Storage: Invalid value was encountered'
};

function assertMechanismDefAndNotNull(mechanism) {
	if (!core$1.isDefAndNotNull(mechanism)) {
		throw Error('Storage mechanism is required');
	}
}

function assertMechanismIntanceOf(mechanism) {
	if (!(mechanism instanceof StorageMechanism)) {
		throw Error('Storage mechanism must me an implementation of StorageMechanism');
	}
}

/**
 * Abstract interface for storing and retrieving data using some persistence
 * mechanism.
 * @constructor
 */
class LocalStorageMechanism extends StorageMechanism {
	/**
	 * Returns reference for global local storage. by default
	 */
	storage() {
		return LocalStorageMechanism.globals.localStorage;
	}

	/**
	 * @inheritDoc
	 */
	clear() {
		this.storage().clear();
	}

	/**
	 * @inheritDoc
	 */
	keys() {
		return Object.keys(this.storage());
	}

	/**
	 * @inheritDoc
	 */
	get(key) {
		return this.storage().getItem(key);
	}

	/**
	 * @inheritDoc
	 */
	static isSupported() {
		return typeof window !== 'undefined';
	}

	/**
	 * @inheritDoc
	 */
	remove(key) {
		this.storage().removeItem(key);
	}

	/**
	 * @inheritDoc
	 */
	set(key, value) {
		this.storage().setItem(key, value);
	}

	/**
	 * @inheritDoc
	 */
	size() {
		return this.storage().length;
	}
}

if (LocalStorageMechanism.isSupported()) {
	LocalStorageMechanism.globals = {
		localStorage: window.localStorage
	};
}

/**
 * Class responsible for encapsulate auth api calls.
 */
class AuthApiHelper extends ApiHelper {
	/**
	 * Constructs an {@link AuthApiHelper} instance.
	 * @constructor
	 */
	constructor(wedeployClient) {
		super(wedeployClient);

		this.currentUser = null;
		this.onSignInCallback = null;
		this.onSignOutCallback = null;
		if (LocalStorageMechanism.isSupported()) {
			this.storage = new Storage(new LocalStorageMechanism());
		}

		this.processSignIn_();

		this.provider = {
			Facebook: FacebookAuthProvider,
			Google: GoogleAuthProvider,
			Github: GithubAuthProvider
		};
	}

	/**
	 * Creates user.
	 * @param {!object} data The data to be used to create the user.
	 * @return {CancellablePromise}
	 */
	createUser(data) {
		assertObject(data, 'User data must be specified as object');
		return this.wedeployClient
			.url(this.wedeployClient.authUrl_)
			.path('/users')
			.post(data)
			.then(response => assertResponseSucceeded(response))
			.then(response => this.makeUserAuthFromData(response.body()));
	}

	/**
	 * Gets the current browser url without the fragment part.
	 * @return {!string}
	 * @protected
	 */
	getHrefWithoutFragment_() {
		var location = globals.window.location;
		return location.protocol + '//' + location.host + location.pathname + (location.search ? location.search : '');
	}

	/**
	 * Gets the access token from the url fragment and removes it.
	 * @return {?string}
	 * @protected
	 */
	getRedirectAccessToken_() {
		if (globals.window) {
			var fragment = globals.window.location.hash;
			if (fragment.indexOf('#access_token=') === 0) {
				return fragment.substring(14);
			}
		}
		return null;
	}

	/**
	 * Gets user by id.
	 * @param {!string} userId
	 * @return {CancellablePromise}
	 */
	getUser(userId) {
		assertDefAndNotNull(userId, 'User userId must be specified');
		assertUserSignedIn(this.currentUser);
		return this.wedeployClient
			.url(this.wedeployClient.authUrl_)
			.path('/users', userId)
			.auth(this.resolveAuthScope().token)
			.get()
			.then(response => assertResponseSucceeded(response))
			.then(response => this.makeUserAuthFromData(response.body()));
	}

	/**
	 * Loads current user. Requires a user token as argument.
	 * @param {!string} token
	 * @return {CancellablePromise}
	 */
	loadCurrentUser(token) {
		assertDefAndNotNull(token, 'User token must be specified');
		return this.wedeployClient
			.url(this.wedeployClient.authUrl_)
			.path('/user')
			.auth(token)
			.get()
			.then(response => {
				var data = response.body();
				data.token = token;
				this.currentUser = this.makeUserAuthFromData(data);
				if (this.storage) {
					this.storage.set('currentUser', data);
				}
				return this.currentUser;
			});
	}

	/**
	 * Makes user Auth from data object.
	 * @param {object} data
	 * @return {Auth}
	 * @protected
	 */
	makeUserAuthFromData(data) {
		var auth = new Auth();
		auth.setWedeployClient(this.wedeployClient);
		auth.setCreatedAt(data.createdAt);
		auth.setEmail(data.email);
		auth.setId(data.id);
		auth.setName(data.name);
		auth.setPhotoUrl(data.photoUrl);
		auth.setToken(data.token);
		return auth;
	}

	/**
	 * Calls the on sign in callback if set.
	 * @protected
	 */
	maybeCallOnSignInCallback_() {
		if (this.onSignInCallback) {
			this.onSignInCallback.call(this, this.currentUser);
		}
	}

	/**
	 * Calls the on sign out callback if set.
	 * @protected
	 */
	maybeCallOnSignOutCallback_() {
		if (this.onSignOutCallback) {
			this.onSignOutCallback.call(this, this.currentUser);
		}
	}

	/**
	 * Fires passed callback when a user sign-in. Note that it keeps only the
	 * last callback passed.
	 * @param {!Function} callback
	 */
	onSignIn(callback) {
		assertFunction(callback, 'Sign-in callback must be a function');
		this.onSignInCallback = callback;
	}

	/**
	 * Fires passed callback when a user sign-out. Note that it keeps only the
	 * last callback passed.
	 * @param {!Function} callback
	 */
	onSignOut(callback) {
		assertFunction(callback, 'Sign-out callback must be a function');
		this.onSignOutCallback = callback;
	}

	/**
	 * Processes sign-in by detecting a presence of a fragment
	 * <code>#access_token=</code> in the url or, alternatively, by local
	 * storage current user.
	 */
	processSignIn_() {
		var redirectAccessToken = this.getRedirectAccessToken_();
		if (redirectAccessToken) {
			this.removeUrlFragmentCompletely_();
			this.loadCurrentUser(redirectAccessToken)
				.then(() => this.maybeCallOnSignInCallback_());
			return;
		}
		var currentUser = this.storage && this.storage.get('currentUser');
		if (currentUser) {
			this.currentUser = this.makeUserAuthFromData(currentUser);
		}
	}

	/**
	 * Removes fragment from url by performing a push state to the current path.
	 * @protected
	 */
	removeUrlFragmentCompletely_() {
		globals.window.history.pushState({}, document.title, window.location.pathname + window.location.search);
	}

	/**
	 * Resolves auth scope from last login or api helper.
	 * @return {Auth}
	 */
	resolveAuthScope() {
		if (this.helperAuthScope) {
			return this.helperAuthScope;
		}
		return this.currentUser;
	}

	/**
	 * Sends password reset email to the specified email if found in database.
	 * For security reasons call do not fail if email not found.
	 * @param {!string} email
	 * @return {CancellablePromise}
	 */
	sendPasswordResetEmail(email) {
		assertDefAndNotNull(email, 'Send password reset email must be specified');
		return this.wedeployClient
			.url(this.wedeployClient.authUrl_)
			.path('/user/recover')
			.param('email', email)
			.post()
			.then(response => assertResponseSucceeded(response));
	}

	/**
	 * Signs in using email and password.
	 * @param {!string} email
	 * @param {!string} password
	 * @return {CancellablePromise}
	 */
	signInWithEmailAndPassword(email, password) {
		assertDefAndNotNull(email, 'Sign-in email must be specified');
		assertDefAndNotNull(password, 'Sign-in password must be specified');

		return this.wedeployClient
			.url(this.wedeployClient.authUrl_)
			.path('/oauth/token')
			.param('grant_type', 'password')
			.param('username', email)
			.param('password', password)
			.get()
			.then(response => assertResponseSucceeded(response))
			.then(response => this.loadCurrentUser(response.body().access_token))
			.then((user) => {
				this.maybeCallOnSignInCallback_();
				return user;
			});
	}

	/**
	 * Signs in with redirect. Some providers and environment may not support
	 * this flow.
	 * @param {AuthProvider} provider
	 */
	signInWithRedirect(provider) {
		assertBrowserEnvironment();
		assertDefAndNotNull(provider, 'Sign-in provider must be defined');
		assertSupportedProvider(provider);

		if (!provider.hasRedirectUri()) {
			provider.setRedirectUri(this.getHrefWithoutFragment_());
		}
		globals.window.location.href = provider.makeAuthorizationUrl(this.wedeployClient.authUrl_);
	}

	/**
	 * Signs out <code>currentUser</code> and removes from <code>localStorage</code>.
	 * @return {[type]} [description]
	 */
	signOut() {
		assertUserSignedIn(this.currentUser);
		return this.wedeployClient
			.url(this.wedeployClient.authUrl_)
			.path('/oauth/revoke')
			.param('token', this.currentUser.token)
			.get()
			.then(response => assertResponseSucceeded(response))
			.then(response => {
				this.maybeCallOnSignOutCallback_();
				this.unloadCurrentUser_();
				return response;
			});
	}

	/**
	 * Unloads all information for <code>currentUser</code> and removes from
	 * <code>localStorage</code> if present.
	 * @return {[type]} [description]
	 */
	unloadCurrentUser_() {
		this.currentUser = null;
		if (this.storage) {
			this.storage.remove('currentUser');
		}
	}
}

function assertSupportedProvider(provider) {
	switch (provider.constructor.PROVIDER) {
		case FacebookAuthProvider.PROVIDER:
		case GithubAuthProvider.PROVIDER:
		case GoogleAuthProvider.PROVIDER:
			break;
		default:
			throw new Error('Sign-in provider not supported');
	}
}

/**
 * Class that represents a search aggregation.
 */
class Aggregation {
	/**
	 * Constructs an {@link Aggregation} instance.
	 * @param {string} field The aggregation field.
	 * @param {string} operator The aggregation operator.
	 * @param {*=} opt_value The aggregation value.
	 * @constructor
	 */
	constructor(field, operator, opt_value) {
		this.field_ = field;
		this.operator_ = operator;
		this.value_ = opt_value;
	}

	/**
	 * Creates an {@link Aggregation} instance with the "avg" operator.
	 * @param {string} field The aggregation field.
	 * @return {!Aggregation}
	 * @static
	 */
	static avg(field) {
		return Aggregation.field(field, 'avg');
	}

	/**
	 * Creates an {@link Aggregation} instance with the "count" operator.
	 * @param {string} field The aggregation field.
	 * @return {!Aggregation}
	 * @static
	 */
	static count(field) {
		return Aggregation.field(field, 'count');
	}

	/**
	 * Creates an {@link DistanceAggregation} instance with the "geoDistance" operator.
	 * @param {string} field The aggregation field.
	 * @param {*} location The aggregation location.
	 * @param {...!Range} ranges The aggregation ranges.
	 * @return {!DistanceAggregation}
	 * @static
	 */
	static distance(field, location, ...ranges) {
		return new Aggregation.DistanceAggregation(field, location, ...ranges);
	}

	/**
	 * Creates an {@link Aggregation} instance with the "extendedStats" operator.
	 * @param {string} field The aggregation field.
	 * @return {!Aggregation}
	 * @static
	 */
	static extendedStats(field) {
		return Aggregation.field(field, 'extendedStats');
	}

	/**
	 * Gets this aggregation's field.
	 * @return {string}
	 */
	getField() {
		return this.field_;
	}

	/**
	 * Gets this aggregation's operator.
	 * @return {string}
	 */
	getOperator() {
		return this.operator_;
	}

	/**
	 * Gets this aggregation's value.
	 * @return {*}
	 */
	getValue() {
		return this.value_;
	}

	/**
	 * Creates an {@link Aggregation} instance with the "histogram" operator.
	 * @param {string} field The aggregation field.
	 * @param {number} interval The histogram's interval.
	 * @return {!Aggregation}
	 * @static
	 */
	static histogram(field, interval) {
		return new Aggregation(field, 'histogram', interval);
	}

	/**
	 * Creates an {@link Aggregation} instance with the "max" operator.
	 * @param {string} field The aggregation field.
	 * @return {!Aggregation}
	 * @static
	 */
	static max(field) {
		return Aggregation.field(field, 'max');
	}

	/**
	 * Creates an {@link Aggregation} instance with the "min" operator.
	 * @param {string} field The aggregation field.
	 * @return {!Aggregation}
	 * @static
	 */
	static min(field) {
		return Aggregation.field(field, 'min');
	}

	/**
	 * Creates an {@link Aggregation} instance with the "missing" operator.
	 * @param {string} field The aggregation field.
	 * @return {!Aggregation}
	 * @static
	 */
	static missing(field) {
		return Aggregation.field(field, 'missing');
	}

	/**
	 * Creates a new {@link Aggregation} instance.
	 * @param {string} field The aggregation field.
	 * @param {string} operator The aggregation operator.
	 * @return {!Aggregation}
	 * @static
	 */
	static field(field, operator) {
		return new Aggregation(field, operator);
	}

	/**
	 * Creates an {@link RangeAggregation} instance with the "range" operator.
	 * @param {string} field The aggregation field.
	 * @param {...!Range} ranges The aggregation ranges.
	 * @return {!RangeAggregation}
	 * @static
	 */
	static range(field, ...ranges) {
		return new Aggregation.RangeAggregation(field, ...ranges);
	}

	/**
	 * Creates an {@link Aggregation} instance with the "stats" operator.
	 * @param {string} field The aggregation field.
	 * @return {!Aggregation}
	 * @static
	 */
	static stats(field) {
		return Aggregation.field(field, 'stats');
	}

	/**
	 * Creates an {@link Aggregation} instance with the "sum" operator.
	 * @param {string} field The aggregation field.
	 * @return {!Aggregation}
	 * @static
	 */
	static sum(field) {
		return Aggregation.field(field, 'sum');
	}

	/**
	 * Creates an {@link Aggregation} instance with the "terms" operator.
	 * @param {string} field The aggregation field.
	 * @return {!Aggregation}
	 * @static
	 */
	static terms(field) {
		return Aggregation.field(field, 'terms');
	}
}

/**
 * Class that represents a distance aggregation.
 * @extends {Aggregation}
 */
class DistanceAggregation extends Aggregation {
	/**
	 * Constructs an {@link DistanceAggregation} instance.
	 * @param {string} field The aggregation field.
	 * @param {*} location The aggregation location.
	 * @param {...!Range} ranges The aggregation ranges.
	 * @constructor
	 */
	constructor(field, location, ...ranges) {
		super(field, 'geoDistance', {});
		this.value_.location = Embodied.toBody(location);
		this.value_.ranges = ranges.map(range => range.body());
	}

	/**
	 * Adds a range to this aggregation.
	 * @param {*} rangeOrFrom
	 * @param {*=} opt_to
	 * @chainnable
	 */
	range(rangeOrFrom, opt_to) {
		var range = rangeOrFrom;
		if (!(range instanceof Range)) {
			range = Range.range(rangeOrFrom, opt_to);
		}
		this.value_.ranges.push(range.body());
		return this;
	}

	/**
	 * Sets this aggregation's unit.
	 * @param {string} unit
	 * @chainnable
	 */
	unit(unit) {
		this.value_.unit = unit;
		return this;
	}
}
Aggregation.DistanceAggregation = DistanceAggregation;

/**
 * Class that represents a range aggregation.
 * @extends {Aggregation}
 */
class RangeAggregation extends Aggregation {
	/**
	 * Constructs an {@link RangeAggregation} instance.
	 * @param {string} field The aggregation field.
	 * @param {...!Range} ranges The aggregation ranges.
	 * @constructor
	 */
	constructor(field, ...ranges) {
		super(field, 'range');
		this.value_ = ranges.map(range => range.body());
	}

	/**
	 * Adds a range to this aggregation.
	 * @param {*} rangeOrFrom
	 * @param {*=} opt_to
	 * @chainnable
	 */
	range(rangeOrFrom, opt_to) {
		var range = rangeOrFrom;
		if (!(range instanceof Range)) {
			range = Range.range(rangeOrFrom, opt_to);
		}
		this.value_.push(range.body());
		return this;
	}
}
Aggregation.RangeAggregation = RangeAggregation;

/**
 * Class responsible for building queries.
 * @extends {Embodied}
 */
class Query extends Embodied {
	/**
	 * Adds an aggregation to this {@link Query} instance.
	 * @param {string} name The aggregation name.
	 * @param {!Aggregation|string} aggregationOrField Either an
	 *   {@link Aggregation} instance or the name of the aggregation field.
	 * @param {string=} opt_operator The aggregation operator.
	 * @return {!Query}
	 * @static
	 */
	static aggregate(name, aggregationOrField, opt_operator) {
		return new Query().aggregate(name, aggregationOrField, opt_operator);
	}

	/**
	 * Sets this query's type to "count".
	 * @return {!Query}
	 * @static
	 */
	static count() {
		return new Query().type('count');
	}

	/**
	 * Sets this query's type to "fetch".
	 * @return {!Query}
	 * @static
	 */
	static fetch() {
		return new Query().type('fetch');
	}

	/**
	 * Adds a filter to this Query.
	 * @param {!Filter|string} fieldOrFilter Either a {@link Filter} or the
	 *   name of the field to filter by.
	 * @param {*=} opt_operatorOrValue Either the field's operator or its value.
	 * @param {*=} opt_value The filter's value.
	 * @return {!Query}
	 * @static
	 */
	static filter(fieldOrFilter, opt_operatorOrValue, opt_value) {
		return new Query().filter(fieldOrFilter, opt_operatorOrValue, opt_value);
	}

	/**
	 * Sets the query offset.
	 * @param {number} offset The index of the first entry that should be returned
	 *   by this query.
	 * @return {!Query}
	 * @static
	 */
	static offset(offset) {
		return new Query().offset(offset);
	}

	/**
	 * Adds a highlight entry to this {@link Query} instance.
	 * @param {string} field The field's name.
	 * @return {!Query}
	 * @static
	 */
	static highlight(field) {
		return new Query().highlight(field);
	}

	/**
	 * Sets the query limit.
	 * @param {number} limit The max amount of entries that this query should return.
	 * @return {!Query}
	 * @static
	 */
	static limit(limit) {
		return new Query().limit(limit);
	}

	/**
	 * Adds a search to this {@link Query} instance.
	 * @param {!Filter|string} filterOrTextOrField If no other arguments
	 *   are passed to this function, this should be either a {@link Filter}
	 *   instance or a text to be used in a match filter. In both cases
	 *   the filter will be applied to all fields. Another option is to
	 *   pass this as a field name instead, together with other arguments
	 *   so the filter can be created.
	 * @param {string=} opt_textOrOperator Either a text to be used in a
	 *   match filter, or the operator that should be used.
	 * @param {*=} opt_value The value to be used by the filter. Should
	 *   only be passed if an operator was passed as the second argument.
	 * @return {!Query}
	 * @static
	 */
	static search(filterOrTextOrField, opt_textOrOperator, opt_value) {
		return new Query().search(filterOrTextOrField, opt_textOrOperator, opt_value);
	}

	/**
	 * Adds a sort entry to this query, specifying the field this query should be
	 * sorted by and, optionally, the sort direction.
	 * @param {string} field The field that the query should be sorted by.
	 * @param {string=} opt_direction The direction the sort operation should use.
	 *   If none is given, "asc" is used by default.
	 * @return {!Query}
	 * @static
	 */
	static sort(field, opt_direction) {
		return new Query().sort(field, opt_direction);
	}

	/**
	 * Sets the query type.
	 * @param {string} type The query's type. For example: "count", "fetch".
	 * @return {!Query}
	 * @static
	 */
	static type(type) {
		return new Query().type(type);
	}

	/**
	 * Adds an aggregation to this {@link Query} instance.
	 * @param {string} name The aggregation name.
	 * @param {!Aggregation|string} aggregationOrField Either an
	 *   {@link Aggregation} instance or the name of the aggregation field.
	 * @param {string=} opt_operator The aggregation operator.
	 * @chainnable
	 */
	aggregate(name, aggregationOrField, opt_operator) {
		var aggregation = aggregationOrField;
		if (!(aggregation instanceof Aggregation)) {
			aggregation = Aggregation.field(aggregationOrField, opt_operator);
		}

		var field = aggregation.getField();
		var value = {};
		value[field] = {
			name: name,
			operator: aggregation.getOperator()
		};
		if (core$1.isDefAndNotNull(aggregation.getValue())) {
			value[field].value = aggregation.getValue();
		}

		if (!this.body_.aggregation) {
			this.body_.aggregation = [];
		}
		this.body_.aggregation.push(value);
		return this;
	}

	/**
	 * Sets this query's type to "count".
	 * @chainnable
	 */
	count() {
		return this.type('count');
	}

	/**
	 * Sets this query's type to "fetch".
	 * @chainnable
	 */
	fetch() {
		return this.type('fetch');
	}

	/**
	 * Adds a filter to this Query.
	 * @param {!Filter|string} fieldOrFilter Either a {@link Filter} or the
	 *   name of the field to filter by.
	 * @param {*=} opt_operatorOrValue Either the field's operator or its value.
	 * @param {*=} opt_value The filter's value.
	 * @chainnable
	 */
	filter(fieldOrFilter, opt_operatorOrValue, opt_value) {
		let filter = Filter.toFilter(fieldOrFilter, opt_operatorOrValue, opt_value);
		if (!this.body_.filter) {
			this.body_.filter = [];
		}
		this.body_.filter.push(filter.body());
		return this;
	}

	/**
	 * Sets the query offset.
	 * @param {number} offset The index of the first entry that should be returned
	 *   by this query.
	 * @chainnable
	 */
	offset(offset) {
		this.body_.offset = offset;
		return this;
	}

	/**
	 * Adds a highlight entry to this {@link Query} instance.
	 * @param {string} field The field's name.
	 * @chainnable
	 */
	highlight(field) {
		if (!this.body_.highlight) {
			this.body_.highlight = [];
		}

		this.body_.highlight.push(field);
		return this;
	}

	/**
	 * Sets the query limit.
	 * @param {number} limit The max amount of entries that this query should return.
	 * @chainnable
	 */
	limit(limit) {
		this.body_.limit = limit;
		return this;
	}

	/**
	 * Adds a search to this {@link Query} instance.
	 * @param {!Filter|string} filterOrTextOrField If no other arguments
	 *   are passed to this function, this should be either a {@link Filter}
	 *   instance or a text to be used in a match filter. In both cases
	 *   the filter will be applied to all fields. Another option is to
	 *   pass this as a field name instead, together with other arguments
	 *   so the filter can be created.
	 * @param {string=} opt_textOrOperator Either a text to be used in a
	 *   match filter, or the operator that should be used.
	 * @param {*=} opt_value The value to be used by the filter. Should
	 *   only be passed if an operator was passed as the second argument.
	 * @chainnable
	 */
	search(filterOrTextOrField, opt_textOrOperator, opt_value) {
		var filter = filterOrTextOrField;

		if (opt_value) {
			filter = Filter.field(filterOrTextOrField, opt_textOrOperator, opt_value);
		} else if (opt_textOrOperator) {
			filter = Filter.match(filterOrTextOrField, opt_textOrOperator);
		} else if (!(filter instanceof Filter)) {
			filter = Filter.match(filterOrTextOrField);
		}

		if (!this.body_.search) {
			this.body_.search = [];
		}

		if (core$1.isDefAndNotNull(filterOrTextOrField)) {
			this.body_.search.push(filter.body());
		} else {
			this.body_.search.push({});
		}

		return this;
	}

	/**
	 * Adds a sort entry to this query, specifying the field this query should be
	 * sorted by and, optionally, the sort direction.
	 * @param {string} field The field that the query should be sorted by.
	 * @param {string=} opt_direction The direction the sort operation should use.
	 *   If none is given, "asc" is used by default.
	 * @chainnable
	 */
	sort(field, opt_direction) {
		if (!this.body_.sort) {
			this.body_.sort = [];
		}
		var sortEntry = {};
		sortEntry[field] = opt_direction || 'asc';
		this.body_.sort.push(sortEntry);
		return this;
	}

	/**
	 * Sets the query type.
	 * @param {string} type The query's type. For example: "count", "fetch".
	 * @chainnable
	 */
	type(type) {
		this.body_.type = type;
		return this;
	}
}

/**
 * Class responsible for encapsulate data api calls.
 */
class DataApiHelper extends ApiHelper {
	/**
	 * Constructs an {@link DataApiHelper} instance.
	 * @param {@link WeDeploy} instance.
	 * @constructor
	 */
	constructor(wedeployClient) {
		super(wedeployClient);
	}

	/**
	 * Adds a filter to this request's {@link Query}.
	 * @param {!Filter|string} fieldOrFilter Either a Filter instance or the
	 *   name of the field to filter by.
	 * @param {*=} opt_operatorOrValue Either the field's operator or its value.
	 * @param {*=} opt_value The filter's value.
	 * @chainable
	 */
	where(fieldOrFilter, opt_operatorOrValue, opt_value) {
		this.getOrCreateFilter_().and(fieldOrFilter, opt_operatorOrValue, opt_value);
		return this;
	}

	/**
	 * Adds a filter to be composed with this filter using the "or" operator.
	 * @param {!Filter|string} fieldOrFilter Either a {@link Filter} instance or
	 *   the name of the field to filter by.
	 * @param {*=} opt_operatorOrValue Either the field's operator or its value.
	 * @param {*=} opt_value The filter's value.
	 * @chainnable
	 */
	or(fieldOrFilter, opt_operatorOrValue, opt_value) {
		if (this.getOrCreateFilter_().body().and.length === 0) {
			throw Error('It\'s required to have a condition before using an \'or()\' for the first time.');
		}
		this.getOrCreateFilter_().or(fieldOrFilter, opt_operatorOrValue, opt_value);
		return this;
	}

	/**
	 * Adds a filter to be compose with this filter using "none" operator.
	 * @param {string} field The name of the field to filter by.
	 * @param {!(Array|...*)} args A variable amount of values to be used with
	 * the "none" operator. Can be passed either as a single array or as
	 * separate params.
	 * @chainnable
	 */
	none(field, ...args) {
		return this.where(Filter.none(field, args));
	}

	/**
	 * Adds a filter to be compose with this filter using "match" operator.
	 * @param {string} fieldOrQuery If no second string argument is given, this
	 * should be the query string, in which case all fields will be matched.
	 * Otherwise, this should be the name of the field to match.
	 * @param {string=} opt_query The query string.
	 * @chainnable
	 */
	match(field, value) {
		return this.where(Filter.match(field, value));
	}

	/**
	 * Adds a filter to be compose with this filter using "similar" operator.
	 * @param {string} fieldOrQuery If no second string argument is given, this
	 * should be the query string, in which case all fields will be matched.
	 * Otherwise, this should be the name of the field to match.
	 * @param {?string} query The query string.
	 * @chainnable
	 */
	similar(fieldOrQuery, query) {
		return this.where(Filter.similar(fieldOrQuery, query));
	}

	/**
	 * Returns a {@link Filter} instance that uses the "<" operator.
	 * @param {string} field The name of the field to filter by.
	 * @param {*} value The filter's value.
	 * @return {!Filter}
   * @static
	 */
	lt(field, value) {
		return this.where(Filter.lt(field, value));
	}

	/**
	 * Returns a {@link Filter} instance that uses the "<=" operator.
	 * @param {string} field The name of the field to filter by.
	 * @param {*} value The filter's value.
	 * @return {!Filter}
   * @static
	 */
	lte(field, value) {
		return this.where(Filter.lte(field, value));
	}


	/**
	 * Adds a filter to be compose with this filter using "any" operator.
	 * @param {string} field The name of the field to filter by.
	 * @param {!(Array|...*)} args A variable amount of values to be used with
	 * the "none" operator. Can be passed either as a single array or as
	 * separate params.
	 * @chainnable
	 */
	any(field, ...args) {
		return this.where(Filter.any(field, args));
	}

	/**
	 * Adds a filter to be compose with this filter using "gp" operator. This is a
	 * special use case of `Filter.polygon` for bounding boxes.
	 * @param {string} field The field's name.
	 * @param {*} boxOrUpperLeft Either a `Geo.BoundingBox` instance, or a
	 * bounding box's upper left coordinate.
	 * @param {*=} opt_lowerRight A bounding box's lower right coordinate.
	 * @chainnable
	 */
	boundingBox(field, boxOrUpperLeft, opt_lowerRight) {
		return this.where(Filter.boundingBox(field, boxOrUpperLeft, opt_lowerRight));
	}

	/**
	 * Adds a filter to be compose with this filter using "gd" operator.
	 * @param {string} field The field's name.
	 * @param {*} locationOrCircle Either a `Geo.Circle` instance or a
	 * coordinate.
	 * @param {Range|string=} opt_rangeOrDistance Either a `Range` instance or
	 * the distance value.
	 * @return {!Filter}
	 * @chainnable
	 */
	distance(field, locationOrCircle, opt_rangeOrDistance) {
		return this.where(Filter.distance(field, locationOrCircle, opt_rangeOrDistance));
	}

	/**
	 * Adds a filter to be compose with this filter using "range" operator.
	 * @param {string} field The field's name.
	 * @param {*} rangeOrMin Either a `Range` instance or a the range's min
	 * value.
	 * @param {*=} opt_max The range's max value.
	 * @return {!Filter}
	 * @chainnable
	 */
	range(field, rangeOrMin, opt_max) {
		return this.where(Filter.range(field, rangeOrMin, opt_max));
	}

	/**
	 * Sets the limit for this request's {@link Query}.
	 * @param {number} limit The max amount of entries that this request should return.
	 * @chainable
	 */
	limit(limit) {
		this.getOrCreateQuery_().limit(limit);
		return this;
	}

	/**
	 * Sets the offset for this request's {@link Query}.
	 * @param {number} offset The index of the first entry that should be
	 * returned by this query.
	 * @chainable
	 */
	offset(offset) {
		this.getOrCreateQuery_().offset(offset);
		return this;
	}

	/**
	 * Adds a highlight entry to this request's {@link Query} instance.
	 * @param {string} field The field's name.
	 * @chainable
	 */
	highlight(field) {
		this.getOrCreateQuery_().highlight(field);
		return this;
	}

	/**
	 * Adds an aggregation to this {@link Query} instance.
	 * @param {string} name The aggregation name.
	 * @param {!Aggregation|string} aggregationOrField Either an {@link
	 * Aggregation} instance or the name of the aggregation field.
	 * @param {string=} opt_operator The aggregation operator.
	 * @chainable
	 */
	aggregate(name, aggregationOrField, opt_operator) {
		this.getOrCreateQuery_().aggregate(name, aggregationOrField, opt_operator);
		return this;
	}

	/**
	 * Sets this request's query type to 'count'.
	 * @chainnable
	 */
	count() {
		this.getOrCreateQuery_().type('count');
		return this;
	}

	/**
	 * Adds a sort query to this request's body.
	 * @param {string} field The field that the query should be sorted by.
	 * @param {string=} opt_direction The direction the sort operation should
	 * use. If none is given, 'asc' is used by default.
	 * @chainnable
	 */
	orderBy(field, opt_direction) {
		this.getOrCreateQuery_().sort(field, opt_direction);
		return this;
	}

	/**
	 * Creates an object (or multiple objects) and saves it to WeDeploy data. If
	 * there's a validation registered in the collection and the request is
	 * successful, the resulting object (or array of objects) is returned. The
	 * data parameter can be either an Object or an Array of Objects.
	 * These Objects describe the attributes on the objects that are to be created.
	 * ```javascript
	 * var data = WeDeploy.data('http://demodata.wedeploy.io');
	 *
	 * data.create('movies', {'title'=> 'Star Wars: Episode I – The Phantom Menace'})
	 * 		 .then(function(movie){
	 * 			 console.log(movie)
	 *     });
	 *
	 * data.create('movies', [{'title'=> 'Star Wars: Episode II – Attack of the Clones'},
	 * 												{'title'=> 'Star Wars: Episode III – Revenge of the Sith'})
	 * 		 .then(function(movies){
	 * 			 console.log(movies)
	 *     });
	 * ```
	 * @param {string} collection Collection (key) used to create the new data.
	 * @param {Object} data Attributes on the object that is to be created.
	 * @return {!CancellablePromise}
	 */
	create(collection, data) {
		assertDefAndNotNull(collection, 'Collection key must be specified.');
		assertObject(data, 'Data can\'t be empty.');

		return this.wedeployClient
			.url(this.wedeployClient.dataUrl_)
			.auth(this.helperAuthScope)
			.path(collection)
			.post(data)
			.then(response => assertResponseSucceeded(response))
			.then(response => response.body());
	}

	/**
	 * Update the attributes of a document form the passed-in object and saves
	 * the record. If the object is invalid, the saving will fail and an error
	 * object will be returned.
	 *
	 * ```javascript
	 * var data = WeDeploy.data('http://demodata.wedeploy.io');
	 *
	 * data.update('movies/1019112353', {'title'=> 'Star Wars: Episode I'})
	 * 		 .then(function(movie){
	 * 			 console.log(movie)
	 *     });
	 * ```
	 * @param {string} document Key used to update the document.
	 * @param {Object} data Attributes on the object that is to be updated.
	 * @return {!CancellablePromise}
	 */
	update(document, data) {
		assertDefAndNotNull(document, 'Document key must be specified.');
		assertObject(data, 'Data must be specified.');

		return this.wedeployClient
			.url(this.wedeployClient.dataUrl_)
			.auth(this.helperAuthScope)
			.path(document)
			.put(data)
			.then(response => assertResponseSucceeded(response))
			.then(response => response.body());
	}

	/**
	 * Deletes a [document/field/collection].
	 * @param {string} key Key used to delete the
	 * document/field/collection.
	 * @return {!CancellablePromise}
	 */
	delete(key) {
		assertDefAndNotNull(key, 'Document/Field/Collection key must be specified');

		return this.wedeployClient
			.url(this.wedeployClient.dataUrl_)
			.auth(this.helperAuthScope)
			.path(key)
			.delete()
			.then(response => assertResponseSucceeded(response))
			.then(() => undefined);
	}

	/**
	 * Retrieve data from a [document/field/collection].
	 * @param {string} key Key used to delete the document/field/collection.
	 * @return {!CancellablePromise}
	 */
	get(key) {
		assertDefAndNotNull(key, 'Document/Field/Collection key must be specified');

		this.addFiltersToQuery_();

		return this.wedeployClient
			.url(this.wedeployClient.dataUrl_)
			.auth(this.helperAuthScope)
			.path(key)
			.get(this.query_)
			.then(response => assertResponseSucceeded(response))
			.then(response => response.body());
	}

	/**
	 * Retrieve data from a [document/field/collection] and put it in a search
	 * format.
	 * @param {string} key Key used to delete the document/field/collection.
	 * @return {!CancellablePromise}
	 */
	search(key) {
		assertDefAndNotNull(key, 'Document/Field/Collection key must be specified');

		this.onSearch_();

		this.addFiltersToQuery_();

		return this.wedeployClient
			.url(this.wedeployClient.dataUrl_)
			.auth(this.helperAuthScope)
			.path(key)
			.get(this.query_)
			.then(response => assertResponseSucceeded(response))
			.then(response => response.body());
	}

	/**
	 * Creates new socket.io instance. Monitor the arrival of new broadcasted
	 * data.
	 * @param  {string} collection key/collection used to find organized data.
	 * @param  {Object=} opt_options Object with Socket IO options.
	 * @return {!io} Socket IO reference. Server events can be listened on it.
	 */
	watch(collection, opt_options) {
		assertDefAndNotNull(collection, 'Collection key must be specified');

		this.addFiltersToQuery_();

		return this.wedeployClient
			.url(this.wedeployClient.dataUrl_)
			.auth(this.helperAuthScope)
			.path(collection)
			.watch(this.query_, opt_options);
	}

	/**
	 * Gets the currentl used main {@link Filter} object. If none exists yet, a
	 * new one is created.
	 * @return {!Query}
	 * @protected
	 */
	getOrCreateFilter_() {
		if (!this.filter_) {
			this.filter_ = new Filter();
		}
		return this.filter_;
	}

	/**
	 * Gets the currently used {@link Query} object. If none exists yet,
	 * a new one is created.
	 * @return {!Query}
	 * @protected
	 */
	getOrCreateQuery_() {
		if (!this.query_) {
			this.query_ = new Query();
		}
		return this.query_;
	}

	/**
	 * Load the currently used main {@link Filter} object into the currently
	 * used {@link Query}.
	 * @chainable
	 * @protected
	 */
	addFiltersToQuery_() {
		if (core$1.isDef(this.filter_) && this.toSearch_ !== true) {
			this.getOrCreateQuery_().filter(this.filter_);
		}
		return this;
	}

	/**
	 * Adds a search to this request's {@link Query} instance.
	 * @chainable
	 * @protected
	 */
	onSearch_() {
		if (core$1.isDef(this.filter_)) {
			this.getOrCreateQuery_().search(this.getOrCreateFilter_());
		} else {
			throw Error('It\'s required to have a condition before using an \'search()\' for the first time.');
		}
		this.toSearch_ = true;
		return this;
	}

}

/**
 * Abstraction layer for string to base64 conversion
 * reference: https://github.com/nodejs/node/issues/3462
 */
class Base64 {
	/**
	 * Creates a base-64 encoded ASCII string from a "string" of binary data.
	 * @param {string} string to be encoded.
	 * @return {string}
	 * @static
	 */
	static encodeString(string) {
		if (typeof btoa === 'function') {
			return btoa(string);
		}

		return new Buffer(string.toString(), 'binary');
	}
}

/*!
 * Promises polyfill from Google's Closure Library.
 *
 *      Copyright 2013 The Closure Library Authors. All Rights Reserved.
 *
 * NOTE(eduardo): Promise support is not ready on all supported browsers,
 * therefore core.js is temporarily using Google's promises as polyfill. It
 * supports cancellable promises and has clean and fast implementation.
 */

/**
 * Provides a more strict interface for Thenables in terms of
 * http://promisesaplus.com for interop with {@see CancellablePromise}.
 *
 * @interface
 * @extends {IThenable.<TYPE>}
 * @template TYPE
 */
var Thenable = function() {};

/**
 * Adds callbacks that will operate on the result of the Thenable, returning a
 * new child Promise.
 *
 * If the Thenable is fulfilled, the {@code onFulfilled} callback will be
 * invoked with the fulfillment value as argument, and the child Promise will
 * be fulfilled with the return value of the callback. If the callback throws
 * an exception, the child Promise will be rejected with the thrown value
 * instead.
 *
 * If the Thenable is rejected, the {@code onRejected} callback will be invoked
 * with the rejection reason as argument, and the child Promise will be rejected
 * with the return value of the callback or thrown value.
 *
 * @param {?(function(this:THIS, TYPE):
 *             (RESULT|IThenable.<RESULT>|Thenable))=} opt_onFulfilled A
 *     function that will be invoked with the fulfillment value if the Promise
 *     is fullfilled.
 * @param {?(function(*): *)=} opt_onRejected A function that will be invoked
 *     with the rejection reason if the Promise is rejected.
 * @param {THIS=} opt_context An optional context object that will be the
 *     execution context for the callbacks. By default, functions are executed
 *     with the default this.
 * @return {!CancellablePromise.<RESULT>} A new Promise that will receive the
 *     result of the fulfillment or rejection callback.
 * @template RESULT,THIS
 */
Thenable.prototype.then = function() {};


/**
 * An expando property to indicate that an object implements
 * {@code Thenable}.
 *
 * {@see addImplementation}.
 *
 * @const
 */
Thenable.IMPLEMENTED_BY_PROP = '$goog_Thenable';


/**
 * Marks a given class (constructor) as an implementation of Thenable, so
 * that we can query that fact at runtime. The class must have already
 * implemented the interface.
 * Exports a 'then' method on the constructor prototype, so that the objects
 * also implement the extern {@see Thenable} interface for interop with
 * other Promise implementations.
 * @param {function(new:Thenable,...[?])} ctor The class constructor. The
 *     corresponding class must have already implemented the interface.
 */
Thenable.addImplementation = function(ctor) {
  ctor.prototype.then = ctor.prototype.then;
  ctor.prototype.$goog_Thenable = true;
};


/**
 * @param {*} object
 * @return {boolean} Whether a given instance implements {@code Thenable}.
 *     The class/superclass of the instance must call {@code addImplementation}.
 */
Thenable.isImplementedBy = function(object$$1) {
  if (!object$$1) {
    return false;
  }
  try {
    return !!object$$1.$goog_Thenable;
  } catch (e) {
    // Property access seems to be forbidden.
    return false;
  }
};


/**
 * Like bind(), except that a 'this object' is not required. Useful when the
 * target function is already bound.
 *
 * Usage:
 * var g = partial(f, arg1, arg2);
 * g(arg3, arg4);
 *
 * @param {Function} fn A function to partially apply.
 * @param {...*} var_args Additional arguments that are partially applied to fn.
 * @return {!Function} A partially-applied form of the function bind() was
 *     invoked as a method of.
 */
var partial = function(fn) {
  var args = Array.prototype.slice.call(arguments, 1);
  return function() {
    // Clone the array (with slice()) and append additional arguments
    // to the existing arguments.
    var newArgs = args.slice();
    newArgs.push.apply(newArgs, arguments);
    return fn.apply(this, newArgs);
  };
};

/**
 * Promises provide a result that may be resolved asynchronously. A Promise may
 * be resolved by being fulfilled or rejected with a value, which will be known
 * as the fulfillment value or the rejection reason. Whether fulfilled or
 * rejected, the Promise result is immutable once it is set.
 *
 * Promises may represent results of any type, including undefined. Rejection
 * reasons are typically Errors, but may also be of any type. Closure Promises
 * allow for optional type annotations that enforce that fulfillment values are
 * of the appropriate types at compile time.
 *
 * The result of a Promise is accessible by calling {@code then} and registering
 * {@code onFulfilled} and {@code onRejected} callbacks. Once the Promise
 * resolves, the relevant callbacks are invoked with the fulfillment value or
 * rejection reason as argument. Callbacks are always invoked in the order they
 * were registered, even when additional {@code then} calls are made from inside
 * another callback. A callback is always run asynchronously sometime after the
 * scope containing the registering {@code then} invocation has returned.
 *
 * If a Promise is resolved with another Promise, the first Promise will block
 * until the second is resolved, and then assumes the same result as the second
 * Promise. This allows Promises to depend on the results of other Promises,
 * linking together multiple asynchronous operations.
 *
 * This implementation is compatible with the Promises/A+ specification and
 * passes that specification's conformance test suite. A Closure Promise may be
 * resolved with a Promise instance (or sufficiently compatible Promise-like
 * object) created by other Promise implementations. From the specification,
 * Promise-like objects are known as "Thenables".
 *
 * @see http://promisesaplus.com/
 *
 * @param {function(
 *             this:RESOLVER_CONTEXT,
 *             function((TYPE|IThenable.<TYPE>|Thenable)),
 *             function(*)): void} resolver
 *     Initialization function that is invoked immediately with {@code resolve}
 *     and {@code reject} functions as arguments. The Promise is resolved or
 *     rejected with the first argument passed to either function.
 * @param {RESOLVER_CONTEXT=} opt_context An optional context for executing the
 *     resolver function. If unspecified, the resolver function will be executed
 *     in the default scope.
 * @constructor
 * @struct
 * @final
 * @implements {Thenable.<TYPE>}
 * @template TYPE,RESOLVER_CONTEXT
 */
var CancellablePromise = function(resolver, opt_context) {
  /**
   * The internal state of this Promise. Either PENDING, FULFILLED, REJECTED, or
   * BLOCKED.
   * @private {CancellablePromise.State_}
   */
  this.state_ = CancellablePromise.State_.PENDING;

  /**
   * The resolved result of the Promise. Immutable once set with either a
   * fulfillment value or rejection reason.
   * @private {*}
   */
  this.result_ = undefined;

  /**
   * For Promises created by calling {@code then()}, the originating parent.
   * @private {CancellablePromise}
   */
  this.parent_ = null;

  /**
   * The list of {@code onFulfilled} and {@code onRejected} callbacks added to
   * this Promise by calls to {@code then()}.
   * @private {Array.<CancellablePromise.CallbackEntry_>}
   */
  this.callbackEntries_ = null;

  /**
   * Whether the Promise is in the queue of Promises to execute.
   * @private {boolean}
   */
  this.executing_ = false;

  if (CancellablePromise.UNHANDLED_REJECTION_DELAY > 0) {
    /**
     * A timeout ID used when the {@code UNHANDLED_REJECTION_DELAY} is greater
     * than 0 milliseconds. The ID is set when the Promise is rejected, and
     * cleared only if an {@code onRejected} callback is invoked for the
     * Promise (or one of its descendants) before the delay is exceeded.
     *
     * If the rejection is not handled before the timeout completes, the
     * rejection reason is passed to the unhandled rejection handler.
     * @private {number}
     */
    this.unhandledRejectionId_ = 0;
  } else if (CancellablePromise.UNHANDLED_REJECTION_DELAY === 0) {
    /**
     * When the {@code UNHANDLED_REJECTION_DELAY} is set to 0 milliseconds, a
     * boolean that is set if the Promise is rejected, and reset to false if an
     * {@code onRejected} callback is invoked for the Promise (or one of its
     * descendants). If the rejection is not handled before the next timestep,
     * the rejection reason is passed to the unhandled rejection handler.
     * @private {boolean}
     */
    this.hadUnhandledRejection_ = false;
  }

  try {
    var self = this;
    resolver.call(
      opt_context, function(value) {
        self.resolve_(CancellablePromise.State_.FULFILLED, value);
      }, function(reason) {
        self.resolve_(CancellablePromise.State_.REJECTED, reason);
      });
  } catch (e) {
    this.resolve_(CancellablePromise.State_.REJECTED, e);
  }
};

/**
 * The delay in milliseconds before a rejected Promise's reason is passed to
 * the rejection handler. By default, the rejection handler rethrows the
 * rejection reason so that it appears in the developer console or
 * {@code window.onerror} handler.
 * Rejections are rethrown as quickly as possible by default. A negative value
 * disables rejection handling entirely.
 * @type {number}
 */
CancellablePromise.UNHANDLED_REJECTION_DELAY = 0;


/**
 * The possible internal states for a Promise. These states are not directly
 * observable to external callers.
 * @enum {number}
 * @private
 */
CancellablePromise.State_ = {
  /** The Promise is waiting for resolution. */
  PENDING: 0,

  /** The Promise is blocked waiting for the result of another Thenable. */
  BLOCKED: 1,

  /** The Promise has been resolved with a fulfillment value. */
  FULFILLED: 2,

  /** The Promise has been resolved with a rejection reason. */
  REJECTED: 3
};


/**
 * Typedef for entries in the callback chain. Each call to {@code then},
 * {@code thenCatch}, or {@code thenAlways} creates an entry containing the
 * functions that may be invoked once the Promise is resolved.
 *
 * @typedef {{
 *   child: CancellablePromise,
 *   onFulfilled: function(*),
 *   onRejected: function(*)
 * }}
 * @private
 */
CancellablePromise.CallbackEntry_ = null;


/**
 * @param {(TYPE|Thenable.<TYPE>|Thenable)=} opt_value
 * @return {!CancellablePromise.<TYPE>} A new Promise that is immediately resolved
 *     with the given value.
 * @template TYPE
 */
CancellablePromise.resolve = function(opt_value) {
  return new CancellablePromise(function(resolve) {
      resolve(opt_value);
    });
};


/**
 * @param {*=} opt_reason
 * @return {!CancellablePromise} A new Promise that is immediately rejected with the
 *     given reason.
 */
CancellablePromise.reject = function(opt_reason) {
  return new CancellablePromise(function(resolve, reject) {
      reject(opt_reason);
    });
};


/**
 * @param {!Array.<!(Thenable.<TYPE>|Thenable)>} promises
 * @return {!CancellablePromise.<TYPE>} A Promise that receives the result of the
 *     first Promise (or Promise-like) input to complete.
 * @template TYPE
 */
CancellablePromise.race = function(promises) {
  return new CancellablePromise(function(resolve, reject) {
      if (!promises.length) {
        resolve(undefined);
      }
      for (var i = 0, promise; (promise = promises[i]); i++) {
        promise.then(resolve, reject);
      }
    });
};


/**
 * @param {!Array.<!(Thenable.<TYPE>|Thenable)>} promises
 * @return {!CancellablePromise.<!Array.<TYPE>>} A Promise that receives a list of
 *     every fulfilled value once every input Promise (or Promise-like) is
 *     successfully fulfilled, or is rejected by the first rejection result.
 * @template TYPE
 */
CancellablePromise.all = function(promises) {
  return new CancellablePromise(function(resolve, reject) {
      var toFulfill = promises.length;
      var values = [];

      if (!toFulfill) {
        resolve(values);
        return;
      }

      var onFulfill = function(index, value) {
        toFulfill--;
        values[index] = value;
        if (toFulfill === 0) {
          resolve(values);
        }
      };

      var onReject = function(reason) {
        reject(reason);
      };

      for (var i = 0, promise; (promise = promises[i]); i++) {
        promise.then(partial(onFulfill, i), onReject);
      }
    });
};


/**
 * @param {!Array.<!(Thenable.<TYPE>|Thenable)>} promises
 * @return {!CancellablePromise.<TYPE>} A Promise that receives the value of
 *     the first input to be fulfilled, or is rejected with a list of every
 *     rejection reason if all inputs are rejected.
 * @template TYPE
 */
CancellablePromise.firstFulfilled = function(promises) {
  return new CancellablePromise(function(resolve, reject) {
      var toReject = promises.length;
      var reasons = [];

      if (!toReject) {
        resolve(undefined);
        return;
      }

      var onFulfill = function(value) {
        resolve(value);
      };

      var onReject = function(index, reason) {
        toReject--;
        reasons[index] = reason;
        if (toReject === 0) {
          reject(reasons);
        }
      };

      for (var i = 0, promise; (promise = promises[i]); i++) {
        promise.then(onFulfill, partial(onReject, i));
      }
    });
};


/**
 * Adds callbacks that will operate on the result of the Promise, returning a
 * new child Promise.
 *
 * If the Promise is fulfilled, the {@code onFulfilled} callback will be invoked
 * with the fulfillment value as argument, and the child Promise will be
 * fulfilled with the return value of the callback. If the callback throws an
 * exception, the child Promise will be rejected with the thrown value instead.
 *
 * If the Promise is rejected, the {@code onRejected} callback will be invoked
 * with the rejection reason as argument, and the child Promise will be rejected
 * with the return value (or thrown value) of the callback.
 *
 * @override
 */
CancellablePromise.prototype.then = function(opt_onFulfilled, opt_onRejected, opt_context) {
  return this.addChildPromise_(
    core$1.isFunction(opt_onFulfilled) ? opt_onFulfilled : null,
    core$1.isFunction(opt_onRejected) ? opt_onRejected : null,
    opt_context);
};
Thenable.addImplementation(CancellablePromise);


/**
 * Adds a callback that will be invoked whether the Promise is fulfilled or
 * rejected. The callback receives no argument, and no new child Promise is
 * created. This is useful for ensuring that cleanup takes place after certain
 * asynchronous operations. Callbacks added with {@code thenAlways} will be
 * executed in the same order with other calls to {@code then},
 * {@code thenAlways}, or {@code thenCatch}.
 *
 * Since it does not produce a new child Promise, cancellation propagation is
 * not prevented by adding callbacks with {@code thenAlways}. A Promise that has
 * a cleanup handler added with {@code thenAlways} will be canceled if all of
 * its children created by {@code then} (or {@code thenCatch}) are canceled.
 *
 * @param {function(this:THIS): void} onResolved A function that will be invoked
 *     when the Promise is resolved.
 * @param {THIS=} opt_context An optional context object that will be the
 *     execution context for the callbacks. By default, functions are executed
 *     in the global scope.
 * @return {!CancellablePromise.<TYPE>} This Promise, for chaining additional calls.
 * @template THIS
 */
CancellablePromise.prototype.thenAlways = function(onResolved, opt_context) {
  var callback = function() {
    try {
      // Ensure that no arguments are passed to onResolved.
      onResolved.call(opt_context);
    } catch (err) {
      CancellablePromise.handleRejection_.call(null, err);
    }
  };

  this.addCallbackEntry_({
    child: null,
    onRejected: callback,
    onFulfilled: callback
  });
  return this;
};


/**
 * Adds a callback that will be invoked only if the Promise is rejected. This
 * is equivalent to {@code then(null, onRejected)}.
 *
 * @param {!function(this:THIS, *): *} onRejected A function that will be
 *     invoked with the rejection reason if the Promise is rejected.
 * @param {THIS=} opt_context An optional context object that will be the
 *     execution context for the callbacks. By default, functions are executed
 *     in the global scope.
 * @return {!CancellablePromise} A new Promise that will receive the result of the
 *     callback.
 * @template THIS
 */
CancellablePromise.prototype.thenCatch = function(onRejected, opt_context) {
  return this.addChildPromise_(null, onRejected, opt_context);
};

/**
 * Alias of {@link CancellablePromise.prototype.thenCatch}
 */
CancellablePromise.prototype.catch = CancellablePromise.prototype.thenCatch;


/**
 * Cancels the Promise if it is still pending by rejecting it with a cancel
 * Error. No action is performed if the Promise is already resolved.
 *
 * All child Promises of the canceled Promise will be rejected with the same
 * cancel error, as with normal Promise rejection. If the Promise to be canceled
 * is the only child of a pending Promise, the parent Promise will also be
 * canceled. Cancellation may propagate upward through multiple generations.
 *
 * @param {string=} opt_message An optional debugging message for describing the
 *     cancellation reason.
 */
CancellablePromise.prototype.cancel = function(opt_message) {
  if (this.state_ === CancellablePromise.State_.PENDING) {
    async.run(function() {
      var err = new CancellablePromise.CancellationError(opt_message);
      err.IS_CANCELLATION_ERROR = true;
      this.cancelInternal_(err);
    }, this);
  }
};


/**
 * Cancels this Promise with the given error.
 *
 * @param {!Error} err The cancellation error.
 * @private
 */
CancellablePromise.prototype.cancelInternal_ = function(err) {
  if (this.state_ === CancellablePromise.State_.PENDING) {
    if (this.parent_) {
      // Cancel the Promise and remove it from the parent's child list.
      this.parent_.cancelChild_(this, err);
    } else {
      this.resolve_(CancellablePromise.State_.REJECTED, err);
    }
  }
};


/**
 * Cancels a child Promise from the list of callback entries. If the Promise has
 * not already been resolved, reject it with a cancel error. If there are no
 * other children in the list of callback entries, propagate the cancellation
 * by canceling this Promise as well.
 *
 * @param {!CancellablePromise} childPromise The Promise to cancel.
 * @param {!Error} err The cancel error to use for rejecting the Promise.
 * @private
 */
CancellablePromise.prototype.cancelChild_ = function(childPromise, err) {
  if (!this.callbackEntries_) {
    return;
  }
  var childCount = 0;
  var childIndex = -1;

  // Find the callback entry for the childPromise, and count whether there are
  // additional child Promises.
  for (var i = 0, entry; (entry = this.callbackEntries_[i]); i++) {
    var child = entry.child;
    if (child) {
      childCount++;
      if (child === childPromise) {
        childIndex = i;
      }
      if (childIndex >= 0 && childCount > 1) {
        break;
      }
    }
  }

  // If the child Promise was the only child, cancel this Promise as well.
  // Otherwise, reject only the child Promise with the cancel error.
  if (childIndex >= 0) {
    if (this.state_ === CancellablePromise.State_.PENDING && childCount === 1) {
      this.cancelInternal_(err);
    } else {
      var callbackEntry = this.callbackEntries_.splice(childIndex, 1)[0];
      this.executeCallback_(
        callbackEntry, CancellablePromise.State_.REJECTED, err);
    }
  }
};


/**
 * Adds a callback entry to the current Promise, and schedules callback
 * execution if the Promise has already been resolved.
 *
 * @param {CancellablePromise.CallbackEntry_} callbackEntry Record containing
 *     {@code onFulfilled} and {@code onRejected} callbacks to execute after
 *     the Promise is resolved.
 * @private
 */
CancellablePromise.prototype.addCallbackEntry_ = function(callbackEntry) {
  if ((!this.callbackEntries_ || !this.callbackEntries_.length) &&
    (this.state_ === CancellablePromise.State_.FULFILLED ||
    this.state_ === CancellablePromise.State_.REJECTED)) {
    this.scheduleCallbacks_();
  }
  if (!this.callbackEntries_) {
    this.callbackEntries_ = [];
  }
  this.callbackEntries_.push(callbackEntry);
};


/**
 * Creates a child Promise and adds it to the callback entry list. The result of
 * the child Promise is determined by the state of the parent Promise and the
 * result of the {@code onFulfilled} or {@code onRejected} callbacks as
 * specified in the Promise resolution procedure.
 *
 * @see http://promisesaplus.com/#the__method
 *
 * @param {?function(this:THIS, TYPE):
 *          (RESULT|CancellablePromise.<RESULT>|Thenable)} onFulfilled A callback that
 *     will be invoked if the Promise is fullfilled, or null.
 * @param {?function(this:THIS, *): *} onRejected A callback that will be
 *     invoked if the Promise is rejected, or null.
 * @param {THIS=} opt_context An optional execution context for the callbacks.
 *     in the default calling context.
 * @return {!CancellablePromise} The child Promise.
 * @template RESULT,THIS
 * @private
 */
CancellablePromise.prototype.addChildPromise_ = function(
onFulfilled, onRejected, opt_context) {

  var callbackEntry = {
    child: null,
    onFulfilled: null,
    onRejected: null
  };

  callbackEntry.child = new CancellablePromise(function(resolve, reject) {
    // Invoke onFulfilled, or resolve with the parent's value if absent.
    callbackEntry.onFulfilled = onFulfilled ? function(value) {
      try {
        var result = onFulfilled.call(opt_context, value);
        resolve(result);
      } catch (err) {
        reject(err);
      }
    } : resolve;

    // Invoke onRejected, or reject with the parent's reason if absent.
    callbackEntry.onRejected = onRejected ? function(reason) {
      try {
        var result = onRejected.call(opt_context, reason);
        if (!core$1.isDef(result) && reason.IS_CANCELLATION_ERROR) {
          // Propagate cancellation to children if no other result is returned.
          reject(reason);
        } else {
          resolve(result);
        }
      } catch (err) {
        reject(err);
      }
    } : reject;
  });

  callbackEntry.child.parent_ = this;
  this.addCallbackEntry_(
    /** @type {CancellablePromise.CallbackEntry_} */ (callbackEntry));
  return callbackEntry.child;
};


/**
 * Unblocks the Promise and fulfills it with the given value.
 *
 * @param {TYPE} value
 * @private
 */
CancellablePromise.prototype.unblockAndFulfill_ = function(value) {
  if (this.state_ !== CancellablePromise.State_.BLOCKED) {
    throw new Error('CancellablePromise is not blocked.');
  }
  this.state_ = CancellablePromise.State_.PENDING;
  this.resolve_(CancellablePromise.State_.FULFILLED, value);
};


/**
 * Unblocks the Promise and rejects it with the given rejection reason.
 *
 * @param {*} reason
 * @private
 */
CancellablePromise.prototype.unblockAndReject_ = function(reason) {
  if (this.state_ !== CancellablePromise.State_.BLOCKED) {
    throw new Error('CancellablePromise is not blocked.');
  }
  this.state_ = CancellablePromise.State_.PENDING;
  this.resolve_(CancellablePromise.State_.REJECTED, reason);
};


/**
 * Attempts to resolve a Promise with a given resolution state and value. This
 * is a no-op if the given Promise has already been resolved.
 *
 * If the given result is a Thenable (such as another Promise), the Promise will
 * be resolved with the same state and result as the Thenable once it is itself
 * resolved.
 *
 * If the given result is not a Thenable, the Promise will be fulfilled or
 * rejected with that result based on the given state.
 *
 * @see http://promisesaplus.com/#the_promise_resolution_procedure
 *
 * @param {CancellablePromise.State_} state
 * @param {*} x The result to apply to the Promise.
 * @private
 */
CancellablePromise.prototype.resolve_ = function(state, x) {
  if (this.state_ !== CancellablePromise.State_.PENDING) {
    return;
  }

  if (this === x) {
    state = CancellablePromise.State_.REJECTED;
    x = new TypeError('CancellablePromise cannot resolve to itself');

  } else if (Thenable.isImplementedBy(x)) {
    x = /** @type {!Thenable} */ (x);
    this.state_ = CancellablePromise.State_.BLOCKED;
    x.then(this.unblockAndFulfill_, this.unblockAndReject_, this);
    return;

  } else if (core$1.isObject(x)) {
    try {
      var then = x.then;
      if (core$1.isFunction(then)) {
        this.tryThen_(x, then);
        return;
      }
    } catch (e) {
      state = CancellablePromise.State_.REJECTED;
      x = e;
    }
  }

  this.result_ = x;
  this.state_ = state;
  this.scheduleCallbacks_();

  if (state === CancellablePromise.State_.REJECTED && !x.IS_CANCELLATION_ERROR) {
    CancellablePromise.addUnhandledRejection_(this, x);
  }
};


/**
 * Attempts to call the {@code then} method on an object in the hopes that it is
 * a Promise-compatible instance. This allows interoperation between different
 * Promise implementations, however a non-compliant object may cause a Promise
 * to hang indefinitely. If the {@code then} method throws an exception, the
 * dependent Promise will be rejected with the thrown value.
 *
 * @see http://promisesaplus.com/#point-70
 *
 * @param {Thenable} thenable An object with a {@code then} method that may be
 *     compatible with the Promise/A+ specification.
 * @param {!Function} then The {@code then} method of the Thenable object.
 * @private
 */
CancellablePromise.prototype.tryThen_ = function(thenable, then) {
  this.state_ = CancellablePromise.State_.BLOCKED;
  var promise = this;
  var called = false;

  var resolve = function(value) {
    if (!called) {
      called = true;
      promise.unblockAndFulfill_(value);
    }
  };

  var reject = function(reason) {
    if (!called) {
      called = true;
      promise.unblockAndReject_(reason);
    }
  };

  try {
    then.call(thenable, resolve, reject);
  } catch (e) {
    reject(e);
  }
};


/**
 * Executes the pending callbacks of a resolved Promise after a timeout.
 *
 * Section 2.2.4 of the Promises/A+ specification requires that Promise
 * callbacks must only be invoked from a call stack that only contains Promise
 * implementation code, which we accomplish by invoking callback execution after
 * a timeout. If {@code startExecution_} is called multiple times for the same
 * Promise, the callback chain will be evaluated only once. Additional callbacks
 * may be added during the evaluation phase, and will be executed in the same
 * event loop.
 *
 * All Promises added to the waiting list during the same browser event loop
 * will be executed in one batch to avoid using a separate timeout per Promise.
 *
 * @private
 */
CancellablePromise.prototype.scheduleCallbacks_ = function() {
  if (!this.executing_) {
    this.executing_ = true;
    async.run(this.executeCallbacks_, this);
  }
};


/**
 * Executes all pending callbacks for this Promise.
 *
 * @private
 */
CancellablePromise.prototype.executeCallbacks_ = function() {
  while (this.callbackEntries_ && this.callbackEntries_.length) {
    var entries = this.callbackEntries_;
    this.callbackEntries_ = [];

    for (var i = 0; i < entries.length; i++) {
      this.executeCallback_(entries[i], this.state_, this.result_);
    }
  }
  this.executing_ = false;
};


/**
 * Executes a pending callback for this Promise. Invokes an {@code onFulfilled}
 * or {@code onRejected} callback based on the resolved state of the Promise.
 *
 * @param {!CancellablePromise.CallbackEntry_} callbackEntry An entry containing the
 *     onFulfilled and/or onRejected callbacks for this step.
 * @param {CancellablePromise.State_} state The resolution status of the Promise,
 *     either FULFILLED or REJECTED.
 * @param {*} result The resolved result of the Promise.
 * @private
 */
CancellablePromise.prototype.executeCallback_ = function(
callbackEntry, state, result) {
  if (state === CancellablePromise.State_.FULFILLED) {
    callbackEntry.onFulfilled(result);
  } else {
    this.removeUnhandledRejection_();
    callbackEntry.onRejected(result);
  }
};


/**
 * Marks this rejected Promise as having being handled. Also marks any parent
 * Promises in the rejected state as handled. The rejection handler will no
 * longer be invoked for this Promise (if it has not been called already).
 *
 * @private
 */
CancellablePromise.prototype.removeUnhandledRejection_ = function() {
  var p;
  if (CancellablePromise.UNHANDLED_REJECTION_DELAY > 0) {
    for (p = this; p && p.unhandledRejectionId_; p = p.parent_) {
      clearTimeout(p.unhandledRejectionId_);
      p.unhandledRejectionId_ = 0;
    }
  } else if (CancellablePromise.UNHANDLED_REJECTION_DELAY === 0) {
    for (p = this; p && p.hadUnhandledRejection_; p = p.parent_) {
      p.hadUnhandledRejection_ = false;
    }
  }
};


/**
 * Marks this rejected Promise as unhandled. If no {@code onRejected} callback
 * is called for this Promise before the {@code UNHANDLED_REJECTION_DELAY}
 * expires, the reason will be passed to the unhandled rejection handler. The
 * handler typically rethrows the rejection reason so that it becomes visible in
 * the developer console.
 *
 * @param {!CancellablePromise} promise The rejected Promise.
 * @param {*} reason The Promise rejection reason.
 * @private
 */
CancellablePromise.addUnhandledRejection_ = function(promise, reason) {
  if (CancellablePromise.UNHANDLED_REJECTION_DELAY > 0) {
    promise.unhandledRejectionId_ = setTimeout(function() {
      CancellablePromise.handleRejection_.call(null, reason);
    }, CancellablePromise.UNHANDLED_REJECTION_DELAY);

  } else if (CancellablePromise.UNHANDLED_REJECTION_DELAY === 0) {
    promise.hadUnhandledRejection_ = true;
    async.run(function() {
      if (promise.hadUnhandledRejection_) {
        CancellablePromise.handleRejection_.call(null, reason);
      }
    });
  }
};


/**
 * A method that is invoked with the rejection reasons for Promises that are
 * rejected but have no {@code onRejected} callbacks registered yet.
 * @type {function(*)}
 * @private
 */
CancellablePromise.handleRejection_ = async.throwException;


/**
 * Sets a handler that will be called with reasons from unhandled rejected
 * Promises. If the rejected Promise (or one of its descendants) has an
 * {@code onRejected} callback registered, the rejection will be considered
 * handled, and the rejection handler will not be called.
 *
 * By default, unhandled rejections are rethrown so that the error may be
 * captured by the developer console or a {@code window.onerror} handler.
 *
 * @param {function(*)} handler A function that will be called with reasons from
 *     rejected Promises. Defaults to {@code async.throwException}.
 */
CancellablePromise.setUnhandledRejectionHandler = function(handler) {
  CancellablePromise.handleRejection_ = handler;
};



/**
 * Error used as a rejection reason for canceled Promises.
 *
 * @param {string=} opt_message
 * @constructor
 * @extends {Error}
 * @final
 */
CancellablePromise.CancellationError = class extends Error {
  constructor(opt_message) {
     super(opt_message);

     if (opt_message) {
       this.message = opt_message;
     }
   }
};

/** @override */
CancellablePromise.CancellationError.prototype.name = 'cancel';

class Ajax {

	/**
	 * XmlHttpRequest's getAllResponseHeaders() method returns a string of
	 * response headers according to the format described on the spec:
	 * {@link http://www.w3.org/TR/XMLHttpRequest/#the-getallresponseheaders-method}.
	 * This method parses that string into a user-friendly name/value pair
	 * object.
	 * @param {string} allHeaders All headers as string.
	 * @return {!Array.<Object<string, string>>}
	 */
	static parseResponseHeaders(allHeaders) {
		var headers = [];
		if (!allHeaders) {
			return headers;
		}
		var pairs = allHeaders.split('\u000d\u000a');
		for (var i = 0; i < pairs.length; i++) {
			var index = pairs[i].indexOf('\u003a\u0020');
			if (index > 0) {
				var name = pairs[i].substring(0, index);
				var value = pairs[i].substring(index + 2);
				headers.push({
					name: name,
					value: value
				});
			}
		}
		return headers;
	}

	/**
	 * Requests the url using XMLHttpRequest.
	 * @param {!string} url
	 * @param {!string} method
	 * @param {?string} body
	 * @param {MultiMap=} opt_headers
	 * @param {MultiMap=} opt_params
	 * @param {number=} opt_timeout
	 * @param {boolean=} opt_sync
	 * @param {boolean=} opt_withCredentials
	 * @return {Promise} Deferred ajax request.
	 * @protected
	 */
	static request(url, method, body, opt_headers, opt_params, opt_timeout, opt_sync, opt_withCredentials) {
		url = url || '';
		method = method || 'GET';

		var request = new XMLHttpRequest();

		var promise = new CancellablePromise(function(resolve, reject) {
			request.onload = function() {
				if (request.aborted) {
					request.onerror();
					return;
				}
				resolve(request);
			};
			request.onerror = function() {
				var error = new Error('Request error');
				error.request = request;
				reject(error);
			};
		}).thenCatch(function(reason) {
			request.abort();
			throw reason;
		}).thenAlways(function() {
			clearTimeout(timeout);
		});

		if (opt_params) {
			url = new Uri(url).addParametersFromMultiMap(opt_params).toString();
		}

		request.open(method, url, !opt_sync);

		if (opt_withCredentials) {
			request.withCredentials = true;
		}

		if (opt_headers) {
			opt_headers.names().forEach(function(name) {
				request.setRequestHeader(name, opt_headers.getAll(name).join(', '));
			});
		}

		request.send(core$1.isDef(body) ? body : null);

		if (core$1.isDefAndNotNull(opt_timeout)) {
			var timeout = setTimeout(function() {
				promise.cancel('Request timeout');
			}, opt_timeout);
		}

		return promise;
	}

}

/**
 * Provides a convenient interface for data transport.
 * @interface
 */
class Transport {

	/**
	 * Sends a message for the specified client.
	 * @param {!ClientRequest} clientRequest
	 * @return {!Promise} Deferred request.
	 */
	send() {}

}

/**
 * Represents a client message (e.g. a request or a response).
 */
class ClientMessage {
	constructor() {
		this.headers_ = new MultiMap();
	}

	/**
	 * Fluent getter and setter for request body.
	 * @param {*=} opt_body Request body to be set. If none is given,
	 *   the current value of the body will be returned.
	 * @return {*} Returns request body if no body value was given. Otherwise
	 *   returns the {@link ClientMessage} object itself, so calls can be chained.
	 * @chainable Chainable when used as setter.
	 */
	body(opt_body) {
		if (core$1.isDef(opt_body)) {
			this.body_ = opt_body;
			return this;
		}
		return this.body_;
	}

	/**
	 * Adds a header. If a header with the same name already exists, it will not be
	 * overwritten, but the new value will be stored as well. The order is preserved.
	 * @param {string} name
	 * @param {string} value
	 * @chainable
	 */
	header(name, value) {
		if (arguments.length !== 2) {
			throw new Error('Invalid arguments');
		}
		this.headers_.set(name, value);
		return this;
	}

	/**
	 * Fluent getter and setter for request headers.
	 * @param {MultiMap|Object=} opt_headers Request headers list to
	 *   be set. If none is given the current value of the headers will
	 *   be returned.
	 * @return {!MultiMap|ClientMessage} Returns map of request headers
	 *   if no new value was given. Otherwise returns the {@link ClientMessage}
	 *   object itself, so calls can be chained.
	 * @chainable Chainable when used as setter.
	 */
	headers(opt_headers) {
		if (core$1.isDef(opt_headers)) {
			if (opt_headers instanceof MultiMap) {
				this.headers_ = opt_headers;
			} else {
				this.headers_.values = opt_headers;
			}
			return opt_headers;
		}
		return this.headers_;
	}

	/**
	 * Removes the body.
	 */
	removeBody() {
		this.body_ = undefined;
	}
}

/**
 * Represents a client response object.
 * @extends {ClientMessage}
 */
class ClientResponse extends ClientMessage {
	constructor(clientRequest) {
		super();
		if (!clientRequest) {
			throw new Error('Can\'t create response without request');
		}
		this.clientRequest_ = clientRequest;
	}

	/**
	 * Returns request that created this response.
	 * @return {!ClientRequest}
	 */
	request() {
		return this.clientRequest_;
	}

	/**
	 * Fluent getter and setter for response status code.
	 * @param {number=} opt_statusCode Request status code to be set. If none is given,
	 *   the current status code value will be returned.
	 * @return {!ClientMessage|number} Returns response status code if no new value was
	 *   given. Otherwise returns the {@link ClientMessage} object itself, so calls can
	 *   be chained.
	 * @chainable Chainable when used as setter.
	 */
	statusCode(opt_statusCode) {
		if (core$1.isDef(opt_statusCode)) {
			this.statusCode_ = opt_statusCode;
			return this;
		}
		return this.statusCode_;
	}

	/**
	 * Fluent getter and setter for response status text.
	 * @param {string=} opt_statusText Request status text to be set. If none is given,
	 *   the current status text value will be returned.
	 * @return {!ClientMessage|number} Returns response status text if no new value was
	 *   given. Otherwise returns the {@link ClientMessage} object itself, so calls can
	 *   be chained.
	 * @chainable Chainable when used as setter.
	 */
	statusText(opt_statusText) {
		if (core$1.isDef(opt_statusText)) {
			this.statusText_ = opt_statusText;
			return this;
		}
		return this.statusText_;
	}

	/**
	 * Checks if response succeeded. Any status code 2xx or 3xx is considered valid.
	 * @return {boolean}
	 */
	succeeded() {
		return this.statusCode() >= 200 && this.statusCode() <= 399;
	}

}

/**
 * The implementation of an ajax transport to be used with {@link WeDeploy}.
 * @extends {Transport}
 */
class AjaxTransport extends Transport {
	/**
	 * @inheritDoc
	 */
	send(clientRequest) {
		var deferred = Ajax.request(
			clientRequest.url(), clientRequest.method(), clientRequest.body(),
			clientRequest.headers(), clientRequest.params(), null, false, clientRequest.withCredentials());

		return deferred.then(function(response) {
			var clientResponse = new ClientResponse(clientRequest);
			clientResponse.body(response.responseText);
			clientResponse.statusCode(response.status);
			clientResponse.statusText(response.statusText);
			Ajax.parseResponseHeaders(response.getAllResponseHeaders()).forEach(function(header) {
				clientResponse.header(header.name, header.value);
			});
			return clientResponse;
		});
	}
}

/**
 * Provides a factory for data transport.
 */
class TransportFactory {
	constructor() {
		this.transports = {};
		this.transports[TransportFactory.DEFAULT_TRANSPORT_NAME] = TransportFactory[TransportFactory.DEFAULT_TRANSPORT_NAME];
	}

	/**
	 * Returns {@link TransportFactory} instance.
	 */
	static instance() {
		if (!TransportFactory.instance_) {
			TransportFactory.instance_ = new TransportFactory();
		}
		return TransportFactory.instance_;
	}

	/**
	 * Gets an instance of the transport implementation with the given name.
	 * @param {string} implementationName
	 * @return {!Transport}
	 */
	get(implementationName) {
		var TransportClass = this.transports[implementationName];

		if (!TransportClass) {
			throw new Error('Invalid transport name: ' + implementationName);
		}

		try {
			return new (TransportClass)();
		} catch (err) {
			throw new Error('Can\'t create transport', err);
		}
	}

	/**
	 * Returns the default transport implementation.
	 * @return {!Transport}
	 */
	getDefault() {
		return this.get(TransportFactory.DEFAULT_TRANSPORT_NAME);
	}
}

TransportFactory.DEFAULT_TRANSPORT_NAME = 'default';

TransportFactory[TransportFactory.DEFAULT_TRANSPORT_NAME] = AjaxTransport;

/**
 * Represents a client request object.
 * @extends {ClientMessage}
 */
class ClientRequest extends ClientMessage {
	constructor() {
		super();
		this.params_ = new MultiMap();
		this.withCredentials_ = true;
	}

	/**
	 * Fluent getter and setter for with credentials option.
	 * @param {boolean=} opt_withCredentials
	 * @chainable Chainable when used as setter.
	 */
	withCredentials(opt_withCredentials) {
		if (core$1.isDef(opt_withCredentials)) {
			this.withCredentials_ = !!opt_withCredentials;
			return this;
		}
		return this.withCredentials_;
	}

	/**
	 * Fluent getter and setter for request method.
	 * @param {string=} opt_method Request method to be set. If none is given,
	 *   the current method value will be returned.
	 * @return {!ClientMessage|string} Returns request method if no new value was
	 *   given. Otherwise returns the {@link ClientMessage} object itself, so
	 *   calls can be chained.
	 * @chainable Chainable when used as setter.
	 */
	method(opt_method) {
		if (core$1.isDef(opt_method)) {
			this.method_ = opt_method;
			return this;
		}
		return this.method_ || ClientRequest.DEFAULT_METHOD;
	}

	/**
	 * Adds a query. If a query with the same name already exists, it will not
	 * be overwritten, but new value will be stored as well. The order is preserved.
	 * @param {string} name
	 * @param {string} value
	 * @chainable
	 */
	param(name, value) {
		if (arguments.length !== 2) {
			throw new Error('Invalid arguments');
		}
		this.params_.set(name, value);
		return this;
	}

	/**
	 * Fluent getter and setter for request querystring.
	 * @param {MultiMap|Object=} opt_params Request querystring map to be set.
	 *   If none is given the current value of the params will be returned.
	 * @return {!MultiMap|ClientMessage} Returns map of request querystring if
	 *   no new value was given. Otherwise returns the {@link ClientMessage}
	 *   object itself, so calls can be chained.
	 */
	params(opt_params) {
		if (core$1.isDef(opt_params)) {
			if (opt_params instanceof MultiMap) {
				this.params_ = opt_params;
			} else {
				this.params_.values = opt_params;
			}
			return opt_params;
		}
		return this.params_;
	}

	/**
	 * Fluent getter and setter for request url.
	 * @param {string=} opt_url Request url to be set. If none is given,
	 *   the current value of the url will be returned.
	 * @return {!ClientMessage|string} Returns request url if no new value was given.
	 *   Otherwise returns the {@link ClientMessage} object itself, so calls can be
	 *   chained.
	 * @chainable Chainable when used as setter.
	 */
	url(opt_url) {
		if (core$1.isDef(opt_url)) {
			this.url_ = opt_url;
			return this;
		}
		return this.url_;
	}

}

ClientRequest.DEFAULT_METHOD = 'GET';

var io;

// Optimistic initialization of `io` reference from global `globals.window.io`.
if (typeof globals.window !== 'undefined') {
	io = globals.window.io;
}

/**
 * The main class for making api requests. Sending requests returns a promise
 * that is resolved when the response arrives. Usage example:
 * ```javascript
 * WeDeploy
 *   .url('/data/tasks')
 *   .post({desc: 'Buy milkl'})
 *   .then(function(response) {
 *     // Handle response here.
 *     console.log(response.body())
 *   });
 * ```
 */
class WeDeploy$1 {
	/**
	 * WeDeploy constructor function.
	 * @param {string} url The base url.
	 * @param {...string} paths Any amount of paths to be appended to the base
	 * url.
	 * @constructor
	 */
	constructor(url, ...paths) {
		if (arguments.length === 0) {
			throw new Error('Invalid arguments, try `new WeDeploy(baseUrl, url)`');
		}

		this.auth_ = null;
		this.body_ = null;
		this.url_ = Uri.joinPaths(url || '', ...paths);
		this.headers_ = new MultiMap();
		this.params_ = new MultiMap();
		this.withCredentials_ = true;

		this.header('Content-Type', 'application/json');
		this.header('X-Requested-With', 'XMLHttpRequest');
	}

	/**
	 * Static factory for creating WeDeploy data for the given url.
	 * @param {string=} opt_dataUrl The url that points to the data services.
	 * @return @return {data} WeDeploy data instance.
	 */
	static data(opt_dataUrl) {
		assertUriWithNoPath(opt_dataUrl, 'The data url should not have a path');

		if (core$1.isString(opt_dataUrl)) {
			WeDeploy$1.dataUrl_ = opt_dataUrl;
		}

		let data = new DataApiHelper(WeDeploy$1);

		data.auth(WeDeploy$1.auth().currentUser);

		return data;
	}

	/**
	 * Adds authorization information to this request.
	 * @param {!Auth|string} authOrTokenOrEmail Either an {@link Auth} instance,
	 * an authorization token, or the email.
	 * @param {string=} opt_password If a email is given as the first param,
	 * this should be the password.
	 * @chainable
	 */
	auth(authOrTokenOrEmail, opt_password) {
		this.auth_ = authOrTokenOrEmail;
		if (!(this.auth_ instanceof Auth)) {
			this.auth_ = Auth.create(authOrTokenOrEmail, opt_password);
		}
		return this;
	}

	/**
	 * Static factory for creating WeDeploy auth for the given url.
	 * @param {string=} opt_authUrl The url that points to the auth service.
	 */
	static auth(opt_authUrl) {
		if (core$1.isString(opt_authUrl)) {
			WeDeploy$1.authUrl_ = opt_authUrl;
		}
		if (!WeDeploy$1.auth_) {
			WeDeploy$1.auth_ = new AuthApiHelper(WeDeploy$1);
		}
		return WeDeploy$1.auth_;
	}

	/**
	 * Sets the body that will be sent with this request.
	 * @param {*} body
	 * @chainable
	 */
	body(body) {
		this.body_ = body;
		return this;
	}

	/**
	 * Converts the given body object to query params.
	 * @param {!ClientRequest} clientRequest Client request.
	 * @param {*} body
	 * @protected
	 */
	convertBodyToParams_(clientRequest, body) {
		if (core$1.isString(body)) {
			body = {
				body: body
			};
		} else if (body instanceof Embodied) {
			body = body.body();
		}
		Object.keys(body || {}).forEach(name => clientRequest.param(name, body[name]));
	}

	/**
	 * Creates client request and encode.
	 * @param {string} method
	 * @param {*} body
	 * @return {!ClientRequest} Client request.
	 * @protected
	 */
	createClientRequest_(method, body) {
		const clientRequest = new ClientRequest();

		clientRequest.body(body || this.body_);

		if (!core$1.isDefAndNotNull(clientRequest.body())) {
			if (this.formData_) {
				clientRequest.body(this.formData_);
			}
		}

		clientRequest.method(method);
		clientRequest.headers(this.headers());
		clientRequest.params(this.params());
		clientRequest.url(this.url());
		clientRequest.withCredentials(this.withCredentials_);

		this.encode(clientRequest);

		return clientRequest;
	}

	/**
	 * Decodes clientResponse body, parsing the body for example.
	 * @param {!ClientResponse} clientResponse The response object to be
	 * decoded.
	 * @return {!ClientResponse} The decoded response.
	 */
	decode(clientResponse) {
		if (WeDeploy$1.isContentTypeJson(clientResponse)) {
			try {
				clientResponse.body(JSON.parse(clientResponse.body()));
			} catch (err) {}
		}
		return clientResponse;
	}

	/**
	 * Sends message with the DELETE http verb.
	 * @param {string=} opt_body Content to be sent as the request's body.
	 * @return {!CancellablePromise}
	 */
	delete(opt_body) {
		return this.sendAsync('DELETE', opt_body);
	}

	/**
	 * Encodes the given {@link ClientRequest}, converting its body to an
	 * appropriate format for example.
	 * @param {!ClientRequest} clientRequest The request object to encode.
	 * @return {!ClientRequest} The encoded request.
	 */
	encode(clientRequest) {
		let body = clientRequest.body();

		if (core$1.isElement(body)) {
			body = new FormData(body);
			clientRequest.body(body);
		}

		body = this.maybeWrapWithQuery_(body);
		if (clientRequest.method() === 'GET') {
			this.convertBodyToParams_(clientRequest, body);
			clientRequest.removeBody();
			body = null;
		}

		if (typeof FormData !== 'undefined' && body instanceof FormData) {
			clientRequest.headers().remove('content-type');
		} else if (body instanceof Embodied) {
			clientRequest.body(body.toString());
		} else if (WeDeploy$1.isContentTypeJson(clientRequest)) {
			clientRequest.body(JSON.stringify(clientRequest.body()));
		}

		this.encodeParams_(clientRequest);
		this.resolveAuthentication_(clientRequest);

		return clientRequest;
	}

	/**
	 * Encodes the params for the given request, according to their types.
	 * @param {!ClientRequest} clientRequest
	 * @protected
	 */
	encodeParams_(clientRequest) {
		let params = clientRequest.params();
		params.names().forEach(function(name) {
			let values = params.getAll(name);
			values.forEach(function(value, index) {
				if (value instanceof Embodied) {
					value = value.toString();
				} else if (core$1.isObject(value) || (value instanceof Array)) {
					value = JSON.stringify(value);
				}
				values[index] = value;
			});
		});
	}

	/**
	 * Adds a key/value pair to be sent via the body in a `multipart/form-data` format.
	 * If the body is set by other means (for example, through the `body` method), this
	 * will be ignored.
	 * @param {string} name
	 * @param {*} value
	 * @chainable
	 */
	form(name, value) {
		if (typeof FormData === 'undefined') {
			throw new Error('form() is only available when FormData API is available.');
		}

		if (!this.formData_) {
			this.formData_ = new FormData();
		}
		this.formData_.append(name, value);
		return this;
	}

	/**
	 * Sends message with the GET http verb.
	 * @param {*=} opt_params Params to be added to the request url.
	 * @return {!CancellablePromise}
	 */
	get(opt_params) {
		return this.sendAsync('GET', opt_params);
	}

	/**
	 * Adds a header. If the header with the same name already exists, it will
	 * not be overwritten, but new value will be stored. The order is preserved.
	 * @param {string} name Header key.
	 * @param {*} value Header value.
	 * @chainable
	 */
	header(name, value) {
		if (arguments.length !== 2) {
			throw new Error('Invalid arguments');
		}
		this.headers_.set(name, value);
		return this;
	}

	/**
	 * Gets the headers.
	 * @return {!MultiMap}
	 */
	headers() {
		return this.headers_;
	}

	/**
	 * Wraps the given `Embodied` instance with a {@link Query} instance if needed.
	 * @param {Embodied} embodied
	 * @return {Embodied}
	 * @protected
	 */
	maybeWrapWithQuery_(embodied) {
		if (embodied instanceof Filter) {
			embodied = Query.filter(embodied);
		}
		return embodied;
	}

	/**
	 * Adds a query. If the query with the same name already exists, it will not
	 * be overwritten, but new value will be stored. The order is preserved.
	 * @param {string} name Param key.
	 * @param {*} value Param value.
	 * @chainable
	 */
	param(name, value) {
		if (arguments.length !== 2) {
			throw new Error('Invalid arguments');
		}
		this.params_.set(name, value);
		return this;
	}

	/**
	 * Gets the query strings map.
	 * @return {!MultiMap}
	 */
	params() {
		return this.params_;
	}

	/**
	 * Sends message with the PATCH http verb.
	 * @param {string=} opt_body Content to be sent as the request's body.
	 * @return {!CancellablePromise}
	 */
	patch(opt_body) {
		return this.sendAsync('PATCH', opt_body);
	}

	/**
	 * Creates a new {@link WeDeploy} instance for handling the url resulting in the
	 * union of the current url with the given paths.
	 * @param {...string} paths Any number of paths.
	 * @return {!WeDeploy} A new {@link WeDeploy} instance for handling the given paths.
	 */
	path(...paths) {
		let wedeployClient = new WeDeploy$1(this.url(), ...paths);

		if (core$1.isDefAndNotNull(this.auth_)) {
			wedeployClient.auth(this.auth_);
		}

		return wedeployClient.use(this.customTransport_);
	}

	/**
	 * Sends message with the POST http verb.
	 * @param {string=} opt_body Content to be sent as the request's body.
	 * @return {!CancellablePromise}
	 */
	post(opt_body) {
		return this.sendAsync('POST', opt_body);
	}

	/**
	 * Sends message with the PUT http verb.
	 * @param {string=} opt_body Content to be sent as the request's body.
	 * @return {!CancellablePromise}
	 */
	put(opt_body) {
		return this.sendAsync('PUT', opt_body);
	}

	/**
	 * Adds the authentication information to the request.
	 * @param {!ClientRequest} clientRequest
	 * @protected
	 */
	resolveAuthentication_(clientRequest) {
		if (!this.auth_) {
			return;
		}
		if (this.auth_.hasToken()) {
			clientRequest.header('Authorization', 'Bearer ' + this.auth_.token);
		} else {
			const credentials = this.auth_.email + ':' + this.auth_.password;
			clientRequest.header('Authorization', 'Basic ' + Base64.encodeString(credentials));
		}
	}

	/**
	 * Uses transport to send request with given method name and body
	 * asynchronously.
	 * @param {string} method The HTTP method to be used when sending data.
	 * @param {string} body Content to be sent as the request's body.
	 * @return {!CancellablePromise} Deferred request.
	 */
	sendAsync(method, body) {
		const transport = this.customTransport_ || TransportFactory.instance().getDefault();

		const clientRequest = this.createClientRequest_(method, body);

		return transport.send(clientRequest).then(this.decode);
	}

	/**
	 * Sets the socket transport
	 * @param {Object} socket implementation object.
	 */
	static socket(socket) {
		io = socket;
	}

	/**
	 * Static factory for creating WeDeploy client for the given url.
	 * @param {string} url The url that the client should use for sending requests.
	 */
	static url(url) {
		return new WeDeploy$1(url).use(this.customTransport_);
	}

	/**
	 * Returns the URL used by this client.
	 */
	url() {
		return this.url_;
	}

	/**
	 * Specifies {@link Transport} implementation.
	 * @param {!Transport} transport The transport implementation that should be
	 * used.
	 */
	use(transport) {
		this.customTransport_ = transport;
		return this;
	}

	/**
	 * Creates new socket.io instance. The parameters passed to socket.io
	 * constructor will be provided:
	 *
	 * ```javascript
	 * WeDeploy.url('http://domain:8080/path/a').watch({id: 'myId'}, {foo: true});
	 * // Equals:
	 * io('domain:8080/?url=path%2Fa%3Fid%3DmyId', {foo: true});
	 * ```
	 *
	 * @param {Object=} opt_params Params to be sent with the Socket IO request.
	 * @param {Object=} opt_options Object with Socket IO options.
	 * @return {!io} Socket IO reference. Server events can be listened on it.
	 */
	watch(opt_params, opt_options) {
		if (typeof io === 'undefined') {
			throw new Error('Socket.io client not loaded');
		}

		const clientRequest = this.createClientRequest_('GET', opt_params);
		const uri = new Uri(clientRequest.url());
		uri.addParametersFromMultiMap(clientRequest.params());

		opt_options = opt_options || {
			forceNew: true
		};
		opt_options.query = 'url=' + encodeURIComponent(uri.getPathname() + uri.getSearch());
		opt_options.path = opt_options.path || uri.getPathname();

		return io(uri.getHost(), opt_options);
	}

	/**
	 * @param {boolean} opt_withCredentials
	 */
	withCredentials(withCredentials) {
		this.withCredentials_ = !!withCredentials;
		return this;
	}
}

WeDeploy$1.isContentTypeJson = function(clientMessage) {
	const contentType = clientMessage.headers().get('content-type') || '';
	return contentType.indexOf('application/json') === 0;
};

WeDeploy$1.auth_ = null;
WeDeploy$1.authUrl_ = '';
WeDeploy$1.data_ = null;
WeDeploy$1.dataUrl_ = '';

globals.window.Filter = Filter;
globals.window.Geo = Geo;
globals.window.Query = Query;
globals.window.Range = Range;
globals.window.WeDeploy = WeDeploy$1;

export { Filter, Geo, Query, Range, WeDeploy$1 as WeDeploy };export default WeDeploy$1;



//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNvY2tldC5pby5qcyIsIi9zb3VyY2Uvc3JjL2dsb2JhbHMvZ2xvYmFscy5qcyIsIi9zb3VyY2Uvbm9kZV9tb2R1bGVzL21ldGFsL3NyYy9jb3JlLmpzIiwiL3NvdXJjZS9ub2RlX21vZHVsZXMvbWV0YWwvc3JjL2FycmF5L2FycmF5LmpzIiwiL3NvdXJjZS9ub2RlX21vZHVsZXMvbWV0YWwvc3JjL2FzeW5jL2FzeW5jLmpzIiwiL3NvdXJjZS9ub2RlX21vZHVsZXMvbWV0YWwvc3JjL2Rpc3Bvc2FibGUvRGlzcG9zYWJsZS5qcyIsIi9zb3VyY2Uvbm9kZV9tb2R1bGVzL21ldGFsL3NyYy9zdHJpbmcvc3RyaW5nLmpzIiwiL3NvdXJjZS9zcmMvYXBpLXF1ZXJ5L0VtYm9kaWVkLmpzIiwiL3NvdXJjZS9zcmMvYXBpLXF1ZXJ5L0ZpbHRlckJvZHkuanMiLCIvc291cmNlL3NyYy9hcGktcXVlcnkvR2VvLmpzIiwiL3NvdXJjZS9zcmMvYXBpLXF1ZXJ5L1JhbmdlLmpzIiwiL3NvdXJjZS9zcmMvYXBpLXF1ZXJ5L0ZpbHRlci5qcyIsIi9zb3VyY2Uvbm9kZV9tb2R1bGVzL21ldGFsLXVyaS9zcmMvcGFyc2VGcm9tQW5jaG9yLmpzIiwiL3NvdXJjZS9ub2RlX21vZHVsZXMvbWV0YWwtdXJpL3NyYy9wYXJzZS5qcyIsIi9zb3VyY2Uvbm9kZV9tb2R1bGVzL21ldGFsLXN0cnVjdHMvc3JjL011bHRpTWFwLmpzIiwiL3NvdXJjZS9ub2RlX21vZHVsZXMvbWV0YWwtc3RydWN0cy9zcmMvVHJlZU5vZGUuanMiLCIvc291cmNlL25vZGVfbW9kdWxlcy9tZXRhbC11cmkvc3JjL1VyaS5qcyIsIi9zb3VyY2Uvc3JjL2FwaS9hc3NlcnRpb25zLmpzIiwiL3NvdXJjZS9zcmMvYXBpL2F1dGgvQXV0aC5qcyIsIi9zb3VyY2Uvc3JjL2FwaS9BcGlIZWxwZXIuanMiLCIvc291cmNlL3NyYy9hcGkvYXV0aC9BdXRoUHJvdmlkZXIuanMiLCIvc291cmNlL3NyYy9hcGkvYXV0aC9GYWNlYm9va0F1dGhQcm92aWRlci5qcyIsIi9zb3VyY2Uvc3JjL2FwaS9hdXRoL0dpdGh1YkF1dGhQcm92aWRlci5qcyIsIi9zb3VyY2Uvc3JjL2FwaS9hdXRoL0dvb2dsZUF1dGhQcm92aWRlci5qcyIsIi9zb3VyY2Uvbm9kZV9tb2R1bGVzL21ldGFsLXN0b3JhZ2Uvc3JjL21lY2hhbmlzbS9TdG9yYWdlTWVjaGFuaXNtLmpzIiwiL3NvdXJjZS9ub2RlX21vZHVsZXMvbWV0YWwtc3RvcmFnZS9zcmMvU3RvcmFnZS5qcyIsIi9zb3VyY2Uvbm9kZV9tb2R1bGVzL21ldGFsLXN0b3JhZ2Uvc3JjL21lY2hhbmlzbS9Mb2NhbFN0b3JhZ2VNZWNoYW5pc20uanMiLCIvc291cmNlL3NyYy9hcGkvYXV0aC9BdXRoQXBpSGVscGVyLmpzIiwiL3NvdXJjZS9zcmMvYXBpLXF1ZXJ5L0FnZ3JlZ2F0aW9uLmpzIiwiL3NvdXJjZS9zcmMvYXBpLXF1ZXJ5L1F1ZXJ5LmpzIiwiL3NvdXJjZS9zcmMvYXBpL2RhdGEvRGF0YUFwaUhlbHBlci5qcyIsIi9zb3VyY2Uvc3JjL2NyeXB0L0Jhc2U2NC5qcyIsIi9zb3VyY2Uvbm9kZV9tb2R1bGVzL21ldGFsLXByb21pc2Uvc3JjL3Byb21pc2UvUHJvbWlzZS5qcyIsIi9zb3VyY2Uvbm9kZV9tb2R1bGVzL21ldGFsLWFqYXgvc3JjL0FqYXguanMiLCIvc291cmNlL3NyYy9hcGkvVHJhbnNwb3J0LmpzIiwiL3NvdXJjZS9zcmMvYXBpL0NsaWVudE1lc3NhZ2UuanMiLCIvc291cmNlL3NyYy9hcGkvQ2xpZW50UmVzcG9uc2UuanMiLCIvc291cmNlL3NyYy9hcGkvYnJvd3Nlci9BamF4VHJhbnNwb3J0LmpzIiwiL3NvdXJjZS9zcmMvYXBpL1RyYW5zcG9ydEZhY3RvcnkuanMiLCIvc291cmNlL3NyYy9hcGkvQ2xpZW50UmVxdWVzdC5qcyIsIi9zb3VyY2Uvc3JjL2FwaS9XZURlcGxveS5qcyIsIi9zb3VyY2Uvc3JjL2Vudi9icm93c2VyLmpzIl0sIm5hbWVzIjpbImNvcmUiLCJvYmplY3QiLCJQcm9taXNlIiwiV2VEZXBsb3kiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFBd0IiLCJmaWxlIjoiYXBpLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKGYpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIiYmdHlwZW9mIG1vZHVsZSE9PVwidW5kZWZpbmVkXCIpe21vZHVsZS5leHBvcnRzPWYoKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXSxmKX1lbHNle3ZhciBnO2lmKHR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiKXtnPXdpbmRvd31lbHNlIGlmKHR5cGVvZiBnbG9iYWwhPT1cInVuZGVmaW5lZFwiKXtnPWdsb2JhbH1lbHNlIGlmKHR5cGVvZiBzZWxmIT09XCJ1bmRlZmluZWRcIil7Zz1zZWxmfWVsc2V7Zz10aGlzfWcuaW8gPSBmKCl9fSkoZnVuY3Rpb24oKXt2YXIgZGVmaW5lLG1vZHVsZSxleHBvcnRzO3JldHVybiAoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSh7MTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgdXJsID0gX2RlcmVxXygnLi91cmwnKTtcbnZhciBwYXJzZXIgPSBfZGVyZXFfKCdzb2NrZXQuaW8tcGFyc2VyJyk7XG52YXIgTWFuYWdlciA9IF9kZXJlcV8oJy4vbWFuYWdlcicpO1xudmFyIGRlYnVnID0gX2RlcmVxXygnZGVidWcnKSgnc29ja2V0LmlvLWNsaWVudCcpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGxvb2t1cDtcblxuLyoqXG4gKiBNYW5hZ2VycyBjYWNoZS5cbiAqL1xuXG52YXIgY2FjaGUgPSBleHBvcnRzLm1hbmFnZXJzID0ge307XG5cbi8qKlxuICogTG9va3MgdXAgYW4gZXhpc3RpbmcgYE1hbmFnZXJgIGZvciBtdWx0aXBsZXhpbmcuXG4gKiBJZiB0aGUgdXNlciBzdW1tb25zOlxuICpcbiAqICAgYGlvKCdodHRwOi8vbG9jYWxob3N0L2EnKTtgXG4gKiAgIGBpbygnaHR0cDovL2xvY2FsaG9zdC9iJyk7YFxuICpcbiAqIFdlIHJldXNlIHRoZSBleGlzdGluZyBpbnN0YW5jZSBiYXNlZCBvbiBzYW1lIHNjaGVtZS9wb3J0L2hvc3QsXG4gKiBhbmQgd2UgaW5pdGlhbGl6ZSBzb2NrZXRzIGZvciBlYWNoIG5hbWVzcGFjZS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGxvb2t1cCh1cmksIG9wdHMpIHtcbiAgaWYgKHR5cGVvZiB1cmkgPT0gJ29iamVjdCcpIHtcbiAgICBvcHRzID0gdXJpO1xuICAgIHVyaSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIHZhciBwYXJzZWQgPSB1cmwodXJpKTtcbiAgdmFyIHNvdXJjZSA9IHBhcnNlZC5zb3VyY2U7XG4gIHZhciBpZCA9IHBhcnNlZC5pZDtcbiAgdmFyIHBhdGggPSBwYXJzZWQucGF0aDtcbiAgdmFyIHNhbWVOYW1lc3BhY2UgPSBjYWNoZVtpZF0gJiYgcGF0aCBpbiBjYWNoZVtpZF0ubnNwcztcbiAgdmFyIG5ld0Nvbm5lY3Rpb24gPSBvcHRzLmZvcmNlTmV3IHx8IG9wdHNbJ2ZvcmNlIG5ldyBjb25uZWN0aW9uJ10gfHxcbiAgICAgICAgICAgICAgICAgICAgICBmYWxzZSA9PT0gb3B0cy5tdWx0aXBsZXggfHwgc2FtZU5hbWVzcGFjZTtcblxuICB2YXIgaW87XG5cbiAgaWYgKG5ld0Nvbm5lY3Rpb24pIHtcbiAgICBkZWJ1ZygnaWdub3Jpbmcgc29ja2V0IGNhY2hlIGZvciAlcycsIHNvdXJjZSk7XG4gICAgaW8gPSBNYW5hZ2VyKHNvdXJjZSwgb3B0cyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFjYWNoZVtpZF0pIHtcbiAgICAgIGRlYnVnKCduZXcgaW8gaW5zdGFuY2UgZm9yICVzJywgc291cmNlKTtcbiAgICAgIGNhY2hlW2lkXSA9IE1hbmFnZXIoc291cmNlLCBvcHRzKTtcbiAgICB9XG4gICAgaW8gPSBjYWNoZVtpZF07XG4gIH1cblxuICByZXR1cm4gaW8uc29ja2V0KHBhcnNlZC5wYXRoKTtcbn1cblxuLyoqXG4gKiBQcm90b2NvbCB2ZXJzaW9uLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5wcm90b2NvbCA9IHBhcnNlci5wcm90b2NvbDtcblxuLyoqXG4gKiBgY29ubmVjdGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVyaVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmNvbm5lY3QgPSBsb29rdXA7XG5cbi8qKlxuICogRXhwb3NlIGNvbnN0cnVjdG9ycyBmb3Igc3RhbmRhbG9uZSBidWlsZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuTWFuYWdlciA9IF9kZXJlcV8oJy4vbWFuYWdlcicpO1xuZXhwb3J0cy5Tb2NrZXQgPSBfZGVyZXFfKCcuL3NvY2tldCcpO1xuXG59LHtcIi4vbWFuYWdlclwiOjIsXCIuL3NvY2tldFwiOjQsXCIuL3VybFwiOjUsXCJkZWJ1Z1wiOjE0LFwic29ja2V0LmlvLXBhcnNlclwiOjQwfV0sMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgZWlvID0gX2RlcmVxXygnZW5naW5lLmlvLWNsaWVudCcpO1xudmFyIFNvY2tldCA9IF9kZXJlcV8oJy4vc29ja2V0Jyk7XG52YXIgRW1pdHRlciA9IF9kZXJlcV8oJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgcGFyc2VyID0gX2RlcmVxXygnc29ja2V0LmlvLXBhcnNlcicpO1xudmFyIG9uID0gX2RlcmVxXygnLi9vbicpO1xudmFyIGJpbmQgPSBfZGVyZXFfKCdjb21wb25lbnQtYmluZCcpO1xudmFyIGRlYnVnID0gX2RlcmVxXygnZGVidWcnKSgnc29ja2V0LmlvLWNsaWVudDptYW5hZ2VyJyk7XG52YXIgaW5kZXhPZiA9IF9kZXJlcV8oJ2luZGV4b2YnKTtcbnZhciBCYWNrb2ZmID0gX2RlcmVxXygnYmFja28yJyk7XG5cbi8qKlxuICogSUU2KyBoYXNPd25Qcm9wZXJ0eVxuICovXG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBNYW5hZ2VyO1xuXG4vKipcbiAqIGBNYW5hZ2VyYCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZW5naW5lIGluc3RhbmNlIG9yIGVuZ2luZSB1cmkvb3B0c1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gTWFuYWdlcih1cmksIG9wdHMpe1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTWFuYWdlcikpIHJldHVybiBuZXcgTWFuYWdlcih1cmksIG9wdHMpO1xuICBpZiAodXJpICYmICgnb2JqZWN0JyA9PSB0eXBlb2YgdXJpKSkge1xuICAgIG9wdHMgPSB1cmk7XG4gICAgdXJpID0gdW5kZWZpbmVkO1xuICB9XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIG9wdHMucGF0aCA9IG9wdHMucGF0aCB8fCAnL3NvY2tldC5pbyc7XG4gIHRoaXMubnNwcyA9IHt9O1xuICB0aGlzLnN1YnMgPSBbXTtcbiAgdGhpcy5vcHRzID0gb3B0cztcbiAgdGhpcy5yZWNvbm5lY3Rpb24ob3B0cy5yZWNvbm5lY3Rpb24gIT09IGZhbHNlKTtcbiAgdGhpcy5yZWNvbm5lY3Rpb25BdHRlbXB0cyhvcHRzLnJlY29ubmVjdGlvbkF0dGVtcHRzIHx8IEluZmluaXR5KTtcbiAgdGhpcy5yZWNvbm5lY3Rpb25EZWxheShvcHRzLnJlY29ubmVjdGlvbkRlbGF5IHx8IDEwMDApO1xuICB0aGlzLnJlY29ubmVjdGlvbkRlbGF5TWF4KG9wdHMucmVjb25uZWN0aW9uRGVsYXlNYXggfHwgNTAwMCk7XG4gIHRoaXMucmFuZG9taXphdGlvbkZhY3RvcihvcHRzLnJhbmRvbWl6YXRpb25GYWN0b3IgfHwgMC41KTtcbiAgdGhpcy5iYWNrb2ZmID0gbmV3IEJhY2tvZmYoe1xuICAgIG1pbjogdGhpcy5yZWNvbm5lY3Rpb25EZWxheSgpLFxuICAgIG1heDogdGhpcy5yZWNvbm5lY3Rpb25EZWxheU1heCgpLFxuICAgIGppdHRlcjogdGhpcy5yYW5kb21pemF0aW9uRmFjdG9yKClcbiAgfSk7XG4gIHRoaXMudGltZW91dChudWxsID09IG9wdHMudGltZW91dCA/IDIwMDAwIDogb3B0cy50aW1lb3V0KTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gIHRoaXMudXJpID0gdXJpO1xuICB0aGlzLmNvbm5lY3RpbmcgPSBbXTtcbiAgdGhpcy5sYXN0UGluZyA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBmYWxzZTtcbiAgdGhpcy5wYWNrZXRCdWZmZXIgPSBbXTtcbiAgdGhpcy5lbmNvZGVyID0gbmV3IHBhcnNlci5FbmNvZGVyKCk7XG4gIHRoaXMuZGVjb2RlciA9IG5ldyBwYXJzZXIuRGVjb2RlcigpO1xuICB0aGlzLmF1dG9Db25uZWN0ID0gb3B0cy5hdXRvQ29ubmVjdCAhPT0gZmFsc2U7XG4gIGlmICh0aGlzLmF1dG9Db25uZWN0KSB0aGlzLm9wZW4oKTtcbn1cblxuLyoqXG4gKiBQcm9wYWdhdGUgZ2l2ZW4gZXZlbnQgdG8gc29ja2V0cyBhbmQgZW1pdCBvbiBgdGhpc2BcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5lbWl0QWxsID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZW1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICBmb3IgKHZhciBuc3AgaW4gdGhpcy5uc3BzKSB7XG4gICAgaWYgKGhhcy5jYWxsKHRoaXMubnNwcywgbnNwKSkge1xuICAgICAgdGhpcy5uc3BzW25zcF0uZW1pdC5hcHBseSh0aGlzLm5zcHNbbnNwXSwgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogVXBkYXRlIGBzb2NrZXQuaWRgIG9mIGFsbCBzb2NrZXRzXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUudXBkYXRlU29ja2V0SWRzID0gZnVuY3Rpb24oKXtcbiAgZm9yICh2YXIgbnNwIGluIHRoaXMubnNwcykge1xuICAgIGlmIChoYXMuY2FsbCh0aGlzLm5zcHMsIG5zcCkpIHtcbiAgICAgIHRoaXMubnNwc1tuc3BdLmlkID0gdGhpcy5lbmdpbmUuaWQ7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihNYW5hZ2VyLnByb3RvdHlwZSk7XG5cbi8qKlxuICogU2V0cyB0aGUgYHJlY29ubmVjdGlvbmAgY29uZmlnLlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdHJ1ZS9mYWxzZSBpZiBpdCBzaG91bGQgYXV0b21hdGljYWxseSByZWNvbm5lY3RcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0aW9uID0gZnVuY3Rpb24odil7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbjtcbiAgdGhpcy5fcmVjb25uZWN0aW9uID0gISF2O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgcmVjb25uZWN0aW9uIGF0dGVtcHRzIGNvbmZpZy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4IHJlY29ubmVjdGlvbiBhdHRlbXB0cyBiZWZvcmUgZ2l2aW5nIHVwXG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbkF0dGVtcHRzID0gZnVuY3Rpb24odil7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzO1xuICB0aGlzLl9yZWNvbm5lY3Rpb25BdHRlbXB0cyA9IHY7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBkZWxheSBiZXR3ZWVuIHJlY29ubmVjdGlvbnMuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5XG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbkRlbGF5ID0gZnVuY3Rpb24odil7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5O1xuICB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheSA9IHY7XG4gIHRoaXMuYmFja29mZiAmJiB0aGlzLmJhY2tvZmYuc2V0TWluKHYpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbk1hbmFnZXIucHJvdG90eXBlLnJhbmRvbWl6YXRpb25GYWN0b3IgPSBmdW5jdGlvbih2KXtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmFuZG9taXphdGlvbkZhY3RvcjtcbiAgdGhpcy5fcmFuZG9taXphdGlvbkZhY3RvciA9IHY7XG4gIHRoaXMuYmFja29mZiAmJiB0aGlzLmJhY2tvZmYuc2V0Sml0dGVyKHYpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgbWF4aW11bSBkZWxheSBiZXR3ZWVuIHJlY29ubmVjdGlvbnMuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5XG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbkRlbGF5TWF4ID0gZnVuY3Rpb24odil7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5TWF4O1xuICB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheU1heCA9IHY7XG4gIHRoaXMuYmFja29mZiAmJiB0aGlzLmJhY2tvZmYuc2V0TWF4KHYpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgY29ubmVjdGlvbiB0aW1lb3V0LiBgZmFsc2VgIHRvIGRpc2FibGVcbiAqXG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnRpbWVvdXQgPSBmdW5jdGlvbih2KXtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fdGltZW91dDtcbiAgdGhpcy5fdGltZW91dCA9IHY7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTdGFydHMgdHJ5aW5nIHRvIHJlY29ubmVjdCBpZiByZWNvbm5lY3Rpb24gaXMgZW5hYmxlZCBhbmQgd2UgaGF2ZSBub3RcbiAqIHN0YXJ0ZWQgcmVjb25uZWN0aW5nIHlldFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm1heWJlUmVjb25uZWN0T25PcGVuID0gZnVuY3Rpb24oKSB7XG4gIC8vIE9ubHkgdHJ5IHRvIHJlY29ubmVjdCBpZiBpdCdzIHRoZSBmaXJzdCB0aW1lIHdlJ3JlIGNvbm5lY3RpbmdcbiAgaWYgKCF0aGlzLnJlY29ubmVjdGluZyAmJiB0aGlzLl9yZWNvbm5lY3Rpb24gJiYgdGhpcy5iYWNrb2ZmLmF0dGVtcHRzID09PSAwKSB7XG4gICAgLy8ga2VlcHMgcmVjb25uZWN0aW9uIGZyb20gZmlyaW5nIHR3aWNlIGZvciB0aGUgc2FtZSByZWNvbm5lY3Rpb24gbG9vcFxuICAgIHRoaXMucmVjb25uZWN0KCk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBTZXRzIHRoZSBjdXJyZW50IHRyYW5zcG9ydCBgc29ja2V0YC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25hbCwgY2FsbGJhY2tcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub3BlbiA9XG5NYW5hZ2VyLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24oZm4pe1xuICBkZWJ1ZygncmVhZHlTdGF0ZSAlcycsIHRoaXMucmVhZHlTdGF0ZSk7XG4gIGlmICh+dGhpcy5yZWFkeVN0YXRlLmluZGV4T2YoJ29wZW4nKSkgcmV0dXJuIHRoaXM7XG5cbiAgZGVidWcoJ29wZW5pbmcgJXMnLCB0aGlzLnVyaSk7XG4gIHRoaXMuZW5naW5lID0gZWlvKHRoaXMudXJpLCB0aGlzLm9wdHMpO1xuICB2YXIgc29ja2V0ID0gdGhpcy5lbmdpbmU7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW5pbmcnO1xuICB0aGlzLnNraXBSZWNvbm5lY3QgPSBmYWxzZTtcblxuICAvLyBlbWl0IGBvcGVuYFxuICB2YXIgb3BlblN1YiA9IG9uKHNvY2tldCwgJ29wZW4nLCBmdW5jdGlvbigpIHtcbiAgICBzZWxmLm9ub3BlbigpO1xuICAgIGZuICYmIGZuKCk7XG4gIH0pO1xuXG4gIC8vIGVtaXQgYGNvbm5lY3RfZXJyb3JgXG4gIHZhciBlcnJvclN1YiA9IG9uKHNvY2tldCwgJ2Vycm9yJywgZnVuY3Rpb24oZGF0YSl7XG4gICAgZGVidWcoJ2Nvbm5lY3RfZXJyb3InKTtcbiAgICBzZWxmLmNsZWFudXAoKTtcbiAgICBzZWxmLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgICBzZWxmLmVtaXRBbGwoJ2Nvbm5lY3RfZXJyb3InLCBkYXRhKTtcbiAgICBpZiAoZm4pIHtcbiAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ0Nvbm5lY3Rpb24gZXJyb3InKTtcbiAgICAgIGVyci5kYXRhID0gZGF0YTtcbiAgICAgIGZuKGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE9ubHkgZG8gdGhpcyBpZiB0aGVyZSBpcyBubyBmbiB0byBoYW5kbGUgdGhlIGVycm9yXG4gICAgICBzZWxmLm1heWJlUmVjb25uZWN0T25PcGVuKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBlbWl0IGBjb25uZWN0X3RpbWVvdXRgXG4gIGlmIChmYWxzZSAhPT0gdGhpcy5fdGltZW91dCkge1xuICAgIHZhciB0aW1lb3V0ID0gdGhpcy5fdGltZW91dDtcbiAgICBkZWJ1ZygnY29ubmVjdCBhdHRlbXB0IHdpbGwgdGltZW91dCBhZnRlciAlZCcsIHRpbWVvdXQpO1xuXG4gICAgLy8gc2V0IHRpbWVyXG4gICAgdmFyIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgZGVidWcoJ2Nvbm5lY3QgYXR0ZW1wdCB0aW1lZCBvdXQgYWZ0ZXIgJWQnLCB0aW1lb3V0KTtcbiAgICAgIG9wZW5TdWIuZGVzdHJveSgpO1xuICAgICAgc29ja2V0LmNsb3NlKCk7XG4gICAgICBzb2NrZXQuZW1pdCgnZXJyb3InLCAndGltZW91dCcpO1xuICAgICAgc2VsZi5lbWl0QWxsKCdjb25uZWN0X3RpbWVvdXQnLCB0aW1lb3V0KTtcbiAgICB9LCB0aW1lb3V0KTtcblxuICAgIHRoaXMuc3Vicy5wdXNoKHtcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCl7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB0aGlzLnN1YnMucHVzaChvcGVuU3ViKTtcbiAgdGhpcy5zdWJzLnB1c2goZXJyb3JTdWIpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiB0cmFuc3BvcnQgb3Blbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbm9wZW4gPSBmdW5jdGlvbigpe1xuICBkZWJ1Zygnb3BlbicpO1xuXG4gIC8vIGNsZWFyIG9sZCBzdWJzXG4gIHRoaXMuY2xlYW51cCgpO1xuXG4gIC8vIG1hcmsgYXMgb3BlblxuICB0aGlzLnJlYWR5U3RhdGUgPSAnb3Blbic7XG4gIHRoaXMuZW1pdCgnb3BlbicpO1xuXG4gIC8vIGFkZCBuZXcgc3Vic1xuICB2YXIgc29ja2V0ID0gdGhpcy5lbmdpbmU7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ2RhdGEnLCBiaW5kKHRoaXMsICdvbmRhdGEnKSkpO1xuICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdwaW5nJywgYmluZCh0aGlzLCAnb25waW5nJykpKTtcbiAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAncG9uZycsIGJpbmQodGhpcywgJ29ucG9uZycpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ2Vycm9yJywgYmluZCh0aGlzLCAnb25lcnJvcicpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ2Nsb3NlJywgYmluZCh0aGlzLCAnb25jbG9zZScpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHRoaXMuZGVjb2RlciwgJ2RlY29kZWQnLCBiaW5kKHRoaXMsICdvbmRlY29kZWQnKSkpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBhIHBpbmcuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25waW5nID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5sYXN0UGluZyA9IG5ldyBEYXRlO1xuICB0aGlzLmVtaXRBbGwoJ3BpbmcnKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gYSBwYWNrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25wb25nID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5lbWl0QWxsKCdwb25nJywgbmV3IERhdGUgLSB0aGlzLmxhc3RQaW5nKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdpdGggZGF0YS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbmRhdGEgPSBmdW5jdGlvbihkYXRhKXtcbiAgdGhpcy5kZWNvZGVyLmFkZChkYXRhKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdoZW4gcGFyc2VyIGZ1bGx5IGRlY29kZXMgYSBwYWNrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25kZWNvZGVkID0gZnVuY3Rpb24ocGFja2V0KSB7XG4gIHRoaXMuZW1pdCgncGFja2V0JywgcGFja2V0KTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gc29ja2V0IGVycm9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9uZXJyb3IgPSBmdW5jdGlvbihlcnIpe1xuICBkZWJ1ZygnZXJyb3InLCBlcnIpO1xuICB0aGlzLmVtaXRBbGwoJ2Vycm9yJywgZXJyKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBzb2NrZXQgZm9yIHRoZSBnaXZlbiBgbnNwYC5cbiAqXG4gKiBAcmV0dXJuIHtTb2NrZXR9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnNvY2tldCA9IGZ1bmN0aW9uKG5zcCl7XG4gIHZhciBzb2NrZXQgPSB0aGlzLm5zcHNbbnNwXTtcbiAgaWYgKCFzb2NrZXQpIHtcbiAgICBzb2NrZXQgPSBuZXcgU29ja2V0KHRoaXMsIG5zcCk7XG4gICAgdGhpcy5uc3BzW25zcF0gPSBzb2NrZXQ7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNvY2tldC5vbignY29ubmVjdGluZycsIG9uQ29ubmVjdGluZyk7XG4gICAgc29ja2V0Lm9uKCdjb25uZWN0JywgZnVuY3Rpb24oKXtcbiAgICAgIHNvY2tldC5pZCA9IHNlbGYuZW5naW5lLmlkO1xuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMuYXV0b0Nvbm5lY3QpIHtcbiAgICAgIC8vIG1hbnVhbGx5IGNhbGwgaGVyZSBzaW5jZSBjb25uZWN0aW5nIGV2bmV0IGlzIGZpcmVkIGJlZm9yZSBsaXN0ZW5pbmdcbiAgICAgIG9uQ29ubmVjdGluZygpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQ29ubmVjdGluZygpIHtcbiAgICBpZiAoIX5pbmRleE9mKHNlbGYuY29ubmVjdGluZywgc29ja2V0KSkge1xuICAgICAgc2VsZi5jb25uZWN0aW5nLnB1c2goc29ja2V0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc29ja2V0O1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBhIHNvY2tldCBjbG9zZS5cbiAqXG4gKiBAcGFyYW0ge1NvY2tldH0gc29ja2V0XG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKHNvY2tldCl7XG4gIHZhciBpbmRleCA9IGluZGV4T2YodGhpcy5jb25uZWN0aW5nLCBzb2NrZXQpO1xuICBpZiAofmluZGV4KSB0aGlzLmNvbm5lY3Rpbmcuc3BsaWNlKGluZGV4LCAxKTtcbiAgaWYgKHRoaXMuY29ubmVjdGluZy5sZW5ndGgpIHJldHVybjtcblxuICB0aGlzLmNsb3NlKCk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5wYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQpe1xuICBkZWJ1Zygnd3JpdGluZyBwYWNrZXQgJWonLCBwYWNrZXQpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKCFzZWxmLmVuY29kaW5nKSB7XG4gICAgLy8gZW5jb2RlLCB0aGVuIHdyaXRlIHRvIGVuZ2luZSB3aXRoIHJlc3VsdFxuICAgIHNlbGYuZW5jb2RpbmcgPSB0cnVlO1xuICAgIHRoaXMuZW5jb2Rlci5lbmNvZGUocGFja2V0LCBmdW5jdGlvbihlbmNvZGVkUGFja2V0cykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmNvZGVkUGFja2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzZWxmLmVuZ2luZS53cml0ZShlbmNvZGVkUGFja2V0c1tpXSwgcGFja2V0Lm9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgc2VsZi5lbmNvZGluZyA9IGZhbHNlO1xuICAgICAgc2VsZi5wcm9jZXNzUGFja2V0UXVldWUoKTtcbiAgICB9KTtcbiAgfSBlbHNlIHsgLy8gYWRkIHBhY2tldCB0byB0aGUgcXVldWVcbiAgICBzZWxmLnBhY2tldEJ1ZmZlci5wdXNoKHBhY2tldCk7XG4gIH1cbn07XG5cbi8qKlxuICogSWYgcGFja2V0IGJ1ZmZlciBpcyBub24tZW1wdHksIGJlZ2lucyBlbmNvZGluZyB0aGVcbiAqIG5leHQgcGFja2V0IGluIGxpbmUuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucHJvY2Vzc1BhY2tldFF1ZXVlID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnBhY2tldEJ1ZmZlci5sZW5ndGggPiAwICYmICF0aGlzLmVuY29kaW5nKSB7XG4gICAgdmFyIHBhY2sgPSB0aGlzLnBhY2tldEJ1ZmZlci5zaGlmdCgpO1xuICAgIHRoaXMucGFja2V0KHBhY2spO1xuICB9XG59O1xuXG4vKipcbiAqIENsZWFuIHVwIHRyYW5zcG9ydCBzdWJzY3JpcHRpb25zIGFuZCBwYWNrZXQgYnVmZmVyLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLmNsZWFudXAgPSBmdW5jdGlvbigpe1xuICBkZWJ1ZygnY2xlYW51cCcpO1xuXG4gIHZhciBzdWI7XG4gIHdoaWxlIChzdWIgPSB0aGlzLnN1YnMuc2hpZnQoKSkgc3ViLmRlc3Ryb3koKTtcblxuICB0aGlzLnBhY2tldEJ1ZmZlciA9IFtdO1xuICB0aGlzLmVuY29kaW5nID0gZmFsc2U7XG4gIHRoaXMubGFzdFBpbmcgPSBudWxsO1xuXG4gIHRoaXMuZGVjb2Rlci5kZXN0cm95KCk7XG59O1xuXG4vKipcbiAqIENsb3NlIHRoZSBjdXJyZW50IHNvY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5jbG9zZSA9XG5NYW5hZ2VyLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24oKXtcbiAgZGVidWcoJ2Rpc2Nvbm5lY3QnKTtcbiAgdGhpcy5za2lwUmVjb25uZWN0ID0gdHJ1ZTtcbiAgdGhpcy5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgaWYgKCdvcGVuaW5nJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAvLyBgb25jbG9zZWAgd2lsbCBub3QgZmlyZSBiZWNhdXNlXG4gICAgLy8gYW4gb3BlbiBldmVudCBuZXZlciBoYXBwZW5lZFxuICAgIHRoaXMuY2xlYW51cCgpO1xuICB9XG4gIHRoaXMuYmFja29mZi5yZXNldCgpO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgaWYgKHRoaXMuZW5naW5lKSB0aGlzLmVuZ2luZS5jbG9zZSgpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBlbmdpbmUgY2xvc2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25jbG9zZSA9IGZ1bmN0aW9uKHJlYXNvbil7XG4gIGRlYnVnKCdvbmNsb3NlJyk7XG5cbiAgdGhpcy5jbGVhbnVwKCk7XG4gIHRoaXMuYmFja29mZi5yZXNldCgpO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgdGhpcy5lbWl0KCdjbG9zZScsIHJlYXNvbik7XG5cbiAgaWYgKHRoaXMuX3JlY29ubmVjdGlvbiAmJiAhdGhpcy5za2lwUmVjb25uZWN0KSB7XG4gICAgdGhpcy5yZWNvbm5lY3QoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBBdHRlbXB0IGEgcmVjb25uZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdCA9IGZ1bmN0aW9uKCl7XG4gIGlmICh0aGlzLnJlY29ubmVjdGluZyB8fCB0aGlzLnNraXBSZWNvbm5lY3QpIHJldHVybiB0aGlzO1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAodGhpcy5iYWNrb2ZmLmF0dGVtcHRzID49IHRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzKSB7XG4gICAgZGVidWcoJ3JlY29ubmVjdCBmYWlsZWQnKTtcbiAgICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgICB0aGlzLmVtaXRBbGwoJ3JlY29ubmVjdF9mYWlsZWQnKTtcbiAgICB0aGlzLnJlY29ubmVjdGluZyA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHZhciBkZWxheSA9IHRoaXMuYmFja29mZi5kdXJhdGlvbigpO1xuICAgIGRlYnVnKCd3aWxsIHdhaXQgJWRtcyBiZWZvcmUgcmVjb25uZWN0IGF0dGVtcHQnLCBkZWxheSk7XG5cbiAgICB0aGlzLnJlY29ubmVjdGluZyA9IHRydWU7XG4gICAgdmFyIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgaWYgKHNlbGYuc2tpcFJlY29ubmVjdCkgcmV0dXJuO1xuXG4gICAgICBkZWJ1ZygnYXR0ZW1wdGluZyByZWNvbm5lY3QnKTtcbiAgICAgIHNlbGYuZW1pdEFsbCgncmVjb25uZWN0X2F0dGVtcHQnLCBzZWxmLmJhY2tvZmYuYXR0ZW1wdHMpO1xuICAgICAgc2VsZi5lbWl0QWxsKCdyZWNvbm5lY3RpbmcnLCBzZWxmLmJhY2tvZmYuYXR0ZW1wdHMpO1xuXG4gICAgICAvLyBjaGVjayBhZ2FpbiBmb3IgdGhlIGNhc2Ugc29ja2V0IGNsb3NlZCBpbiBhYm92ZSBldmVudHNcbiAgICAgIGlmIChzZWxmLnNraXBSZWNvbm5lY3QpIHJldHVybjtcblxuICAgICAgc2VsZi5vcGVuKGZ1bmN0aW9uKGVycil7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBkZWJ1ZygncmVjb25uZWN0IGF0dGVtcHQgZXJyb3InKTtcbiAgICAgICAgICBzZWxmLnJlY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICAgIHNlbGYucmVjb25uZWN0KCk7XG4gICAgICAgICAgc2VsZi5lbWl0QWxsKCdyZWNvbm5lY3RfZXJyb3InLCBlcnIuZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVidWcoJ3JlY29ubmVjdCBzdWNjZXNzJyk7XG4gICAgICAgICAgc2VsZi5vbnJlY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LCBkZWxheSk7XG5cbiAgICB0aGlzLnN1YnMucHVzaCh7XG4gICAgICBkZXN0cm95OiBmdW5jdGlvbigpe1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHN1Y2Nlc3NmdWwgcmVjb25uZWN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9ucmVjb25uZWN0ID0gZnVuY3Rpb24oKXtcbiAgdmFyIGF0dGVtcHQgPSB0aGlzLmJhY2tvZmYuYXR0ZW1wdHM7XG4gIHRoaXMucmVjb25uZWN0aW5nID0gZmFsc2U7XG4gIHRoaXMuYmFja29mZi5yZXNldCgpO1xuICB0aGlzLnVwZGF0ZVNvY2tldElkcygpO1xuICB0aGlzLmVtaXRBbGwoJ3JlY29ubmVjdCcsIGF0dGVtcHQpO1xufTtcblxufSx7XCIuL29uXCI6MyxcIi4vc29ja2V0XCI6NCxcImJhY2tvMlwiOjgsXCJjb21wb25lbnQtYmluZFwiOjExLFwiY29tcG9uZW50LWVtaXR0ZXJcIjoxMixcImRlYnVnXCI6MTQsXCJlbmdpbmUuaW8tY2xpZW50XCI6MTYsXCJpbmRleG9mXCI6MzIsXCJzb2NrZXQuaW8tcGFyc2VyXCI6NDB9XSwzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IG9uO1xuXG4vKipcbiAqIEhlbHBlciBmb3Igc3Vic2NyaXB0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxFdmVudEVtaXR0ZXJ9IG9iaiB3aXRoIGBFbWl0dGVyYCBtaXhpbiBvciBgRXZlbnRFbWl0dGVyYFxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIG9uKG9iaiwgZXYsIGZuKSB7XG4gIG9iai5vbihldiwgZm4pO1xuICByZXR1cm4ge1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCl7XG4gICAgICBvYmoucmVtb3ZlTGlzdGVuZXIoZXYsIGZuKTtcbiAgICB9XG4gIH07XG59XG5cbn0se31dLDQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHBhcnNlciA9IF9kZXJlcV8oJ3NvY2tldC5pby1wYXJzZXInKTtcbnZhciBFbWl0dGVyID0gX2RlcmVxXygnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciB0b0FycmF5ID0gX2RlcmVxXygndG8tYXJyYXknKTtcbnZhciBvbiA9IF9kZXJlcV8oJy4vb24nKTtcbnZhciBiaW5kID0gX2RlcmVxXygnY29tcG9uZW50LWJpbmQnKTtcbnZhciBkZWJ1ZyA9IF9kZXJlcV8oJ2RlYnVnJykoJ3NvY2tldC5pby1jbGllbnQ6c29ja2V0Jyk7XG52YXIgaGFzQmluID0gX2RlcmVxXygnaGFzLWJpbmFyeScpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IFNvY2tldDtcblxuLyoqXG4gKiBJbnRlcm5hbCBldmVudHMgKGJsYWNrbGlzdGVkKS5cbiAqIFRoZXNlIGV2ZW50cyBjYW4ndCBiZSBlbWl0dGVkIGJ5IHRoZSB1c2VyLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbnZhciBldmVudHMgPSB7XG4gIGNvbm5lY3Q6IDEsXG4gIGNvbm5lY3RfZXJyb3I6IDEsXG4gIGNvbm5lY3RfdGltZW91dDogMSxcbiAgY29ubmVjdGluZzogMSxcbiAgZGlzY29ubmVjdDogMSxcbiAgZXJyb3I6IDEsXG4gIHJlY29ubmVjdDogMSxcbiAgcmVjb25uZWN0X2F0dGVtcHQ6IDEsXG4gIHJlY29ubmVjdF9mYWlsZWQ6IDEsXG4gIHJlY29ubmVjdF9lcnJvcjogMSxcbiAgcmVjb25uZWN0aW5nOiAxLFxuICBwaW5nOiAxLFxuICBwb25nOiAxXG59O1xuXG4vKipcbiAqIFNob3J0Y3V0IHRvIGBFbWl0dGVyI2VtaXRgLlxuICovXG5cbnZhciBlbWl0ID0gRW1pdHRlci5wcm90b3R5cGUuZW1pdDtcblxuLyoqXG4gKiBgU29ja2V0YCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFNvY2tldChpbywgbnNwKXtcbiAgdGhpcy5pbyA9IGlvO1xuICB0aGlzLm5zcCA9IG5zcDtcbiAgdGhpcy5qc29uID0gdGhpczsgLy8gY29tcGF0XG4gIHRoaXMuaWRzID0gMDtcbiAgdGhpcy5hY2tzID0ge307XG4gIHRoaXMucmVjZWl2ZUJ1ZmZlciA9IFtdO1xuICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcbiAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgdGhpcy5kaXNjb25uZWN0ZWQgPSB0cnVlO1xuICBpZiAodGhpcy5pby5hdXRvQ29ubmVjdCkgdGhpcy5vcGVuKCk7XG59XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKFNvY2tldC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFN1YnNjcmliZSB0byBvcGVuLCBjbG9zZSBhbmQgcGFja2V0IGV2ZW50c1xuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuc3ViRXZlbnRzID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnN1YnMpIHJldHVybjtcblxuICB2YXIgaW8gPSB0aGlzLmlvO1xuICB0aGlzLnN1YnMgPSBbXG4gICAgb24oaW8sICdvcGVuJywgYmluZCh0aGlzLCAnb25vcGVuJykpLFxuICAgIG9uKGlvLCAncGFja2V0JywgYmluZCh0aGlzLCAnb25wYWNrZXQnKSksXG4gICAgb24oaW8sICdjbG9zZScsIGJpbmQodGhpcywgJ29uY2xvc2UnKSlcbiAgXTtcbn07XG5cbi8qKlxuICogXCJPcGVuc1wiIHRoZSBzb2NrZXQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9wZW4gPVxuU29ja2V0LnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24oKXtcbiAgaWYgKHRoaXMuY29ubmVjdGVkKSByZXR1cm4gdGhpcztcblxuICB0aGlzLnN1YkV2ZW50cygpO1xuICB0aGlzLmlvLm9wZW4oKTsgLy8gZW5zdXJlIG9wZW5cbiAgaWYgKCdvcGVuJyA9PSB0aGlzLmlvLnJlYWR5U3RhdGUpIHRoaXMub25vcGVuKCk7XG4gIHRoaXMuZW1pdCgnY29ubmVjdGluZycpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2VuZHMgYSBgbWVzc2FnZWAgZXZlbnQuXG4gKlxuICogQHJldHVybiB7U29ja2V0fSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKCl7XG4gIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMpO1xuICBhcmdzLnVuc2hpZnQoJ21lc3NhZ2UnKTtcbiAgdGhpcy5lbWl0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogT3ZlcnJpZGUgYGVtaXRgLlxuICogSWYgdGhlIGV2ZW50IGlzIGluIGBldmVudHNgLCBpdCdzIGVtaXR0ZWQgbm9ybWFsbHkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IG5hbWVcbiAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldil7XG4gIGlmIChldmVudHMuaGFzT3duUHJvcGVydHkoZXYpKSB7XG4gICAgZW1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cyk7XG4gIHZhciBwYXJzZXJUeXBlID0gcGFyc2VyLkVWRU5UOyAvLyBkZWZhdWx0XG4gIGlmIChoYXNCaW4oYXJncykpIHsgcGFyc2VyVHlwZSA9IHBhcnNlci5CSU5BUllfRVZFTlQ7IH0gLy8gYmluYXJ5XG4gIHZhciBwYWNrZXQgPSB7IHR5cGU6IHBhcnNlclR5cGUsIGRhdGE6IGFyZ3MgfTtcblxuICBwYWNrZXQub3B0aW9ucyA9IHt9O1xuICBwYWNrZXQub3B0aW9ucy5jb21wcmVzcyA9ICF0aGlzLmZsYWdzIHx8IGZhbHNlICE9PSB0aGlzLmZsYWdzLmNvbXByZXNzO1xuXG4gIC8vIGV2ZW50IGFjayBjYWxsYmFja1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdKSB7XG4gICAgZGVidWcoJ2VtaXR0aW5nIHBhY2tldCB3aXRoIGFjayBpZCAlZCcsIHRoaXMuaWRzKTtcbiAgICB0aGlzLmFja3NbdGhpcy5pZHNdID0gYXJncy5wb3AoKTtcbiAgICBwYWNrZXQuaWQgPSB0aGlzLmlkcysrO1xuICB9XG5cbiAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgdGhpcy5wYWNrZXQocGFja2V0KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnNlbmRCdWZmZXIucHVzaChwYWNrZXQpO1xuICB9XG5cbiAgZGVsZXRlIHRoaXMuZmxhZ3M7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNlbmRzIGEgcGFja2V0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUucGFja2V0ID0gZnVuY3Rpb24ocGFja2V0KXtcbiAgcGFja2V0Lm5zcCA9IHRoaXMubnNwO1xuICB0aGlzLmlvLnBhY2tldChwYWNrZXQpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBlbmdpbmUgYG9wZW5gLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25vcGVuID0gZnVuY3Rpb24oKXtcbiAgZGVidWcoJ3RyYW5zcG9ydCBpcyBvcGVuIC0gY29ubmVjdGluZycpO1xuXG4gIC8vIHdyaXRlIGNvbm5lY3QgcGFja2V0IGlmIG5lY2Vzc2FyeVxuICBpZiAoJy8nICE9IHRoaXMubnNwKSB7XG4gICAgdGhpcy5wYWNrZXQoeyB0eXBlOiBwYXJzZXIuQ09OTkVDVCB9KTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBlbmdpbmUgYGNsb3NlYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVhc29uXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uY2xvc2UgPSBmdW5jdGlvbihyZWFzb24pe1xuICBkZWJ1ZygnY2xvc2UgKCVzKScsIHJlYXNvbik7XG4gIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gIHRoaXMuZGlzY29ubmVjdGVkID0gdHJ1ZTtcbiAgZGVsZXRlIHRoaXMuaWQ7XG4gIHRoaXMuZW1pdCgnZGlzY29ubmVjdCcsIHJlYXNvbik7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aXRoIHNvY2tldCBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbnBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCl7XG4gIGlmIChwYWNrZXQubnNwICE9IHRoaXMubnNwKSByZXR1cm47XG5cbiAgc3dpdGNoIChwYWNrZXQudHlwZSkge1xuICAgIGNhc2UgcGFyc2VyLkNPTk5FQ1Q6XG4gICAgICB0aGlzLm9uY29ubmVjdCgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5FVkVOVDpcbiAgICAgIHRoaXMub25ldmVudChwYWNrZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5CSU5BUllfRVZFTlQ6XG4gICAgICB0aGlzLm9uZXZlbnQocGFja2V0KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuQUNLOlxuICAgICAgdGhpcy5vbmFjayhwYWNrZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5CSU5BUllfQUNLOlxuICAgICAgdGhpcy5vbmFjayhwYWNrZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5ESVNDT05ORUNUOlxuICAgICAgdGhpcy5vbmRpc2Nvbm5lY3QoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuRVJST1I6XG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgcGFja2V0LmRhdGEpO1xuICAgICAgYnJlYWs7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gYSBzZXJ2ZXIgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmV2ZW50ID0gZnVuY3Rpb24ocGFja2V0KXtcbiAgdmFyIGFyZ3MgPSBwYWNrZXQuZGF0YSB8fCBbXTtcbiAgZGVidWcoJ2VtaXR0aW5nIGV2ZW50ICVqJywgYXJncyk7XG5cbiAgaWYgKG51bGwgIT0gcGFja2V0LmlkKSB7XG4gICAgZGVidWcoJ2F0dGFjaGluZyBhY2sgY2FsbGJhY2sgdG8gZXZlbnQnKTtcbiAgICBhcmdzLnB1c2godGhpcy5hY2socGFja2V0LmlkKSk7XG4gIH1cblxuICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICBlbWl0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucmVjZWl2ZUJ1ZmZlci5wdXNoKGFyZ3MpO1xuICB9XG59O1xuXG4vKipcbiAqIFByb2R1Y2VzIGFuIGFjayBjYWxsYmFjayB0byBlbWl0IHdpdGggYW4gZXZlbnQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5hY2sgPSBmdW5jdGlvbihpZCl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHNlbnQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgLy8gcHJldmVudCBkb3VibGUgY2FsbGJhY2tzXG4gICAgaWYgKHNlbnQpIHJldHVybjtcbiAgICBzZW50ID0gdHJ1ZTtcbiAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzKTtcbiAgICBkZWJ1Zygnc2VuZGluZyBhY2sgJWonLCBhcmdzKTtcblxuICAgIHZhciB0eXBlID0gaGFzQmluKGFyZ3MpID8gcGFyc2VyLkJJTkFSWV9BQ0sgOiBwYXJzZXIuQUNLO1xuICAgIHNlbGYucGFja2V0KHtcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBpZDogaWQsXG4gICAgICBkYXRhOiBhcmdzXG4gICAgfSk7XG4gIH07XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGEgc2VydmVyIGFja25vd2xlZ2VtZW50LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25hY2sgPSBmdW5jdGlvbihwYWNrZXQpe1xuICB2YXIgYWNrID0gdGhpcy5hY2tzW3BhY2tldC5pZF07XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBhY2spIHtcbiAgICBkZWJ1ZygnY2FsbGluZyBhY2sgJXMgd2l0aCAlaicsIHBhY2tldC5pZCwgcGFja2V0LmRhdGEpO1xuICAgIGFjay5hcHBseSh0aGlzLCBwYWNrZXQuZGF0YSk7XG4gICAgZGVsZXRlIHRoaXMuYWNrc1twYWNrZXQuaWRdO1xuICB9IGVsc2Uge1xuICAgIGRlYnVnKCdiYWQgYWNrICVzJywgcGFja2V0LmlkKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzZXJ2ZXIgY29ubmVjdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uY29ubmVjdCA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuY29ubmVjdGVkID0gdHJ1ZTtcbiAgdGhpcy5kaXNjb25uZWN0ZWQgPSBmYWxzZTtcbiAgdGhpcy5lbWl0KCdjb25uZWN0Jyk7XG4gIHRoaXMuZW1pdEJ1ZmZlcmVkKCk7XG59O1xuXG4vKipcbiAqIEVtaXQgYnVmZmVyZWQgZXZlbnRzIChyZWNlaXZlZCBhbmQgZW1pdHRlZCkuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5lbWl0QnVmZmVyZWQgPSBmdW5jdGlvbigpe1xuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IHRoaXMucmVjZWl2ZUJ1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgIGVtaXQuYXBwbHkodGhpcywgdGhpcy5yZWNlaXZlQnVmZmVyW2ldKTtcbiAgfVxuICB0aGlzLnJlY2VpdmVCdWZmZXIgPSBbXTtcblxuICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5zZW5kQnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5wYWNrZXQodGhpcy5zZW5kQnVmZmVyW2ldKTtcbiAgfVxuICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gc2VydmVyIGRpc2Nvbm5lY3QuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmRpc2Nvbm5lY3QgPSBmdW5jdGlvbigpe1xuICBkZWJ1Zygnc2VydmVyIGRpc2Nvbm5lY3QgKCVzKScsIHRoaXMubnNwKTtcbiAgdGhpcy5kZXN0cm95KCk7XG4gIHRoaXMub25jbG9zZSgnaW8gc2VydmVyIGRpc2Nvbm5lY3QnKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZm9yY2VkIGNsaWVudC9zZXJ2ZXIgc2lkZSBkaXNjb25uZWN0aW9ucyxcbiAqIHRoaXMgbWV0aG9kIGVuc3VyZXMgdGhlIG1hbmFnZXIgc3RvcHMgdHJhY2tpbmcgdXMgYW5kXG4gKiB0aGF0IHJlY29ubmVjdGlvbnMgZG9uJ3QgZ2V0IHRyaWdnZXJlZCBmb3IgdGhpcy5cbiAqXG4gKiBAYXBpIHByaXZhdGUuXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKXtcbiAgaWYgKHRoaXMuc3Vicykge1xuICAgIC8vIGNsZWFuIHN1YnNjcmlwdGlvbnMgdG8gYXZvaWQgcmVjb25uZWN0aW9uc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zdWJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLnN1YnNbaV0uZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLnN1YnMgPSBudWxsO1xuICB9XG5cbiAgdGhpcy5pby5kZXN0cm95KHRoaXMpO1xufTtcblxuLyoqXG4gKiBEaXNjb25uZWN0cyB0aGUgc29ja2V0IG1hbnVhbGx5LlxuICpcbiAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmNsb3NlID1cblNvY2tldC5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uKCl7XG4gIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgIGRlYnVnKCdwZXJmb3JtaW5nIGRpc2Nvbm5lY3QgKCVzKScsIHRoaXMubnNwKTtcbiAgICB0aGlzLnBhY2tldCh7IHR5cGU6IHBhcnNlci5ESVNDT05ORUNUIH0pO1xuICB9XG5cbiAgLy8gcmVtb3ZlIHNvY2tldCBmcm9tIHBvb2xcbiAgdGhpcy5kZXN0cm95KCk7XG5cbiAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgLy8gZmlyZSBldmVudHNcbiAgICB0aGlzLm9uY2xvc2UoJ2lvIGNsaWVudCBkaXNjb25uZWN0Jyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGNvbXByZXNzIGZsYWcuXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBpZiBgdHJ1ZWAsIGNvbXByZXNzZXMgdGhlIHNlbmRpbmcgZGF0YVxuICogQHJldHVybiB7U29ja2V0fSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUuY29tcHJlc3MgPSBmdW5jdGlvbihjb21wcmVzcyl7XG4gIHRoaXMuZmxhZ3MgPSB0aGlzLmZsYWdzIHx8IHt9O1xuICB0aGlzLmZsYWdzLmNvbXByZXNzID0gY29tcHJlc3M7XG4gIHJldHVybiB0aGlzO1xufTtcblxufSx7XCIuL29uXCI6MyxcImNvbXBvbmVudC1iaW5kXCI6MTEsXCJjb21wb25lbnQtZW1pdHRlclwiOjEyLFwiZGVidWdcIjoxNCxcImhhcy1iaW5hcnlcIjozMCxcInNvY2tldC5pby1wYXJzZXJcIjo0MCxcInRvLWFycmF5XCI6NDN9XSw1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcblxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBwYXJzZXVyaSA9IF9kZXJlcV8oJ3BhcnNldXJpJyk7XG52YXIgZGVidWcgPSBfZGVyZXFfKCdkZWJ1ZycpKCdzb2NrZXQuaW8tY2xpZW50OnVybCcpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gdXJsO1xuXG4vKipcbiAqIFVSTCBwYXJzZXIuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtPYmplY3R9IEFuIG9iamVjdCBtZWFudCB0byBtaW1pYyB3aW5kb3cubG9jYXRpb24uXG4gKiAgICAgICAgICAgICAgICAgRGVmYXVsdHMgdG8gd2luZG93LmxvY2F0aW9uLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiB1cmwodXJpLCBsb2Mpe1xuICB2YXIgb2JqID0gdXJpO1xuXG4gIC8vIGRlZmF1bHQgdG8gd2luZG93LmxvY2F0aW9uXG4gIHZhciBsb2MgPSBsb2MgfHwgZ2xvYmFsLmxvY2F0aW9uO1xuICBpZiAobnVsbCA9PSB1cmkpIHVyaSA9IGxvYy5wcm90b2NvbCArICcvLycgKyBsb2MuaG9zdDtcblxuICAvLyByZWxhdGl2ZSBwYXRoIHN1cHBvcnRcbiAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiB1cmkpIHtcbiAgICBpZiAoJy8nID09IHVyaS5jaGFyQXQoMCkpIHtcbiAgICAgIGlmICgnLycgPT0gdXJpLmNoYXJBdCgxKSkge1xuICAgICAgICB1cmkgPSBsb2MucHJvdG9jb2wgKyB1cmk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cmkgPSBsb2MuaG9zdCArIHVyaTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIS9eKGh0dHBzP3x3c3M/KTpcXC9cXC8vLnRlc3QodXJpKSkge1xuICAgICAgZGVidWcoJ3Byb3RvY29sLWxlc3MgdXJsICVzJywgdXJpKTtcbiAgICAgIGlmICgndW5kZWZpbmVkJyAhPSB0eXBlb2YgbG9jKSB7XG4gICAgICAgIHVyaSA9IGxvYy5wcm90b2NvbCArICcvLycgKyB1cmk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cmkgPSAnaHR0cHM6Ly8nICsgdXJpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHBhcnNlXG4gICAgZGVidWcoJ3BhcnNlICVzJywgdXJpKTtcbiAgICBvYmogPSBwYXJzZXVyaSh1cmkpO1xuICB9XG5cbiAgLy8gbWFrZSBzdXJlIHdlIHRyZWF0IGBsb2NhbGhvc3Q6ODBgIGFuZCBgbG9jYWxob3N0YCBlcXVhbGx5XG4gIGlmICghb2JqLnBvcnQpIHtcbiAgICBpZiAoL14oaHR0cHx3cykkLy50ZXN0KG9iai5wcm90b2NvbCkpIHtcbiAgICAgIG9iai5wb3J0ID0gJzgwJztcbiAgICB9XG4gICAgZWxzZSBpZiAoL14oaHR0cHx3cylzJC8udGVzdChvYmoucHJvdG9jb2wpKSB7XG4gICAgICBvYmoucG9ydCA9ICc0NDMnO1xuICAgIH1cbiAgfVxuXG4gIG9iai5wYXRoID0gb2JqLnBhdGggfHwgJy8nO1xuXG4gIHZhciBpcHY2ID0gb2JqLmhvc3QuaW5kZXhPZignOicpICE9PSAtMTtcbiAgdmFyIGhvc3QgPSBpcHY2ID8gJ1snICsgb2JqLmhvc3QgKyAnXScgOiBvYmouaG9zdDtcblxuICAvLyBkZWZpbmUgdW5pcXVlIGlkXG4gIG9iai5pZCA9IG9iai5wcm90b2NvbCArICc6Ly8nICsgaG9zdCArICc6JyArIG9iai5wb3J0O1xuICAvLyBkZWZpbmUgaHJlZlxuICBvYmouaHJlZiA9IG9iai5wcm90b2NvbCArICc6Ly8nICsgaG9zdCArIChsb2MgJiYgbG9jLnBvcnQgPT0gb2JqLnBvcnQgPyAnJyA6ICgnOicgKyBvYmoucG9ydCkpO1xuXG4gIHJldHVybiBvYmo7XG59XG5cbn0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHt9KVxufSx7XCJkZWJ1Z1wiOjE0LFwicGFyc2V1cmlcIjozOH1dLDY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBhZnRlclxuXG5mdW5jdGlvbiBhZnRlcihjb3VudCwgY2FsbGJhY2ssIGVycl9jYikge1xuICAgIHZhciBiYWlsID0gZmFsc2VcbiAgICBlcnJfY2IgPSBlcnJfY2IgfHwgbm9vcFxuICAgIHByb3h5LmNvdW50ID0gY291bnRcblxuICAgIHJldHVybiAoY291bnQgPT09IDApID8gY2FsbGJhY2soKSA6IHByb3h5XG5cbiAgICBmdW5jdGlvbiBwcm94eShlcnIsIHJlc3VsdCkge1xuICAgICAgICBpZiAocHJveHkuY291bnQgPD0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhZnRlciBjYWxsZWQgdG9vIG1hbnkgdGltZXMnKVxuICAgICAgICB9XG4gICAgICAgIC0tcHJveHkuY291bnRcblxuICAgICAgICAvLyBhZnRlciBmaXJzdCBlcnJvciwgcmVzdCBhcmUgcGFzc2VkIHRvIGVycl9jYlxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBiYWlsID0gdHJ1ZVxuICAgICAgICAgICAgY2FsbGJhY2soZXJyKVxuICAgICAgICAgICAgLy8gZnV0dXJlIGVycm9yIGNhbGxiYWNrcyB3aWxsIGdvIHRvIGVycm9yIGhhbmRsZXJcbiAgICAgICAgICAgIGNhbGxiYWNrID0gZXJyX2NiXG4gICAgICAgIH0gZWxzZSBpZiAocHJveHkuY291bnQgPT09IDAgJiYgIWJhaWwpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdClcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbn0se31dLDc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBBbiBhYnN0cmFjdGlvbiBmb3Igc2xpY2luZyBhbiBhcnJheWJ1ZmZlciBldmVuIHdoZW5cbiAqIEFycmF5QnVmZmVyLnByb3RvdHlwZS5zbGljZSBpcyBub3Qgc3VwcG9ydGVkXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFycmF5YnVmZmVyLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGFycmF5YnVmZmVyLmJ5dGVMZW5ndGg7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgZW5kID0gZW5kIHx8IGJ5dGVzO1xuXG4gIGlmIChhcnJheWJ1ZmZlci5zbGljZSkgeyByZXR1cm4gYXJyYXlidWZmZXIuc2xpY2Uoc3RhcnQsIGVuZCk7IH1cblxuICBpZiAoc3RhcnQgPCAwKSB7IHN0YXJ0ICs9IGJ5dGVzOyB9XG4gIGlmIChlbmQgPCAwKSB7IGVuZCArPSBieXRlczsgfVxuICBpZiAoZW5kID4gYnl0ZXMpIHsgZW5kID0gYnl0ZXM7IH1cblxuICBpZiAoc3RhcnQgPj0gYnl0ZXMgfHwgc3RhcnQgPj0gZW5kIHx8IGJ5dGVzID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgfVxuXG4gIHZhciBhYnYgPSBuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlcik7XG4gIHZhciByZXN1bHQgPSBuZXcgVWludDhBcnJheShlbmQgLSBzdGFydCk7XG4gIGZvciAodmFyIGkgPSBzdGFydCwgaWkgPSAwOyBpIDwgZW5kOyBpKyssIGlpKyspIHtcbiAgICByZXN1bHRbaWldID0gYWJ2W2ldO1xuICB9XG4gIHJldHVybiByZXN1bHQuYnVmZmVyO1xufTtcblxufSx7fV0sODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cbi8qKlxuICogRXhwb3NlIGBCYWNrb2ZmYC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tvZmY7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBiYWNrb2ZmIHRpbWVyIHdpdGggYG9wdHNgLlxuICpcbiAqIC0gYG1pbmAgaW5pdGlhbCB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyBbMTAwXVxuICogLSBgbWF4YCBtYXggdGltZW91dCBbMTAwMDBdXG4gKiAtIGBqaXR0ZXJgIFswXVxuICogLSBgZmFjdG9yYCBbMl1cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBCYWNrb2ZmKG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIHRoaXMubXMgPSBvcHRzLm1pbiB8fCAxMDA7XG4gIHRoaXMubWF4ID0gb3B0cy5tYXggfHwgMTAwMDA7XG4gIHRoaXMuZmFjdG9yID0gb3B0cy5mYWN0b3IgfHwgMjtcbiAgdGhpcy5qaXR0ZXIgPSBvcHRzLmppdHRlciA+IDAgJiYgb3B0cy5qaXR0ZXIgPD0gMSA/IG9wdHMuaml0dGVyIDogMDtcbiAgdGhpcy5hdHRlbXB0cyA9IDA7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBiYWNrb2ZmIGR1cmF0aW9uLlxuICpcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUuZHVyYXRpb24gPSBmdW5jdGlvbigpe1xuICB2YXIgbXMgPSB0aGlzLm1zICogTWF0aC5wb3codGhpcy5mYWN0b3IsIHRoaXMuYXR0ZW1wdHMrKyk7XG4gIGlmICh0aGlzLmppdHRlcikge1xuICAgIHZhciByYW5kID0gIE1hdGgucmFuZG9tKCk7XG4gICAgdmFyIGRldmlhdGlvbiA9IE1hdGguZmxvb3IocmFuZCAqIHRoaXMuaml0dGVyICogbXMpO1xuICAgIG1zID0gKE1hdGguZmxvb3IocmFuZCAqIDEwKSAmIDEpID09IDAgID8gbXMgLSBkZXZpYXRpb24gOiBtcyArIGRldmlhdGlvbjtcbiAgfVxuICByZXR1cm4gTWF0aC5taW4obXMsIHRoaXMubWF4KSB8IDA7XG59O1xuXG4vKipcbiAqIFJlc2V0IHRoZSBudW1iZXIgb2YgYXR0ZW1wdHMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5CYWNrb2ZmLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuYXR0ZW1wdHMgPSAwO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG1pbmltdW0gZHVyYXRpb25cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLnNldE1pbiA9IGZ1bmN0aW9uKG1pbil7XG4gIHRoaXMubXMgPSBtaW47XG59O1xuXG4vKipcbiAqIFNldCB0aGUgbWF4aW11bSBkdXJhdGlvblxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUuc2V0TWF4ID0gZnVuY3Rpb24obWF4KXtcbiAgdGhpcy5tYXggPSBtYXg7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgaml0dGVyXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5CYWNrb2ZmLnByb3RvdHlwZS5zZXRKaXR0ZXIgPSBmdW5jdGlvbihqaXR0ZXIpe1xuICB0aGlzLmppdHRlciA9IGppdHRlcjtcbn07XG5cblxufSx7fV0sOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKlxuICogYmFzZTY0LWFycmF5YnVmZmVyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbmlrbGFzdmgvYmFzZTY0LWFycmF5YnVmZmVyXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEyIE5pa2xhcyB2b24gSGVydHplblxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICovXG4oZnVuY3Rpb24oKXtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIGNoYXJzID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCI7XG5cbiAgLy8gVXNlIGEgbG9va3VwIHRhYmxlIHRvIGZpbmQgdGhlIGluZGV4LlxuICB2YXIgbG9va3VwID0gbmV3IFVpbnQ4QXJyYXkoMjU2KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkrKykge1xuICAgIGxvb2t1cFtjaGFycy5jaGFyQ29kZUF0KGkpXSA9IGk7XG4gIH1cblxuICBleHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uKGFycmF5YnVmZmVyKSB7XG4gICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpLFxuICAgIGksIGxlbiA9IGJ5dGVzLmxlbmd0aCwgYmFzZTY0ID0gXCJcIjtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrPTMpIHtcbiAgICAgIGJhc2U2NCArPSBjaGFyc1tieXRlc1tpXSA+PiAyXTtcbiAgICAgIGJhc2U2NCArPSBjaGFyc1soKGJ5dGVzW2ldICYgMykgPDwgNCkgfCAoYnl0ZXNbaSArIDFdID4+IDQpXTtcbiAgICAgIGJhc2U2NCArPSBjaGFyc1soKGJ5dGVzW2kgKyAxXSAmIDE1KSA8PCAyKSB8IChieXRlc1tpICsgMl0gPj4gNildO1xuICAgICAgYmFzZTY0ICs9IGNoYXJzW2J5dGVzW2kgKyAyXSAmIDYzXTtcbiAgICB9XG5cbiAgICBpZiAoKGxlbiAlIDMpID09PSAyKSB7XG4gICAgICBiYXNlNjQgPSBiYXNlNjQuc3Vic3RyaW5nKDAsIGJhc2U2NC5sZW5ndGggLSAxKSArIFwiPVwiO1xuICAgIH0gZWxzZSBpZiAobGVuICUgMyA9PT0gMSkge1xuICAgICAgYmFzZTY0ID0gYmFzZTY0LnN1YnN0cmluZygwLCBiYXNlNjQubGVuZ3RoIC0gMikgKyBcIj09XCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJhc2U2NDtcbiAgfTtcblxuICBleHBvcnRzLmRlY29kZSA9ICBmdW5jdGlvbihiYXNlNjQpIHtcbiAgICB2YXIgYnVmZmVyTGVuZ3RoID0gYmFzZTY0Lmxlbmd0aCAqIDAuNzUsXG4gICAgbGVuID0gYmFzZTY0Lmxlbmd0aCwgaSwgcCA9IDAsXG4gICAgZW5jb2RlZDEsIGVuY29kZWQyLCBlbmNvZGVkMywgZW5jb2RlZDQ7XG5cbiAgICBpZiAoYmFzZTY0W2Jhc2U2NC5sZW5ndGggLSAxXSA9PT0gXCI9XCIpIHtcbiAgICAgIGJ1ZmZlckxlbmd0aC0tO1xuICAgICAgaWYgKGJhc2U2NFtiYXNlNjQubGVuZ3RoIC0gMl0gPT09IFwiPVwiKSB7XG4gICAgICAgIGJ1ZmZlckxlbmd0aC0tO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBhcnJheWJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihidWZmZXJMZW5ndGgpLFxuICAgIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSs9NCkge1xuICAgICAgZW5jb2RlZDEgPSBsb29rdXBbYmFzZTY0LmNoYXJDb2RlQXQoaSldO1xuICAgICAgZW5jb2RlZDIgPSBsb29rdXBbYmFzZTY0LmNoYXJDb2RlQXQoaSsxKV07XG4gICAgICBlbmNvZGVkMyA9IGxvb2t1cFtiYXNlNjQuY2hhckNvZGVBdChpKzIpXTtcbiAgICAgIGVuY29kZWQ0ID0gbG9va3VwW2Jhc2U2NC5jaGFyQ29kZUF0KGkrMyldO1xuXG4gICAgICBieXRlc1twKytdID0gKGVuY29kZWQxIDw8IDIpIHwgKGVuY29kZWQyID4+IDQpO1xuICAgICAgYnl0ZXNbcCsrXSA9ICgoZW5jb2RlZDIgJiAxNSkgPDwgNCkgfCAoZW5jb2RlZDMgPj4gMik7XG4gICAgICBieXRlc1twKytdID0gKChlbmNvZGVkMyAmIDMpIDw8IDYpIHwgKGVuY29kZWQ0ICYgNjMpO1xuICAgIH1cblxuICAgIHJldHVybiBhcnJheWJ1ZmZlcjtcbiAgfTtcbn0pKCk7XG5cbn0se31dLDEwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbi8qKlxuICogQ3JlYXRlIGEgYmxvYiBidWlsZGVyIGV2ZW4gd2hlbiB2ZW5kb3IgcHJlZml4ZXMgZXhpc3RcbiAqL1xuXG52YXIgQmxvYkJ1aWxkZXIgPSBnbG9iYWwuQmxvYkJ1aWxkZXJcbiAgfHwgZ2xvYmFsLldlYktpdEJsb2JCdWlsZGVyXG4gIHx8IGdsb2JhbC5NU0Jsb2JCdWlsZGVyXG4gIHx8IGdsb2JhbC5Nb3pCbG9iQnVpbGRlcjtcblxuLyoqXG4gKiBDaGVjayBpZiBCbG9iIGNvbnN0cnVjdG9yIGlzIHN1cHBvcnRlZFxuICovXG5cbnZhciBibG9iU3VwcG9ydGVkID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHZhciBhID0gbmV3IEJsb2IoWydoaSddKTtcbiAgICByZXR1cm4gYS5zaXplID09PSAyO1xuICB9IGNhdGNoKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn0pKCk7XG5cbi8qKlxuICogQ2hlY2sgaWYgQmxvYiBjb25zdHJ1Y3RvciBzdXBwb3J0cyBBcnJheUJ1ZmZlclZpZXdzXG4gKiBGYWlscyBpbiBTYWZhcmkgNiwgc28gd2UgbmVlZCB0byBtYXAgdG8gQXJyYXlCdWZmZXJzIHRoZXJlLlxuICovXG5cbnZhciBibG9iU3VwcG9ydHNBcnJheUJ1ZmZlclZpZXcgPSBibG9iU3VwcG9ydGVkICYmIChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYiA9IG5ldyBCbG9iKFtuZXcgVWludDhBcnJheShbMSwyXSldKTtcbiAgICByZXR1cm4gYi5zaXplID09PSAyO1xuICB9IGNhdGNoKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn0pKCk7XG5cbi8qKlxuICogQ2hlY2sgaWYgQmxvYkJ1aWxkZXIgaXMgc3VwcG9ydGVkXG4gKi9cblxudmFyIGJsb2JCdWlsZGVyU3VwcG9ydGVkID0gQmxvYkJ1aWxkZXJcbiAgJiYgQmxvYkJ1aWxkZXIucHJvdG90eXBlLmFwcGVuZFxuICAmJiBCbG9iQnVpbGRlci5wcm90b3R5cGUuZ2V0QmxvYjtcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBtYXBzIEFycmF5QnVmZmVyVmlld3MgdG8gQXJyYXlCdWZmZXJzXG4gKiBVc2VkIGJ5IEJsb2JCdWlsZGVyIGNvbnN0cnVjdG9yIGFuZCBvbGQgYnJvd3NlcnMgdGhhdCBkaWRuJ3RcbiAqIHN1cHBvcnQgaXQgaW4gdGhlIEJsb2IgY29uc3RydWN0b3IuXG4gKi9cblxuZnVuY3Rpb24gbWFwQXJyYXlCdWZmZXJWaWV3cyhhcnkpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnkubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2h1bmsgPSBhcnlbaV07XG4gICAgaWYgKGNodW5rLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICB2YXIgYnVmID0gY2h1bmsuYnVmZmVyO1xuXG4gICAgICAvLyBpZiB0aGlzIGlzIGEgc3ViYXJyYXksIG1ha2UgYSBjb3B5IHNvIHdlIG9ubHlcbiAgICAgIC8vIGluY2x1ZGUgdGhlIHN1YmFycmF5IHJlZ2lvbiBmcm9tIHRoZSB1bmRlcmx5aW5nIGJ1ZmZlclxuICAgICAgaWYgKGNodW5rLmJ5dGVMZW5ndGggIT09IGJ1Zi5ieXRlTGVuZ3RoKSB7XG4gICAgICAgIHZhciBjb3B5ID0gbmV3IFVpbnQ4QXJyYXkoY2h1bmsuYnl0ZUxlbmd0aCk7XG4gICAgICAgIGNvcHkuc2V0KG5ldyBVaW50OEFycmF5KGJ1ZiwgY2h1bmsuYnl0ZU9mZnNldCwgY2h1bmsuYnl0ZUxlbmd0aCkpO1xuICAgICAgICBidWYgPSBjb3B5LmJ1ZmZlcjtcbiAgICAgIH1cblxuICAgICAgYXJ5W2ldID0gYnVmO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBCbG9iQnVpbGRlckNvbnN0cnVjdG9yKGFyeSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgYmIgPSBuZXcgQmxvYkJ1aWxkZXIoKTtcbiAgbWFwQXJyYXlCdWZmZXJWaWV3cyhhcnkpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgYmIuYXBwZW5kKGFyeVtpXSk7XG4gIH1cblxuICByZXR1cm4gKG9wdGlvbnMudHlwZSkgPyBiYi5nZXRCbG9iKG9wdGlvbnMudHlwZSkgOiBiYi5nZXRCbG9iKCk7XG59O1xuXG5mdW5jdGlvbiBCbG9iQ29uc3RydWN0b3IoYXJ5LCBvcHRpb25zKSB7XG4gIG1hcEFycmF5QnVmZmVyVmlld3MoYXJ5KTtcbiAgcmV0dXJuIG5ldyBCbG9iKGFyeSwgb3B0aW9ucyB8fCB7fSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgaWYgKGJsb2JTdXBwb3J0ZWQpIHtcbiAgICByZXR1cm4gYmxvYlN1cHBvcnRzQXJyYXlCdWZmZXJWaWV3ID8gZ2xvYmFsLkJsb2IgOiBCbG9iQ29uc3RydWN0b3I7XG4gIH0gZWxzZSBpZiAoYmxvYkJ1aWxkZXJTdXBwb3J0ZWQpIHtcbiAgICByZXR1cm4gQmxvYkJ1aWxkZXJDb25zdHJ1Y3RvcjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59KSgpO1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB7fSlcbn0se31dLDExOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogU2xpY2UgcmVmZXJlbmNlLlxuICovXG5cbnZhciBzbGljZSA9IFtdLnNsaWNlO1xuXG4vKipcbiAqIEJpbmQgYG9iamAgdG8gYGZuYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufFN0cmluZ30gZm4gb3Igc3RyaW5nXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIGZuKXtcbiAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiBmbikgZm4gPSBvYmpbZm5dO1xuICBpZiAoJ2Z1bmN0aW9uJyAhPSB0eXBlb2YgZm4pIHRocm93IG5ldyBFcnJvcignYmluZCgpIHJlcXVpcmVzIGEgZnVuY3Rpb24nKTtcbiAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gIHJldHVybiBmdW5jdGlvbigpe1xuICAgIHJldHVybiBmbi5hcHBseShvYmosIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICB9XG59O1xuXG59LHt9XSwxMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cbi8qKlxuICogRXhwb3NlIGBFbWl0dGVyYC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVtaXR0ZXI7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgRW1pdHRlcmAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBFbWl0dGVyKG9iaikge1xuICBpZiAob2JqKSByZXR1cm4gbWl4aW4ob2JqKTtcbn07XG5cbi8qKlxuICogTWl4aW4gdGhlIGVtaXR0ZXIgcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBtaXhpbihvYmopIHtcbiAgZm9yICh2YXIga2V5IGluIEVtaXR0ZXIucHJvdG90eXBlKSB7XG4gICAgb2JqW2tleV0gPSBFbWl0dGVyLnByb3RvdHlwZVtrZXldO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogTGlzdGVuIG9uIHRoZSBnaXZlbiBgZXZlbnRgIHdpdGggYGZuYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5vbiA9XG5FbWl0dGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICAodGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW10pXG4gICAgLnB1c2goZm4pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkcyBhbiBgZXZlbnRgIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBpbnZva2VkIGEgc2luZ2xlXG4gKiB0aW1lIHRoZW4gYXV0b21hdGljYWxseSByZW1vdmVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICBmdW5jdGlvbiBvbigpIHtcbiAgICB0aGlzLm9mZihldmVudCwgb24pO1xuICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBvbi5mbiA9IGZuO1xuICB0aGlzLm9uKGV2ZW50LCBvbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBgZXZlbnRgIG9yIGFsbFxuICogcmVnaXN0ZXJlZCBjYWxsYmFja3MuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUub2ZmID1cbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuXG4gIC8vIGFsbFxuICBpZiAoMCA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgdGhpcy5fY2FsbGJhY2tzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzcGVjaWZpYyBldmVudFxuICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcbiAgaWYgKCFjYWxsYmFja3MpIHJldHVybiB0aGlzO1xuXG4gIC8vIHJlbW92ZSBhbGwgaGFuZGxlcnNcbiAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gcmVtb3ZlIHNwZWNpZmljIGhhbmRsZXJcbiAgdmFyIGNiO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgIGNiID0gY2FsbGJhY2tzW2ldO1xuICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICBjYWxsYmFja3Muc3BsaWNlKGksIDEpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFbWl0IGBldmVudGAgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7TWl4ZWR9IC4uLlxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oZXZlbnQpe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXG4gICAgLCBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xuXG4gIGlmIChjYWxsYmFja3MpIHtcbiAgICBjYWxsYmFja3MgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgY2FsbGJhY2tzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYXJyYXkgb2YgY2FsbGJhY2tzIGZvciBgZXZlbnRgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhpcyBlbWl0dGVyIGhhcyBgZXZlbnRgIGhhbmRsZXJzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUuaGFzTGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xuICByZXR1cm4gISEgdGhpcy5saXN0ZW5lcnMoZXZlbnQpLmxlbmd0aDtcbn07XG5cbn0se31dLDEzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhLCBiKXtcbiAgdmFyIGZuID0gZnVuY3Rpb24oKXt9O1xuICBmbi5wcm90b3R5cGUgPSBiLnByb3RvdHlwZTtcbiAgYS5wcm90b3R5cGUgPSBuZXcgZm47XG4gIGEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gYTtcbn07XG59LHt9XSwxNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBfZGVyZXFfKCcuL2RlYnVnJyk7XG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5zdG9yYWdlID0gJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZVxuICAgICAgICAgICAgICAgJiYgJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZS5zdG9yYWdlXG4gICAgICAgICAgICAgICAgICA/IGNocm9tZS5zdG9yYWdlLmxvY2FsXG4gICAgICAgICAgICAgICAgICA6IGxvY2Fsc3RvcmFnZSgpO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFtcbiAgJ2xpZ2h0c2VhZ3JlZW4nLFxuICAnZm9yZXN0Z3JlZW4nLFxuICAnZ29sZGVucm9kJyxcbiAgJ2RvZGdlcmJsdWUnLFxuICAnZGFya29yY2hpZCcsXG4gICdjcmltc29uJ1xuXTtcblxuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuXG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG4gIC8vIGlzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG4gIHJldHVybiAoJ1dlYmtpdEFwcGVhcmFuY2UnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSkgfHxcbiAgICAvLyBpcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG4gICAgKHdpbmRvdy5jb25zb2xlICYmIChjb25zb2xlLmZpcmVidWcgfHwgKGNvbnNvbGUuZXhjZXB0aW9uICYmIGNvbnNvbGUudGFibGUpKSkgfHxcbiAgICAvLyBpcyBmaXJlZm94ID49IHYzMT9cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcbiAgICAobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpO1xufVxuXG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xufTtcblxuXG4vKipcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoKSB7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgdXNlQ29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG5cbiAgYXJnc1swXSA9ICh1c2VDb2xvcnMgPyAnJWMnIDogJycpXG4gICAgKyB0aGlzLm5hbWVzcGFjZVxuICAgICsgKHVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKVxuICAgICsgYXJnc1swXVxuICAgICsgKHVzZUNvbG9ycyA/ICclYyAnIDogJyAnKVxuICAgICsgJysnICsgZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG4gIGlmICghdXNlQ29sb3JzKSByZXR1cm4gYXJncztcblxuICB2YXIgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG4gIGFyZ3MgPSBbYXJnc1swXSwgYywgJ2NvbG9yOiBpbmhlcml0J10uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MsIDEpKTtcblxuICAvLyB0aGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuICAvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG4gIC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdEMgPSAwO1xuICBhcmdzWzBdLnJlcGxhY2UoLyVbYS16JV0vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICBpZiAoJyUlJyA9PT0gbWF0Y2gpIHJldHVybjtcbiAgICBpbmRleCsrO1xuICAgIGlmICgnJWMnID09PSBtYXRjaCkge1xuICAgICAgLy8gd2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG4gICAgICAvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuICAgICAgbGFzdEMgPSBpbmRleDtcbiAgICB9XG4gIH0pO1xuXG4gIGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbiAgcmV0dXJuIGFyZ3M7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmxvZ2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbG9nKCkge1xuICAvLyB0aGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOC85LCB3aGVyZVxuICAvLyB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbiBkb2Vzbid0IGhhdmUgJ2FwcGx5J1xuICByZXR1cm4gJ29iamVjdCcgPT09IHR5cGVvZiBjb25zb2xlXG4gICAgJiYgY29uc29sZS5sb2dcbiAgICAmJiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlLmxvZywgY29uc29sZSwgYXJndW1lbnRzKTtcbn1cblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG4gIHRyeSB7XG4gICAgaWYgKG51bGwgPT0gbmFtZXNwYWNlcykge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZyA9IG5hbWVzcGFjZXM7XG4gICAgfVxuICB9IGNhdGNoKGUpIHt9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9hZCgpIHtcbiAgdmFyIHI7XG4gIHRyeSB7XG4gICAgciA9IGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZztcbiAgfSBjYXRjaChlKSB7fVxuICByZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBFbmFibGUgbmFtZXNwYWNlcyBsaXN0ZWQgaW4gYGxvY2FsU3RvcmFnZS5kZWJ1Z2AgaW5pdGlhbGx5LlxuICovXG5cbmV4cG9ydHMuZW5hYmxlKGxvYWQoKSk7XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCl7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG5cbn0se1wiLi9kZWJ1Z1wiOjE1fV0sMTU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGRlYnVnO1xuZXhwb3J0cy5jb2VyY2UgPSBjb2VyY2U7XG5leHBvcnRzLmRpc2FibGUgPSBkaXNhYmxlO1xuZXhwb3J0cy5lbmFibGUgPSBlbmFibGU7XG5leHBvcnRzLmVuYWJsZWQgPSBlbmFibGVkO1xuZXhwb3J0cy5odW1hbml6ZSA9IF9kZXJlcV8oJ21zJyk7XG5cbi8qKlxuICogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG4gKi9cblxuZXhwb3J0cy5uYW1lcyA9IFtdO1xuZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4vKipcbiAqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cbiAqXG4gKiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlcmNhc2VkIGxldHRlciwgaS5lLiBcIm5cIi5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMgPSB7fTtcblxuLyoqXG4gKiBQcmV2aW91c2x5IGFzc2lnbmVkIGNvbG9yLlxuICovXG5cbnZhciBwcmV2Q29sb3IgPSAwO1xuXG4vKipcbiAqIFByZXZpb3VzIGxvZyB0aW1lc3RhbXAuXG4gKi9cblxudmFyIHByZXZUaW1lO1xuXG4vKipcbiAqIFNlbGVjdCBhIGNvbG9yLlxuICpcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNlbGVjdENvbG9yKCkge1xuICByZXR1cm4gZXhwb3J0cy5jb2xvcnNbcHJldkNvbG9yKysgJSBleHBvcnRzLmNvbG9ycy5sZW5ndGhdO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZWJ1ZyhuYW1lc3BhY2UpIHtcblxuICAvLyBkZWZpbmUgdGhlIGBkaXNhYmxlZGAgdmVyc2lvblxuICBmdW5jdGlvbiBkaXNhYmxlZCgpIHtcbiAgfVxuICBkaXNhYmxlZC5lbmFibGVkID0gZmFsc2U7XG5cbiAgLy8gZGVmaW5lIHRoZSBgZW5hYmxlZGAgdmVyc2lvblxuICBmdW5jdGlvbiBlbmFibGVkKCkge1xuXG4gICAgdmFyIHNlbGYgPSBlbmFibGVkO1xuXG4gICAgLy8gc2V0IGBkaWZmYCB0aW1lc3RhbXBcbiAgICB2YXIgY3VyciA9ICtuZXcgRGF0ZSgpO1xuICAgIHZhciBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG4gICAgc2VsZi5kaWZmID0gbXM7XG4gICAgc2VsZi5wcmV2ID0gcHJldlRpbWU7XG4gICAgc2VsZi5jdXJyID0gY3VycjtcbiAgICBwcmV2VGltZSA9IGN1cnI7XG5cbiAgICAvLyBhZGQgdGhlIGBjb2xvcmAgaWYgbm90IHNldFxuICAgIGlmIChudWxsID09IHNlbGYudXNlQ29sb3JzKSBzZWxmLnVzZUNvbG9ycyA9IGV4cG9ydHMudXNlQ29sb3JzKCk7XG4gICAgaWYgKG51bGwgPT0gc2VsZi5jb2xvciAmJiBzZWxmLnVzZUNvbG9ycykgc2VsZi5jb2xvciA9IHNlbGVjdENvbG9yKCk7XG5cbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgICBhcmdzWzBdID0gZXhwb3J0cy5jb2VyY2UoYXJnc1swXSk7XG5cbiAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBhcmdzWzBdKSB7XG4gICAgICAvLyBhbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlb1xuICAgICAgYXJncyA9IFsnJW8nXS5jb25jYXQoYXJncyk7XG4gICAgfVxuXG4gICAgLy8gYXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EteiVdKS9nLCBmdW5jdGlvbihtYXRjaCwgZm9ybWF0KSB7XG4gICAgICAvLyBpZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG4gICAgICBpZiAobWF0Y2ggPT09ICclJScpIHJldHVybiBtYXRjaDtcbiAgICAgIGluZGV4Kys7XG4gICAgICB2YXIgZm9ybWF0dGVyID0gZXhwb3J0cy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG4gICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGZvcm1hdHRlcikge1xuICAgICAgICB2YXIgdmFsID0gYXJnc1tpbmRleF07XG4gICAgICAgIG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuICAgICAgICAvLyBub3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG4gICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgaW5kZXgtLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcblxuICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZXhwb3J0cy5mb3JtYXRBcmdzKSB7XG4gICAgICBhcmdzID0gZXhwb3J0cy5mb3JtYXRBcmdzLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIH1cbiAgICB2YXIgbG9nRm4gPSBlbmFibGVkLmxvZyB8fCBleHBvcnRzLmxvZyB8fCBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO1xuICAgIGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICB9XG4gIGVuYWJsZWQuZW5hYmxlZCA9IHRydWU7XG5cbiAgdmFyIGZuID0gZXhwb3J0cy5lbmFibGVkKG5hbWVzcGFjZSkgPyBlbmFibGVkIDogZGlzYWJsZWQ7XG5cbiAgZm4ubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuXG4gIHJldHVybiBmbjtcbn1cblxuLyoqXG4gKiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG4gKiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG4gIGV4cG9ydHMuc2F2ZShuYW1lc3BhY2VzKTtcblxuICB2YXIgc3BsaXQgPSAobmFtZXNwYWNlcyB8fCAnJykuc3BsaXQoL1tcXHMsXSsvKTtcbiAgdmFyIGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKCFzcGxpdFtpXSkgY29udGludWU7IC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG4gICAgbmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG4gICAgaWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuICAgICAgZXhwb3J0cy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zdWJzdHIoMSkgKyAnJCcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgZXhwb3J0cy5lbmFibGUoJycpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG4gIHZhciBpLCBsZW47XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENvZXJjZSBgdmFsYC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSB2YWxcbiAqIEByZXR1cm4ge01peGVkfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG4gIHJldHVybiB2YWw7XG59XG5cbn0se1wibXNcIjozNX1dLDE2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblxubW9kdWxlLmV4cG9ydHMgPSAgX2RlcmVxXygnLi9saWIvJyk7XG5cbn0se1wiLi9saWIvXCI6MTd9XSwxNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlcmVxXygnLi9zb2NrZXQnKTtcblxuLyoqXG4gKiBFeHBvcnRzIHBhcnNlclxuICpcbiAqIEBhcGkgcHVibGljXG4gKlxuICovXG5tb2R1bGUuZXhwb3J0cy5wYXJzZXIgPSBfZGVyZXFfKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG5cbn0se1wiLi9zb2NrZXRcIjoxOCxcImVuZ2luZS5pby1wYXJzZXJcIjoyN31dLDE4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgdHJhbnNwb3J0cyA9IF9kZXJlcV8oJy4vdHJhbnNwb3J0cycpO1xudmFyIEVtaXR0ZXIgPSBfZGVyZXFfKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIGRlYnVnID0gX2RlcmVxXygnZGVidWcnKSgnZW5naW5lLmlvLWNsaWVudDpzb2NrZXQnKTtcbnZhciBpbmRleCA9IF9kZXJlcV8oJ2luZGV4b2YnKTtcbnZhciBwYXJzZXIgPSBfZGVyZXFfKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG52YXIgcGFyc2V1cmkgPSBfZGVyZXFfKCdwYXJzZXVyaScpO1xudmFyIHBhcnNlanNvbiA9IF9kZXJlcV8oJ3BhcnNlanNvbicpO1xudmFyIHBhcnNlcXMgPSBfZGVyZXFfKCdwYXJzZXFzJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTb2NrZXQ7XG5cbi8qKlxuICogTm9vcCBmdW5jdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBub29wKCl7fVxuXG4vKipcbiAqIFNvY2tldCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHVyaSBvciBvcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBTb2NrZXQodXJpLCBvcHRzKXtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNvY2tldCkpIHJldHVybiBuZXcgU29ja2V0KHVyaSwgb3B0cyk7XG5cbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgaWYgKHVyaSAmJiAnb2JqZWN0JyA9PSB0eXBlb2YgdXJpKSB7XG4gICAgb3B0cyA9IHVyaTtcbiAgICB1cmkgPSBudWxsO1xuICB9XG5cbiAgaWYgKHVyaSkge1xuICAgIHVyaSA9IHBhcnNldXJpKHVyaSk7XG4gICAgb3B0cy5ob3N0bmFtZSA9IHVyaS5ob3N0O1xuICAgIG9wdHMuc2VjdXJlID0gdXJpLnByb3RvY29sID09ICdodHRwcycgfHwgdXJpLnByb3RvY29sID09ICd3c3MnO1xuICAgIG9wdHMucG9ydCA9IHVyaS5wb3J0O1xuICAgIGlmICh1cmkucXVlcnkpIG9wdHMucXVlcnkgPSB1cmkucXVlcnk7XG4gIH0gZWxzZSBpZiAob3B0cy5ob3N0KSB7XG4gICAgb3B0cy5ob3N0bmFtZSA9IHBhcnNldXJpKG9wdHMuaG9zdCkuaG9zdDtcbiAgfVxuXG4gIHRoaXMuc2VjdXJlID0gbnVsbCAhPSBvcHRzLnNlY3VyZSA/IG9wdHMuc2VjdXJlIDpcbiAgICAoZ2xvYmFsLmxvY2F0aW9uICYmICdodHRwczonID09IGxvY2F0aW9uLnByb3RvY29sKTtcblxuICBpZiAob3B0cy5ob3N0bmFtZSAmJiAhb3B0cy5wb3J0KSB7XG4gICAgLy8gaWYgbm8gcG9ydCBpcyBzcGVjaWZpZWQgbWFudWFsbHksIHVzZSB0aGUgcHJvdG9jb2wgZGVmYXVsdFxuICAgIG9wdHMucG9ydCA9IHRoaXMuc2VjdXJlID8gJzQ0MycgOiAnODAnO1xuICB9XG5cbiAgdGhpcy5hZ2VudCA9IG9wdHMuYWdlbnQgfHwgZmFsc2U7XG4gIHRoaXMuaG9zdG5hbWUgPSBvcHRzLmhvc3RuYW1lIHx8XG4gICAgKGdsb2JhbC5sb2NhdGlvbiA/IGxvY2F0aW9uLmhvc3RuYW1lIDogJ2xvY2FsaG9zdCcpO1xuICB0aGlzLnBvcnQgPSBvcHRzLnBvcnQgfHwgKGdsb2JhbC5sb2NhdGlvbiAmJiBsb2NhdGlvbi5wb3J0ID9cbiAgICAgICBsb2NhdGlvbi5wb3J0IDpcbiAgICAgICAodGhpcy5zZWN1cmUgPyA0NDMgOiA4MCkpO1xuICB0aGlzLnF1ZXJ5ID0gb3B0cy5xdWVyeSB8fCB7fTtcbiAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiB0aGlzLnF1ZXJ5KSB0aGlzLnF1ZXJ5ID0gcGFyc2Vxcy5kZWNvZGUodGhpcy5xdWVyeSk7XG4gIHRoaXMudXBncmFkZSA9IGZhbHNlICE9PSBvcHRzLnVwZ3JhZGU7XG4gIHRoaXMucGF0aCA9IChvcHRzLnBhdGggfHwgJy9lbmdpbmUuaW8nKS5yZXBsYWNlKC9cXC8kLywgJycpICsgJy8nO1xuICB0aGlzLmZvcmNlSlNPTlAgPSAhIW9wdHMuZm9yY2VKU09OUDtcbiAgdGhpcy5qc29ucCA9IGZhbHNlICE9PSBvcHRzLmpzb25wO1xuICB0aGlzLmZvcmNlQmFzZTY0ID0gISFvcHRzLmZvcmNlQmFzZTY0O1xuICB0aGlzLmVuYWJsZXNYRFIgPSAhIW9wdHMuZW5hYmxlc1hEUjtcbiAgdGhpcy50aW1lc3RhbXBQYXJhbSA9IG9wdHMudGltZXN0YW1wUGFyYW0gfHwgJ3QnO1xuICB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzID0gb3B0cy50aW1lc3RhbXBSZXF1ZXN0cztcbiAgdGhpcy50cmFuc3BvcnRzID0gb3B0cy50cmFuc3BvcnRzIHx8IFsncG9sbGluZycsICd3ZWJzb2NrZXQnXTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJyc7XG4gIHRoaXMud3JpdGVCdWZmZXIgPSBbXTtcbiAgdGhpcy5wb2xpY3lQb3J0ID0gb3B0cy5wb2xpY3lQb3J0IHx8IDg0MztcbiAgdGhpcy5yZW1lbWJlclVwZ3JhZGUgPSBvcHRzLnJlbWVtYmVyVXBncmFkZSB8fCBmYWxzZTtcbiAgdGhpcy5iaW5hcnlUeXBlID0gbnVsbDtcbiAgdGhpcy5vbmx5QmluYXJ5VXBncmFkZXMgPSBvcHRzLm9ubHlCaW5hcnlVcGdyYWRlcztcbiAgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSA9IGZhbHNlICE9PSBvcHRzLnBlck1lc3NhZ2VEZWZsYXRlID8gKG9wdHMucGVyTWVzc2FnZURlZmxhdGUgfHwge30pIDogZmFsc2U7XG5cbiAgaWYgKHRydWUgPT09IHRoaXMucGVyTWVzc2FnZURlZmxhdGUpIHRoaXMucGVyTWVzc2FnZURlZmxhdGUgPSB7fTtcbiAgaWYgKHRoaXMucGVyTWVzc2FnZURlZmxhdGUgJiYgbnVsbCA9PSB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlLnRocmVzaG9sZCkge1xuICAgIHRoaXMucGVyTWVzc2FnZURlZmxhdGUudGhyZXNob2xkID0gMTAyNDtcbiAgfVxuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLnBmeCA9IG9wdHMucGZ4IHx8IG51bGw7XG4gIHRoaXMua2V5ID0gb3B0cy5rZXkgfHwgbnVsbDtcbiAgdGhpcy5wYXNzcGhyYXNlID0gb3B0cy5wYXNzcGhyYXNlIHx8IG51bGw7XG4gIHRoaXMuY2VydCA9IG9wdHMuY2VydCB8fCBudWxsO1xuICB0aGlzLmNhID0gb3B0cy5jYSB8fCBudWxsO1xuICB0aGlzLmNpcGhlcnMgPSBvcHRzLmNpcGhlcnMgfHwgbnVsbDtcbiAgdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQgPSBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG9wdHMucmVqZWN0VW5hdXRob3JpemVkO1xuXG4gIC8vIG90aGVyIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG4gIGlmIChmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCkge1xuICAgIGlmIChvcHRzLmV4dHJhSGVhZGVycyAmJiBPYmplY3Qua2V5cyhvcHRzLmV4dHJhSGVhZGVycykubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5leHRyYUhlYWRlcnMgPSBvcHRzLmV4dHJhSGVhZGVycztcbiAgICB9XG4gIH1cblxuICB0aGlzLm9wZW4oKTtcbn1cblxuU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IGZhbHNlO1xuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihTb2NrZXQucHJvdG90eXBlKTtcblxuLyoqXG4gKiBQcm90b2NvbCB2ZXJzaW9uLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvY29sID0gcGFyc2VyLnByb3RvY29sOyAvLyB0aGlzIGlzIGFuIGludFxuXG4vKipcbiAqIEV4cG9zZSBkZXBzIGZvciBsZWdhY3kgY29tcGF0aWJpbGl0eVxuICogYW5kIHN0YW5kYWxvbmUgYnJvd3NlciBhY2Nlc3MuXG4gKi9cblxuU29ja2V0LlNvY2tldCA9IFNvY2tldDtcblNvY2tldC5UcmFuc3BvcnQgPSBfZGVyZXFfKCcuL3RyYW5zcG9ydCcpO1xuU29ja2V0LnRyYW5zcG9ydHMgPSBfZGVyZXFfKCcuL3RyYW5zcG9ydHMnKTtcblNvY2tldC5wYXJzZXIgPSBfZGVyZXFfKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG5cbi8qKlxuICogQ3JlYXRlcyB0cmFuc3BvcnQgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRyYW5zcG9ydCBuYW1lXG4gKiBAcmV0dXJuIHtUcmFuc3BvcnR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmNyZWF0ZVRyYW5zcG9ydCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGRlYnVnKCdjcmVhdGluZyB0cmFuc3BvcnQgXCIlc1wiJywgbmFtZSk7XG4gIHZhciBxdWVyeSA9IGNsb25lKHRoaXMucXVlcnkpO1xuXG4gIC8vIGFwcGVuZCBlbmdpbmUuaW8gcHJvdG9jb2wgaWRlbnRpZmllclxuICBxdWVyeS5FSU8gPSBwYXJzZXIucHJvdG9jb2w7XG5cbiAgLy8gdHJhbnNwb3J0IG5hbWVcbiAgcXVlcnkudHJhbnNwb3J0ID0gbmFtZTtcblxuICAvLyBzZXNzaW9uIGlkIGlmIHdlIGFscmVhZHkgaGF2ZSBvbmVcbiAgaWYgKHRoaXMuaWQpIHF1ZXJ5LnNpZCA9IHRoaXMuaWQ7XG5cbiAgdmFyIHRyYW5zcG9ydCA9IG5ldyB0cmFuc3BvcnRzW25hbWVdKHtcbiAgICBhZ2VudDogdGhpcy5hZ2VudCxcbiAgICBob3N0bmFtZTogdGhpcy5ob3N0bmFtZSxcbiAgICBwb3J0OiB0aGlzLnBvcnQsXG4gICAgc2VjdXJlOiB0aGlzLnNlY3VyZSxcbiAgICBwYXRoOiB0aGlzLnBhdGgsXG4gICAgcXVlcnk6IHF1ZXJ5LFxuICAgIGZvcmNlSlNPTlA6IHRoaXMuZm9yY2VKU09OUCxcbiAgICBqc29ucDogdGhpcy5qc29ucCxcbiAgICBmb3JjZUJhc2U2NDogdGhpcy5mb3JjZUJhc2U2NCxcbiAgICBlbmFibGVzWERSOiB0aGlzLmVuYWJsZXNYRFIsXG4gICAgdGltZXN0YW1wUmVxdWVzdHM6IHRoaXMudGltZXN0YW1wUmVxdWVzdHMsXG4gICAgdGltZXN0YW1wUGFyYW06IHRoaXMudGltZXN0YW1wUGFyYW0sXG4gICAgcG9saWN5UG9ydDogdGhpcy5wb2xpY3lQb3J0LFxuICAgIHNvY2tldDogdGhpcyxcbiAgICBwZng6IHRoaXMucGZ4LFxuICAgIGtleTogdGhpcy5rZXksXG4gICAgcGFzc3BocmFzZTogdGhpcy5wYXNzcGhyYXNlLFxuICAgIGNlcnQ6IHRoaXMuY2VydCxcbiAgICBjYTogdGhpcy5jYSxcbiAgICBjaXBoZXJzOiB0aGlzLmNpcGhlcnMsXG4gICAgcmVqZWN0VW5hdXRob3JpemVkOiB0aGlzLnJlamVjdFVuYXV0aG9yaXplZCxcbiAgICBwZXJNZXNzYWdlRGVmbGF0ZTogdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSxcbiAgICBleHRyYUhlYWRlcnM6IHRoaXMuZXh0cmFIZWFkZXJzXG4gIH0pO1xuXG4gIHJldHVybiB0cmFuc3BvcnQ7XG59O1xuXG5mdW5jdGlvbiBjbG9uZSAob2JqKSB7XG4gIHZhciBvID0ge307XG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgb1tpXSA9IG9ialtpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG87XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgdHJhbnNwb3J0IHRvIHVzZSBhbmQgc3RhcnRzIHByb2JlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5Tb2NrZXQucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0cmFuc3BvcnQ7XG4gIGlmICh0aGlzLnJlbWVtYmVyVXBncmFkZSAmJiBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzICYmIHRoaXMudHJhbnNwb3J0cy5pbmRleE9mKCd3ZWJzb2NrZXQnKSAhPSAtMSkge1xuICAgIHRyYW5zcG9ydCA9ICd3ZWJzb2NrZXQnO1xuICB9IGVsc2UgaWYgKDAgPT09IHRoaXMudHJhbnNwb3J0cy5sZW5ndGgpIHtcbiAgICAvLyBFbWl0IGVycm9yIG9uIG5leHQgdGljayBzbyBpdCBjYW4gYmUgbGlzdGVuZWQgdG9cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCAnTm8gdHJhbnNwb3J0cyBhdmFpbGFibGUnKTtcbiAgICB9LCAwKTtcbiAgICByZXR1cm47XG4gIH0gZWxzZSB7XG4gICAgdHJhbnNwb3J0ID0gdGhpcy50cmFuc3BvcnRzWzBdO1xuICB9XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuaW5nJztcblxuICAvLyBSZXRyeSB3aXRoIHRoZSBuZXh0IHRyYW5zcG9ydCBpZiB0aGUgdHJhbnNwb3J0IGlzIGRpc2FibGVkIChqc29ucDogZmFsc2UpXG4gIHRyeSB7XG4gICAgdHJhbnNwb3J0ID0gdGhpcy5jcmVhdGVUcmFuc3BvcnQodHJhbnNwb3J0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRoaXMudHJhbnNwb3J0cy5zaGlmdCgpO1xuICAgIHRoaXMub3BlbigpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRyYW5zcG9ydC5vcGVuKCk7XG4gIHRoaXMuc2V0VHJhbnNwb3J0KHRyYW5zcG9ydCk7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGN1cnJlbnQgdHJhbnNwb3J0LiBEaXNhYmxlcyB0aGUgZXhpc3Rpbmcgb25lIChpZiBhbnkpLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuc2V0VHJhbnNwb3J0ID0gZnVuY3Rpb24odHJhbnNwb3J0KXtcbiAgZGVidWcoJ3NldHRpbmcgdHJhbnNwb3J0ICVzJywgdHJhbnNwb3J0Lm5hbWUpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKHRoaXMudHJhbnNwb3J0KSB7XG4gICAgZGVidWcoJ2NsZWFyaW5nIGV4aXN0aW5nIHRyYW5zcG9ydCAlcycsIHRoaXMudHJhbnNwb3J0Lm5hbWUpO1xuICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB9XG5cbiAgLy8gc2V0IHVwIHRyYW5zcG9ydFxuICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcblxuICAvLyBzZXQgdXAgdHJhbnNwb3J0IGxpc3RlbmVyc1xuICB0cmFuc3BvcnRcbiAgLm9uKCdkcmFpbicsIGZ1bmN0aW9uKCl7XG4gICAgc2VsZi5vbkRyYWluKCk7XG4gIH0pXG4gIC5vbigncGFja2V0JywgZnVuY3Rpb24ocGFja2V0KXtcbiAgICBzZWxmLm9uUGFja2V0KHBhY2tldCk7XG4gIH0pXG4gIC5vbignZXJyb3InLCBmdW5jdGlvbihlKXtcbiAgICBzZWxmLm9uRXJyb3IoZSk7XG4gIH0pXG4gIC5vbignY2xvc2UnLCBmdW5jdGlvbigpe1xuICAgIHNlbGYub25DbG9zZSgndHJhbnNwb3J0IGNsb3NlJyk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBQcm9iZXMgYSB0cmFuc3BvcnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRyYW5zcG9ydCBuYW1lXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnByb2JlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgZGVidWcoJ3Byb2JpbmcgdHJhbnNwb3J0IFwiJXNcIicsIG5hbWUpO1xuICB2YXIgdHJhbnNwb3J0ID0gdGhpcy5jcmVhdGVUcmFuc3BvcnQobmFtZSwgeyBwcm9iZTogMSB9KVxuICAgICwgZmFpbGVkID0gZmFsc2VcbiAgICAsIHNlbGYgPSB0aGlzO1xuXG4gIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBvblRyYW5zcG9ydE9wZW4oKXtcbiAgICBpZiAoc2VsZi5vbmx5QmluYXJ5VXBncmFkZXMpIHtcbiAgICAgIHZhciB1cGdyYWRlTG9zZXNCaW5hcnkgPSAhdGhpcy5zdXBwb3J0c0JpbmFyeSAmJiBzZWxmLnRyYW5zcG9ydC5zdXBwb3J0c0JpbmFyeTtcbiAgICAgIGZhaWxlZCA9IGZhaWxlZCB8fCB1cGdyYWRlTG9zZXNCaW5hcnk7XG4gICAgfVxuICAgIGlmIChmYWlsZWQpIHJldHVybjtcblxuICAgIGRlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIG9wZW5lZCcsIG5hbWUpO1xuICAgIHRyYW5zcG9ydC5zZW5kKFt7IHR5cGU6ICdwaW5nJywgZGF0YTogJ3Byb2JlJyB9XSk7XG4gICAgdHJhbnNwb3J0Lm9uY2UoJ3BhY2tldCcsIGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgIGlmIChmYWlsZWQpIHJldHVybjtcbiAgICAgIGlmICgncG9uZycgPT0gbXNnLnR5cGUgJiYgJ3Byb2JlJyA9PSBtc2cuZGF0YSkge1xuICAgICAgICBkZWJ1ZygncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBwb25nJywgbmFtZSk7XG4gICAgICAgIHNlbGYudXBncmFkaW5nID0gdHJ1ZTtcbiAgICAgICAgc2VsZi5lbWl0KCd1cGdyYWRpbmcnLCB0cmFuc3BvcnQpO1xuICAgICAgICBpZiAoIXRyYW5zcG9ydCkgcmV0dXJuO1xuICAgICAgICBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gJ3dlYnNvY2tldCcgPT0gdHJhbnNwb3J0Lm5hbWU7XG5cbiAgICAgICAgZGVidWcoJ3BhdXNpbmcgY3VycmVudCB0cmFuc3BvcnQgXCIlc1wiJywgc2VsZi50cmFuc3BvcnQubmFtZSk7XG4gICAgICAgIHNlbGYudHJhbnNwb3J0LnBhdXNlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoZmFpbGVkKSByZXR1cm47XG4gICAgICAgICAgaWYgKCdjbG9zZWQnID09IHNlbGYucmVhZHlTdGF0ZSkgcmV0dXJuO1xuICAgICAgICAgIGRlYnVnKCdjaGFuZ2luZyB0cmFuc3BvcnQgYW5kIHNlbmRpbmcgdXBncmFkZSBwYWNrZXQnKTtcblxuICAgICAgICAgIGNsZWFudXAoKTtcblxuICAgICAgICAgIHNlbGYuc2V0VHJhbnNwb3J0KHRyYW5zcG9ydCk7XG4gICAgICAgICAgdHJhbnNwb3J0LnNlbmQoW3sgdHlwZTogJ3VwZ3JhZGUnIH1dKTtcbiAgICAgICAgICBzZWxmLmVtaXQoJ3VwZ3JhZGUnLCB0cmFuc3BvcnQpO1xuICAgICAgICAgIHRyYW5zcG9ydCA9IG51bGw7XG4gICAgICAgICAgc2VsZi51cGdyYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICBzZWxmLmZsdXNoKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgZmFpbGVkJywgbmFtZSk7XG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ3Byb2JlIGVycm9yJyk7XG4gICAgICAgIGVyci50cmFuc3BvcnQgPSB0cmFuc3BvcnQubmFtZTtcbiAgICAgICAgc2VsZi5lbWl0KCd1cGdyYWRlRXJyb3InLCBlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZnJlZXplVHJhbnNwb3J0KCkge1xuICAgIGlmIChmYWlsZWQpIHJldHVybjtcblxuICAgIC8vIEFueSBjYWxsYmFjayBjYWxsZWQgYnkgdHJhbnNwb3J0IHNob3VsZCBiZSBpZ25vcmVkIHNpbmNlIG5vd1xuICAgIGZhaWxlZCA9IHRydWU7XG5cbiAgICBjbGVhbnVwKCk7XG5cbiAgICB0cmFuc3BvcnQuY2xvc2UoKTtcbiAgICB0cmFuc3BvcnQgPSBudWxsO1xuICB9XG5cbiAgLy9IYW5kbGUgYW55IGVycm9yIHRoYXQgaGFwcGVucyB3aGlsZSBwcm9iaW5nXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXJyKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdwcm9iZSBlcnJvcjogJyArIGVycik7XG4gICAgZXJyb3IudHJhbnNwb3J0ID0gdHJhbnNwb3J0Lm5hbWU7XG5cbiAgICBmcmVlemVUcmFuc3BvcnQoKTtcblxuICAgIGRlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIGZhaWxlZCBiZWNhdXNlIG9mIGVycm9yOiAlcycsIG5hbWUsIGVycik7XG5cbiAgICBzZWxmLmVtaXQoJ3VwZ3JhZGVFcnJvcicsIGVycm9yKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uVHJhbnNwb3J0Q2xvc2UoKXtcbiAgICBvbmVycm9yKFwidHJhbnNwb3J0IGNsb3NlZFwiKTtcbiAgfVxuXG4gIC8vV2hlbiB0aGUgc29ja2V0IGlzIGNsb3NlZCB3aGlsZSB3ZSdyZSBwcm9iaW5nXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKXtcbiAgICBvbmVycm9yKFwic29ja2V0IGNsb3NlZFwiKTtcbiAgfVxuXG4gIC8vV2hlbiB0aGUgc29ja2V0IGlzIHVwZ3JhZGVkIHdoaWxlIHdlJ3JlIHByb2JpbmdcbiAgZnVuY3Rpb24gb251cGdyYWRlKHRvKXtcbiAgICBpZiAodHJhbnNwb3J0ICYmIHRvLm5hbWUgIT0gdHJhbnNwb3J0Lm5hbWUpIHtcbiAgICAgIGRlYnVnKCdcIiVzXCIgd29ya3MgLSBhYm9ydGluZyBcIiVzXCInLCB0by5uYW1lLCB0cmFuc3BvcnQubmFtZSk7XG4gICAgICBmcmVlemVUcmFuc3BvcnQoKTtcbiAgICB9XG4gIH1cblxuICAvL1JlbW92ZSBhbGwgbGlzdGVuZXJzIG9uIHRoZSB0cmFuc3BvcnQgYW5kIG9uIHNlbGZcbiAgZnVuY3Rpb24gY2xlYW51cCgpe1xuICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcignb3BlbicsIG9uVHJhbnNwb3J0T3Blbik7XG4gICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvblRyYW5zcG9ydENsb3NlKTtcbiAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ3VwZ3JhZGluZycsIG9udXBncmFkZSk7XG4gIH1cblxuICB0cmFuc3BvcnQub25jZSgnb3BlbicsIG9uVHJhbnNwb3J0T3Blbik7XG4gIHRyYW5zcG9ydC5vbmNlKCdlcnJvcicsIG9uZXJyb3IpO1xuICB0cmFuc3BvcnQub25jZSgnY2xvc2UnLCBvblRyYW5zcG9ydENsb3NlKTtcblxuICB0aGlzLm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIHRoaXMub25jZSgndXBncmFkaW5nJywgb251cGdyYWRlKTtcblxuICB0cmFuc3BvcnQub3BlbigpO1xuXG59O1xuXG4vKipcbiAqIENhbGxlZCB3aGVuIGNvbm5lY3Rpb24gaXMgZGVlbWVkIG9wZW4uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ3NvY2tldCBvcGVuJyk7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuJztcbiAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9ICd3ZWJzb2NrZXQnID09IHRoaXMudHJhbnNwb3J0Lm5hbWU7XG4gIHRoaXMuZW1pdCgnb3BlbicpO1xuICB0aGlzLmZsdXNoKCk7XG5cbiAgLy8gd2UgY2hlY2sgZm9yIGByZWFkeVN0YXRlYCBpbiBjYXNlIGFuIGBvcGVuYFxuICAvLyBsaXN0ZW5lciBhbHJlYWR5IGNsb3NlZCB0aGUgc29ja2V0XG4gIGlmICgnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlICYmIHRoaXMudXBncmFkZSAmJiB0aGlzLnRyYW5zcG9ydC5wYXVzZSkge1xuICAgIGRlYnVnKCdzdGFydGluZyB1cGdyYWRlIHByb2JlcycpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy51cGdyYWRlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHRoaXMucHJvYmUodGhpcy51cGdyYWRlc1tpXSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEhhbmRsZXMgYSBwYWNrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vblBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgaWYgKCdvcGVuaW5nJyA9PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIGRlYnVnKCdzb2NrZXQgcmVjZWl2ZTogdHlwZSBcIiVzXCIsIGRhdGEgXCIlc1wiJywgcGFja2V0LnR5cGUsIHBhY2tldC5kYXRhKTtcblxuICAgIHRoaXMuZW1pdCgncGFja2V0JywgcGFja2V0KTtcblxuICAgIC8vIFNvY2tldCBpcyBsaXZlIC0gYW55IHBhY2tldCBjb3VudHNcbiAgICB0aGlzLmVtaXQoJ2hlYXJ0YmVhdCcpO1xuXG4gICAgc3dpdGNoIChwYWNrZXQudHlwZSkge1xuICAgICAgY2FzZSAnb3Blbic6XG4gICAgICAgIHRoaXMub25IYW5kc2hha2UocGFyc2Vqc29uKHBhY2tldC5kYXRhKSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdwb25nJzpcbiAgICAgICAgdGhpcy5zZXRQaW5nKCk7XG4gICAgICAgIHRoaXMuZW1pdCgncG9uZycpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdzZXJ2ZXIgZXJyb3InKTtcbiAgICAgICAgZXJyLmNvZGUgPSBwYWNrZXQuZGF0YTtcbiAgICAgICAgdGhpcy5vbkVycm9yKGVycik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdtZXNzYWdlJzpcbiAgICAgICAgdGhpcy5lbWl0KCdkYXRhJywgcGFja2V0LmRhdGEpO1xuICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBwYWNrZXQuZGF0YSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBkZWJ1ZygncGFja2V0IHJlY2VpdmVkIHdpdGggc29ja2V0IHJlYWR5U3RhdGUgXCIlc1wiJywgdGhpcy5yZWFkeVN0YXRlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBoYW5kc2hha2UgY29tcGxldGlvbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaGFuZHNoYWtlIG9ialxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkhhbmRzaGFrZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuZW1pdCgnaGFuZHNoYWtlJywgZGF0YSk7XG4gIHRoaXMuaWQgPSBkYXRhLnNpZDtcbiAgdGhpcy50cmFuc3BvcnQucXVlcnkuc2lkID0gZGF0YS5zaWQ7XG4gIHRoaXMudXBncmFkZXMgPSB0aGlzLmZpbHRlclVwZ3JhZGVzKGRhdGEudXBncmFkZXMpO1xuICB0aGlzLnBpbmdJbnRlcnZhbCA9IGRhdGEucGluZ0ludGVydmFsO1xuICB0aGlzLnBpbmdUaW1lb3V0ID0gZGF0YS5waW5nVGltZW91dDtcbiAgdGhpcy5vbk9wZW4oKTtcbiAgLy8gSW4gY2FzZSBvcGVuIGhhbmRsZXIgY2xvc2VzIHNvY2tldFxuICBpZiAgKCdjbG9zZWQnID09IHRoaXMucmVhZHlTdGF0ZSkgcmV0dXJuO1xuICB0aGlzLnNldFBpbmcoKTtcblxuICAvLyBQcm9sb25nIGxpdmVuZXNzIG9mIHNvY2tldCBvbiBoZWFydGJlYXRcbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignaGVhcnRiZWF0JywgdGhpcy5vbkhlYXJ0YmVhdCk7XG4gIHRoaXMub24oJ2hlYXJ0YmVhdCcsIHRoaXMub25IZWFydGJlYXQpO1xufTtcblxuLyoqXG4gKiBSZXNldHMgcGluZyB0aW1lb3V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25IZWFydGJlYXQgPSBmdW5jdGlvbiAodGltZW91dCkge1xuICBjbGVhclRpbWVvdXQodGhpcy5waW5nVGltZW91dFRpbWVyKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLnBpbmdUaW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoJ2Nsb3NlZCcgPT0gc2VsZi5yZWFkeVN0YXRlKSByZXR1cm47XG4gICAgc2VsZi5vbkNsb3NlKCdwaW5nIHRpbWVvdXQnKTtcbiAgfSwgdGltZW91dCB8fCAoc2VsZi5waW5nSW50ZXJ2YWwgKyBzZWxmLnBpbmdUaW1lb3V0KSk7XG59O1xuXG4vKipcbiAqIFBpbmdzIHNlcnZlciBldmVyeSBgdGhpcy5waW5nSW50ZXJ2YWxgIGFuZCBleHBlY3RzIHJlc3BvbnNlXG4gKiB3aXRoaW4gYHRoaXMucGluZ1RpbWVvdXRgIG9yIGNsb3NlcyBjb25uZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuc2V0UGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBjbGVhclRpbWVvdXQoc2VsZi5waW5nSW50ZXJ2YWxUaW1lcik7XG4gIHNlbGYucGluZ0ludGVydmFsVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1Zygnd3JpdGluZyBwaW5nIHBhY2tldCAtIGV4cGVjdGluZyBwb25nIHdpdGhpbiAlc21zJywgc2VsZi5waW5nVGltZW91dCk7XG4gICAgc2VsZi5waW5nKCk7XG4gICAgc2VsZi5vbkhlYXJ0YmVhdChzZWxmLnBpbmdUaW1lb3V0KTtcbiAgfSwgc2VsZi5waW5nSW50ZXJ2YWwpO1xufTtcblxuLyoqXG4qIFNlbmRzIGEgcGluZyBwYWNrZXQuXG4qXG4qIEBhcGkgcHJpdmF0ZVxuKi9cblxuU29ja2V0LnByb3RvdHlwZS5waW5nID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuc2VuZFBhY2tldCgncGluZycsIGZ1bmN0aW9uKCl7XG4gICAgc2VsZi5lbWl0KCdwaW5nJyk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgb24gYGRyYWluYCBldmVudFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25EcmFpbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLndyaXRlQnVmZmVyLnNwbGljZSgwLCB0aGlzLnByZXZCdWZmZXJMZW4pO1xuXG4gIC8vIHNldHRpbmcgcHJldkJ1ZmZlckxlbiA9IDAgaXMgdmVyeSBpbXBvcnRhbnRcbiAgLy8gZm9yIGV4YW1wbGUsIHdoZW4gdXBncmFkaW5nLCB1cGdyYWRlIHBhY2tldCBpcyBzZW50IG92ZXIsXG4gIC8vIGFuZCBhIG5vbnplcm8gcHJldkJ1ZmZlckxlbiBjb3VsZCBjYXVzZSBwcm9ibGVtcyBvbiBgZHJhaW5gXG4gIHRoaXMucHJldkJ1ZmZlckxlbiA9IDA7XG5cbiAgaWYgKDAgPT09IHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKSB7XG4gICAgdGhpcy5lbWl0KCdkcmFpbicpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZmx1c2goKTtcbiAgfVxufTtcblxuLyoqXG4gKiBGbHVzaCB3cml0ZSBidWZmZXJzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgnY2xvc2VkJyAhPSB0aGlzLnJlYWR5U3RhdGUgJiYgdGhpcy50cmFuc3BvcnQud3JpdGFibGUgJiZcbiAgICAhdGhpcy51cGdyYWRpbmcgJiYgdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpIHtcbiAgICBkZWJ1ZygnZmx1c2hpbmcgJWQgcGFja2V0cyBpbiBzb2NrZXQnLCB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCk7XG4gICAgdGhpcy50cmFuc3BvcnQuc2VuZCh0aGlzLndyaXRlQnVmZmVyKTtcbiAgICAvLyBrZWVwIHRyYWNrIG9mIGN1cnJlbnQgbGVuZ3RoIG9mIHdyaXRlQnVmZmVyXG4gICAgLy8gc3BsaWNlIHdyaXRlQnVmZmVyIGFuZCBjYWxsYmFja0J1ZmZlciBvbiBgZHJhaW5gXG4gICAgdGhpcy5wcmV2QnVmZmVyTGVuID0gdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGg7XG4gICAgdGhpcy5lbWl0KCdmbHVzaCcpO1xuICB9XG59O1xuXG4vKipcbiAqIFNlbmRzIGEgbWVzc2FnZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuXG4gKiBAcmV0dXJuIHtTb2NrZXR9IGZvciBjaGFpbmluZy5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS53cml0ZSA9XG5Tb2NrZXQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAobXNnLCBvcHRpb25zLCBmbikge1xuICB0aGlzLnNlbmRQYWNrZXQoJ21lc3NhZ2UnLCBtc2csIG9wdGlvbnMsIGZuKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNlbmRzIGEgcGFja2V0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYWNrZXQgdHlwZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbi5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuc2VuZFBhY2tldCA9IGZ1bmN0aW9uICh0eXBlLCBkYXRhLCBvcHRpb25zLCBmbikge1xuICBpZignZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSB7XG4gICAgZm4gPSBkYXRhO1xuICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2Ygb3B0aW9ucykge1xuICAgIGZuID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0gbnVsbDtcbiAgfVxuXG4gIGlmICgnY2xvc2luZycgPT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdjbG9zZWQnID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLmNvbXByZXNzID0gZmFsc2UgIT09IG9wdGlvbnMuY29tcHJlc3M7XG5cbiAgdmFyIHBhY2tldCA9IHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIGRhdGE6IGRhdGEsXG4gICAgb3B0aW9uczogb3B0aW9uc1xuICB9O1xuICB0aGlzLmVtaXQoJ3BhY2tldENyZWF0ZScsIHBhY2tldCk7XG4gIHRoaXMud3JpdGVCdWZmZXIucHVzaChwYWNrZXQpO1xuICBpZiAoZm4pIHRoaXMub25jZSgnZmx1c2gnLCBmbik7XG4gIHRoaXMuZmx1c2goKTtcbn07XG5cbi8qKlxuICogQ2xvc2VzIHRoZSBjb25uZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgnb3BlbmluZycgPT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdvcGVuJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2luZyc7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgIHRoaXMub25jZSgnZHJhaW4nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMudXBncmFkaW5nKSB7XG4gICAgICAgICAgd2FpdEZvclVwZ3JhZGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudXBncmFkaW5nKSB7XG4gICAgICB3YWl0Rm9yVXBncmFkZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbG9zZSgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgIHNlbGYub25DbG9zZSgnZm9yY2VkIGNsb3NlJyk7XG4gICAgZGVidWcoJ3NvY2tldCBjbG9zaW5nIC0gdGVsbGluZyB0cmFuc3BvcnQgdG8gY2xvc2UnKTtcbiAgICBzZWxmLnRyYW5zcG9ydC5jbG9zZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xlYW51cEFuZENsb3NlKCkge1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ3VwZ3JhZGUnLCBjbGVhbnVwQW5kQ2xvc2UpO1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ3VwZ3JhZGVFcnJvcicsIGNsZWFudXBBbmRDbG9zZSk7XG4gICAgY2xvc2UoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdhaXRGb3JVcGdyYWRlKCkge1xuICAgIC8vIHdhaXQgZm9yIHVwZ3JhZGUgdG8gZmluaXNoIHNpbmNlIHdlIGNhbid0IHNlbmQgcGFja2V0cyB3aGlsZSBwYXVzaW5nIGEgdHJhbnNwb3J0XG4gICAgc2VsZi5vbmNlKCd1cGdyYWRlJywgY2xlYW51cEFuZENsb3NlKTtcbiAgICBzZWxmLm9uY2UoJ3VwZ3JhZGVFcnJvcicsIGNsZWFudXBBbmRDbG9zZSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IGVycm9yXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICBkZWJ1Zygnc29ja2V0IGVycm9yICVqJywgZXJyKTtcbiAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IGZhbHNlO1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgdGhpcy5vbkNsb3NlKCd0cmFuc3BvcnQgZXJyb3InLCBlcnIpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiB0cmFuc3BvcnQgY2xvc2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkNsb3NlID0gZnVuY3Rpb24gKHJlYXNvbiwgZGVzYykge1xuICBpZiAoJ29wZW5pbmcnID09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdjbG9zaW5nJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICBkZWJ1Zygnc29ja2V0IGNsb3NlIHdpdGggcmVhc29uOiBcIiVzXCInLCByZWFzb24pO1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIGNsZWFyIHRpbWVyc1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnBpbmdJbnRlcnZhbFRpbWVyKTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5waW5nVGltZW91dFRpbWVyKTtcblxuICAgIC8vIHN0b3AgZXZlbnQgZnJvbSBmaXJpbmcgYWdhaW4gZm9yIHRyYW5zcG9ydFxuICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygnY2xvc2UnKTtcblxuICAgIC8vIGVuc3VyZSB0cmFuc3BvcnQgd29uJ3Qgc3RheSBvcGVuXG4gICAgdGhpcy50cmFuc3BvcnQuY2xvc2UoKTtcblxuICAgIC8vIGlnbm9yZSBmdXJ0aGVyIHRyYW5zcG9ydCBjb21tdW5pY2F0aW9uXG4gICAgdGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG5cbiAgICAvLyBzZXQgcmVhZHkgc3RhdGVcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcblxuICAgIC8vIGNsZWFyIHNlc3Npb24gaWRcbiAgICB0aGlzLmlkID0gbnVsbDtcblxuICAgIC8vIGVtaXQgY2xvc2UgZXZlbnRcbiAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgcmVhc29uLCBkZXNjKTtcblxuICAgIC8vIGNsZWFuIGJ1ZmZlcnMgYWZ0ZXIsIHNvIHVzZXJzIGNhbiBzdGlsbFxuICAgIC8vIGdyYWIgdGhlIGJ1ZmZlcnMgb24gYGNsb3NlYCBldmVudFxuICAgIHNlbGYud3JpdGVCdWZmZXIgPSBbXTtcbiAgICBzZWxmLnByZXZCdWZmZXJMZW4gPSAwO1xuICB9XG59O1xuXG4vKipcbiAqIEZpbHRlcnMgdXBncmFkZXMsIHJldHVybmluZyBvbmx5IHRob3NlIG1hdGNoaW5nIGNsaWVudCB0cmFuc3BvcnRzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHNlcnZlciB1cGdyYWRlc1xuICogQGFwaSBwcml2YXRlXG4gKlxuICovXG5cblNvY2tldC5wcm90b3R5cGUuZmlsdGVyVXBncmFkZXMgPSBmdW5jdGlvbiAodXBncmFkZXMpIHtcbiAgdmFyIGZpbHRlcmVkVXBncmFkZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGogPSB1cGdyYWRlcy5sZW5ndGg7IGk8ajsgaSsrKSB7XG4gICAgaWYgKH5pbmRleCh0aGlzLnRyYW5zcG9ydHMsIHVwZ3JhZGVzW2ldKSkgZmlsdGVyZWRVcGdyYWRlcy5wdXNoKHVwZ3JhZGVzW2ldKTtcbiAgfVxuICByZXR1cm4gZmlsdGVyZWRVcGdyYWRlcztcbn07XG5cbn0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHt9KVxufSx7XCIuL3RyYW5zcG9ydFwiOjE5LFwiLi90cmFuc3BvcnRzXCI6MjAsXCJjb21wb25lbnQtZW1pdHRlclwiOjI2LFwiZGVidWdcIjoxNCxcImVuZ2luZS5pby1wYXJzZXJcIjoyNyxcImluZGV4b2ZcIjozMixcInBhcnNlanNvblwiOjM2LFwicGFyc2Vxc1wiOjM3LFwicGFyc2V1cmlcIjozOH1dLDE5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgcGFyc2VyID0gX2RlcmVxXygnZW5naW5lLmlvLXBhcnNlcicpO1xudmFyIEVtaXR0ZXIgPSBfZGVyZXFfKCdjb21wb25lbnQtZW1pdHRlcicpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNwb3J0O1xuXG4vKipcbiAqIFRyYW5zcG9ydCBhYnN0cmFjdCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIFRyYW5zcG9ydCAob3B0cykge1xuICB0aGlzLnBhdGggPSBvcHRzLnBhdGg7XG4gIHRoaXMuaG9zdG5hbWUgPSBvcHRzLmhvc3RuYW1lO1xuICB0aGlzLnBvcnQgPSBvcHRzLnBvcnQ7XG4gIHRoaXMuc2VjdXJlID0gb3B0cy5zZWN1cmU7XG4gIHRoaXMucXVlcnkgPSBvcHRzLnF1ZXJ5O1xuICB0aGlzLnRpbWVzdGFtcFBhcmFtID0gb3B0cy50aW1lc3RhbXBQYXJhbTtcbiAgdGhpcy50aW1lc3RhbXBSZXF1ZXN0cyA9IG9wdHMudGltZXN0YW1wUmVxdWVzdHM7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICcnO1xuICB0aGlzLmFnZW50ID0gb3B0cy5hZ2VudCB8fCBmYWxzZTtcbiAgdGhpcy5zb2NrZXQgPSBvcHRzLnNvY2tldDtcbiAgdGhpcy5lbmFibGVzWERSID0gb3B0cy5lbmFibGVzWERSO1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLnBmeCA9IG9wdHMucGZ4O1xuICB0aGlzLmtleSA9IG9wdHMua2V5O1xuICB0aGlzLnBhc3NwaHJhc2UgPSBvcHRzLnBhc3NwaHJhc2U7XG4gIHRoaXMuY2VydCA9IG9wdHMuY2VydDtcbiAgdGhpcy5jYSA9IG9wdHMuY2E7XG4gIHRoaXMuY2lwaGVycyA9IG9wdHMuY2lwaGVycztcbiAgdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQgPSBvcHRzLnJlamVjdFVuYXV0aG9yaXplZDtcblxuICAvLyBvdGhlciBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLmV4dHJhSGVhZGVycyA9IG9wdHMuZXh0cmFIZWFkZXJzO1xufVxuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihUcmFuc3BvcnQucHJvdG90eXBlKTtcblxuLyoqXG4gKiBFbWl0cyBhbiBlcnJvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtUcmFuc3BvcnR9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiAobXNnLCBkZXNjKSB7XG4gIHZhciBlcnIgPSBuZXcgRXJyb3IobXNnKTtcbiAgZXJyLnR5cGUgPSAnVHJhbnNwb3J0RXJyb3InO1xuICBlcnIuZGVzY3JpcHRpb24gPSBkZXNjO1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE9wZW5zIHRoZSB0cmFuc3BvcnQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgnY2xvc2VkJyA9PSB0aGlzLnJlYWR5U3RhdGUgfHwgJycgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW5pbmcnO1xuICAgIHRoaXMuZG9PcGVuKCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2xvc2VzIHRoZSB0cmFuc3BvcnQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCdvcGVuaW5nJyA9PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHRoaXMuZG9DbG9zZSgpO1xuICAgIHRoaXMub25DbG9zZSgpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNlbmRzIG11bHRpcGxlIHBhY2tldHMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24ocGFja2V0cyl7XG4gIGlmICgnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgdGhpcy53cml0ZShwYWNrZXRzKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBub3Qgb3BlbicpO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIG9wZW5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW4nO1xuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcbiAgdGhpcy5lbWl0KCdvcGVuJyk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aXRoIGRhdGEuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGFcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24oZGF0YSl7XG4gIHZhciBwYWNrZXQgPSBwYXJzZXIuZGVjb2RlUGFja2V0KGRhdGEsIHRoaXMuc29ja2V0LmJpbmFyeVR5cGUpO1xuICB0aGlzLm9uUGFja2V0KHBhY2tldCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aXRoIGEgZGVjb2RlZCBwYWNrZXQuXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vblBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgdGhpcy5lbWl0KCdwYWNrZXQnLCBwYWNrZXQpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBjbG9zZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICB0aGlzLmVtaXQoJ2Nsb3NlJyk7XG59O1xuXG59LHtcImNvbXBvbmVudC1lbWl0dGVyXCI6MjYsXCJlbmdpbmUuaW8tcGFyc2VyXCI6Mjd9XSwyMDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXNcbiAqL1xuXG52YXIgWE1MSHR0cFJlcXVlc3QgPSBfZGVyZXFfKCd4bWxodHRwcmVxdWVzdC1zc2wnKTtcbnZhciBYSFIgPSBfZGVyZXFfKCcuL3BvbGxpbmcteGhyJyk7XG52YXIgSlNPTlAgPSBfZGVyZXFfKCcuL3BvbGxpbmctanNvbnAnKTtcbnZhciB3ZWJzb2NrZXQgPSBfZGVyZXFfKCcuL3dlYnNvY2tldCcpO1xuXG4vKipcbiAqIEV4cG9ydCB0cmFuc3BvcnRzLlxuICovXG5cbmV4cG9ydHMucG9sbGluZyA9IHBvbGxpbmc7XG5leHBvcnRzLndlYnNvY2tldCA9IHdlYnNvY2tldDtcblxuLyoqXG4gKiBQb2xsaW5nIHRyYW5zcG9ydCBwb2x5bW9ycGhpYyBjb25zdHJ1Y3Rvci5cbiAqIERlY2lkZXMgb24geGhyIHZzIGpzb25wIGJhc2VkIG9uIGZlYXR1cmUgZGV0ZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBvbGxpbmcob3B0cyl7XG4gIHZhciB4aHI7XG4gIHZhciB4ZCA9IGZhbHNlO1xuICB2YXIgeHMgPSBmYWxzZTtcbiAgdmFyIGpzb25wID0gZmFsc2UgIT09IG9wdHMuanNvbnA7XG5cbiAgaWYgKGdsb2JhbC5sb2NhdGlvbikge1xuICAgIHZhciBpc1NTTCA9ICdodHRwczonID09IGxvY2F0aW9uLnByb3RvY29sO1xuICAgIHZhciBwb3J0ID0gbG9jYXRpb24ucG9ydDtcblxuICAgIC8vIHNvbWUgdXNlciBhZ2VudHMgaGF2ZSBlbXB0eSBgbG9jYXRpb24ucG9ydGBcbiAgICBpZiAoIXBvcnQpIHtcbiAgICAgIHBvcnQgPSBpc1NTTCA/IDQ0MyA6IDgwO1xuICAgIH1cblxuICAgIHhkID0gb3B0cy5ob3N0bmFtZSAhPSBsb2NhdGlvbi5ob3N0bmFtZSB8fCBwb3J0ICE9IG9wdHMucG9ydDtcbiAgICB4cyA9IG9wdHMuc2VjdXJlICE9IGlzU1NMO1xuICB9XG5cbiAgb3B0cy54ZG9tYWluID0geGQ7XG4gIG9wdHMueHNjaGVtZSA9IHhzO1xuICB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3Qob3B0cyk7XG5cbiAgaWYgKCdvcGVuJyBpbiB4aHIgJiYgIW9wdHMuZm9yY2VKU09OUCkge1xuICAgIHJldHVybiBuZXcgWEhSKG9wdHMpO1xuICB9IGVsc2Uge1xuICAgIGlmICghanNvbnApIHRocm93IG5ldyBFcnJvcignSlNPTlAgZGlzYWJsZWQnKTtcbiAgICByZXR1cm4gbmV3IEpTT05QKG9wdHMpO1xuICB9XG59XG5cbn0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHt9KVxufSx7XCIuL3BvbGxpbmctanNvbnBcIjoyMSxcIi4vcG9sbGluZy14aHJcIjoyMixcIi4vd2Vic29ja2V0XCI6MjQsXCJ4bWxodHRwcmVxdWVzdC1zc2xcIjoyNX1dLDIxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcblxuLyoqXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzLlxuICovXG5cbnZhciBQb2xsaW5nID0gX2RlcmVxXygnLi9wb2xsaW5nJyk7XG52YXIgaW5oZXJpdCA9IF9kZXJlcV8oJ2NvbXBvbmVudC1pbmhlcml0Jyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBKU09OUFBvbGxpbmc7XG5cbi8qKlxuICogQ2FjaGVkIHJlZ3VsYXIgZXhwcmVzc2lvbnMuXG4gKi9cblxudmFyIHJOZXdsaW5lID0gL1xcbi9nO1xudmFyIHJFc2NhcGVkTmV3bGluZSA9IC9cXFxcbi9nO1xuXG4vKipcbiAqIEdsb2JhbCBKU09OUCBjYWxsYmFja3MuXG4gKi9cblxudmFyIGNhbGxiYWNrcztcblxuLyoqXG4gKiBDYWxsYmFja3MgY291bnQuXG4gKi9cblxudmFyIGluZGV4ID0gMDtcblxuLyoqXG4gKiBOb29wLlxuICovXG5cbmZ1bmN0aW9uIGVtcHR5ICgpIHsgfVxuXG4vKipcbiAqIEpTT05QIFBvbGxpbmcgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEpTT05QUG9sbGluZyAob3B0cykge1xuICBQb2xsaW5nLmNhbGwodGhpcywgb3B0cyk7XG5cbiAgdGhpcy5xdWVyeSA9IHRoaXMucXVlcnkgfHwge307XG5cbiAgLy8gZGVmaW5lIGdsb2JhbCBjYWxsYmFja3MgYXJyYXkgaWYgbm90IHByZXNlbnRcbiAgLy8gd2UgZG8gdGhpcyBoZXJlIChsYXppbHkpIHRvIGF2b2lkIHVubmVlZGVkIGdsb2JhbCBwb2xsdXRpb25cbiAgaWYgKCFjYWxsYmFja3MpIHtcbiAgICAvLyB3ZSBuZWVkIHRvIGNvbnNpZGVyIG11bHRpcGxlIGVuZ2luZXMgaW4gdGhlIHNhbWUgcGFnZVxuICAgIGlmICghZ2xvYmFsLl9fX2VpbykgZ2xvYmFsLl9fX2VpbyA9IFtdO1xuICAgIGNhbGxiYWNrcyA9IGdsb2JhbC5fX19laW87XG4gIH1cblxuICAvLyBjYWxsYmFjayBpZGVudGlmaWVyXG4gIHRoaXMuaW5kZXggPSBjYWxsYmFja3MubGVuZ3RoO1xuXG4gIC8vIGFkZCBjYWxsYmFjayB0byBqc29ucCBnbG9iYWxcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBjYWxsYmFja3MucHVzaChmdW5jdGlvbiAobXNnKSB7XG4gICAgc2VsZi5vbkRhdGEobXNnKTtcbiAgfSk7XG5cbiAgLy8gYXBwZW5kIHRvIHF1ZXJ5IHN0cmluZ1xuICB0aGlzLnF1ZXJ5LmogPSB0aGlzLmluZGV4O1xuXG4gIC8vIHByZXZlbnQgc3B1cmlvdXMgZXJyb3JzIGZyb20gYmVpbmcgZW1pdHRlZCB3aGVuIHRoZSB3aW5kb3cgaXMgdW5sb2FkZWRcbiAgaWYgKGdsb2JhbC5kb2N1bWVudCAmJiBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2VsZi5zY3JpcHQpIHNlbGYuc2NyaXB0Lm9uZXJyb3IgPSBlbXB0eTtcbiAgICB9LCBmYWxzZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBJbmhlcml0cyBmcm9tIFBvbGxpbmcuXG4gKi9cblxuaW5oZXJpdChKU09OUFBvbGxpbmcsIFBvbGxpbmcpO1xuXG4vKlxuICogSlNPTlAgb25seSBzdXBwb3J0cyBiaW5hcnkgYXMgYmFzZTY0IGVuY29kZWQgc3RyaW5nc1xuICovXG5cbkpTT05QUG9sbGluZy5wcm90b3R5cGUuc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcblxuLyoqXG4gKiBDbG9zZXMgdGhlIHNvY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5KU09OUFBvbGxpbmcucHJvdG90eXBlLmRvQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnNjcmlwdCkge1xuICAgIHRoaXMuc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zY3JpcHQpO1xuICAgIHRoaXMuc2NyaXB0ID0gbnVsbDtcbiAgfVxuXG4gIGlmICh0aGlzLmZvcm0pIHtcbiAgICB0aGlzLmZvcm0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmZvcm0pO1xuICAgIHRoaXMuZm9ybSA9IG51bGw7XG4gICAgdGhpcy5pZnJhbWUgPSBudWxsO1xuICB9XG5cbiAgUG9sbGluZy5wcm90b3R5cGUuZG9DbG9zZS5jYWxsKHRoaXMpO1xufTtcblxuLyoqXG4gKiBTdGFydHMgYSBwb2xsIGN5Y2xlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkpTT05QUG9sbGluZy5wcm90b3R5cGUuZG9Qb2xsID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcblxuICBpZiAodGhpcy5zY3JpcHQpIHtcbiAgICB0aGlzLnNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc2NyaXB0KTtcbiAgICB0aGlzLnNjcmlwdCA9IG51bGw7XG4gIH1cblxuICBzY3JpcHQuYXN5bmMgPSB0cnVlO1xuICBzY3JpcHQuc3JjID0gdGhpcy51cmkoKTtcbiAgc2NyaXB0Lm9uZXJyb3IgPSBmdW5jdGlvbihlKXtcbiAgICBzZWxmLm9uRXJyb3IoJ2pzb25wIHBvbGwgZXJyb3InLGUpO1xuICB9O1xuXG4gIHZhciBpbnNlcnRBdCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKVswXTtcbiAgaWYgKGluc2VydEF0KSB7XG4gICAgaW5zZXJ0QXQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc2NyaXB0LCBpbnNlcnRBdCk7XG4gIH1cbiAgZWxzZSB7XG4gICAgKGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuYm9keSkuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgfVxuICB0aGlzLnNjcmlwdCA9IHNjcmlwdDtcblxuICB2YXIgaXNVQWdlY2tvID0gJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIG5hdmlnYXRvciAmJiAvZ2Vja28vaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICBcbiAgaWYgKGlzVUFnZWNrbykge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICAgIH0sIDEwMCk7XG4gIH1cbn07XG5cbi8qKlxuICogV3JpdGVzIHdpdGggYSBoaWRkZW4gaWZyYW1lLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhIHRvIHNlbmRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxlZCB1cG9uIGZsdXNoLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuSlNPTlBQb2xsaW5nLnByb3RvdHlwZS5kb1dyaXRlID0gZnVuY3Rpb24gKGRhdGEsIGZuKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAoIXRoaXMuZm9ybSkge1xuICAgIHZhciBmb3JtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZm9ybScpO1xuICAgIHZhciBhcmVhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKTtcbiAgICB2YXIgaWQgPSB0aGlzLmlmcmFtZUlkID0gJ2Vpb19pZnJhbWVfJyArIHRoaXMuaW5kZXg7XG4gICAgdmFyIGlmcmFtZTtcblxuICAgIGZvcm0uY2xhc3NOYW1lID0gJ3NvY2tldGlvJztcbiAgICBmb3JtLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBmb3JtLnN0eWxlLnRvcCA9ICctMTAwMHB4JztcbiAgICBmb3JtLnN0eWxlLmxlZnQgPSAnLTEwMDBweCc7XG4gICAgZm9ybS50YXJnZXQgPSBpZDtcbiAgICBmb3JtLm1ldGhvZCA9ICdQT1NUJztcbiAgICBmb3JtLnNldEF0dHJpYnV0ZSgnYWNjZXB0LWNoYXJzZXQnLCAndXRmLTgnKTtcbiAgICBhcmVhLm5hbWUgPSAnZCc7XG4gICAgZm9ybS5hcHBlbmRDaGlsZChhcmVhKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGZvcm0pO1xuXG4gICAgdGhpcy5mb3JtID0gZm9ybTtcbiAgICB0aGlzLmFyZWEgPSBhcmVhO1xuICB9XG5cbiAgdGhpcy5mb3JtLmFjdGlvbiA9IHRoaXMudXJpKCk7XG5cbiAgZnVuY3Rpb24gY29tcGxldGUgKCkge1xuICAgIGluaXRJZnJhbWUoKTtcbiAgICBmbigpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5pdElmcmFtZSAoKSB7XG4gICAgaWYgKHNlbGYuaWZyYW1lKSB7XG4gICAgICB0cnkge1xuICAgICAgICBzZWxmLmZvcm0ucmVtb3ZlQ2hpbGQoc2VsZi5pZnJhbWUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBzZWxmLm9uRXJyb3IoJ2pzb25wIHBvbGxpbmcgaWZyYW1lIHJlbW92YWwgZXJyb3InLCBlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gaWU2IGR5bmFtaWMgaWZyYW1lcyB3aXRoIHRhcmdldD1cIlwiIHN1cHBvcnQgKHRoYW5rcyBDaHJpcyBMYW1iYWNoZXIpXG4gICAgICB2YXIgaHRtbCA9ICc8aWZyYW1lIHNyYz1cImphdmFzY3JpcHQ6MFwiIG5hbWU9XCInKyBzZWxmLmlmcmFtZUlkICsnXCI+JztcbiAgICAgIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaHRtbCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgICBpZnJhbWUubmFtZSA9IHNlbGYuaWZyYW1lSWQ7XG4gICAgICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6MCc7XG4gICAgfVxuXG4gICAgaWZyYW1lLmlkID0gc2VsZi5pZnJhbWVJZDtcblxuICAgIHNlbGYuZm9ybS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgIHNlbGYuaWZyYW1lID0gaWZyYW1lO1xuICB9XG5cbiAgaW5pdElmcmFtZSgpO1xuXG4gIC8vIGVzY2FwZSBcXG4gdG8gcHJldmVudCBpdCBmcm9tIGJlaW5nIGNvbnZlcnRlZCBpbnRvIFxcclxcbiBieSBzb21lIFVBc1xuICAvLyBkb3VibGUgZXNjYXBpbmcgaXMgcmVxdWlyZWQgZm9yIGVzY2FwZWQgbmV3IGxpbmVzIGJlY2F1c2UgdW5lc2NhcGluZyBvZiBuZXcgbGluZXMgY2FuIGJlIGRvbmUgc2FmZWx5IG9uIHNlcnZlci1zaWRlXG4gIGRhdGEgPSBkYXRhLnJlcGxhY2UockVzY2FwZWROZXdsaW5lLCAnXFxcXFxcbicpO1xuICB0aGlzLmFyZWEudmFsdWUgPSBkYXRhLnJlcGxhY2Uock5ld2xpbmUsICdcXFxcbicpO1xuXG4gIHRyeSB7XG4gICAgdGhpcy5mb3JtLnN1Ym1pdCgpO1xuICB9IGNhdGNoKGUpIHt9XG5cbiAgaWYgKHRoaXMuaWZyYW1lLmF0dGFjaEV2ZW50KSB7XG4gICAgdGhpcy5pZnJhbWUub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKXtcbiAgICAgIGlmIChzZWxmLmlmcmFtZS5yZWFkeVN0YXRlID09ICdjb21wbGV0ZScpIHtcbiAgICAgICAgY29tcGxldGUoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHRoaXMuaWZyYW1lLm9ubG9hZCA9IGNvbXBsZXRlO1xuICB9XG59O1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB7fSlcbn0se1wiLi9wb2xsaW5nXCI6MjMsXCJjb21wb25lbnQtaW5oZXJpdFwiOjEzfV0sMjI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuLyoqXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzLlxuICovXG5cbnZhciBYTUxIdHRwUmVxdWVzdCA9IF9kZXJlcV8oJ3htbGh0dHByZXF1ZXN0LXNzbCcpO1xudmFyIFBvbGxpbmcgPSBfZGVyZXFfKCcuL3BvbGxpbmcnKTtcbnZhciBFbWl0dGVyID0gX2RlcmVxXygnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciBpbmhlcml0ID0gX2RlcmVxXygnY29tcG9uZW50LWluaGVyaXQnKTtcbnZhciBkZWJ1ZyA9IF9kZXJlcV8oJ2RlYnVnJykoJ2VuZ2luZS5pby1jbGllbnQ6cG9sbGluZy14aHInKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhIUjtcbm1vZHVsZS5leHBvcnRzLlJlcXVlc3QgPSBSZXF1ZXN0O1xuXG4vKipcbiAqIEVtcHR5IGZ1bmN0aW9uXG4gKi9cblxuZnVuY3Rpb24gZW1wdHkoKXt9XG5cbi8qKlxuICogWEhSIFBvbGxpbmcgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gWEhSKG9wdHMpe1xuICBQb2xsaW5nLmNhbGwodGhpcywgb3B0cyk7XG5cbiAgaWYgKGdsb2JhbC5sb2NhdGlvbikge1xuICAgIHZhciBpc1NTTCA9ICdodHRwczonID09IGxvY2F0aW9uLnByb3RvY29sO1xuICAgIHZhciBwb3J0ID0gbG9jYXRpb24ucG9ydDtcblxuICAgIC8vIHNvbWUgdXNlciBhZ2VudHMgaGF2ZSBlbXB0eSBgbG9jYXRpb24ucG9ydGBcbiAgICBpZiAoIXBvcnQpIHtcbiAgICAgIHBvcnQgPSBpc1NTTCA/IDQ0MyA6IDgwO1xuICAgIH1cblxuICAgIHRoaXMueGQgPSBvcHRzLmhvc3RuYW1lICE9IGdsb2JhbC5sb2NhdGlvbi5ob3N0bmFtZSB8fFxuICAgICAgcG9ydCAhPSBvcHRzLnBvcnQ7XG4gICAgdGhpcy54cyA9IG9wdHMuc2VjdXJlICE9IGlzU1NMO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZXh0cmFIZWFkZXJzID0gb3B0cy5leHRyYUhlYWRlcnM7XG4gIH1cbn1cblxuLyoqXG4gKiBJbmhlcml0cyBmcm9tIFBvbGxpbmcuXG4gKi9cblxuaW5oZXJpdChYSFIsIFBvbGxpbmcpO1xuXG4vKipcbiAqIFhIUiBzdXBwb3J0cyBiaW5hcnlcbiAqL1xuXG5YSFIucHJvdG90eXBlLnN1cHBvcnRzQmluYXJ5ID0gdHJ1ZTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgcmVxdWVzdC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5YSFIucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbihvcHRzKXtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIG9wdHMudXJpID0gdGhpcy51cmkoKTtcbiAgb3B0cy54ZCA9IHRoaXMueGQ7XG4gIG9wdHMueHMgPSB0aGlzLnhzO1xuICBvcHRzLmFnZW50ID0gdGhpcy5hZ2VudCB8fCBmYWxzZTtcbiAgb3B0cy5zdXBwb3J0c0JpbmFyeSA9IHRoaXMuc3VwcG9ydHNCaW5hcnk7XG4gIG9wdHMuZW5hYmxlc1hEUiA9IHRoaXMuZW5hYmxlc1hEUjtcblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgb3B0cy5wZnggPSB0aGlzLnBmeDtcbiAgb3B0cy5rZXkgPSB0aGlzLmtleTtcbiAgb3B0cy5wYXNzcGhyYXNlID0gdGhpcy5wYXNzcGhyYXNlO1xuICBvcHRzLmNlcnQgPSB0aGlzLmNlcnQ7XG4gIG9wdHMuY2EgPSB0aGlzLmNhO1xuICBvcHRzLmNpcGhlcnMgPSB0aGlzLmNpcGhlcnM7XG4gIG9wdHMucmVqZWN0VW5hdXRob3JpemVkID0gdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQ7XG5cbiAgLy8gb3RoZXIgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgb3B0cy5leHRyYUhlYWRlcnMgPSB0aGlzLmV4dHJhSGVhZGVycztcblxuICByZXR1cm4gbmV3IFJlcXVlc3Qob3B0cyk7XG59O1xuXG4vKipcbiAqIFNlbmRzIGRhdGEuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgdG8gc2VuZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxlZCB1cG9uIGZsdXNoLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuWEhSLnByb3RvdHlwZS5kb1dyaXRlID0gZnVuY3Rpb24oZGF0YSwgZm4pe1xuICB2YXIgaXNCaW5hcnkgPSB0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycgJiYgZGF0YSAhPT0gdW5kZWZpbmVkO1xuICB2YXIgcmVxID0gdGhpcy5yZXF1ZXN0KHsgbWV0aG9kOiAnUE9TVCcsIGRhdGE6IGRhdGEsIGlzQmluYXJ5OiBpc0JpbmFyeSB9KTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXEub24oJ3N1Y2Nlc3MnLCBmbik7XG4gIHJlcS5vbignZXJyb3InLCBmdW5jdGlvbihlcnIpe1xuICAgIHNlbGYub25FcnJvcigneGhyIHBvc3QgZXJyb3InLCBlcnIpO1xuICB9KTtcbiAgdGhpcy5zZW5kWGhyID0gcmVxO1xufTtcblxuLyoqXG4gKiBTdGFydHMgYSBwb2xsIGN5Y2xlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblhIUi5wcm90b3R5cGUuZG9Qb2xsID0gZnVuY3Rpb24oKXtcbiAgZGVidWcoJ3hociBwb2xsJyk7XG4gIHZhciByZXEgPSB0aGlzLnJlcXVlc3QoKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXEub24oJ2RhdGEnLCBmdW5jdGlvbihkYXRhKXtcbiAgICBzZWxmLm9uRGF0YShkYXRhKTtcbiAgfSk7XG4gIHJlcS5vbignZXJyb3InLCBmdW5jdGlvbihlcnIpe1xuICAgIHNlbGYub25FcnJvcigneGhyIHBvbGwgZXJyb3InLCBlcnIpO1xuICB9KTtcbiAgdGhpcy5wb2xsWGhyID0gcmVxO1xufTtcblxuLyoqXG4gKiBSZXF1ZXN0IGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gUmVxdWVzdChvcHRzKXtcbiAgdGhpcy5tZXRob2QgPSBvcHRzLm1ldGhvZCB8fCAnR0VUJztcbiAgdGhpcy51cmkgPSBvcHRzLnVyaTtcbiAgdGhpcy54ZCA9ICEhb3B0cy54ZDtcbiAgdGhpcy54cyA9ICEhb3B0cy54cztcbiAgdGhpcy5hc3luYyA9IGZhbHNlICE9PSBvcHRzLmFzeW5jO1xuICB0aGlzLmRhdGEgPSB1bmRlZmluZWQgIT0gb3B0cy5kYXRhID8gb3B0cy5kYXRhIDogbnVsbDtcbiAgdGhpcy5hZ2VudCA9IG9wdHMuYWdlbnQ7XG4gIHRoaXMuaXNCaW5hcnkgPSBvcHRzLmlzQmluYXJ5O1xuICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gb3B0cy5zdXBwb3J0c0JpbmFyeTtcbiAgdGhpcy5lbmFibGVzWERSID0gb3B0cy5lbmFibGVzWERSO1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLnBmeCA9IG9wdHMucGZ4O1xuICB0aGlzLmtleSA9IG9wdHMua2V5O1xuICB0aGlzLnBhc3NwaHJhc2UgPSBvcHRzLnBhc3NwaHJhc2U7XG4gIHRoaXMuY2VydCA9IG9wdHMuY2VydDtcbiAgdGhpcy5jYSA9IG9wdHMuY2E7XG4gIHRoaXMuY2lwaGVycyA9IG9wdHMuY2lwaGVycztcbiAgdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQgPSBvcHRzLnJlamVjdFVuYXV0aG9yaXplZDtcblxuICAvLyBvdGhlciBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLmV4dHJhSGVhZGVycyA9IG9wdHMuZXh0cmFIZWFkZXJzO1xuXG4gIHRoaXMuY3JlYXRlKCk7XG59XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKFJlcXVlc3QucHJvdG90eXBlKTtcblxuLyoqXG4gKiBDcmVhdGVzIHRoZSBYSFIgb2JqZWN0IGFuZCBzZW5kcyB0aGUgcmVxdWVzdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbigpe1xuICB2YXIgb3B0cyA9IHsgYWdlbnQ6IHRoaXMuYWdlbnQsIHhkb21haW46IHRoaXMueGQsIHhzY2hlbWU6IHRoaXMueHMsIGVuYWJsZXNYRFI6IHRoaXMuZW5hYmxlc1hEUiB9O1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICBvcHRzLnBmeCA9IHRoaXMucGZ4O1xuICBvcHRzLmtleSA9IHRoaXMua2V5O1xuICBvcHRzLnBhc3NwaHJhc2UgPSB0aGlzLnBhc3NwaHJhc2U7XG4gIG9wdHMuY2VydCA9IHRoaXMuY2VydDtcbiAgb3B0cy5jYSA9IHRoaXMuY2E7XG4gIG9wdHMuY2lwaGVycyA9IHRoaXMuY2lwaGVycztcbiAgb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPSB0aGlzLnJlamVjdFVuYXV0aG9yaXplZDtcblxuICB2YXIgeGhyID0gdGhpcy54aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3Qob3B0cyk7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0cnkge1xuICAgIGRlYnVnKCd4aHIgb3BlbiAlczogJXMnLCB0aGlzLm1ldGhvZCwgdGhpcy51cmkpO1xuICAgIHhoci5vcGVuKHRoaXMubWV0aG9kLCB0aGlzLnVyaSwgdGhpcy5hc3luYyk7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzLmV4dHJhSGVhZGVycykge1xuICAgICAgICB4aHIuc2V0RGlzYWJsZUhlYWRlckNoZWNrKHRydWUpO1xuICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuZXh0cmFIZWFkZXJzKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZXh0cmFIZWFkZXJzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihpLCB0aGlzLmV4dHJhSGVhZGVyc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICBpZiAodGhpcy5zdXBwb3J0c0JpbmFyeSkge1xuICAgICAgLy8gVGhpcyBoYXMgdG8gYmUgZG9uZSBhZnRlciBvcGVuIGJlY2F1c2UgRmlyZWZveCBpcyBzdHVwaWRcbiAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTMyMTY5MDMvZ2V0LWJpbmFyeS1kYXRhLXdpdGgteG1saHR0cHJlcXVlc3QtaW4tYS1maXJlZm94LWV4dGVuc2lvblxuICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgfVxuXG4gICAgaWYgKCdQT1NUJyA9PSB0aGlzLm1ldGhvZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHRoaXMuaXNCaW5hcnkpIHtcbiAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LXR5cGUnLCAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04Jyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuXG4gICAgLy8gaWU2IGNoZWNrXG4gICAgaWYgKCd3aXRoQ3JlZGVudGlhbHMnIGluIHhocikge1xuICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaGFzWERSKCkpIHtcbiAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbigpe1xuICAgICAgICBzZWxmLm9uTG9hZCgpO1xuICAgICAgfTtcbiAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKXtcbiAgICAgICAgc2VsZi5vbkVycm9yKHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmICg0ICE9IHhoci5yZWFkeVN0YXRlKSByZXR1cm47XG4gICAgICAgIGlmICgyMDAgPT0geGhyLnN0YXR1cyB8fCAxMjIzID09IHhoci5zdGF0dXMpIHtcbiAgICAgICAgICBzZWxmLm9uTG9hZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgYGVycm9yYCBldmVudCBoYW5kbGVyIHRoYXQncyB1c2VyLXNldFxuICAgICAgICAgIC8vIGRvZXMgbm90IHRocm93IGluIHRoZSBzYW1lIHRpY2sgYW5kIGdldHMgY2F1Z2h0IGhlcmVcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBzZWxmLm9uRXJyb3IoeGhyLnN0YXR1cyk7XG4gICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgZGVidWcoJ3hociBkYXRhICVzJywgdGhpcy5kYXRhKTtcbiAgICB4aHIuc2VuZCh0aGlzLmRhdGEpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gTmVlZCB0byBkZWZlciBzaW5jZSAuY3JlYXRlKCkgaXMgY2FsbGVkIGRpcmVjdGx5IGZocm9tIHRoZSBjb25zdHJ1Y3RvclxuICAgIC8vIGFuZCB0aHVzIHRoZSAnZXJyb3InIGV2ZW50IGNhbiBvbmx5IGJlIG9ubHkgYm91bmQgKmFmdGVyKiB0aGlzIGV4Y2VwdGlvblxuICAgIC8vIG9jY3Vycy4gIFRoZXJlZm9yZSwgYWxzbywgd2UgY2Fubm90IHRocm93IGhlcmUgYXQgYWxsLlxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLm9uRXJyb3IoZSk7XG4gICAgfSwgMCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGdsb2JhbC5kb2N1bWVudCkge1xuICAgIHRoaXMuaW5kZXggPSBSZXF1ZXN0LnJlcXVlc3RzQ291bnQrKztcbiAgICBSZXF1ZXN0LnJlcXVlc3RzW3RoaXMuaW5kZXhdID0gdGhpcztcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzdWNjZXNzZnVsIHJlc3BvbnNlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uU3VjY2VzcyA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuZW1pdCgnc3VjY2VzcycpO1xuICB0aGlzLmNsZWFudXAoKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIGlmIHdlIGhhdmUgZGF0YS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbihkYXRhKXtcbiAgdGhpcy5lbWl0KCdkYXRhJywgZGF0YSk7XG4gIHRoaXMub25TdWNjZXNzKCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGVycm9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbihlcnIpe1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgdGhpcy5jbGVhbnVwKHRydWUpO1xufTtcblxuLyoqXG4gKiBDbGVhbnMgdXAgaG91c2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uKGZyb21FcnJvcil7XG4gIGlmICgndW5kZWZpbmVkJyA9PSB0eXBlb2YgdGhpcy54aHIgfHwgbnVsbCA9PT0gdGhpcy54aHIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8geG1saHR0cHJlcXVlc3RcbiAgaWYgKHRoaXMuaGFzWERSKCkpIHtcbiAgICB0aGlzLnhoci5vbmxvYWQgPSB0aGlzLnhoci5vbmVycm9yID0gZW1wdHk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy54aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZW1wdHk7XG4gIH1cblxuICBpZiAoZnJvbUVycm9yKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMueGhyLmFib3J0KCk7XG4gICAgfSBjYXRjaChlKSB7fVxuICB9XG5cbiAgaWYgKGdsb2JhbC5kb2N1bWVudCkge1xuICAgIGRlbGV0ZSBSZXF1ZXN0LnJlcXVlc3RzW3RoaXMuaW5kZXhdO1xuICB9XG5cbiAgdGhpcy54aHIgPSBudWxsO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBsb2FkLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uTG9hZCA9IGZ1bmN0aW9uKCl7XG4gIHZhciBkYXRhO1xuICB0cnkge1xuICAgIHZhciBjb250ZW50VHlwZTtcbiAgICB0cnkge1xuICAgICAgY29udGVudFR5cGUgPSB0aGlzLnhoci5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1UeXBlJykuc3BsaXQoJzsnKVswXTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIGlmIChjb250ZW50VHlwZSA9PT0gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScpIHtcbiAgICAgIGRhdGEgPSB0aGlzLnhoci5yZXNwb25zZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCF0aGlzLnN1cHBvcnRzQmluYXJ5KSB7XG4gICAgICAgIGRhdGEgPSB0aGlzLnhoci5yZXNwb25zZVRleHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGRhdGEgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KHRoaXMueGhyLnJlc3BvbnNlKSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB2YXIgdWk4QXJyID0gbmV3IFVpbnQ4QXJyYXkodGhpcy54aHIucmVzcG9uc2UpO1xuICAgICAgICAgIHZhciBkYXRhQXJyYXkgPSBbXTtcbiAgICAgICAgICBmb3IgKHZhciBpZHggPSAwLCBsZW5ndGggPSB1aThBcnIubGVuZ3RoOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgICBkYXRhQXJyYXkucHVzaCh1aThBcnJbaWR4XSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGF0YSA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgZGF0YUFycmF5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIHRoaXMub25FcnJvcihlKTtcbiAgfVxuICBpZiAobnVsbCAhPSBkYXRhKSB7XG4gICAgdGhpcy5vbkRhdGEoZGF0YSk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgaXQgaGFzIFhEb21haW5SZXF1ZXN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmhhc1hEUiA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiAndW5kZWZpbmVkJyAhPT0gdHlwZW9mIGdsb2JhbC5YRG9tYWluUmVxdWVzdCAmJiAhdGhpcy54cyAmJiB0aGlzLmVuYWJsZXNYRFI7XG59O1xuXG4vKipcbiAqIEFib3J0cyB0aGUgcmVxdWVzdC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5jbGVhbnVwKCk7XG59O1xuXG4vKipcbiAqIEFib3J0cyBwZW5kaW5nIHJlcXVlc3RzIHdoZW4gdW5sb2FkaW5nIHRoZSB3aW5kb3cuIFRoaXMgaXMgbmVlZGVkIHRvIHByZXZlbnRcbiAqIG1lbW9yeSBsZWFrcyAoZS5nLiB3aGVuIHVzaW5nIElFKSBhbmQgdG8gZW5zdXJlIHRoYXQgbm8gc3B1cmlvdXMgZXJyb3IgaXNcbiAqIGVtaXR0ZWQuXG4gKi9cblxuaWYgKGdsb2JhbC5kb2N1bWVudCkge1xuICBSZXF1ZXN0LnJlcXVlc3RzQ291bnQgPSAwO1xuICBSZXF1ZXN0LnJlcXVlc3RzID0ge307XG4gIGlmIChnbG9iYWwuYXR0YWNoRXZlbnQpIHtcbiAgICBnbG9iYWwuYXR0YWNoRXZlbnQoJ29udW5sb2FkJywgdW5sb2FkSGFuZGxlcik7XG4gIH0gZWxzZSBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgdW5sb2FkSGFuZGxlciwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVubG9hZEhhbmRsZXIoKSB7XG4gIGZvciAodmFyIGkgaW4gUmVxdWVzdC5yZXF1ZXN0cykge1xuICAgIGlmIChSZXF1ZXN0LnJlcXVlc3RzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICBSZXF1ZXN0LnJlcXVlc3RzW2ldLmFib3J0KCk7XG4gICAgfVxuICB9XG59XG5cbn0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHt9KVxufSx7XCIuL3BvbGxpbmdcIjoyMyxcImNvbXBvbmVudC1lbWl0dGVyXCI6MjYsXCJjb21wb25lbnQtaW5oZXJpdFwiOjEzLFwiZGVidWdcIjoxNCxcInhtbGh0dHByZXF1ZXN0LXNzbFwiOjI1fV0sMjM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBUcmFuc3BvcnQgPSBfZGVyZXFfKCcuLi90cmFuc3BvcnQnKTtcbnZhciBwYXJzZXFzID0gX2RlcmVxXygncGFyc2VxcycpO1xudmFyIHBhcnNlciA9IF9kZXJlcV8oJ2VuZ2luZS5pby1wYXJzZXInKTtcbnZhciBpbmhlcml0ID0gX2RlcmVxXygnY29tcG9uZW50LWluaGVyaXQnKTtcbnZhciB5ZWFzdCA9IF9kZXJlcV8oJ3llYXN0Jyk7XG52YXIgZGVidWcgPSBfZGVyZXFfKCdkZWJ1ZycpKCdlbmdpbmUuaW8tY2xpZW50OnBvbGxpbmcnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvbGxpbmc7XG5cbi8qKlxuICogSXMgWEhSMiBzdXBwb3J0ZWQ/XG4gKi9cblxudmFyIGhhc1hIUjIgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciBYTUxIdHRwUmVxdWVzdCA9IF9kZXJlcV8oJ3htbGh0dHByZXF1ZXN0LXNzbCcpO1xuICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KHsgeGRvbWFpbjogZmFsc2UgfSk7XG4gIHJldHVybiBudWxsICE9IHhoci5yZXNwb25zZVR5cGU7XG59KSgpO1xuXG4vKipcbiAqIFBvbGxpbmcgaW50ZXJmYWNlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBQb2xsaW5nKG9wdHMpe1xuICB2YXIgZm9yY2VCYXNlNjQgPSAob3B0cyAmJiBvcHRzLmZvcmNlQmFzZTY0KTtcbiAgaWYgKCFoYXNYSFIyIHx8IGZvcmNlQmFzZTY0KSB7XG4gICAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuICB9XG4gIFRyYW5zcG9ydC5jYWxsKHRoaXMsIG9wdHMpO1xufVxuXG4vKipcbiAqIEluaGVyaXRzIGZyb20gVHJhbnNwb3J0LlxuICovXG5cbmluaGVyaXQoUG9sbGluZywgVHJhbnNwb3J0KTtcblxuLyoqXG4gKiBUcmFuc3BvcnQgbmFtZS5cbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5uYW1lID0gJ3BvbGxpbmcnO1xuXG4vKipcbiAqIE9wZW5zIHRoZSBzb2NrZXQgKHRyaWdnZXJzIHBvbGxpbmcpLiBXZSB3cml0ZSBhIFBJTkcgbWVzc2FnZSB0byBkZXRlcm1pbmVcbiAqIHdoZW4gdGhlIHRyYW5zcG9ydCBpcyBvcGVuLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLmRvT3BlbiA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMucG9sbCgpO1xufTtcblxuLyoqXG4gKiBQYXVzZXMgcG9sbGluZy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayB1cG9uIGJ1ZmZlcnMgYXJlIGZsdXNoZWQgYW5kIHRyYW5zcG9ydCBpcyBwYXVzZWRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24ob25QYXVzZSl7XG4gIHZhciBwZW5kaW5nID0gMDtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdwYXVzaW5nJztcblxuICBmdW5jdGlvbiBwYXVzZSgpe1xuICAgIGRlYnVnKCdwYXVzZWQnKTtcbiAgICBzZWxmLnJlYWR5U3RhdGUgPSAncGF1c2VkJztcbiAgICBvblBhdXNlKCk7XG4gIH1cblxuICBpZiAodGhpcy5wb2xsaW5nIHx8ICF0aGlzLndyaXRhYmxlKSB7XG4gICAgdmFyIHRvdGFsID0gMDtcblxuICAgIGlmICh0aGlzLnBvbGxpbmcpIHtcbiAgICAgIGRlYnVnKCd3ZSBhcmUgY3VycmVudGx5IHBvbGxpbmcgLSB3YWl0aW5nIHRvIHBhdXNlJyk7XG4gICAgICB0b3RhbCsrO1xuICAgICAgdGhpcy5vbmNlKCdwb2xsQ29tcGxldGUnLCBmdW5jdGlvbigpe1xuICAgICAgICBkZWJ1ZygncHJlLXBhdXNlIHBvbGxpbmcgY29tcGxldGUnKTtcbiAgICAgICAgLS10b3RhbCB8fCBwYXVzZSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLndyaXRhYmxlKSB7XG4gICAgICBkZWJ1Zygnd2UgYXJlIGN1cnJlbnRseSB3cml0aW5nIC0gd2FpdGluZyB0byBwYXVzZScpO1xuICAgICAgdG90YWwrKztcbiAgICAgIHRoaXMub25jZSgnZHJhaW4nLCBmdW5jdGlvbigpe1xuICAgICAgICBkZWJ1ZygncHJlLXBhdXNlIHdyaXRpbmcgY29tcGxldGUnKTtcbiAgICAgICAgLS10b3RhbCB8fCBwYXVzZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBhdXNlKCk7XG4gIH1cbn07XG5cbi8qKlxuICogU3RhcnRzIHBvbGxpbmcgY3ljbGUuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5wb2xsID0gZnVuY3Rpb24oKXtcbiAgZGVidWcoJ3BvbGxpbmcnKTtcbiAgdGhpcy5wb2xsaW5nID0gdHJ1ZTtcbiAgdGhpcy5kb1BvbGwoKTtcbiAgdGhpcy5lbWl0KCdwb2xsJyk7XG59O1xuXG4vKipcbiAqIE92ZXJsb2FkcyBvbkRhdGEgdG8gZGV0ZWN0IHBheWxvYWRzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uKGRhdGEpe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGRlYnVnKCdwb2xsaW5nIGdvdCBkYXRhICVzJywgZGF0YSk7XG4gIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uKHBhY2tldCwgaW5kZXgsIHRvdGFsKSB7XG4gICAgLy8gaWYgaXRzIHRoZSBmaXJzdCBtZXNzYWdlIHdlIGNvbnNpZGVyIHRoZSB0cmFuc3BvcnQgb3BlblxuICAgIGlmICgnb3BlbmluZycgPT0gc2VsZi5yZWFkeVN0YXRlKSB7XG4gICAgICBzZWxmLm9uT3BlbigpO1xuICAgIH1cblxuICAgIC8vIGlmIGl0cyBhIGNsb3NlIHBhY2tldCwgd2UgY2xvc2UgdGhlIG9uZ29pbmcgcmVxdWVzdHNcbiAgICBpZiAoJ2Nsb3NlJyA9PSBwYWNrZXQudHlwZSkge1xuICAgICAgc2VsZi5vbkNsb3NlKCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gb3RoZXJ3aXNlIGJ5cGFzcyBvbkRhdGEgYW5kIGhhbmRsZSB0aGUgbWVzc2FnZVxuICAgIHNlbGYub25QYWNrZXQocGFja2V0KTtcbiAgfTtcblxuICAvLyBkZWNvZGUgcGF5bG9hZFxuICBwYXJzZXIuZGVjb2RlUGF5bG9hZChkYXRhLCB0aGlzLnNvY2tldC5iaW5hcnlUeXBlLCBjYWxsYmFjayk7XG5cbiAgLy8gaWYgYW4gZXZlbnQgZGlkIG5vdCB0cmlnZ2VyIGNsb3NpbmdcbiAgaWYgKCdjbG9zZWQnICE9IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIC8vIGlmIHdlIGdvdCBkYXRhIHdlJ3JlIG5vdCBwb2xsaW5nXG4gICAgdGhpcy5wb2xsaW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwb2xsQ29tcGxldGUnKTtcblxuICAgIGlmICgnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgICB0aGlzLnBvbGwoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWcoJ2lnbm9yaW5nIHBvbGwgLSB0cmFuc3BvcnQgc3RhdGUgXCIlc1wiJywgdGhpcy5yZWFkeVN0YXRlKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogRm9yIHBvbGxpbmcsIHNlbmQgYSBjbG9zZSBwYWNrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUuZG9DbG9zZSA9IGZ1bmN0aW9uKCl7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBmdW5jdGlvbiBjbG9zZSgpe1xuICAgIGRlYnVnKCd3cml0aW5nIGNsb3NlIHBhY2tldCcpO1xuICAgIHNlbGYud3JpdGUoW3sgdHlwZTogJ2Nsb3NlJyB9XSk7XG4gIH1cblxuICBpZiAoJ29wZW4nID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIGRlYnVnKCd0cmFuc3BvcnQgb3BlbiAtIGNsb3NpbmcnKTtcbiAgICBjbG9zZSgpO1xuICB9IGVsc2Uge1xuICAgIC8vIGluIGNhc2Ugd2UncmUgdHJ5aW5nIHRvIGNsb3NlIHdoaWxlXG4gICAgLy8gaGFuZHNoYWtpbmcgaXMgaW4gcHJvZ3Jlc3MgKEdILTE2NClcbiAgICBkZWJ1ZygndHJhbnNwb3J0IG5vdCBvcGVuIC0gZGVmZXJyaW5nIGNsb3NlJyk7XG4gICAgdGhpcy5vbmNlKCdvcGVuJywgY2xvc2UpO1xuICB9XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHBhY2tldHMgcGF5bG9hZC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBkYXRhIHBhY2tldHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRyYWluIGNhbGxiYWNrXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHBhY2tldHMpe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcbiAgdmFyIGNhbGxiYWNrZm4gPSBmdW5jdGlvbigpIHtcbiAgICBzZWxmLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBzZWxmLmVtaXQoJ2RyYWluJyk7XG4gIH07XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBwYXJzZXIuZW5jb2RlUGF5bG9hZChwYWNrZXRzLCB0aGlzLnN1cHBvcnRzQmluYXJ5LCBmdW5jdGlvbihkYXRhKSB7XG4gICAgc2VsZi5kb1dyaXRlKGRhdGEsIGNhbGxiYWNrZm4pO1xuICB9KTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIHVyaSBmb3IgY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS51cmkgPSBmdW5jdGlvbigpe1xuICB2YXIgcXVlcnkgPSB0aGlzLnF1ZXJ5IHx8IHt9O1xuICB2YXIgc2NoZW1hID0gdGhpcy5zZWN1cmUgPyAnaHR0cHMnIDogJ2h0dHAnO1xuICB2YXIgcG9ydCA9ICcnO1xuXG4gIC8vIGNhY2hlIGJ1c3RpbmcgaXMgZm9yY2VkXG4gIGlmIChmYWxzZSAhPT0gdGhpcy50aW1lc3RhbXBSZXF1ZXN0cykge1xuICAgIHF1ZXJ5W3RoaXMudGltZXN0YW1wUGFyYW1dID0geWVhc3QoKTtcbiAgfVxuXG4gIGlmICghdGhpcy5zdXBwb3J0c0JpbmFyeSAmJiAhcXVlcnkuc2lkKSB7XG4gICAgcXVlcnkuYjY0ID0gMTtcbiAgfVxuXG4gIHF1ZXJ5ID0gcGFyc2Vxcy5lbmNvZGUocXVlcnkpO1xuXG4gIC8vIGF2b2lkIHBvcnQgaWYgZGVmYXVsdCBmb3Igc2NoZW1hXG4gIGlmICh0aGlzLnBvcnQgJiYgKCgnaHR0cHMnID09IHNjaGVtYSAmJiB0aGlzLnBvcnQgIT0gNDQzKSB8fFxuICAgICAoJ2h0dHAnID09IHNjaGVtYSAmJiB0aGlzLnBvcnQgIT0gODApKSkge1xuICAgIHBvcnQgPSAnOicgKyB0aGlzLnBvcnQ7XG4gIH1cblxuICAvLyBwcmVwZW5kID8gdG8gcXVlcnlcbiAgaWYgKHF1ZXJ5Lmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gJz8nICsgcXVlcnk7XG4gIH1cblxuICB2YXIgaXB2NiA9IHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpICE9PSAtMTtcbiAgcmV0dXJuIHNjaGVtYSArICc6Ly8nICsgKGlwdjYgPyAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nIDogdGhpcy5ob3N0bmFtZSkgKyBwb3J0ICsgdGhpcy5wYXRoICsgcXVlcnk7XG59O1xuXG59LHtcIi4uL3RyYW5zcG9ydFwiOjE5LFwiY29tcG9uZW50LWluaGVyaXRcIjoxMyxcImRlYnVnXCI6MTQsXCJlbmdpbmUuaW8tcGFyc2VyXCI6MjcsXCJwYXJzZXFzXCI6MzcsXCJ4bWxodHRwcmVxdWVzdC1zc2xcIjoyNSxcInllYXN0XCI6NDV9XSwyNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIFRyYW5zcG9ydCA9IF9kZXJlcV8oJy4uL3RyYW5zcG9ydCcpO1xudmFyIHBhcnNlciA9IF9kZXJlcV8oJ2VuZ2luZS5pby1wYXJzZXInKTtcbnZhciBwYXJzZXFzID0gX2RlcmVxXygncGFyc2VxcycpO1xudmFyIGluaGVyaXQgPSBfZGVyZXFfKCdjb21wb25lbnQtaW5oZXJpdCcpO1xudmFyIHllYXN0ID0gX2RlcmVxXygneWVhc3QnKTtcbnZhciBkZWJ1ZyA9IF9kZXJlcV8oJ2RlYnVnJykoJ2VuZ2luZS5pby1jbGllbnQ6d2Vic29ja2V0Jyk7XG52YXIgQnJvd3NlcldlYlNvY2tldCA9IGdsb2JhbC5XZWJTb2NrZXQgfHwgZ2xvYmFsLk1veldlYlNvY2tldDtcblxuLyoqXG4gKiBHZXQgZWl0aGVyIHRoZSBgV2ViU29ja2V0YCBvciBgTW96V2ViU29ja2V0YCBnbG9iYWxzXG4gKiBpbiB0aGUgYnJvd3NlciBvciB0cnkgdG8gcmVzb2x2ZSBXZWJTb2NrZXQtY29tcGF0aWJsZVxuICogaW50ZXJmYWNlIGV4cG9zZWQgYnkgYHdzYCBmb3IgTm9kZS1saWtlIGVudmlyb25tZW50LlxuICovXG5cbnZhciBXZWJTb2NrZXQgPSBCcm93c2VyV2ViU29ja2V0O1xuaWYgKCFXZWJTb2NrZXQgJiYgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgdHJ5IHtcbiAgICBXZWJTb2NrZXQgPSBfZGVyZXFfKCd3cycpO1xuICB9IGNhdGNoIChlKSB7IH1cbn1cblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdTO1xuXG4vKipcbiAqIFdlYlNvY2tldCB0cmFuc3BvcnQgY29uc3RydWN0b3IuXG4gKlxuICogQGFwaSB7T2JqZWN0fSBjb25uZWN0aW9uIG9wdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gV1Mob3B0cyl7XG4gIHZhciBmb3JjZUJhc2U2NCA9IChvcHRzICYmIG9wdHMuZm9yY2VCYXNlNjQpO1xuICBpZiAoZm9yY2VCYXNlNjQpIHtcbiAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cbiAgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSA9IG9wdHMucGVyTWVzc2FnZURlZmxhdGU7XG4gIFRyYW5zcG9ydC5jYWxsKHRoaXMsIG9wdHMpO1xufVxuXG4vKipcbiAqIEluaGVyaXRzIGZyb20gVHJhbnNwb3J0LlxuICovXG5cbmluaGVyaXQoV1MsIFRyYW5zcG9ydCk7XG5cbi8qKlxuICogVHJhbnNwb3J0IG5hbWUuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5XUy5wcm90b3R5cGUubmFtZSA9ICd3ZWJzb2NrZXQnO1xuXG4vKlxuICogV2ViU29ja2V0cyBzdXBwb3J0IGJpbmFyeVxuICovXG5cbldTLnByb3RvdHlwZS5zdXBwb3J0c0JpbmFyeSA9IHRydWU7XG5cbi8qKlxuICogT3BlbnMgc29ja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS5kb09wZW4gPSBmdW5jdGlvbigpe1xuICBpZiAoIXRoaXMuY2hlY2soKSkge1xuICAgIC8vIGxldCBwcm9iZSB0aW1lb3V0XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdXJpID0gdGhpcy51cmkoKTtcbiAgdmFyIHByb3RvY29scyA9IHZvaWQoMCk7XG4gIHZhciBvcHRzID0ge1xuICAgIGFnZW50OiB0aGlzLmFnZW50LFxuICAgIHBlck1lc3NhZ2VEZWZsYXRlOiB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlXG4gIH07XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIG9wdHMucGZ4ID0gdGhpcy5wZng7XG4gIG9wdHMua2V5ID0gdGhpcy5rZXk7XG4gIG9wdHMucGFzc3BocmFzZSA9IHRoaXMucGFzc3BocmFzZTtcbiAgb3B0cy5jZXJ0ID0gdGhpcy5jZXJ0O1xuICBvcHRzLmNhID0gdGhpcy5jYTtcbiAgb3B0cy5jaXBoZXJzID0gdGhpcy5jaXBoZXJzO1xuICBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCA9IHRoaXMucmVqZWN0VW5hdXRob3JpemVkO1xuICBpZiAodGhpcy5leHRyYUhlYWRlcnMpIHtcbiAgICBvcHRzLmhlYWRlcnMgPSB0aGlzLmV4dHJhSGVhZGVycztcbiAgfVxuXG4gIHRoaXMud3MgPSBCcm93c2VyV2ViU29ja2V0ID8gbmV3IFdlYlNvY2tldCh1cmkpIDogbmV3IFdlYlNvY2tldCh1cmksIHByb3RvY29scywgb3B0cyk7XG5cbiAgaWYgKHRoaXMud3MuYmluYXJ5VHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHRoaXMud3Muc3VwcG9ydHMgJiYgdGhpcy53cy5zdXBwb3J0cy5iaW5hcnkpIHtcbiAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gdHJ1ZTtcbiAgICB0aGlzLndzLmJpbmFyeVR5cGUgPSAnYnVmZmVyJztcbiAgfSBlbHNlIHtcbiAgICB0aGlzLndzLmJpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICB9XG5cbiAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xufTtcblxuLyoqXG4gKiBBZGRzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgc29ja2V0XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24oKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRoaXMud3Mub25vcGVuID0gZnVuY3Rpb24oKXtcbiAgICBzZWxmLm9uT3BlbigpO1xuICB9O1xuICB0aGlzLndzLm9uY2xvc2UgPSBmdW5jdGlvbigpe1xuICAgIHNlbGYub25DbG9zZSgpO1xuICB9O1xuICB0aGlzLndzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2KXtcbiAgICBzZWxmLm9uRGF0YShldi5kYXRhKTtcbiAgfTtcbiAgdGhpcy53cy5vbmVycm9yID0gZnVuY3Rpb24oZSl7XG4gICAgc2VsZi5vbkVycm9yKCd3ZWJzb2NrZXQgZXJyb3InLCBlKTtcbiAgfTtcbn07XG5cbi8qKlxuICogT3ZlcnJpZGUgYG9uRGF0YWAgdG8gdXNlIGEgdGltZXIgb24gaU9TLlxuICogU2VlOiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9tbG91Z2hyYW4vMjA1MjAwNlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmlmICgndW5kZWZpbmVkJyAhPSB0eXBlb2YgbmF2aWdhdG9yXG4gICYmIC9pUGFkfGlQaG9uZXxpUG9kL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICBXUy5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24oZGF0YSl7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIFRyYW5zcG9ydC5wcm90b3R5cGUub25EYXRhLmNhbGwoc2VsZiwgZGF0YSk7XG4gICAgfSwgMCk7XG4gIH07XG59XG5cbi8qKlxuICogV3JpdGVzIGRhdGEgdG8gc29ja2V0LlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IG9mIHBhY2tldHMuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihwYWNrZXRzKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgLy8gZW5jb2RlUGFja2V0IGVmZmljaWVudCBhcyBpdCB1c2VzIFdTIGZyYW1pbmdcbiAgLy8gbm8gbmVlZCBmb3IgZW5jb2RlUGF5bG9hZFxuICB2YXIgdG90YWwgPSBwYWNrZXRzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB0b3RhbDsgaSA8IGw7IGkrKykge1xuICAgIChmdW5jdGlvbihwYWNrZXQpIHtcbiAgICAgIHBhcnNlci5lbmNvZGVQYWNrZXQocGFja2V0LCBzZWxmLnN1cHBvcnRzQmluYXJ5LCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIGlmICghQnJvd3NlcldlYlNvY2tldCkge1xuICAgICAgICAgIC8vIGFsd2F5cyBjcmVhdGUgYSBuZXcgb2JqZWN0IChHSC00MzcpXG4gICAgICAgICAgdmFyIG9wdHMgPSB7fTtcbiAgICAgICAgICBpZiAocGFja2V0Lm9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdHMuY29tcHJlc3MgPSBwYWNrZXQub3B0aW9ucy5jb21wcmVzcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VsZi5wZXJNZXNzYWdlRGVmbGF0ZSkge1xuICAgICAgICAgICAgdmFyIGxlbiA9ICdzdHJpbmcnID09IHR5cGVvZiBkYXRhID8gZ2xvYmFsLkJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpIDogZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobGVuIDwgc2VsZi5wZXJNZXNzYWdlRGVmbGF0ZS50aHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgb3B0cy5jb21wcmVzcyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vU29tZXRpbWVzIHRoZSB3ZWJzb2NrZXQgaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQgYnV0IHRoZSBicm93c2VyIGRpZG4ndFxuICAgICAgICAvL2hhdmUgYSBjaGFuY2Ugb2YgaW5mb3JtaW5nIHVzIGFib3V0IGl0IHlldCwgaW4gdGhhdCBjYXNlIHNlbmQgd2lsbFxuICAgICAgICAvL3Rocm93IGFuIGVycm9yXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKEJyb3dzZXJXZWJTb2NrZXQpIHtcbiAgICAgICAgICAgIC8vIFR5cGVFcnJvciBpcyB0aHJvd24gd2hlbiBwYXNzaW5nIHRoZSBzZWNvbmQgYXJndW1lbnQgb24gU2FmYXJpXG4gICAgICAgICAgICBzZWxmLndzLnNlbmQoZGF0YSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYud3Muc2VuZChkYXRhLCBvcHRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgIGRlYnVnKCd3ZWJzb2NrZXQgY2xvc2VkIGJlZm9yZSBvbmNsb3NlIGV2ZW50Jyk7XG4gICAgICAgIH1cblxuICAgICAgICAtLXRvdGFsIHx8IGRvbmUoKTtcbiAgICAgIH0pO1xuICAgIH0pKHBhY2tldHNbaV0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZG9uZSgpe1xuICAgIHNlbGYuZW1pdCgnZmx1c2gnKTtcblxuICAgIC8vIGZha2UgZHJhaW5cbiAgICAvLyBkZWZlciB0byBuZXh0IHRpY2sgdG8gYWxsb3cgU29ja2V0IHRvIGNsZWFyIHdyaXRlQnVmZmVyXG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgc2VsZi53cml0YWJsZSA9IHRydWU7XG4gICAgICBzZWxmLmVtaXQoJ2RyYWluJyk7XG4gICAgfSwgMCk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gY2xvc2VcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUub25DbG9zZSA9IGZ1bmN0aW9uKCl7XG4gIFRyYW5zcG9ydC5wcm90b3R5cGUub25DbG9zZS5jYWxsKHRoaXMpO1xufTtcblxuLyoqXG4gKiBDbG9zZXMgc29ja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS5kb0Nsb3NlID0gZnVuY3Rpb24oKXtcbiAgaWYgKHR5cGVvZiB0aGlzLndzICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRoaXMud3MuY2xvc2UoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgdXJpIGZvciBjb25uZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS51cmkgPSBmdW5jdGlvbigpe1xuICB2YXIgcXVlcnkgPSB0aGlzLnF1ZXJ5IHx8IHt9O1xuICB2YXIgc2NoZW1hID0gdGhpcy5zZWN1cmUgPyAnd3NzJyA6ICd3cyc7XG4gIHZhciBwb3J0ID0gJyc7XG5cbiAgLy8gYXZvaWQgcG9ydCBpZiBkZWZhdWx0IGZvciBzY2hlbWFcbiAgaWYgKHRoaXMucG9ydCAmJiAoKCd3c3MnID09IHNjaGVtYSAmJiB0aGlzLnBvcnQgIT0gNDQzKVxuICAgIHx8ICgnd3MnID09IHNjaGVtYSAmJiB0aGlzLnBvcnQgIT0gODApKSkge1xuICAgIHBvcnQgPSAnOicgKyB0aGlzLnBvcnQ7XG4gIH1cblxuICAvLyBhcHBlbmQgdGltZXN0YW1wIHRvIFVSSVxuICBpZiAodGhpcy50aW1lc3RhbXBSZXF1ZXN0cykge1xuICAgIHF1ZXJ5W3RoaXMudGltZXN0YW1wUGFyYW1dID0geWVhc3QoKTtcbiAgfVxuXG4gIC8vIGNvbW11bmljYXRlIGJpbmFyeSBzdXBwb3J0IGNhcGFiaWxpdGllc1xuICBpZiAoIXRoaXMuc3VwcG9ydHNCaW5hcnkpIHtcbiAgICBxdWVyeS5iNjQgPSAxO1xuICB9XG5cbiAgcXVlcnkgPSBwYXJzZXFzLmVuY29kZShxdWVyeSk7XG5cbiAgLy8gcHJlcGVuZCA/IHRvIHF1ZXJ5XG4gIGlmIChxdWVyeS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9ICc/JyArIHF1ZXJ5O1xuICB9XG5cbiAgdmFyIGlwdjYgPSB0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSAhPT0gLTE7XG4gIHJldHVybiBzY2hlbWEgKyAnOi8vJyArIChpcHY2ID8gJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyA6IHRoaXMuaG9zdG5hbWUpICsgcG9ydCArIHRoaXMucGF0aCArIHF1ZXJ5O1xufTtcblxuLyoqXG4gKiBGZWF0dXJlIGRldGVjdGlvbiBmb3IgV2ViU29ja2V0LlxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHdoZXRoZXIgdGhpcyB0cmFuc3BvcnQgaXMgYXZhaWxhYmxlLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5XUy5wcm90b3R5cGUuY2hlY2sgPSBmdW5jdGlvbigpe1xuICByZXR1cm4gISFXZWJTb2NrZXQgJiYgISgnX19pbml0aWFsaXplJyBpbiBXZWJTb2NrZXQgJiYgdGhpcy5uYW1lID09PSBXUy5wcm90b3R5cGUubmFtZSk7XG59O1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB7fSlcbn0se1wiLi4vdHJhbnNwb3J0XCI6MTksXCJjb21wb25lbnQtaW5oZXJpdFwiOjEzLFwiZGVidWdcIjoxNCxcImVuZ2luZS5pby1wYXJzZXJcIjoyNyxcInBhcnNlcXNcIjozNyxcIndzXCI6dW5kZWZpbmVkLFwieWVhc3RcIjo0NX1dLDI1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8vIGJyb3dzZXIgc2hpbSBmb3IgeG1saHR0cHJlcXVlc3QgbW9kdWxlXG52YXIgaGFzQ09SUyA9IF9kZXJlcV8oJ2hhcy1jb3JzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3B0cykge1xuICB2YXIgeGRvbWFpbiA9IG9wdHMueGRvbWFpbjtcblxuICAvLyBzY2hlbWUgbXVzdCBiZSBzYW1lIHdoZW4gdXNpZ24gWERvbWFpblJlcXVlc3RcbiAgLy8gaHR0cDovL2Jsb2dzLm1zZG4uY29tL2IvaWVpbnRlcm5hbHMvYXJjaGl2ZS8yMDEwLzA1LzEzL3hkb21haW5yZXF1ZXN0LXJlc3RyaWN0aW9ucy1saW1pdGF0aW9ucy1hbmQtd29ya2Fyb3VuZHMuYXNweFxuICB2YXIgeHNjaGVtZSA9IG9wdHMueHNjaGVtZTtcblxuICAvLyBYRG9tYWluUmVxdWVzdCBoYXMgYSBmbG93IG9mIG5vdCBzZW5kaW5nIGNvb2tpZSwgdGhlcmVmb3JlIGl0IHNob3VsZCBiZSBkaXNhYmxlZCBhcyBhIGRlZmF1bHQuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9BdXRvbWF0dGljL2VuZ2luZS5pby1jbGllbnQvcHVsbC8yMTdcbiAgdmFyIGVuYWJsZXNYRFIgPSBvcHRzLmVuYWJsZXNYRFI7XG5cbiAgLy8gWE1MSHR0cFJlcXVlc3QgY2FuIGJlIGRpc2FibGVkIG9uIElFXG4gIHRyeSB7XG4gICAgaWYgKCd1bmRlZmluZWQnICE9IHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAmJiAoIXhkb21haW4gfHwgaGFzQ09SUykpIHtcbiAgICAgIHJldHVybiBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHsgfVxuXG4gIC8vIFVzZSBYRG9tYWluUmVxdWVzdCBmb3IgSUU4IGlmIGVuYWJsZXNYRFIgaXMgdHJ1ZVxuICAvLyBiZWNhdXNlIGxvYWRpbmcgYmFyIGtlZXBzIGZsYXNoaW5nIHdoZW4gdXNpbmcganNvbnAtcG9sbGluZ1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20veXVqaW9zYWthL3NvY2tlLmlvLWllOC1sb2FkaW5nLWV4YW1wbGVcbiAgdHJ5IHtcbiAgICBpZiAoJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIFhEb21haW5SZXF1ZXN0ICYmICF4c2NoZW1lICYmIGVuYWJsZXNYRFIpIHtcbiAgICAgIHJldHVybiBuZXcgWERvbWFpblJlcXVlc3QoKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHsgfVxuXG4gIGlmICgheGRvbWFpbikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01pY3Jvc29mdC5YTUxIVFRQJyk7XG4gICAgfSBjYXRjaChlKSB7IH1cbiAgfVxufVxuXG59LHtcImhhcy1jb3JzXCI6MzF9XSwyNjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cbi8qKlxuICogRXhwb3NlIGBFbWl0dGVyYC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVtaXR0ZXI7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgRW1pdHRlcmAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBFbWl0dGVyKG9iaikge1xuICBpZiAob2JqKSByZXR1cm4gbWl4aW4ob2JqKTtcbn07XG5cbi8qKlxuICogTWl4aW4gdGhlIGVtaXR0ZXIgcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBtaXhpbihvYmopIHtcbiAgZm9yICh2YXIga2V5IGluIEVtaXR0ZXIucHJvdG90eXBlKSB7XG4gICAgb2JqW2tleV0gPSBFbWl0dGVyLnByb3RvdHlwZVtrZXldO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogTGlzdGVuIG9uIHRoZSBnaXZlbiBgZXZlbnRgIHdpdGggYGZuYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5vbiA9XG5FbWl0dGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICAodGhpcy5fY2FsbGJhY2tzW2V2ZW50XSA9IHRoaXMuX2NhbGxiYWNrc1tldmVudF0gfHwgW10pXG4gICAgLnB1c2goZm4pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkcyBhbiBgZXZlbnRgIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBpbnZva2VkIGEgc2luZ2xlXG4gKiB0aW1lIHRoZW4gYXV0b21hdGljYWxseSByZW1vdmVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcblxuICBmdW5jdGlvbiBvbigpIHtcbiAgICBzZWxmLm9mZihldmVudCwgb24pO1xuICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBvbi5mbiA9IGZuO1xuICB0aGlzLm9uKGV2ZW50LCBvbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBgZXZlbnRgIG9yIGFsbFxuICogcmVnaXN0ZXJlZCBjYWxsYmFja3MuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUub2ZmID1cbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuXG4gIC8vIGFsbFxuICBpZiAoMCA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgdGhpcy5fY2FsbGJhY2tzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzcGVjaWZpYyBldmVudFxuICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XTtcbiAgaWYgKCFjYWxsYmFja3MpIHJldHVybiB0aGlzO1xuXG4gIC8vIHJlbW92ZSBhbGwgaGFuZGxlcnNcbiAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gcmVtb3ZlIHNwZWNpZmljIGhhbmRsZXJcbiAgdmFyIGNiO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgIGNiID0gY2FsbGJhY2tzW2ldO1xuICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICBjYWxsYmFja3Muc3BsaWNlKGksIDEpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFbWl0IGBldmVudGAgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7TWl4ZWR9IC4uLlxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oZXZlbnQpe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXG4gICAgLCBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdO1xuXG4gIGlmIChjYWxsYmFja3MpIHtcbiAgICBjYWxsYmFja3MgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgY2FsbGJhY2tzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYXJyYXkgb2YgY2FsbGJhY2tzIGZvciBgZXZlbnRgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XSB8fCBbXTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhpcyBlbWl0dGVyIGhhcyBgZXZlbnRgIGhhbmRsZXJzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUuaGFzTGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xuICByZXR1cm4gISEgdGhpcy5saXN0ZW5lcnMoZXZlbnQpLmxlbmd0aDtcbn07XG5cbn0se31dLDI3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIga2V5cyA9IF9kZXJlcV8oJy4va2V5cycpO1xudmFyIGhhc0JpbmFyeSA9IF9kZXJlcV8oJ2hhcy1iaW5hcnknKTtcbnZhciBzbGljZUJ1ZmZlciA9IF9kZXJlcV8oJ2FycmF5YnVmZmVyLnNsaWNlJyk7XG52YXIgYmFzZTY0ZW5jb2RlciA9IF9kZXJlcV8oJ2Jhc2U2NC1hcnJheWJ1ZmZlcicpO1xudmFyIGFmdGVyID0gX2RlcmVxXygnYWZ0ZXInKTtcbnZhciB1dGY4ID0gX2RlcmVxXygndXRmOCcpO1xuXG4vKipcbiAqIENoZWNrIGlmIHdlIGFyZSBydW5uaW5nIGFuIGFuZHJvaWQgYnJvd3Nlci4gVGhhdCByZXF1aXJlcyB1cyB0byB1c2VcbiAqIEFycmF5QnVmZmVyIHdpdGggcG9sbGluZyB0cmFuc3BvcnRzLi4uXG4gKlxuICogaHR0cDovL2doaW5kYS5uZXQvanBlZy1ibG9iLWFqYXgtYW5kcm9pZC9cbiAqL1xuXG52YXIgaXNBbmRyb2lkID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvQW5kcm9pZC9pKTtcblxuLyoqXG4gKiBDaGVjayBpZiB3ZSBhcmUgcnVubmluZyBpbiBQaGFudG9tSlMuXG4gKiBVcGxvYWRpbmcgYSBCbG9iIHdpdGggUGhhbnRvbUpTIGRvZXMgbm90IHdvcmsgY29ycmVjdGx5LCBhcyByZXBvcnRlZCBoZXJlOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2FyaXlhL3BoYW50b21qcy9pc3N1ZXMvMTEzOTVcbiAqIEB0eXBlIGJvb2xlYW5cbiAqL1xudmFyIGlzUGhhbnRvbUpTID0gL1BoYW50b21KUy9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbi8qKlxuICogV2hlbiB0cnVlLCBhdm9pZHMgdXNpbmcgQmxvYnMgdG8gZW5jb2RlIHBheWxvYWRzLlxuICogQHR5cGUgYm9vbGVhblxuICovXG52YXIgZG9udFNlbmRCbG9icyA9IGlzQW5kcm9pZCB8fCBpc1BoYW50b21KUztcblxuLyoqXG4gKiBDdXJyZW50IHByb3RvY29sIHZlcnNpb24uXG4gKi9cblxuZXhwb3J0cy5wcm90b2NvbCA9IDM7XG5cbi8qKlxuICogUGFja2V0IHR5cGVzLlxuICovXG5cbnZhciBwYWNrZXRzID0gZXhwb3J0cy5wYWNrZXRzID0ge1xuICAgIG9wZW46ICAgICAwICAgIC8vIG5vbi13c1xuICAsIGNsb3NlOiAgICAxICAgIC8vIG5vbi13c1xuICAsIHBpbmc6ICAgICAyXG4gICwgcG9uZzogICAgIDNcbiAgLCBtZXNzYWdlOiAgNFxuICAsIHVwZ3JhZGU6ICA1XG4gICwgbm9vcDogICAgIDZcbn07XG5cbnZhciBwYWNrZXRzbGlzdCA9IGtleXMocGFja2V0cyk7XG5cbi8qKlxuICogUHJlbWFkZSBlcnJvciBwYWNrZXQuXG4gKi9cblxudmFyIGVyciA9IHsgdHlwZTogJ2Vycm9yJywgZGF0YTogJ3BhcnNlciBlcnJvcicgfTtcblxuLyoqXG4gKiBDcmVhdGUgYSBibG9iIGFwaSBldmVuIGZvciBibG9iIGJ1aWxkZXIgd2hlbiB2ZW5kb3IgcHJlZml4ZXMgZXhpc3RcbiAqL1xuXG52YXIgQmxvYiA9IF9kZXJlcV8oJ2Jsb2InKTtcblxuLyoqXG4gKiBFbmNvZGVzIGEgcGFja2V0LlxuICpcbiAqICAgICA8cGFja2V0IHR5cGUgaWQ+IFsgPGRhdGE+IF1cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICA1aGVsbG8gd29ybGRcbiAqICAgICAzXG4gKiAgICAgNFxuICpcbiAqIEJpbmFyeSBpcyBlbmNvZGVkIGluIGFuIGlkZW50aWNhbCBwcmluY2lwbGVcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmVuY29kZVBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCB1dGY4ZW5jb2RlLCBjYWxsYmFjaykge1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2Ygc3VwcG9ydHNCaW5hcnkpIHtcbiAgICBjYWxsYmFjayA9IHN1cHBvcnRzQmluYXJ5O1xuICAgIHN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cblxuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgdXRmOGVuY29kZSkge1xuICAgIGNhbGxiYWNrID0gdXRmOGVuY29kZTtcbiAgICB1dGY4ZW5jb2RlID0gbnVsbDtcbiAgfVxuXG4gIHZhciBkYXRhID0gKHBhY2tldC5kYXRhID09PSB1bmRlZmluZWQpXG4gICAgPyB1bmRlZmluZWRcbiAgICA6IHBhY2tldC5kYXRhLmJ1ZmZlciB8fCBwYWNrZXQuZGF0YTtcblxuICBpZiAoZ2xvYmFsLkFycmF5QnVmZmVyICYmIGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBlbmNvZGVBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjayk7XG4gIH0gZWxzZSBpZiAoQmxvYiAmJiBkYXRhIGluc3RhbmNlb2YgZ2xvYmFsLkJsb2IpIHtcbiAgICByZXR1cm4gZW5jb2RlQmxvYihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjayk7XG4gIH1cblxuICAvLyBtaWdodCBiZSBhbiBvYmplY3Qgd2l0aCB7IGJhc2U2NDogdHJ1ZSwgZGF0YTogZGF0YUFzQmFzZTY0U3RyaW5nIH1cbiAgaWYgKGRhdGEgJiYgZGF0YS5iYXNlNjQpIHtcbiAgICByZXR1cm4gZW5jb2RlQmFzZTY0T2JqZWN0KHBhY2tldCwgY2FsbGJhY2spO1xuICB9XG5cbiAgLy8gU2VuZGluZyBkYXRhIGFzIGEgdXRmLTggc3RyaW5nXG4gIHZhciBlbmNvZGVkID0gcGFja2V0c1twYWNrZXQudHlwZV07XG5cbiAgLy8gZGF0YSBmcmFnbWVudCBpcyBvcHRpb25hbFxuICBpZiAodW5kZWZpbmVkICE9PSBwYWNrZXQuZGF0YSkge1xuICAgIGVuY29kZWQgKz0gdXRmOGVuY29kZSA/IHV0ZjguZW5jb2RlKFN0cmluZyhwYWNrZXQuZGF0YSkpIDogU3RyaW5nKHBhY2tldC5kYXRhKTtcbiAgfVxuXG4gIHJldHVybiBjYWxsYmFjaygnJyArIGVuY29kZWQpO1xuXG59O1xuXG5mdW5jdGlvbiBlbmNvZGVCYXNlNjRPYmplY3QocGFja2V0LCBjYWxsYmFjaykge1xuICAvLyBwYWNrZXQgZGF0YSBpcyBhbiBvYmplY3QgeyBiYXNlNjQ6IHRydWUsIGRhdGE6IGRhdGFBc0Jhc2U2NFN0cmluZyB9XG4gIHZhciBtZXNzYWdlID0gJ2InICsgZXhwb3J0cy5wYWNrZXRzW3BhY2tldC50eXBlXSArIHBhY2tldC5kYXRhLmRhdGE7XG4gIHJldHVybiBjYWxsYmFjayhtZXNzYWdlKTtcbn1cblxuLyoqXG4gKiBFbmNvZGUgcGFja2V0IGhlbHBlcnMgZm9yIGJpbmFyeSB0eXBlc1xuICovXG5cbmZ1bmN0aW9uIGVuY29kZUFycmF5QnVmZmVyKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKSB7XG4gIGlmICghc3VwcG9ydHNCaW5hcnkpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQocGFja2V0LCBjYWxsYmFjayk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHBhY2tldC5kYXRhO1xuICB2YXIgY29udGVudEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIHZhciByZXN1bHRCdWZmZXIgPSBuZXcgVWludDhBcnJheSgxICsgZGF0YS5ieXRlTGVuZ3RoKTtcblxuICByZXN1bHRCdWZmZXJbMF0gPSBwYWNrZXRzW3BhY2tldC50eXBlXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250ZW50QXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICByZXN1bHRCdWZmZXJbaSsxXSA9IGNvbnRlbnRBcnJheVtpXTtcbiAgfVxuXG4gIHJldHVybiBjYWxsYmFjayhyZXN1bHRCdWZmZXIuYnVmZmVyKTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlQmxvYkFzQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcbiAgaWYgKCFzdXBwb3J0c0JpbmFyeSkge1xuICAgIHJldHVybiBleHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldChwYWNrZXQsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIHZhciBmciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gIGZyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIHBhY2tldC5kYXRhID0gZnIucmVzdWx0O1xuICAgIGV4cG9ydHMuZW5jb2RlUGFja2V0KHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIHRydWUsIGNhbGxiYWNrKTtcbiAgfTtcbiAgcmV0dXJuIGZyLnJlYWRBc0FycmF5QnVmZmVyKHBhY2tldC5kYXRhKTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlQmxvYihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICBpZiAoIXN1cHBvcnRzQmluYXJ5KSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0KHBhY2tldCwgY2FsbGJhY2spO1xuICB9XG5cbiAgaWYgKGRvbnRTZW5kQmxvYnMpIHtcbiAgICByZXR1cm4gZW5jb2RlQmxvYkFzQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spO1xuICB9XG5cbiAgdmFyIGxlbmd0aCA9IG5ldyBVaW50OEFycmF5KDEpO1xuICBsZW5ndGhbMF0gPSBwYWNrZXRzW3BhY2tldC50eXBlXTtcbiAgdmFyIGJsb2IgPSBuZXcgQmxvYihbbGVuZ3RoLmJ1ZmZlciwgcGFja2V0LmRhdGFdKTtcblxuICByZXR1cm4gY2FsbGJhY2soYmxvYik7XG59XG5cbi8qKlxuICogRW5jb2RlcyBhIHBhY2tldCB3aXRoIGJpbmFyeSBkYXRhIGluIGEgYmFzZTY0IHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQsIGhhcyBgdHlwZWAgYW5kIGBkYXRhYFxuICogQHJldHVybiB7U3RyaW5nfSBiYXNlNjQgZW5jb2RlZCBtZXNzYWdlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQsIGNhbGxiYWNrKSB7XG4gIHZhciBtZXNzYWdlID0gJ2InICsgZXhwb3J0cy5wYWNrZXRzW3BhY2tldC50eXBlXTtcbiAgaWYgKEJsb2IgJiYgcGFja2V0LmRhdGEgaW5zdGFuY2VvZiBnbG9iYWwuQmxvYikge1xuICAgIHZhciBmciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgZnIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYjY0ID0gZnIucmVzdWx0LnNwbGl0KCcsJylbMV07XG4gICAgICBjYWxsYmFjayhtZXNzYWdlICsgYjY0KTtcbiAgICB9O1xuICAgIHJldHVybiBmci5yZWFkQXNEYXRhVVJMKHBhY2tldC5kYXRhKTtcbiAgfVxuXG4gIHZhciBiNjRkYXRhO1xuICB0cnkge1xuICAgIGI2NGRhdGEgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KHBhY2tldC5kYXRhKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBpUGhvbmUgU2FmYXJpIGRvZXNuJ3QgbGV0IHlvdSBhcHBseSB3aXRoIHR5cGVkIGFycmF5c1xuICAgIHZhciB0eXBlZCA9IG5ldyBVaW50OEFycmF5KHBhY2tldC5kYXRhKTtcbiAgICB2YXIgYmFzaWMgPSBuZXcgQXJyYXkodHlwZWQubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBiYXNpY1tpXSA9IHR5cGVkW2ldO1xuICAgIH1cbiAgICBiNjRkYXRhID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBiYXNpYyk7XG4gIH1cbiAgbWVzc2FnZSArPSBnbG9iYWwuYnRvYShiNjRkYXRhKTtcbiAgcmV0dXJuIGNhbGxiYWNrKG1lc3NhZ2UpO1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIGEgcGFja2V0LiBDaGFuZ2VzIGZvcm1hdCB0byBCbG9iIGlmIHJlcXVlc3RlZC5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IHdpdGggYHR5cGVgIGFuZCBgZGF0YWAgKGlmIGFueSlcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZGVjb2RlUGFja2V0ID0gZnVuY3Rpb24gKGRhdGEsIGJpbmFyeVR5cGUsIHV0ZjhkZWNvZGUpIHtcbiAgLy8gU3RyaW5nIGRhdGFcbiAgaWYgKHR5cGVvZiBkYXRhID09ICdzdHJpbmcnIHx8IGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChkYXRhLmNoYXJBdCgwKSA9PSAnYicpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlY29kZUJhc2U2NFBhY2tldChkYXRhLnN1YnN0cigxKSwgYmluYXJ5VHlwZSk7XG4gICAgfVxuXG4gICAgaWYgKHV0ZjhkZWNvZGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRhdGEgPSB1dGY4LmRlY29kZShkYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHR5cGUgPSBkYXRhLmNoYXJBdCgwKTtcblxuICAgIGlmIChOdW1iZXIodHlwZSkgIT0gdHlwZSB8fCAhcGFja2V0c2xpc3RbdHlwZV0pIHtcbiAgICAgIHJldHVybiBlcnI7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEubGVuZ3RoID4gMSkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogcGFja2V0c2xpc3RbdHlwZV0sIGRhdGE6IGRhdGEuc3Vic3RyaW5nKDEpIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IHBhY2tldHNsaXN0W3R5cGVdIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIGFzQXJyYXkgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgdmFyIHR5cGUgPSBhc0FycmF5WzBdO1xuICB2YXIgcmVzdCA9IHNsaWNlQnVmZmVyKGRhdGEsIDEpO1xuICBpZiAoQmxvYiAmJiBiaW5hcnlUeXBlID09PSAnYmxvYicpIHtcbiAgICByZXN0ID0gbmV3IEJsb2IoW3Jlc3RdKTtcbiAgfVxuICByZXR1cm4geyB0eXBlOiBwYWNrZXRzbGlzdFt0eXBlXSwgZGF0YTogcmVzdCB9O1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIGEgcGFja2V0IGVuY29kZWQgaW4gYSBiYXNlNjQgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGJhc2U2NCBlbmNvZGVkIG1lc3NhZ2VcbiAqIEByZXR1cm4ge09iamVjdH0gd2l0aCBgdHlwZWAgYW5kIGBkYXRhYCAoaWYgYW55KVxuICovXG5cbmV4cG9ydHMuZGVjb2RlQmFzZTY0UGFja2V0ID0gZnVuY3Rpb24obXNnLCBiaW5hcnlUeXBlKSB7XG4gIHZhciB0eXBlID0gcGFja2V0c2xpc3RbbXNnLmNoYXJBdCgwKV07XG4gIGlmICghZ2xvYmFsLkFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogdHlwZSwgZGF0YTogeyBiYXNlNjQ6IHRydWUsIGRhdGE6IG1zZy5zdWJzdHIoMSkgfSB9O1xuICB9XG5cbiAgdmFyIGRhdGEgPSBiYXNlNjRlbmNvZGVyLmRlY29kZShtc2cuc3Vic3RyKDEpKTtcblxuICBpZiAoYmluYXJ5VHlwZSA9PT0gJ2Jsb2InICYmIEJsb2IpIHtcbiAgICBkYXRhID0gbmV3IEJsb2IoW2RhdGFdKTtcbiAgfVxuXG4gIHJldHVybiB7IHR5cGU6IHR5cGUsIGRhdGE6IGRhdGEgfTtcbn07XG5cbi8qKlxuICogRW5jb2RlcyBtdWx0aXBsZSBtZXNzYWdlcyAocGF5bG9hZCkuXG4gKlxuICogICAgIDxsZW5ndGg+OmRhdGFcbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICAxMTpoZWxsbyB3b3JsZDI6aGlcbiAqXG4gKiBJZiBhbnkgY29udGVudHMgYXJlIGJpbmFyeSwgdGhleSB3aWxsIGJlIGVuY29kZWQgYXMgYmFzZTY0IHN0cmluZ3MuIEJhc2U2NFxuICogZW5jb2RlZCBzdHJpbmdzIGFyZSBtYXJrZWQgd2l0aCBhIGIgYmVmb3JlIHRoZSBsZW5ndGggc3BlY2lmaWVyXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVQYXlsb2FkID0gZnVuY3Rpb24gKHBhY2tldHMsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIHN1cHBvcnRzQmluYXJ5ID09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IHN1cHBvcnRzQmluYXJ5O1xuICAgIHN1cHBvcnRzQmluYXJ5ID0gbnVsbDtcbiAgfVxuXG4gIHZhciBpc0JpbmFyeSA9IGhhc0JpbmFyeShwYWNrZXRzKTtcblxuICBpZiAoc3VwcG9ydHNCaW5hcnkgJiYgaXNCaW5hcnkpIHtcbiAgICBpZiAoQmxvYiAmJiAhZG9udFNlbmRCbG9icykge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlUGF5bG9hZEFzQmxvYihwYWNrZXRzLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlUGF5bG9hZEFzQXJyYXlCdWZmZXIocGFja2V0cywgY2FsbGJhY2spO1xuICB9XG5cbiAgaWYgKCFwYWNrZXRzLmxlbmd0aCkge1xuICAgIHJldHVybiBjYWxsYmFjaygnMDonKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldExlbmd0aEhlYWRlcihtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG1lc3NhZ2UubGVuZ3RoICsgJzonICsgbWVzc2FnZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuY29kZU9uZShwYWNrZXQsIGRvbmVDYWxsYmFjaykge1xuICAgIGV4cG9ydHMuZW5jb2RlUGFja2V0KHBhY2tldCwgIWlzQmluYXJ5ID8gZmFsc2UgOiBzdXBwb3J0c0JpbmFyeSwgdHJ1ZSwgZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgZG9uZUNhbGxiYWNrKG51bGwsIHNldExlbmd0aEhlYWRlcihtZXNzYWdlKSk7XG4gICAgfSk7XG4gIH1cblxuICBtYXAocGFja2V0cywgZW5jb2RlT25lLCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAgICByZXR1cm4gY2FsbGJhY2socmVzdWx0cy5qb2luKCcnKSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBBc3luYyBhcnJheSBtYXAgdXNpbmcgYWZ0ZXJcbiAqL1xuXG5mdW5jdGlvbiBtYXAoYXJ5LCBlYWNoLCBkb25lKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgQXJyYXkoYXJ5Lmxlbmd0aCk7XG4gIHZhciBuZXh0ID0gYWZ0ZXIoYXJ5Lmxlbmd0aCwgZG9uZSk7XG5cbiAgdmFyIGVhY2hXaXRoSW5kZXggPSBmdW5jdGlvbihpLCBlbCwgY2IpIHtcbiAgICBlYWNoKGVsLCBmdW5jdGlvbihlcnJvciwgbXNnKSB7XG4gICAgICByZXN1bHRbaV0gPSBtc2c7XG4gICAgICBjYihlcnJvciwgcmVzdWx0KTtcbiAgICB9KTtcbiAgfTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyeS5sZW5ndGg7IGkrKykge1xuICAgIGVhY2hXaXRoSW5kZXgoaSwgYXJ5W2ldLCBuZXh0KTtcbiAgfVxufVxuXG4vKlxuICogRGVjb2RlcyBkYXRhIHdoZW4gYSBwYXlsb2FkIGlzIG1heWJlIGV4cGVjdGVkLiBQb3NzaWJsZSBiaW5hcnkgY29udGVudHMgYXJlXG4gKiBkZWNvZGVkIGZyb20gdGhlaXIgYmFzZTY0IHJlcHJlc2VudGF0aW9uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGEsIGNhbGxiYWNrIG1ldGhvZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmRlY29kZVBheWxvYWQgPSBmdW5jdGlvbiAoZGF0YSwgYmluYXJ5VHlwZSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBkYXRhICE9ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZGVjb2RlUGF5bG9hZEFzQmluYXJ5KGRhdGEsIGJpbmFyeVR5cGUsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYmluYXJ5VHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gYmluYXJ5VHlwZTtcbiAgICBiaW5hcnlUeXBlID0gbnVsbDtcbiAgfVxuXG4gIHZhciBwYWNrZXQ7XG4gIGlmIChkYXRhID09ICcnKSB7XG4gICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICB9XG5cbiAgdmFyIGxlbmd0aCA9ICcnXG4gICAgLCBuLCBtc2c7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBkYXRhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBjaHIgPSBkYXRhLmNoYXJBdChpKTtcblxuICAgIGlmICgnOicgIT0gY2hyKSB7XG4gICAgICBsZW5ndGggKz0gY2hyO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoJycgPT0gbGVuZ3RoIHx8IChsZW5ndGggIT0gKG4gPSBOdW1iZXIobGVuZ3RoKSkpKSB7XG4gICAgICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgICB9XG5cbiAgICAgIG1zZyA9IGRhdGEuc3Vic3RyKGkgKyAxLCBuKTtcblxuICAgICAgaWYgKGxlbmd0aCAhPSBtc2cubGVuZ3RoKSB7XG4gICAgICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtc2cubGVuZ3RoKSB7XG4gICAgICAgIHBhY2tldCA9IGV4cG9ydHMuZGVjb2RlUGFja2V0KG1zZywgYmluYXJ5VHlwZSwgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKGVyci50eXBlID09IHBhY2tldC50eXBlICYmIGVyci5kYXRhID09IHBhY2tldC5kYXRhKSB7XG4gICAgICAgICAgLy8gcGFyc2VyIGVycm9yIGluIGluZGl2aWR1YWwgcGFja2V0IC0gaWdub3JpbmcgcGF5bG9hZFxuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJldCA9IGNhbGxiYWNrKHBhY2tldCwgaSArIG4sIGwpO1xuICAgICAgICBpZiAoZmFsc2UgPT09IHJldCkgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBhZHZhbmNlIGN1cnNvclxuICAgICAgaSArPSBuO1xuICAgICAgbGVuZ3RoID0gJyc7XG4gICAgfVxuICB9XG5cbiAgaWYgKGxlbmd0aCAhPSAnJykge1xuICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgfVxuXG59O1xuXG4vKipcbiAqIEVuY29kZXMgbXVsdGlwbGUgbWVzc2FnZXMgKHBheWxvYWQpIGFzIGJpbmFyeS5cbiAqXG4gKiA8MSA9IGJpbmFyeSwgMCA9IHN0cmluZz48bnVtYmVyIGZyb20gMC05PjxudW1iZXIgZnJvbSAwLTk+Wy4uLl08bnVtYmVyXG4gKiAyNTU+PGRhdGE+XG4gKlxuICogRXhhbXBsZTpcbiAqIDEgMyAyNTUgMSAyIDMsIGlmIHRoZSBiaW5hcnkgY29udGVudHMgYXJlIGludGVycHJldGVkIGFzIDggYml0IGludGVnZXJzXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuICogQHJldHVybiB7QXJyYXlCdWZmZXJ9IGVuY29kZWQgcGF5bG9hZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKHBhY2tldHMsIGNhbGxiYWNrKSB7XG4gIGlmICghcGFja2V0cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gY2FsbGJhY2sobmV3IEFycmF5QnVmZmVyKDApKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuY29kZU9uZShwYWNrZXQsIGRvbmVDYWxsYmFjaykge1xuICAgIGV4cG9ydHMuZW5jb2RlUGFja2V0KHBhY2tldCwgdHJ1ZSwgdHJ1ZSwgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgcmV0dXJuIGRvbmVDYWxsYmFjayhudWxsLCBkYXRhKTtcbiAgICB9KTtcbiAgfVxuXG4gIG1hcChwYWNrZXRzLCBlbmNvZGVPbmUsIGZ1bmN0aW9uKGVyciwgZW5jb2RlZFBhY2tldHMpIHtcbiAgICB2YXIgdG90YWxMZW5ndGggPSBlbmNvZGVkUGFja2V0cy5yZWR1Y2UoZnVuY3Rpb24oYWNjLCBwKSB7XG4gICAgICB2YXIgbGVuO1xuICAgICAgaWYgKHR5cGVvZiBwID09PSAnc3RyaW5nJyl7XG4gICAgICAgIGxlbiA9IHAubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVuID0gcC5ieXRlTGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYyArIGxlbi50b1N0cmluZygpLmxlbmd0aCArIGxlbiArIDI7IC8vIHN0cmluZy9iaW5hcnkgaWRlbnRpZmllciArIHNlcGFyYXRvciA9IDJcbiAgICB9LCAwKTtcblxuICAgIHZhciByZXN1bHRBcnJheSA9IG5ldyBVaW50OEFycmF5KHRvdGFsTGVuZ3RoKTtcblxuICAgIHZhciBidWZmZXJJbmRleCA9IDA7XG4gICAgZW5jb2RlZFBhY2tldHMuZm9yRWFjaChmdW5jdGlvbihwKSB7XG4gICAgICB2YXIgaXNTdHJpbmcgPSB0eXBlb2YgcCA9PT0gJ3N0cmluZyc7XG4gICAgICB2YXIgYWIgPSBwO1xuICAgICAgaWYgKGlzU3RyaW5nKSB7XG4gICAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkocC5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2aWV3W2ldID0gcC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIGFiID0gdmlldy5idWZmZXI7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1N0cmluZykgeyAvLyBub3QgdHJ1ZSBiaW5hcnlcbiAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSAwO1xuICAgICAgfSBlbHNlIHsgLy8gdHJ1ZSBiaW5hcnlcbiAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSAxO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGVuU3RyID0gYWIuYnl0ZUxlbmd0aC50b1N0cmluZygpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5TdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSBwYXJzZUludChsZW5TdHJbaV0pO1xuICAgICAgfVxuICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSAyNTU7XG5cbiAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYWIpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gdmlld1tpXTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBjYWxsYmFjayhyZXN1bHRBcnJheS5idWZmZXIpO1xuICB9KTtcbn07XG5cbi8qKlxuICogRW5jb2RlIGFzIEJsb2JcbiAqL1xuXG5leHBvcnRzLmVuY29kZVBheWxvYWRBc0Jsb2IgPSBmdW5jdGlvbihwYWNrZXRzLCBjYWxsYmFjaykge1xuICBmdW5jdGlvbiBlbmNvZGVPbmUocGFja2V0LCBkb25lQ2FsbGJhY2spIHtcbiAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsIHRydWUsIHRydWUsIGZ1bmN0aW9uKGVuY29kZWQpIHtcbiAgICAgIHZhciBiaW5hcnlJZGVudGlmaWVyID0gbmV3IFVpbnQ4QXJyYXkoMSk7XG4gICAgICBiaW5hcnlJZGVudGlmaWVyWzBdID0gMTtcbiAgICAgIGlmICh0eXBlb2YgZW5jb2RlZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShlbmNvZGVkLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5jb2RlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZpZXdbaV0gPSBlbmNvZGVkLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RlZCA9IHZpZXcuYnVmZmVyO1xuICAgICAgICBiaW5hcnlJZGVudGlmaWVyWzBdID0gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlbiA9IChlbmNvZGVkIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpXG4gICAgICAgID8gZW5jb2RlZC5ieXRlTGVuZ3RoXG4gICAgICAgIDogZW5jb2RlZC5zaXplO1xuXG4gICAgICB2YXIgbGVuU3RyID0gbGVuLnRvU3RyaW5nKCk7XG4gICAgICB2YXIgbGVuZ3RoQXJ5ID0gbmV3IFVpbnQ4QXJyYXkobGVuU3RyLmxlbmd0aCArIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5TdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGVuZ3RoQXJ5W2ldID0gcGFyc2VJbnQobGVuU3RyW2ldKTtcbiAgICAgIH1cbiAgICAgIGxlbmd0aEFyeVtsZW5TdHIubGVuZ3RoXSA9IDI1NTtcblxuICAgICAgaWYgKEJsb2IpIHtcbiAgICAgICAgdmFyIGJsb2IgPSBuZXcgQmxvYihbYmluYXJ5SWRlbnRpZmllci5idWZmZXIsIGxlbmd0aEFyeS5idWZmZXIsIGVuY29kZWRdKTtcbiAgICAgICAgZG9uZUNhbGxiYWNrKG51bGwsIGJsb2IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgbWFwKHBhY2tldHMsIGVuY29kZU9uZSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBCbG9iKHJlc3VsdHMpKTtcbiAgfSk7XG59O1xuXG4vKlxuICogRGVjb2RlcyBkYXRhIHdoZW4gYSBwYXlsb2FkIGlzIG1heWJlIGV4cGVjdGVkLiBTdHJpbmdzIGFyZSBkZWNvZGVkIGJ5XG4gKiBpbnRlcnByZXRpbmcgZWFjaCBieXRlIGFzIGEga2V5IGNvZGUgZm9yIGVudHJpZXMgbWFya2VkIHRvIHN0YXJ0IHdpdGggMC4gU2VlXG4gKiBkZXNjcmlwdGlvbiBvZiBlbmNvZGVQYXlsb2FkQXNCaW5hcnlcbiAqXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBkYXRhLCBjYWxsYmFjayBtZXRob2RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5kZWNvZGVQYXlsb2FkQXNCaW5hcnkgPSBmdW5jdGlvbiAoZGF0YSwgYmluYXJ5VHlwZSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBiaW5hcnlUeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBiaW5hcnlUeXBlO1xuICAgIGJpbmFyeVR5cGUgPSBudWxsO1xuICB9XG5cbiAgdmFyIGJ1ZmZlclRhaWwgPSBkYXRhO1xuICB2YXIgYnVmZmVycyA9IFtdO1xuXG4gIHZhciBudW1iZXJUb29Mb25nID0gZmFsc2U7XG4gIHdoaWxlIChidWZmZXJUYWlsLmJ5dGVMZW5ndGggPiAwKSB7XG4gICAgdmFyIHRhaWxBcnJheSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlclRhaWwpO1xuICAgIHZhciBpc1N0cmluZyA9IHRhaWxBcnJheVswXSA9PT0gMDtcbiAgICB2YXIgbXNnTGVuZ3RoID0gJyc7XG5cbiAgICBmb3IgKHZhciBpID0gMTsgOyBpKyspIHtcbiAgICAgIGlmICh0YWlsQXJyYXlbaV0gPT0gMjU1KSBicmVhaztcblxuICAgICAgaWYgKG1zZ0xlbmd0aC5sZW5ndGggPiAzMTApIHtcbiAgICAgICAgbnVtYmVyVG9vTG9uZyA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBtc2dMZW5ndGggKz0gdGFpbEFycmF5W2ldO1xuICAgIH1cblxuICAgIGlmKG51bWJlclRvb0xvbmcpIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuXG4gICAgYnVmZmVyVGFpbCA9IHNsaWNlQnVmZmVyKGJ1ZmZlclRhaWwsIDIgKyBtc2dMZW5ndGgubGVuZ3RoKTtcbiAgICBtc2dMZW5ndGggPSBwYXJzZUludChtc2dMZW5ndGgpO1xuXG4gICAgdmFyIG1zZyA9IHNsaWNlQnVmZmVyKGJ1ZmZlclRhaWwsIDAsIG1zZ0xlbmd0aCk7XG4gICAgaWYgKGlzU3RyaW5nKSB7XG4gICAgICB0cnkge1xuICAgICAgICBtc2cgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KG1zZykpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBpUGhvbmUgU2FmYXJpIGRvZXNuJ3QgbGV0IHlvdSBhcHBseSB0byB0eXBlZCBhcnJheXNcbiAgICAgICAgdmFyIHR5cGVkID0gbmV3IFVpbnQ4QXJyYXkobXNnKTtcbiAgICAgICAgbXNnID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBtc2cgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh0eXBlZFtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBidWZmZXJzLnB1c2gobXNnKTtcbiAgICBidWZmZXJUYWlsID0gc2xpY2VCdWZmZXIoYnVmZmVyVGFpbCwgbXNnTGVuZ3RoKTtcbiAgfVxuXG4gIHZhciB0b3RhbCA9IGJ1ZmZlcnMubGVuZ3RoO1xuICBidWZmZXJzLmZvckVhY2goZnVuY3Rpb24oYnVmZmVyLCBpKSB7XG4gICAgY2FsbGJhY2soZXhwb3J0cy5kZWNvZGVQYWNrZXQoYnVmZmVyLCBiaW5hcnlUeXBlLCB0cnVlKSwgaSwgdG90YWwpO1xuICB9KTtcbn07XG5cbn0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHt9KVxufSx7XCIuL2tleXNcIjoyOCxcImFmdGVyXCI6NixcImFycmF5YnVmZmVyLnNsaWNlXCI6NyxcImJhc2U2NC1hcnJheWJ1ZmZlclwiOjksXCJibG9iXCI6MTAsXCJoYXMtYmluYXJ5XCI6MjksXCJ1dGY4XCI6NDR9XSwyODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cbi8qKlxuICogR2V0cyB0aGUga2V5cyBmb3IgYW4gb2JqZWN0LlxuICpcbiAqIEByZXR1cm4ge0FycmF5fSBrZXlzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMgKG9iail7XG4gIHZhciBhcnIgPSBbXTtcbiAgdmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbiAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICBpZiAoaGFzLmNhbGwob2JqLCBpKSkge1xuICAgICAgYXJyLnB1c2goaSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnI7XG59O1xuXG59LHt9XSwyOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG5cbi8qXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzLlxuICovXG5cbnZhciBpc0FycmF5ID0gX2RlcmVxXygnaXNhcnJheScpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gaGFzQmluYXJ5O1xuXG4vKipcbiAqIENoZWNrcyBmb3IgYmluYXJ5IGRhdGEuXG4gKlxuICogUmlnaHQgbm93IG9ubHkgQnVmZmVyIGFuZCBBcnJheUJ1ZmZlciBhcmUgc3VwcG9ydGVkLi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYW55dGhpbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gaGFzQmluYXJ5KGRhdGEpIHtcblxuICBmdW5jdGlvbiBfaGFzQmluYXJ5KG9iaikge1xuICAgIGlmICghb2JqKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAoIChnbG9iYWwuQnVmZmVyICYmIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIob2JqKSkgfHxcbiAgICAgICAgIChnbG9iYWwuQXJyYXlCdWZmZXIgJiYgb2JqIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8XG4gICAgICAgICAoZ2xvYmFsLkJsb2IgJiYgb2JqIGluc3RhbmNlb2YgQmxvYikgfHxcbiAgICAgICAgIChnbG9iYWwuRmlsZSAmJiBvYmogaW5zdGFuY2VvZiBGaWxlKVxuICAgICAgICApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKF9oYXNCaW5hcnkob2JqW2ldKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvYmogJiYgJ29iamVjdCcgPT0gdHlwZW9mIG9iaikge1xuICAgICAgaWYgKG9iai50b0pTT04pIHtcbiAgICAgICAgb2JqID0gb2JqLnRvSlNPTigpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpICYmIF9oYXNCaW5hcnkob2JqW2tleV0pKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gX2hhc0JpbmFyeShkYXRhKTtcbn1cblxufSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDoge30pXG59LHtcImlzYXJyYXlcIjozM31dLDMwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcblxuLypcbiAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG4gKi9cblxudmFyIGlzQXJyYXkgPSBfZGVyZXFfKCdpc2FycmF5Jyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNCaW5hcnk7XG5cbi8qKlxuICogQ2hlY2tzIGZvciBiaW5hcnkgZGF0YS5cbiAqXG4gKiBSaWdodCBub3cgb25seSBCdWZmZXIgYW5kIEFycmF5QnVmZmVyIGFyZSBzdXBwb3J0ZWQuLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhbnl0aGluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBoYXNCaW5hcnkoZGF0YSkge1xuXG4gIGZ1bmN0aW9uIF9oYXNCaW5hcnkob2JqKSB7XG4gICAgaWYgKCFvYmopIHJldHVybiBmYWxzZTtcblxuICAgIGlmICggKGdsb2JhbC5CdWZmZXIgJiYgZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlciAmJiBnbG9iYWwuQnVmZmVyLmlzQnVmZmVyKG9iaikpIHx8XG4gICAgICAgICAoZ2xvYmFsLkFycmF5QnVmZmVyICYmIG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fFxuICAgICAgICAgKGdsb2JhbC5CbG9iICYmIG9iaiBpbnN0YW5jZW9mIEJsb2IpIHx8XG4gICAgICAgICAoZ2xvYmFsLkZpbGUgJiYgb2JqIGluc3RhbmNlb2YgRmlsZSlcbiAgICAgICAgKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChfaGFzQmluYXJ5KG9ialtpXSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob2JqICYmICdvYmplY3QnID09IHR5cGVvZiBvYmopIHtcbiAgICAgIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL0F1dG9tYXR0aWMvaGFzLWJpbmFyeS9wdWxsLzRcbiAgICAgIGlmIChvYmoudG9KU09OICYmICdmdW5jdGlvbicgPT0gdHlwZW9mIG9iai50b0pTT04pIHtcbiAgICAgICAgb2JqID0gb2JqLnRvSlNPTigpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpICYmIF9oYXNCaW5hcnkob2JqW2tleV0pKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gX2hhc0JpbmFyeShkYXRhKTtcbn1cblxufSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDoge30pXG59LHtcImlzYXJyYXlcIjozM31dLDMxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqXG4gKiBMb2dpYyBib3Jyb3dlZCBmcm9tIE1vZGVybml6cjpcbiAqXG4gKiAgIC0gaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvZmVhdHVyZS1kZXRlY3RzL2NvcnMuanNcbiAqL1xuXG50cnkge1xuICBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAnd2l0aENyZWRlbnRpYWxzJyBpbiBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbn0gY2F0Y2ggKGVycikge1xuICAvLyBpZiBYTUxIdHRwIHN1cHBvcnQgaXMgZGlzYWJsZWQgaW4gSUUgdGhlbiBpdCB3aWxsIHRocm93XG4gIC8vIHdoZW4gdHJ5aW5nIHRvIGNyZWF0ZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZhbHNlO1xufVxuXG59LHt9XSwzMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cbnZhciBpbmRleE9mID0gW10uaW5kZXhPZjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcnIsIG9iail7XG4gIGlmIChpbmRleE9mKSByZXR1cm4gYXJyLmluZGV4T2Yob2JqKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoYXJyW2ldID09PSBvYmopIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn07XG59LHt9XSwzMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbn0se31dLDM0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbi8qISBKU09OIHYzLjMuMiB8IGh0dHA6Ly9iZXN0aWVqcy5naXRodWIuaW8vanNvbjMgfCBDb3B5cmlnaHQgMjAxMi0yMDE0LCBLaXQgQ2FtYnJpZGdlIHwgaHR0cDovL2tpdC5taXQtbGljZW5zZS5vcmcgKi9cbjsoZnVuY3Rpb24gKCkge1xuICAvLyBEZXRlY3QgdGhlIGBkZWZpbmVgIGZ1bmN0aW9uIGV4cG9zZWQgYnkgYXN5bmNocm9ub3VzIG1vZHVsZSBsb2FkZXJzLiBUaGVcbiAgLy8gc3RyaWN0IGBkZWZpbmVgIGNoZWNrIGlzIG5lY2Vzc2FyeSBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIGByLmpzYC5cbiAgdmFyIGlzTG9hZGVyID0gdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQ7XG5cbiAgLy8gQSBzZXQgb2YgdHlwZXMgdXNlZCB0byBkaXN0aW5ndWlzaCBvYmplY3RzIGZyb20gcHJpbWl0aXZlcy5cbiAgdmFyIG9iamVjdFR5cGVzID0ge1xuICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICBcIm9iamVjdFwiOiB0cnVlXG4gIH07XG5cbiAgLy8gRGV0ZWN0IHRoZSBgZXhwb3J0c2Agb2JqZWN0IGV4cG9zZWQgYnkgQ29tbW9uSlMgaW1wbGVtZW50YXRpb25zLlxuICB2YXIgZnJlZUV4cG9ydHMgPSBvYmplY3RUeXBlc1t0eXBlb2YgZXhwb3J0c10gJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4gIC8vIFVzZSB0aGUgYGdsb2JhbGAgb2JqZWN0IGV4cG9zZWQgYnkgTm9kZSAoaW5jbHVkaW5nIEJyb3dzZXJpZnkgdmlhXG4gIC8vIGBpbnNlcnQtbW9kdWxlLWdsb2JhbHNgKSwgTmFyd2hhbCwgYW5kIFJpbmdvIGFzIHRoZSBkZWZhdWx0IGNvbnRleHQsXG4gIC8vIGFuZCB0aGUgYHdpbmRvd2Agb2JqZWN0IGluIGJyb3dzZXJzLiBSaGlubyBleHBvcnRzIGEgYGdsb2JhbGAgZnVuY3Rpb25cbiAgLy8gaW5zdGVhZC5cbiAgdmFyIHJvb3QgPSBvYmplY3RUeXBlc1t0eXBlb2Ygd2luZG93XSAmJiB3aW5kb3cgfHwgdGhpcyxcbiAgICAgIGZyZWVHbG9iYWwgPSBmcmVlRXhwb3J0cyAmJiBvYmplY3RUeXBlc1t0eXBlb2YgbW9kdWxlXSAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiB0eXBlb2YgZ2xvYmFsID09IFwib2JqZWN0XCIgJiYgZ2xvYmFsO1xuXG4gIGlmIChmcmVlR2xvYmFsICYmIChmcmVlR2xvYmFsW1wiZ2xvYmFsXCJdID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWxbXCJ3aW5kb3dcIl0gPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbFtcInNlbGZcIl0gPT09IGZyZWVHbG9iYWwpKSB7XG4gICAgcm9vdCA9IGZyZWVHbG9iYWw7XG4gIH1cblxuICAvLyBQdWJsaWM6IEluaXRpYWxpemVzIEpTT04gMyB1c2luZyB0aGUgZ2l2ZW4gYGNvbnRleHRgIG9iamVjdCwgYXR0YWNoaW5nIHRoZVxuICAvLyBgc3RyaW5naWZ5YCBhbmQgYHBhcnNlYCBmdW5jdGlvbnMgdG8gdGhlIHNwZWNpZmllZCBgZXhwb3J0c2Agb2JqZWN0LlxuICBmdW5jdGlvbiBydW5JbkNvbnRleHQoY29udGV4dCwgZXhwb3J0cykge1xuICAgIGNvbnRleHQgfHwgKGNvbnRleHQgPSByb290W1wiT2JqZWN0XCJdKCkpO1xuICAgIGV4cG9ydHMgfHwgKGV4cG9ydHMgPSByb290W1wiT2JqZWN0XCJdKCkpO1xuXG4gICAgLy8gTmF0aXZlIGNvbnN0cnVjdG9yIGFsaWFzZXMuXG4gICAgdmFyIE51bWJlciA9IGNvbnRleHRbXCJOdW1iZXJcIl0gfHwgcm9vdFtcIk51bWJlclwiXSxcbiAgICAgICAgU3RyaW5nID0gY29udGV4dFtcIlN0cmluZ1wiXSB8fCByb290W1wiU3RyaW5nXCJdLFxuICAgICAgICBPYmplY3QgPSBjb250ZXh0W1wiT2JqZWN0XCJdIHx8IHJvb3RbXCJPYmplY3RcIl0sXG4gICAgICAgIERhdGUgPSBjb250ZXh0W1wiRGF0ZVwiXSB8fCByb290W1wiRGF0ZVwiXSxcbiAgICAgICAgU3ludGF4RXJyb3IgPSBjb250ZXh0W1wiU3ludGF4RXJyb3JcIl0gfHwgcm9vdFtcIlN5bnRheEVycm9yXCJdLFxuICAgICAgICBUeXBlRXJyb3IgPSBjb250ZXh0W1wiVHlwZUVycm9yXCJdIHx8IHJvb3RbXCJUeXBlRXJyb3JcIl0sXG4gICAgICAgIE1hdGggPSBjb250ZXh0W1wiTWF0aFwiXSB8fCByb290W1wiTWF0aFwiXSxcbiAgICAgICAgbmF0aXZlSlNPTiA9IGNvbnRleHRbXCJKU09OXCJdIHx8IHJvb3RbXCJKU09OXCJdO1xuXG4gICAgLy8gRGVsZWdhdGUgdG8gdGhlIG5hdGl2ZSBgc3RyaW5naWZ5YCBhbmQgYHBhcnNlYCBpbXBsZW1lbnRhdGlvbnMuXG4gICAgaWYgKHR5cGVvZiBuYXRpdmVKU09OID09IFwib2JqZWN0XCIgJiYgbmF0aXZlSlNPTikge1xuICAgICAgZXhwb3J0cy5zdHJpbmdpZnkgPSBuYXRpdmVKU09OLnN0cmluZ2lmeTtcbiAgICAgIGV4cG9ydHMucGFyc2UgPSBuYXRpdmVKU09OLnBhcnNlO1xuICAgIH1cblxuICAgIC8vIENvbnZlbmllbmNlIGFsaWFzZXMuXG4gICAgdmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZSxcbiAgICAgICAgZ2V0Q2xhc3MgPSBvYmplY3RQcm90by50b1N0cmluZyxcbiAgICAgICAgaXNQcm9wZXJ0eSwgZm9yRWFjaCwgdW5kZWY7XG5cbiAgICAvLyBUZXN0IHRoZSBgRGF0ZSNnZXRVVEMqYCBtZXRob2RzLiBCYXNlZCBvbiB3b3JrIGJ5IEBZYWZmbGUuXG4gICAgdmFyIGlzRXh0ZW5kZWQgPSBuZXcgRGF0ZSgtMzUwOTgyNzMzNDU3MzI5Mik7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFRoZSBgZ2V0VVRDRnVsbFllYXJgLCBgTW9udGhgLCBhbmQgYERhdGVgIG1ldGhvZHMgcmV0dXJuIG5vbnNlbnNpY2FsXG4gICAgICAvLyByZXN1bHRzIGZvciBjZXJ0YWluIGRhdGVzIGluIE9wZXJhID49IDEwLjUzLlxuICAgICAgaXNFeHRlbmRlZCA9IGlzRXh0ZW5kZWQuZ2V0VVRDRnVsbFllYXIoKSA9PSAtMTA5MjUyICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTW9udGgoKSA9PT0gMCAmJiBpc0V4dGVuZGVkLmdldFVUQ0RhdGUoKSA9PT0gMSAmJlxuICAgICAgICAvLyBTYWZhcmkgPCAyLjAuMiBzdG9yZXMgdGhlIGludGVybmFsIG1pbGxpc2Vjb25kIHRpbWUgdmFsdWUgY29ycmVjdGx5LFxuICAgICAgICAvLyBidXQgY2xpcHMgdGhlIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgZGF0ZSBtZXRob2RzIHRvIHRoZSByYW5nZSBvZlxuICAgICAgICAvLyBzaWduZWQgMzItYml0IGludGVnZXJzIChbLTIgKiogMzEsIDIgKiogMzEgLSAxXSkuXG4gICAgICAgIGlzRXh0ZW5kZWQuZ2V0VVRDSG91cnMoKSA9PSAxMCAmJiBpc0V4dGVuZGVkLmdldFVUQ01pbnV0ZXMoKSA9PSAzNyAmJiBpc0V4dGVuZGVkLmdldFVUQ1NlY29uZHMoKSA9PSA2ICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTWlsbGlzZWNvbmRzKCkgPT0gNzA4O1xuICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cblxuICAgIC8vIEludGVybmFsOiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG5hdGl2ZSBgSlNPTi5zdHJpbmdpZnlgIGFuZCBgcGFyc2VgXG4gICAgLy8gaW1wbGVtZW50YXRpb25zIGFyZSBzcGVjLWNvbXBsaWFudC4gQmFzZWQgb24gd29yayBieSBLZW4gU255ZGVyLlxuICAgIGZ1bmN0aW9uIGhhcyhuYW1lKSB7XG4gICAgICBpZiAoaGFzW25hbWVdICE9PSB1bmRlZikge1xuICAgICAgICAvLyBSZXR1cm4gY2FjaGVkIGZlYXR1cmUgdGVzdCByZXN1bHQuXG4gICAgICAgIHJldHVybiBoYXNbbmFtZV07XG4gICAgICB9XG4gICAgICB2YXIgaXNTdXBwb3J0ZWQ7XG4gICAgICBpZiAobmFtZSA9PSBcImJ1Zy1zdHJpbmctY2hhci1pbmRleFwiKSB7XG4gICAgICAgIC8vIElFIDw9IDcgZG9lc24ndCBzdXBwb3J0IGFjY2Vzc2luZyBzdHJpbmcgY2hhcmFjdGVycyB1c2luZyBzcXVhcmVcbiAgICAgICAgLy8gYnJhY2tldCBub3RhdGlvbi4gSUUgOCBvbmx5IHN1cHBvcnRzIHRoaXMgZm9yIHByaW1pdGl2ZXMuXG4gICAgICAgIGlzU3VwcG9ydGVkID0gXCJhXCJbMF0gIT0gXCJhXCI7XG4gICAgICB9IGVsc2UgaWYgKG5hbWUgPT0gXCJqc29uXCIpIHtcbiAgICAgICAgLy8gSW5kaWNhdGVzIHdoZXRoZXIgYm90aCBgSlNPTi5zdHJpbmdpZnlgIGFuZCBgSlNPTi5wYXJzZWAgYXJlXG4gICAgICAgIC8vIHN1cHBvcnRlZC5cbiAgICAgICAgaXNTdXBwb3J0ZWQgPSBoYXMoXCJqc29uLXN0cmluZ2lmeVwiKSAmJiBoYXMoXCJqc29uLXBhcnNlXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHZhbHVlLCBzZXJpYWxpemVkID0gJ3tcImFcIjpbMSx0cnVlLGZhbHNlLG51bGwsXCJcXFxcdTAwMDBcXFxcYlxcXFxuXFxcXGZcXFxcclxcXFx0XCJdfSc7XG4gICAgICAgIC8vIFRlc3QgYEpTT04uc3RyaW5naWZ5YC5cbiAgICAgICAgaWYgKG5hbWUgPT0gXCJqc29uLXN0cmluZ2lmeVwiKSB7XG4gICAgICAgICAgdmFyIHN0cmluZ2lmeSA9IGV4cG9ydHMuc3RyaW5naWZ5LCBzdHJpbmdpZnlTdXBwb3J0ZWQgPSB0eXBlb2Ygc3RyaW5naWZ5ID09IFwiZnVuY3Rpb25cIiAmJiBpc0V4dGVuZGVkO1xuICAgICAgICAgIGlmIChzdHJpbmdpZnlTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIC8vIEEgdGVzdCBmdW5jdGlvbiBvYmplY3Qgd2l0aCBhIGN1c3RvbSBgdG9KU09OYCBtZXRob2QuXG4gICAgICAgICAgICAodmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfSkudG9KU09OID0gdmFsdWU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzdHJpbmdpZnlTdXBwb3J0ZWQgPVxuICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggMy4xYjEgYW5kIGIyIHNlcmlhbGl6ZSBzdHJpbmcsIG51bWJlciwgYW5kIGJvb2xlYW5cbiAgICAgICAgICAgICAgICAvLyBwcmltaXRpdmVzIGFzIG9iamVjdCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoMCkgPT09IFwiMFwiICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIGIyLCBhbmQgSlNPTiAyIHNlcmlhbGl6ZSB3cmFwcGVkIHByaW1pdGl2ZXMgYXMgb2JqZWN0XG4gICAgICAgICAgICAgICAgLy8gbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBOdW1iZXIoKSkgPT09IFwiMFwiICYmXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBTdHJpbmcoKSkgPT0gJ1wiXCInICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIHZhbHVlIGlzIGBudWxsYCwgYHVuZGVmaW5lZGAsIG9yXG4gICAgICAgICAgICAgICAgLy8gZG9lcyBub3QgZGVmaW5lIGEgY2Fub25pY2FsIEpTT04gcmVwcmVzZW50YXRpb24gKHRoaXMgYXBwbGllcyB0b1xuICAgICAgICAgICAgICAgIC8vIG9iamVjdHMgd2l0aCBgdG9KU09OYCBwcm9wZXJ0aWVzIGFzIHdlbGwsICp1bmxlc3MqIHRoZXkgYXJlIG5lc3RlZFxuICAgICAgICAgICAgICAgIC8vIHdpdGhpbiBhbiBvYmplY3Qgb3IgYXJyYXkpLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShnZXRDbGFzcykgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgICAgLy8gSUUgOCBzZXJpYWxpemVzIGB1bmRlZmluZWRgIGFzIGBcInVuZGVmaW5lZFwiYC4gU2FmYXJpIDw9IDUuMS43IGFuZFxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIzIHBhc3MgdGhpcyB0ZXN0LlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSh1bmRlZikgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDUuMS43IGFuZCBGRiAzLjFiMyB0aHJvdyBgRXJyb3JgcyBhbmQgYFR5cGVFcnJvcmBzLFxuICAgICAgICAgICAgICAgIC8vIHJlc3BlY3RpdmVseSwgaWYgdGhlIHZhbHVlIGlzIG9taXR0ZWQgZW50aXJlbHkuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KCkgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIG51bWJlcixcbiAgICAgICAgICAgICAgICAvLyBzdHJpbmcsIGFycmF5LCBvYmplY3QsIEJvb2xlYW4sIG9yIGBudWxsYCBsaXRlcmFsLiBUaGlzIGFwcGxpZXMgdG9cbiAgICAgICAgICAgICAgICAvLyBvYmplY3RzIHdpdGggY3VzdG9tIGB0b0pTT05gIG1ldGhvZHMgYXMgd2VsbCwgdW5sZXNzIHRoZXkgYXJlIG5lc3RlZFxuICAgICAgICAgICAgICAgIC8vIGluc2lkZSBvYmplY3Qgb3IgYXJyYXkgbGl0ZXJhbHMuIFlVSSAzLjAuMGIxIGlnbm9yZXMgY3VzdG9tIGB0b0pTT05gXG4gICAgICAgICAgICAgICAgLy8gbWV0aG9kcyBlbnRpcmVseS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkodmFsdWUpID09PSBcIjFcIiAmJlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbdmFsdWVdKSA9PSBcIlsxXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gUHJvdG90eXBlIDw9IDEuNi4xIHNlcmlhbGl6ZXMgYFt1bmRlZmluZWRdYCBhcyBgXCJbXVwiYCBpbnN0ZWFkIG9mXG4gICAgICAgICAgICAgICAgLy8gYFwiW251bGxdXCJgLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbdW5kZWZdKSA9PSBcIltudWxsXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gWVVJIDMuMC4wYjEgZmFpbHMgdG8gc2VyaWFsaXplIGBudWxsYCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobnVsbCkgPT0gXCJudWxsXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgMiBoYWx0cyBzZXJpYWxpemF0aW9uIGlmIGFuIGFycmF5IGNvbnRhaW5zIGEgZnVuY3Rpb246XG4gICAgICAgICAgICAgICAgLy8gYFsxLCB0cnVlLCBnZXRDbGFzcywgMV1gIHNlcmlhbGl6ZXMgYXMgXCJbMSx0cnVlLF0sXCIuIEZGIDMuMWIzXG4gICAgICAgICAgICAgICAgLy8gZWxpZGVzIG5vbi1KU09OIHZhbHVlcyBmcm9tIG9iamVjdHMgYW5kIGFycmF5cywgdW5sZXNzIHRoZXlcbiAgICAgICAgICAgICAgICAvLyBkZWZpbmUgY3VzdG9tIGB0b0pTT05gIG1ldGhvZHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KFt1bmRlZiwgZ2V0Q2xhc3MsIG51bGxdKSA9PSBcIltudWxsLG51bGwsbnVsbF1cIiAmJlxuICAgICAgICAgICAgICAgIC8vIFNpbXBsZSBzZXJpYWxpemF0aW9uIHRlc3QuIEZGIDMuMWIxIHVzZXMgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2VzXG4gICAgICAgICAgICAgICAgLy8gd2hlcmUgY2hhcmFjdGVyIGVzY2FwZSBjb2RlcyBhcmUgZXhwZWN0ZWQgKGUuZy4sIGBcXGJgID0+IGBcXHUwMDA4YCkuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KHsgXCJhXCI6IFt2YWx1ZSwgdHJ1ZSwgZmFsc2UsIG51bGwsIFwiXFx4MDBcXGJcXG5cXGZcXHJcXHRcIl0gfSkgPT0gc2VyaWFsaXplZCAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxIGFuZCBiMiBpZ25vcmUgdGhlIGBmaWx0ZXJgIGFuZCBgd2lkdGhgIGFyZ3VtZW50cy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobnVsbCwgdmFsdWUpID09PSBcIjFcIiAmJlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbMSwgMl0sIG51bGwsIDEpID09IFwiW1xcbiAxLFxcbiAyXFxuXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gSlNPTiAyLCBQcm90b3R5cGUgPD0gMS43LCBhbmQgb2xkZXIgV2ViS2l0IGJ1aWxkcyBpbmNvcnJlY3RseVxuICAgICAgICAgICAgICAgIC8vIHNlcmlhbGl6ZSBleHRlbmRlZCB5ZWFycy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoLTguNjRlMTUpKSA9PSAnXCItMjcxODIxLTA0LTIwVDAwOjAwOjAwLjAwMFpcIicgJiZcbiAgICAgICAgICAgICAgICAvLyBUaGUgbWlsbGlzZWNvbmRzIGFyZSBvcHRpb25hbCBpbiBFUyA1LCBidXQgcmVxdWlyZWQgaW4gNS4xLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSg4LjY0ZTE1KSkgPT0gJ1wiKzI3NTc2MC0wOS0xM1QwMDowMDowMC4wMDBaXCInICYmXG4gICAgICAgICAgICAgICAgLy8gRmlyZWZveCA8PSAxMS4wIGluY29ycmVjdGx5IHNlcmlhbGl6ZXMgeWVhcnMgcHJpb3IgdG8gMCBhcyBuZWdhdGl2ZVxuICAgICAgICAgICAgICAgIC8vIGZvdXItZGlnaXQgeWVhcnMgaW5zdGVhZCBvZiBzaXgtZGlnaXQgeWVhcnMuIENyZWRpdHM6IEBZYWZmbGUuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKC02MjE5ODc1NTJlNSkpID09ICdcIi0wMDAwMDEtMDEtMDFUMDA6MDA6MDAuMDAwWlwiJyAmJlxuICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA8PSA1LjEuNSBhbmQgT3BlcmEgPj0gMTAuNTMgaW5jb3JyZWN0bHkgc2VyaWFsaXplIG1pbGxpc2Vjb25kXG4gICAgICAgICAgICAgICAgLy8gdmFsdWVzIGxlc3MgdGhhbiAxMDAwLiBDcmVkaXRzOiBAWWFmZmxlLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSgtMSkpID09ICdcIjE5NjktMTItMzFUMjM6NTk6NTkuOTk5WlwiJztcbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICBzdHJpbmdpZnlTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaXNTdXBwb3J0ZWQgPSBzdHJpbmdpZnlTdXBwb3J0ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGVzdCBgSlNPTi5wYXJzZWAuXG4gICAgICAgIGlmIChuYW1lID09IFwianNvbi1wYXJzZVwiKSB7XG4gICAgICAgICAgdmFyIHBhcnNlID0gZXhwb3J0cy5wYXJzZTtcbiAgICAgICAgICBpZiAodHlwZW9mIHBhcnNlID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIGIyIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGEgYmFyZSBsaXRlcmFsIGlzIHByb3ZpZGVkLlxuICAgICAgICAgICAgICAvLyBDb25mb3JtaW5nIGltcGxlbWVudGF0aW9ucyBzaG91bGQgYWxzbyBjb2VyY2UgdGhlIGluaXRpYWwgYXJndW1lbnQgdG9cbiAgICAgICAgICAgICAgLy8gYSBzdHJpbmcgcHJpb3IgdG8gcGFyc2luZy5cbiAgICAgICAgICAgICAgaWYgKHBhcnNlKFwiMFwiKSA9PT0gMCAmJiAhcGFyc2UoZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgLy8gU2ltcGxlIHBhcnNpbmcgdGVzdC5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlKHNlcmlhbGl6ZWQpO1xuICAgICAgICAgICAgICAgIHZhciBwYXJzZVN1cHBvcnRlZCA9IHZhbHVlW1wiYVwiXS5sZW5ndGggPT0gNSAmJiB2YWx1ZVtcImFcIl1bMF0gPT09IDE7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTYWZhcmkgPD0gNS4xLjIgYW5kIEZGIDMuMWIxIGFsbG93IHVuZXNjYXBlZCB0YWJzIGluIHN0cmluZ3MuXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gIXBhcnNlKCdcIlxcdFwiJyk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgICAgICAgICBpZiAocGFyc2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBGRiA0LjAgYW5kIDQuMC4xIGFsbG93IGxlYWRpbmcgYCtgIHNpZ25zIGFuZCBsZWFkaW5nXG4gICAgICAgICAgICAgICAgICAgICAgLy8gZGVjaW1hbCBwb2ludHMuIEZGIDQuMCwgNC4wLjEsIGFuZCBJRSA5LTEwIGFsc28gYWxsb3dcbiAgICAgICAgICAgICAgICAgICAgICAvLyBjZXJ0YWluIG9jdGFsIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gcGFyc2UoXCIwMVwiKSAhPT0gMTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gRkYgNC4wLCA0LjAuMSwgYW5kIFJoaW5vIDEuN1IzLVI0IGFsbG93IHRyYWlsaW5nIGRlY2ltYWxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBwb2ludHMuIFRoZXNlIGVudmlyb25tZW50cywgYWxvbmcgd2l0aCBGRiAzLjFiMSBhbmQgMixcbiAgICAgICAgICAgICAgICAgICAgICAvLyBhbHNvIGFsbG93IHRyYWlsaW5nIGNvbW1hcyBpbiBKU09OIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICAgICAgICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IHBhcnNlKFwiMS5cIikgIT09IDE7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpc1N1cHBvcnRlZCA9IHBhcnNlU3VwcG9ydGVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzW25hbWVdID0gISFpc1N1cHBvcnRlZDtcbiAgICB9XG5cbiAgICBpZiAoIWhhcyhcImpzb25cIikpIHtcbiAgICAgIC8vIENvbW1vbiBgW1tDbGFzc11dYCBuYW1lIGFsaWFzZXMuXG4gICAgICB2YXIgZnVuY3Rpb25DbGFzcyA9IFwiW29iamVjdCBGdW5jdGlvbl1cIixcbiAgICAgICAgICBkYXRlQ2xhc3MgPSBcIltvYmplY3QgRGF0ZV1cIixcbiAgICAgICAgICBudW1iZXJDbGFzcyA9IFwiW29iamVjdCBOdW1iZXJdXCIsXG4gICAgICAgICAgc3RyaW5nQ2xhc3MgPSBcIltvYmplY3QgU3RyaW5nXVwiLFxuICAgICAgICAgIGFycmF5Q2xhc3MgPSBcIltvYmplY3QgQXJyYXldXCIsXG4gICAgICAgICAgYm9vbGVhbkNsYXNzID0gXCJbb2JqZWN0IEJvb2xlYW5dXCI7XG5cbiAgICAgIC8vIERldGVjdCBpbmNvbXBsZXRlIHN1cHBvcnQgZm9yIGFjY2Vzc2luZyBzdHJpbmcgY2hhcmFjdGVycyBieSBpbmRleC5cbiAgICAgIHZhciBjaGFySW5kZXhCdWdneSA9IGhhcyhcImJ1Zy1zdHJpbmctY2hhci1pbmRleFwiKTtcblxuICAgICAgLy8gRGVmaW5lIGFkZGl0aW9uYWwgdXRpbGl0eSBtZXRob2RzIGlmIHRoZSBgRGF0ZWAgbWV0aG9kcyBhcmUgYnVnZ3kuXG4gICAgICBpZiAoIWlzRXh0ZW5kZWQpIHtcbiAgICAgICAgdmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbiAgICAgICAgLy8gQSBtYXBwaW5nIGJldHdlZW4gdGhlIG1vbnRocyBvZiB0aGUgeWVhciBhbmQgdGhlIG51bWJlciBvZiBkYXlzIGJldHdlZW5cbiAgICAgICAgLy8gSmFudWFyeSAxc3QgYW5kIHRoZSBmaXJzdCBvZiB0aGUgcmVzcGVjdGl2ZSBtb250aC5cbiAgICAgICAgdmFyIE1vbnRocyA9IFswLCAzMSwgNTksIDkwLCAxMjAsIDE1MSwgMTgxLCAyMTIsIDI0MywgMjczLCAzMDQsIDMzNF07XG4gICAgICAgIC8vIEludGVybmFsOiBDYWxjdWxhdGVzIHRoZSBudW1iZXIgb2YgZGF5cyBiZXR3ZWVuIHRoZSBVbml4IGVwb2NoIGFuZCB0aGVcbiAgICAgICAgLy8gZmlyc3QgZGF5IG9mIHRoZSBnaXZlbiBtb250aC5cbiAgICAgICAgdmFyIGdldERheSA9IGZ1bmN0aW9uICh5ZWFyLCBtb250aCkge1xuICAgICAgICAgIHJldHVybiBNb250aHNbbW9udGhdICsgMzY1ICogKHllYXIgLSAxOTcwKSArIGZsb29yKCh5ZWFyIC0gMTk2OSArIChtb250aCA9ICsobW9udGggPiAxKSkpIC8gNCkgLSBmbG9vcigoeWVhciAtIDE5MDEgKyBtb250aCkgLyAxMDApICsgZmxvb3IoKHllYXIgLSAxNjAxICsgbW9udGgpIC8gNDAwKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gSW50ZXJuYWw6IERldGVybWluZXMgaWYgYSBwcm9wZXJ0eSBpcyBhIGRpcmVjdCBwcm9wZXJ0eSBvZiB0aGUgZ2l2ZW5cbiAgICAgIC8vIG9iamVjdC4gRGVsZWdhdGVzIHRvIHRoZSBuYXRpdmUgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgbWV0aG9kLlxuICAgICAgaWYgKCEoaXNQcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5KSkge1xuICAgICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgdmFyIG1lbWJlcnMgPSB7fSwgY29uc3RydWN0b3I7XG4gICAgICAgICAgaWYgKChtZW1iZXJzLl9fcHJvdG9fXyA9IG51bGwsIG1lbWJlcnMuX19wcm90b19fID0ge1xuICAgICAgICAgICAgLy8gVGhlICpwcm90byogcHJvcGVydHkgY2Fubm90IGJlIHNldCBtdWx0aXBsZSB0aW1lcyBpbiByZWNlbnRcbiAgICAgICAgICAgIC8vIHZlcnNpb25zIG9mIEZpcmVmb3ggYW5kIFNlYU1vbmtleS5cbiAgICAgICAgICAgIFwidG9TdHJpbmdcIjogMVxuICAgICAgICAgIH0sIG1lbWJlcnMpLnRvU3RyaW5nICE9IGdldENsYXNzKSB7XG4gICAgICAgICAgICAvLyBTYWZhcmkgPD0gMi4wLjMgZG9lc24ndCBpbXBsZW1lbnQgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAsIGJ1dFxuICAgICAgICAgICAgLy8gc3VwcG9ydHMgdGhlIG11dGFibGUgKnByb3RvKiBwcm9wZXJ0eS5cbiAgICAgICAgICAgIGlzUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgLy8gQ2FwdHVyZSBhbmQgYnJlYWsgdGhlIG9iamVjdCdzIHByb3RvdHlwZSBjaGFpbiAoc2VlIHNlY3Rpb24gOC42LjJcbiAgICAgICAgICAgICAgLy8gb2YgdGhlIEVTIDUuMSBzcGVjKS4gVGhlIHBhcmVudGhlc2l6ZWQgZXhwcmVzc2lvbiBwcmV2ZW50cyBhblxuICAgICAgICAgICAgICAvLyB1bnNhZmUgdHJhbnNmb3JtYXRpb24gYnkgdGhlIENsb3N1cmUgQ29tcGlsZXIuXG4gICAgICAgICAgICAgIHZhciBvcmlnaW5hbCA9IHRoaXMuX19wcm90b19fLCByZXN1bHQgPSBwcm9wZXJ0eSBpbiAodGhpcy5fX3Byb3RvX18gPSBudWxsLCB0aGlzKTtcbiAgICAgICAgICAgICAgLy8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgcHJvdG90eXBlIGNoYWluLlxuICAgICAgICAgICAgICB0aGlzLl9fcHJvdG9fXyA9IG9yaWdpbmFsO1xuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQ2FwdHVyZSBhIHJlZmVyZW5jZSB0byB0aGUgdG9wLWxldmVsIGBPYmplY3RgIGNvbnN0cnVjdG9yLlxuICAgICAgICAgICAgY29uc3RydWN0b3IgPSBtZW1iZXJzLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgLy8gVXNlIHRoZSBgY29uc3RydWN0b3JgIHByb3BlcnR5IHRvIHNpbXVsYXRlIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIGluXG4gICAgICAgICAgICAvLyBvdGhlciBlbnZpcm9ubWVudHMuXG4gICAgICAgICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgIHZhciBwYXJlbnQgPSAodGhpcy5jb25zdHJ1Y3RvciB8fCBjb25zdHJ1Y3RvcikucHJvdG90eXBlO1xuICAgICAgICAgICAgICByZXR1cm4gcHJvcGVydHkgaW4gdGhpcyAmJiAhKHByb3BlcnR5IGluIHBhcmVudCAmJiB0aGlzW3Byb3BlcnR5XSA9PT0gcGFyZW50W3Byb3BlcnR5XSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBtZW1iZXJzID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gaXNQcm9wZXJ0eS5jYWxsKHRoaXMsIHByb3BlcnR5KTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gSW50ZXJuYWw6IE5vcm1hbGl6ZXMgdGhlIGBmb3IuLi5pbmAgaXRlcmF0aW9uIGFsZ29yaXRobSBhY3Jvc3NcbiAgICAgIC8vIGVudmlyb25tZW50cy4gRWFjaCBlbnVtZXJhdGVkIGtleSBpcyB5aWVsZGVkIHRvIGEgYGNhbGxiYWNrYCBmdW5jdGlvbi5cbiAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgc2l6ZSA9IDAsIFByb3BlcnRpZXMsIG1lbWJlcnMsIHByb3BlcnR5O1xuXG4gICAgICAgIC8vIFRlc3RzIGZvciBidWdzIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50J3MgYGZvci4uLmluYCBhbGdvcml0aG0uIFRoZVxuICAgICAgICAvLyBgdmFsdWVPZmAgcHJvcGVydHkgaW5oZXJpdHMgdGhlIG5vbi1lbnVtZXJhYmxlIGZsYWcgZnJvbVxuICAgICAgICAvLyBgT2JqZWN0LnByb3RvdHlwZWAgaW4gb2xkZXIgdmVyc2lvbnMgb2YgSUUsIE5ldHNjYXBlLCBhbmQgTW96aWxsYS5cbiAgICAgICAgKFByb3BlcnRpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy52YWx1ZU9mID0gMDtcbiAgICAgICAgfSkucHJvdG90eXBlLnZhbHVlT2YgPSAwO1xuXG4gICAgICAgIC8vIEl0ZXJhdGUgb3ZlciBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgYFByb3BlcnRpZXNgIGNsYXNzLlxuICAgICAgICBtZW1iZXJzID0gbmV3IFByb3BlcnRpZXMoKTtcbiAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBtZW1iZXJzKSB7XG4gICAgICAgICAgLy8gSWdub3JlIGFsbCBwcm9wZXJ0aWVzIGluaGVyaXRlZCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC5cbiAgICAgICAgICBpZiAoaXNQcm9wZXJ0eS5jYWxsKG1lbWJlcnMsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgc2l6ZSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBQcm9wZXJ0aWVzID0gbWVtYmVycyA9IG51bGw7XG5cbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBpdGVyYXRpb24gYWxnb3JpdGhtLlxuICAgICAgICBpZiAoIXNpemUpIHtcbiAgICAgICAgICAvLyBBIGxpc3Qgb2Ygbm9uLWVudW1lcmFibGUgcHJvcGVydGllcyBpbmhlcml0ZWQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuXG4gICAgICAgICAgbWVtYmVycyA9IFtcInZhbHVlT2ZcIiwgXCJ0b1N0cmluZ1wiLCBcInRvTG9jYWxlU3RyaW5nXCIsIFwicHJvcGVydHlJc0VudW1lcmFibGVcIiwgXCJpc1Byb3RvdHlwZU9mXCIsIFwiaGFzT3duUHJvcGVydHlcIiwgXCJjb25zdHJ1Y3RvclwiXTtcbiAgICAgICAgICAvLyBJRSA8PSA4LCBNb3ppbGxhIDEuMCwgYW5kIE5ldHNjYXBlIDYuMiBpZ25vcmUgc2hhZG93ZWQgbm9uLWVudW1lcmFibGVcbiAgICAgICAgICAvLyBwcm9wZXJ0aWVzLlxuICAgICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIGlzRnVuY3Rpb24gPSBnZXRDbGFzcy5jYWxsKG9iamVjdCkgPT0gZnVuY3Rpb25DbGFzcywgcHJvcGVydHksIGxlbmd0aDtcbiAgICAgICAgICAgIHZhciBoYXNQcm9wZXJ0eSA9ICFpc0Z1bmN0aW9uICYmIHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgIT0gXCJmdW5jdGlvblwiICYmIG9iamVjdFR5cGVzW3R5cGVvZiBvYmplY3QuaGFzT3duUHJvcGVydHldICYmIG9iamVjdC5oYXNPd25Qcm9wZXJ0eSB8fCBpc1Byb3BlcnR5O1xuICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgLy8gR2Vja28gPD0gMS4wIGVudW1lcmF0ZXMgdGhlIGBwcm90b3R5cGVgIHByb3BlcnR5IG9mIGZ1bmN0aW9ucyB1bmRlclxuICAgICAgICAgICAgICAvLyBjZXJ0YWluIGNvbmRpdGlvbnM7IElFIGRvZXMgbm90LlxuICAgICAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmIGhhc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1hbnVhbGx5IGludm9rZSB0aGUgY2FsbGJhY2sgZm9yIGVhY2ggbm9uLWVudW1lcmFibGUgcHJvcGVydHkuXG4gICAgICAgICAgICBmb3IgKGxlbmd0aCA9IG1lbWJlcnMubGVuZ3RoOyBwcm9wZXJ0eSA9IG1lbWJlcnNbLS1sZW5ndGhdOyBoYXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpICYmIGNhbGxiYWNrKHByb3BlcnR5KSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChzaXplID09IDIpIHtcbiAgICAgICAgICAvLyBTYWZhcmkgPD0gMi4wLjQgZW51bWVyYXRlcyBzaGFkb3dlZCBwcm9wZXJ0aWVzIHR3aWNlLlxuICAgICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgc2V0IG9mIGl0ZXJhdGVkIHByb3BlcnRpZXMuXG4gICAgICAgICAgICB2YXIgbWVtYmVycyA9IHt9LCBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5O1xuICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgLy8gU3RvcmUgZWFjaCBwcm9wZXJ0eSBuYW1lIHRvIHByZXZlbnQgZG91YmxlIGVudW1lcmF0aW9uLiBUaGVcbiAgICAgICAgICAgICAgLy8gYHByb3RvdHlwZWAgcHJvcGVydHkgb2YgZnVuY3Rpb25zIGlzIG5vdCBlbnVtZXJhdGVkIGR1ZSB0byBjcm9zcy1cbiAgICAgICAgICAgICAgLy8gZW52aXJvbm1lbnQgaW5jb25zaXN0ZW5jaWVzLlxuICAgICAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmICFpc1Byb3BlcnR5LmNhbGwobWVtYmVycywgcHJvcGVydHkpICYmIChtZW1iZXJzW3Byb3BlcnR5XSA9IDEpICYmIGlzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTm8gYnVncyBkZXRlY3RlZDsgdXNlIHRoZSBzdGFuZGFyZCBgZm9yLi4uaW5gIGFsZ29yaXRobS5cbiAgICAgICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5LCBpc0NvbnN0cnVjdG9yO1xuICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiBpc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkgJiYgIShpc0NvbnN0cnVjdG9yID0gcHJvcGVydHkgPT09IFwiY29uc3RydWN0b3JcIikpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1hbnVhbGx5IGludm9rZSB0aGUgY2FsbGJhY2sgZm9yIHRoZSBgY29uc3RydWN0b3JgIHByb3BlcnR5IGR1ZSB0b1xuICAgICAgICAgICAgLy8gY3Jvc3MtZW52aXJvbm1lbnQgaW5jb25zaXN0ZW5jaWVzLlxuICAgICAgICAgICAgaWYgKGlzQ29uc3RydWN0b3IgfHwgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgKHByb3BlcnR5ID0gXCJjb25zdHJ1Y3RvclwiKSkpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvckVhY2gob2JqZWN0LCBjYWxsYmFjayk7XG4gICAgICB9O1xuXG4gICAgICAvLyBQdWJsaWM6IFNlcmlhbGl6ZXMgYSBKYXZhU2NyaXB0IGB2YWx1ZWAgYXMgYSBKU09OIHN0cmluZy4gVGhlIG9wdGlvbmFsXG4gICAgICAvLyBgZmlsdGVyYCBhcmd1bWVudCBtYXkgc3BlY2lmeSBlaXRoZXIgYSBmdW5jdGlvbiB0aGF0IGFsdGVycyBob3cgb2JqZWN0IGFuZFxuICAgICAgLy8gYXJyYXkgbWVtYmVycyBhcmUgc2VyaWFsaXplZCwgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncyBhbmQgbnVtYmVycyB0aGF0XG4gICAgICAvLyBpbmRpY2F0ZXMgd2hpY2ggcHJvcGVydGllcyBzaG91bGQgYmUgc2VyaWFsaXplZC4gVGhlIG9wdGlvbmFsIGB3aWR0aGBcbiAgICAgIC8vIGFyZ3VtZW50IG1heSBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgbnVtYmVyIHRoYXQgc3BlY2lmaWVzIHRoZSBpbmRlbnRhdGlvblxuICAgICAgLy8gbGV2ZWwgb2YgdGhlIG91dHB1dC5cbiAgICAgIGlmICghaGFzKFwianNvbi1zdHJpbmdpZnlcIikpIHtcbiAgICAgICAgLy8gSW50ZXJuYWw6IEEgbWFwIG9mIGNvbnRyb2wgY2hhcmFjdGVycyBhbmQgdGhlaXIgZXNjYXBlZCBlcXVpdmFsZW50cy5cbiAgICAgICAgdmFyIEVzY2FwZXMgPSB7XG4gICAgICAgICAgOTI6IFwiXFxcXFxcXFxcIixcbiAgICAgICAgICAzNDogJ1xcXFxcIicsXG4gICAgICAgICAgODogXCJcXFxcYlwiLFxuICAgICAgICAgIDEyOiBcIlxcXFxmXCIsXG4gICAgICAgICAgMTA6IFwiXFxcXG5cIixcbiAgICAgICAgICAxMzogXCJcXFxcclwiLFxuICAgICAgICAgIDk6IFwiXFxcXHRcIlxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBDb252ZXJ0cyBgdmFsdWVgIGludG8gYSB6ZXJvLXBhZGRlZCBzdHJpbmcgc3VjaCB0aGF0IGl0c1xuICAgICAgICAvLyBsZW5ndGggaXMgYXQgbGVhc3QgZXF1YWwgdG8gYHdpZHRoYC4gVGhlIGB3aWR0aGAgbXVzdCBiZSA8PSA2LlxuICAgICAgICB2YXIgbGVhZGluZ1plcm9lcyA9IFwiMDAwMDAwXCI7XG4gICAgICAgIHZhciB0b1BhZGRlZFN0cmluZyA9IGZ1bmN0aW9uICh3aWR0aCwgdmFsdWUpIHtcbiAgICAgICAgICAvLyBUaGUgYHx8IDBgIGV4cHJlc3Npb24gaXMgbmVjZXNzYXJ5IHRvIHdvcmsgYXJvdW5kIGEgYnVnIGluXG4gICAgICAgICAgLy8gT3BlcmEgPD0gNy41NHUyIHdoZXJlIGAwID09IC0wYCwgYnV0IGBTdHJpbmcoLTApICE9PSBcIjBcImAuXG4gICAgICAgICAgcmV0dXJuIChsZWFkaW5nWmVyb2VzICsgKHZhbHVlIHx8IDApKS5zbGljZSgtd2lkdGgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBEb3VibGUtcXVvdGVzIGEgc3RyaW5nIGB2YWx1ZWAsIHJlcGxhY2luZyBhbGwgQVNDSUkgY29udHJvbFxuICAgICAgICAvLyBjaGFyYWN0ZXJzIChjaGFyYWN0ZXJzIHdpdGggY29kZSB1bml0IHZhbHVlcyBiZXR3ZWVuIDAgYW5kIDMxKSB3aXRoXG4gICAgICAgIC8vIHRoZWlyIGVzY2FwZWQgZXF1aXZhbGVudHMuIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhlXG4gICAgICAgIC8vIGBRdW90ZSh2YWx1ZSlgIG9wZXJhdGlvbiBkZWZpbmVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMuXG4gICAgICAgIHZhciB1bmljb2RlUHJlZml4ID0gXCJcXFxcdTAwXCI7XG4gICAgICAgIHZhciBxdW90ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSAnXCInLCBpbmRleCA9IDAsIGxlbmd0aCA9IHZhbHVlLmxlbmd0aCwgdXNlQ2hhckluZGV4ID0gIWNoYXJJbmRleEJ1Z2d5IHx8IGxlbmd0aCA+IDEwO1xuICAgICAgICAgIHZhciBzeW1ib2xzID0gdXNlQ2hhckluZGV4ICYmIChjaGFySW5kZXhCdWdneSA/IHZhbHVlLnNwbGl0KFwiXCIpIDogdmFsdWUpO1xuICAgICAgICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgdmFyIGNoYXJDb2RlID0gdmFsdWUuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgY2hhcmFjdGVyIGlzIGEgY29udHJvbCBjaGFyYWN0ZXIsIGFwcGVuZCBpdHMgVW5pY29kZSBvclxuICAgICAgICAgICAgLy8gc2hvcnRoYW5kIGVzY2FwZSBzZXF1ZW5jZTsgb3RoZXJ3aXNlLCBhcHBlbmQgdGhlIGNoYXJhY3RlciBhcy1pcy5cbiAgICAgICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgY2FzZSA4OiBjYXNlIDk6IGNhc2UgMTA6IGNhc2UgMTI6IGNhc2UgMTM6IGNhc2UgMzQ6IGNhc2UgOTI6XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IEVzY2FwZXNbY2hhckNvZGVdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA8IDMyKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQgKz0gdW5pY29kZVByZWZpeCArIHRvUGFkZGVkU3RyaW5nKDIsIGNoYXJDb2RlLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHVzZUNoYXJJbmRleCA/IHN5bWJvbHNbaW5kZXhdIDogdmFsdWUuY2hhckF0KGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdCArICdcIic7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZXMgYW4gb2JqZWN0LiBJbXBsZW1lbnRzIHRoZVxuICAgICAgICAvLyBgU3RyKGtleSwgaG9sZGVyKWAsIGBKTyh2YWx1ZSlgLCBhbmQgYEpBKHZhbHVlKWAgb3BlcmF0aW9ucy5cbiAgICAgICAgdmFyIHNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSwgb2JqZWN0LCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKSB7XG4gICAgICAgICAgdmFyIHZhbHVlLCBjbGFzc05hbWUsIHllYXIsIG1vbnRoLCBkYXRlLCB0aW1lLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCByZXN1bHRzLCBlbGVtZW50LCBpbmRleCwgbGVuZ3RoLCBwcmVmaXgsIHJlc3VsdDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTmVjZXNzYXJ5IGZvciBob3N0IG9iamVjdCBzdXBwb3J0LlxuICAgICAgICAgICAgdmFsdWUgPSBvYmplY3RbcHJvcGVydHldO1xuICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSA9PSBkYXRlQ2xhc3MgJiYgIWlzUHJvcGVydHkuY2FsbCh2YWx1ZSwgXCJ0b0pTT05cIikpIHtcbiAgICAgICAgICAgICAgaWYgKHZhbHVlID4gLTEgLyAwICYmIHZhbHVlIDwgMSAvIDApIHtcbiAgICAgICAgICAgICAgICAvLyBEYXRlcyBhcmUgc2VyaWFsaXplZCBhY2NvcmRpbmcgdG8gdGhlIGBEYXRlI3RvSlNPTmAgbWV0aG9kXG4gICAgICAgICAgICAgICAgLy8gc3BlY2lmaWVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjkuNS40NC4gU2VlIHNlY3Rpb24gMTUuOS4xLjE1XG4gICAgICAgICAgICAgICAgLy8gZm9yIHRoZSBJU08gODYwMSBkYXRlIHRpbWUgc3RyaW5nIGZvcm1hdC5cbiAgICAgICAgICAgICAgICBpZiAoZ2V0RGF5KSB7XG4gICAgICAgICAgICAgICAgICAvLyBNYW51YWxseSBjb21wdXRlIHRoZSB5ZWFyLCBtb250aCwgZGF0ZSwgaG91cnMsIG1pbnV0ZXMsXG4gICAgICAgICAgICAgICAgICAvLyBzZWNvbmRzLCBhbmQgbWlsbGlzZWNvbmRzIGlmIHRoZSBgZ2V0VVRDKmAgbWV0aG9kcyBhcmVcbiAgICAgICAgICAgICAgICAgIC8vIGJ1Z2d5LiBBZGFwdGVkIGZyb20gQFlhZmZsZSdzIGBkYXRlLXNoaW1gIHByb2plY3QuXG4gICAgICAgICAgICAgICAgICBkYXRlID0gZmxvb3IodmFsdWUgLyA4NjRlNSk7XG4gICAgICAgICAgICAgICAgICBmb3IgKHllYXIgPSBmbG9vcihkYXRlIC8gMzY1LjI0MjUpICsgMTk3MCAtIDE7IGdldERheSh5ZWFyICsgMSwgMCkgPD0gZGF0ZTsgeWVhcisrKTtcbiAgICAgICAgICAgICAgICAgIGZvciAobW9udGggPSBmbG9vcigoZGF0ZSAtIGdldERheSh5ZWFyLCAwKSkgLyAzMC40Mik7IGdldERheSh5ZWFyLCBtb250aCArIDEpIDw9IGRhdGU7IG1vbnRoKyspO1xuICAgICAgICAgICAgICAgICAgZGF0ZSA9IDEgKyBkYXRlIC0gZ2V0RGF5KHllYXIsIG1vbnRoKTtcbiAgICAgICAgICAgICAgICAgIC8vIFRoZSBgdGltZWAgdmFsdWUgc3BlY2lmaWVzIHRoZSB0aW1lIHdpdGhpbiB0aGUgZGF5IChzZWUgRVNcbiAgICAgICAgICAgICAgICAgIC8vIDUuMSBzZWN0aW9uIDE1LjkuMS4yKS4gVGhlIGZvcm11bGEgYChBICUgQiArIEIpICUgQmAgaXMgdXNlZFxuICAgICAgICAgICAgICAgICAgLy8gdG8gY29tcHV0ZSBgQSBtb2R1bG8gQmAsIGFzIHRoZSBgJWAgb3BlcmF0b3IgZG9lcyBub3RcbiAgICAgICAgICAgICAgICAgIC8vIGNvcnJlc3BvbmQgdG8gdGhlIGBtb2R1bG9gIG9wZXJhdGlvbiBmb3IgbmVnYXRpdmUgbnVtYmVycy5cbiAgICAgICAgICAgICAgICAgIHRpbWUgPSAodmFsdWUgJSA4NjRlNSArIDg2NGU1KSAlIDg2NGU1O1xuICAgICAgICAgICAgICAgICAgLy8gVGhlIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBhbmQgbWlsbGlzZWNvbmRzIGFyZSBvYnRhaW5lZCBieVxuICAgICAgICAgICAgICAgICAgLy8gZGVjb21wb3NpbmcgdGhlIHRpbWUgd2l0aGluIHRoZSBkYXkuIFNlZSBzZWN0aW9uIDE1LjkuMS4xMC5cbiAgICAgICAgICAgICAgICAgIGhvdXJzID0gZmxvb3IodGltZSAvIDM2ZTUpICUgMjQ7XG4gICAgICAgICAgICAgICAgICBtaW51dGVzID0gZmxvb3IodGltZSAvIDZlNCkgJSA2MDtcbiAgICAgICAgICAgICAgICAgIHNlY29uZHMgPSBmbG9vcih0aW1lIC8gMWUzKSAlIDYwO1xuICAgICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gdGltZSAlIDFlMztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgeWVhciA9IHZhbHVlLmdldFVUQ0Z1bGxZZWFyKCk7XG4gICAgICAgICAgICAgICAgICBtb250aCA9IHZhbHVlLmdldFVUQ01vbnRoKCk7XG4gICAgICAgICAgICAgICAgICBkYXRlID0gdmFsdWUuZ2V0VVRDRGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgaG91cnMgPSB2YWx1ZS5nZXRVVENIb3VycygpO1xuICAgICAgICAgICAgICAgICAgbWludXRlcyA9IHZhbHVlLmdldFVUQ01pbnV0ZXMoKTtcbiAgICAgICAgICAgICAgICAgIHNlY29uZHMgPSB2YWx1ZS5nZXRVVENTZWNvbmRzKCk7XG4gICAgICAgICAgICAgICAgICBtaWxsaXNlY29uZHMgPSB2YWx1ZS5nZXRVVENNaWxsaXNlY29uZHMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU2VyaWFsaXplIGV4dGVuZGVkIHllYXJzIGNvcnJlY3RseS5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICh5ZWFyIDw9IDAgfHwgeWVhciA+PSAxZTQgPyAoeWVhciA8IDAgPyBcIi1cIiA6IFwiK1wiKSArIHRvUGFkZGVkU3RyaW5nKDYsIHllYXIgPCAwID8gLXllYXIgOiB5ZWFyKSA6IHRvUGFkZGVkU3RyaW5nKDQsIHllYXIpKSArXG4gICAgICAgICAgICAgICAgICBcIi1cIiArIHRvUGFkZGVkU3RyaW5nKDIsIG1vbnRoICsgMSkgKyBcIi1cIiArIHRvUGFkZGVkU3RyaW5nKDIsIGRhdGUpICtcbiAgICAgICAgICAgICAgICAgIC8vIE1vbnRocywgZGF0ZXMsIGhvdXJzLCBtaW51dGVzLCBhbmQgc2Vjb25kcyBzaG91bGQgaGF2ZSB0d29cbiAgICAgICAgICAgICAgICAgIC8vIGRpZ2l0czsgbWlsbGlzZWNvbmRzIHNob3VsZCBoYXZlIHRocmVlLlxuICAgICAgICAgICAgICAgICAgXCJUXCIgKyB0b1BhZGRlZFN0cmluZygyLCBob3VycykgKyBcIjpcIiArIHRvUGFkZGVkU3RyaW5nKDIsIG1pbnV0ZXMpICsgXCI6XCIgKyB0b1BhZGRlZFN0cmluZygyLCBzZWNvbmRzKSArXG4gICAgICAgICAgICAgICAgICAvLyBNaWxsaXNlY29uZHMgYXJlIG9wdGlvbmFsIGluIEVTIDUuMCwgYnV0IHJlcXVpcmVkIGluIDUuMS5cbiAgICAgICAgICAgICAgICAgIFwiLlwiICsgdG9QYWRkZWRTdHJpbmcoMywgbWlsbGlzZWNvbmRzKSArIFwiWlwiO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUudG9KU09OID09IFwiZnVuY3Rpb25cIiAmJiAoKGNsYXNzTmFtZSAhPSBudW1iZXJDbGFzcyAmJiBjbGFzc05hbWUgIT0gc3RyaW5nQ2xhc3MgJiYgY2xhc3NOYW1lICE9IGFycmF5Q2xhc3MpIHx8IGlzUHJvcGVydHkuY2FsbCh2YWx1ZSwgXCJ0b0pTT05cIikpKSB7XG4gICAgICAgICAgICAgIC8vIFByb3RvdHlwZSA8PSAxLjYuMSBhZGRzIG5vbi1zdGFuZGFyZCBgdG9KU09OYCBtZXRob2RzIHRvIHRoZVxuICAgICAgICAgICAgICAvLyBgTnVtYmVyYCwgYFN0cmluZ2AsIGBEYXRlYCwgYW5kIGBBcnJheWAgcHJvdG90eXBlcy4gSlNPTiAzXG4gICAgICAgICAgICAgIC8vIGlnbm9yZXMgYWxsIGB0b0pTT05gIG1ldGhvZHMgb24gdGhlc2Ugb2JqZWN0cyB1bmxlc3MgdGhleSBhcmVcbiAgICAgICAgICAgICAgLy8gZGVmaW5lZCBkaXJlY3RseSBvbiBhbiBpbnN0YW5jZS5cbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0pTT04ocHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIC8vIElmIGEgcmVwbGFjZW1lbnQgZnVuY3Rpb24gd2FzIHByb3ZpZGVkLCBjYWxsIGl0IHRvIG9idGFpbiB0aGUgdmFsdWVcbiAgICAgICAgICAgIC8vIGZvciBzZXJpYWxpemF0aW9uLlxuICAgICAgICAgICAgdmFsdWUgPSBjYWxsYmFjay5jYWxsKG9iamVjdCwgcHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpO1xuICAgICAgICAgIGlmIChjbGFzc05hbWUgPT0gYm9vbGVhbkNsYXNzKSB7XG4gICAgICAgICAgICAvLyBCb29sZWFucyBhcmUgcmVwcmVzZW50ZWQgbGl0ZXJhbGx5LlxuICAgICAgICAgICAgcmV0dXJuIFwiXCIgKyB2YWx1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBudW1iZXJDbGFzcykge1xuICAgICAgICAgICAgLy8gSlNPTiBudW1iZXJzIG11c3QgYmUgZmluaXRlLiBgSW5maW5pdHlgIGFuZCBgTmFOYCBhcmUgc2VyaWFsaXplZCBhc1xuICAgICAgICAgICAgLy8gYFwibnVsbFwiYC5cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA+IC0xIC8gMCAmJiB2YWx1ZSA8IDEgLyAwID8gXCJcIiArIHZhbHVlIDogXCJudWxsXCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MpIHtcbiAgICAgICAgICAgIC8vIFN0cmluZ3MgYXJlIGRvdWJsZS1xdW90ZWQgYW5kIGVzY2FwZWQuXG4gICAgICAgICAgICByZXR1cm4gcXVvdGUoXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUmVjdXJzaXZlbHkgc2VyaWFsaXplIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBjeWNsaWMgc3RydWN0dXJlcy4gVGhpcyBpcyBhIGxpbmVhciBzZWFyY2g7IHBlcmZvcm1hbmNlXG4gICAgICAgICAgICAvLyBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2YgdW5pcXVlIG5lc3RlZCBvYmplY3RzLlxuICAgICAgICAgICAgZm9yIChsZW5ndGggPSBzdGFjay5sZW5ndGg7IGxlbmd0aC0tOykge1xuICAgICAgICAgICAgICBpZiAoc3RhY2tbbGVuZ3RoXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBDeWNsaWMgc3RydWN0dXJlcyBjYW5ub3QgYmUgc2VyaWFsaXplZCBieSBgSlNPTi5zdHJpbmdpZnlgLlxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgdGhlIG9iamVjdCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgICAgICAgICBzdGFjay5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIC8vIFNhdmUgdGhlIGN1cnJlbnQgaW5kZW50YXRpb24gbGV2ZWwgYW5kIGluZGVudCBvbmUgYWRkaXRpb25hbCBsZXZlbC5cbiAgICAgICAgICAgIHByZWZpeCA9IGluZGVudGF0aW9uO1xuICAgICAgICAgICAgaW5kZW50YXRpb24gKz0gd2hpdGVzcGFjZTtcbiAgICAgICAgICAgIGlmIChjbGFzc05hbWUgPT0gYXJyYXlDbGFzcykge1xuICAgICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgYXJyYXkgZWxlbWVudHMuXG4gICAgICAgICAgICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IHNlcmlhbGl6ZShpbmRleCwgdmFsdWUsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBpbmRlbnRhdGlvbiwgc3RhY2spO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChlbGVtZW50ID09PSB1bmRlZiA/IFwibnVsbFwiIDogZWxlbWVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0cy5sZW5ndGggPyAod2hpdGVzcGFjZSA/IFwiW1xcblwiICsgaW5kZW50YXRpb24gKyByZXN1bHRzLmpvaW4oXCIsXFxuXCIgKyBpbmRlbnRhdGlvbikgKyBcIlxcblwiICsgcHJlZml4ICsgXCJdXCIgOiAoXCJbXCIgKyByZXN1bHRzLmpvaW4oXCIsXCIpICsgXCJdXCIpKSA6IFwiW11cIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBvYmplY3QgbWVtYmVycy4gTWVtYmVycyBhcmUgc2VsZWN0ZWQgZnJvbVxuICAgICAgICAgICAgICAvLyBlaXRoZXIgYSB1c2VyLXNwZWNpZmllZCBsaXN0IG9mIHByb3BlcnR5IG5hbWVzLCBvciB0aGUgb2JqZWN0XG4gICAgICAgICAgICAgIC8vIGl0c2VsZi5cbiAgICAgICAgICAgICAgZm9yRWFjaChwcm9wZXJ0aWVzIHx8IHZhbHVlLCBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHNlcmlhbGl6ZShwcm9wZXJ0eSwgdmFsdWUsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBpbmRlbnRhdGlvbiwgc3RhY2spO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50ICE9PSB1bmRlZikge1xuICAgICAgICAgICAgICAgICAgLy8gQWNjb3JkaW5nIHRvIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjM6IFwiSWYgYGdhcGAge3doaXRlc3BhY2V9XG4gICAgICAgICAgICAgICAgICAvLyBpcyBub3QgdGhlIGVtcHR5IHN0cmluZywgbGV0IGBtZW1iZXJgIHtxdW90ZShwcm9wZXJ0eSkgKyBcIjpcIn1cbiAgICAgICAgICAgICAgICAgIC8vIGJlIHRoZSBjb25jYXRlbmF0aW9uIG9mIGBtZW1iZXJgIGFuZCB0aGUgYHNwYWNlYCBjaGFyYWN0ZXIuXCJcbiAgICAgICAgICAgICAgICAgIC8vIFRoZSBcImBzcGFjZWAgY2hhcmFjdGVyXCIgcmVmZXJzIHRvIHRoZSBsaXRlcmFsIHNwYWNlXG4gICAgICAgICAgICAgICAgICAvLyBjaGFyYWN0ZXIsIG5vdCB0aGUgYHNwYWNlYCB7d2lkdGh9IGFyZ3VtZW50IHByb3ZpZGVkIHRvXG4gICAgICAgICAgICAgICAgICAvLyBgSlNPTi5zdHJpbmdpZnlgLlxuICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHF1b3RlKHByb3BlcnR5KSArIFwiOlwiICsgKHdoaXRlc3BhY2UgPyBcIiBcIiA6IFwiXCIpICsgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0cy5sZW5ndGggPyAod2hpdGVzcGFjZSA/IFwie1xcblwiICsgaW5kZW50YXRpb24gKyByZXN1bHRzLmpvaW4oXCIsXFxuXCIgKyBpbmRlbnRhdGlvbikgKyBcIlxcblwiICsgcHJlZml4ICsgXCJ9XCIgOiAoXCJ7XCIgKyByZXN1bHRzLmpvaW4oXCIsXCIpICsgXCJ9XCIpKSA6IFwie31cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgb2JqZWN0IGZyb20gdGhlIHRyYXZlcnNlZCBvYmplY3Qgc3RhY2suXG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFB1YmxpYzogYEpTT04uc3RyaW5naWZ5YC4gU2VlIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMuXG4gICAgICAgIGV4cG9ydHMuc3RyaW5naWZ5ID0gZnVuY3Rpb24gKHNvdXJjZSwgZmlsdGVyLCB3aWR0aCkge1xuICAgICAgICAgIHZhciB3aGl0ZXNwYWNlLCBjYWxsYmFjaywgcHJvcGVydGllcywgY2xhc3NOYW1lO1xuICAgICAgICAgIGlmIChvYmplY3RUeXBlc1t0eXBlb2YgZmlsdGVyXSAmJiBmaWx0ZXIpIHtcbiAgICAgICAgICAgIGlmICgoY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbChmaWx0ZXIpKSA9PSBmdW5jdGlvbkNsYXNzKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrID0gZmlsdGVyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gYXJyYXlDbGFzcykge1xuICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBwcm9wZXJ0eSBuYW1lcyBhcnJheSBpbnRvIGEgbWFrZXNoaWZ0IHNldC5cbiAgICAgICAgICAgICAgcHJvcGVydGllcyA9IHt9O1xuICAgICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbmd0aCA9IGZpbHRlci5sZW5ndGgsIHZhbHVlOyBpbmRleCA8IGxlbmd0aDsgdmFsdWUgPSBmaWx0ZXJbaW5kZXgrK10sICgoY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh2YWx1ZSkpLCBjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MgfHwgY2xhc3NOYW1lID09IG51bWJlckNsYXNzKSAmJiAocHJvcGVydGllc1t2YWx1ZV0gPSAxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh3aWR0aCkge1xuICAgICAgICAgICAgaWYgKChjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHdpZHRoKSkgPT0gbnVtYmVyQ2xhc3MpIHtcbiAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgYHdpZHRoYCB0byBhbiBpbnRlZ2VyIGFuZCBjcmVhdGUgYSBzdHJpbmcgY29udGFpbmluZ1xuICAgICAgICAgICAgICAvLyBgd2lkdGhgIG51bWJlciBvZiBzcGFjZSBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICBpZiAoKHdpZHRoIC09IHdpZHRoICUgMSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yICh3aGl0ZXNwYWNlID0gXCJcIiwgd2lkdGggPiAxMCAmJiAod2lkdGggPSAxMCk7IHdoaXRlc3BhY2UubGVuZ3RoIDwgd2lkdGg7IHdoaXRlc3BhY2UgKz0gXCIgXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcykge1xuICAgICAgICAgICAgICB3aGl0ZXNwYWNlID0gd2lkdGgubGVuZ3RoIDw9IDEwID8gd2lkdGggOiB3aWR0aC5zbGljZSgwLCAxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIE9wZXJhIDw9IDcuNTR1MiBkaXNjYXJkcyB0aGUgdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCBlbXB0eSBzdHJpbmcga2V5c1xuICAgICAgICAgIC8vIChgXCJcImApIG9ubHkgaWYgdGhleSBhcmUgdXNlZCBkaXJlY3RseSB3aXRoaW4gYW4gb2JqZWN0IG1lbWJlciBsaXN0XG4gICAgICAgICAgLy8gKGUuZy4sIGAhKFwiXCIgaW4geyBcIlwiOiAxfSlgKS5cbiAgICAgICAgICByZXR1cm4gc2VyaWFsaXplKFwiXCIsICh2YWx1ZSA9IHt9LCB2YWx1ZVtcIlwiXSA9IHNvdXJjZSwgdmFsdWUpLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgXCJcIiwgW10pO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBQdWJsaWM6IFBhcnNlcyBhIEpTT04gc291cmNlIHN0cmluZy5cbiAgICAgIGlmICghaGFzKFwianNvbi1wYXJzZVwiKSkge1xuICAgICAgICB2YXIgZnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogQSBtYXAgb2YgZXNjYXBlZCBjb250cm9sIGNoYXJhY3RlcnMgYW5kIHRoZWlyIHVuZXNjYXBlZFxuICAgICAgICAvLyBlcXVpdmFsZW50cy5cbiAgICAgICAgdmFyIFVuZXNjYXBlcyA9IHtcbiAgICAgICAgICA5MjogXCJcXFxcXCIsXG4gICAgICAgICAgMzQ6ICdcIicsXG4gICAgICAgICAgNDc6IFwiL1wiLFxuICAgICAgICAgIDk4OiBcIlxcYlwiLFxuICAgICAgICAgIDExNjogXCJcXHRcIixcbiAgICAgICAgICAxMTA6IFwiXFxuXCIsXG4gICAgICAgICAgMTAyOiBcIlxcZlwiLFxuICAgICAgICAgIDExNDogXCJcXHJcIlxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBTdG9yZXMgdGhlIHBhcnNlciBzdGF0ZS5cbiAgICAgICAgdmFyIEluZGV4LCBTb3VyY2U7XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJlc2V0cyB0aGUgcGFyc2VyIHN0YXRlIGFuZCB0aHJvd3MgYSBgU3ludGF4RXJyb3JgLlxuICAgICAgICB2YXIgYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgSW5kZXggPSBTb3VyY2UgPSBudWxsO1xuICAgICAgICAgIHRocm93IFN5bnRheEVycm9yKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJldHVybnMgdGhlIG5leHQgdG9rZW4sIG9yIGBcIiRcImAgaWYgdGhlIHBhcnNlciBoYXMgcmVhY2hlZFxuICAgICAgICAvLyB0aGUgZW5kIG9mIHRoZSBzb3VyY2Ugc3RyaW5nLiBBIHRva2VuIG1heSBiZSBhIHN0cmluZywgbnVtYmVyLCBgbnVsbGBcbiAgICAgICAgLy8gbGl0ZXJhbCwgb3IgQm9vbGVhbiBsaXRlcmFsLlxuICAgICAgICB2YXIgbGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBzb3VyY2UgPSBTb3VyY2UsIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGgsIHZhbHVlLCBiZWdpbiwgcG9zaXRpb24sIGlzU2lnbmVkLCBjaGFyQ29kZTtcbiAgICAgICAgICB3aGlsZSAoSW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xuICAgICAgICAgICAgICBjYXNlIDk6IGNhc2UgMTA6IGNhc2UgMTM6IGNhc2UgMzI6XG4gICAgICAgICAgICAgICAgLy8gU2tpcCB3aGl0ZXNwYWNlIHRva2VucywgaW5jbHVkaW5nIHRhYnMsIGNhcnJpYWdlIHJldHVybnMsIGxpbmVcbiAgICAgICAgICAgICAgICAvLyBmZWVkcywgYW5kIHNwYWNlIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAxMjM6IGNhc2UgMTI1OiBjYXNlIDkxOiBjYXNlIDkzOiBjYXNlIDU4OiBjYXNlIDQ0OlxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIGEgcHVuY3R1YXRvciB0b2tlbiAoYHtgLCBgfWAsIGBbYCwgYF1gLCBgOmAsIG9yIGAsYCkgYXRcbiAgICAgICAgICAgICAgICAvLyB0aGUgY3VycmVudCBwb3NpdGlvbi5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGNoYXJJbmRleEJ1Z2d5ID8gc291cmNlLmNoYXJBdChJbmRleCkgOiBzb3VyY2VbSW5kZXhdO1xuICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICBjYXNlIDM0OlxuICAgICAgICAgICAgICAgIC8vIGBcImAgZGVsaW1pdHMgYSBKU09OIHN0cmluZzsgYWR2YW5jZSB0byB0aGUgbmV4dCBjaGFyYWN0ZXIgYW5kXG4gICAgICAgICAgICAgICAgLy8gYmVnaW4gcGFyc2luZyB0aGUgc3RyaW5nLiBTdHJpbmcgdG9rZW5zIGFyZSBwcmVmaXhlZCB3aXRoIHRoZVxuICAgICAgICAgICAgICAgIC8vIHNlbnRpbmVsIGBAYCBjaGFyYWN0ZXIgdG8gZGlzdGluZ3Vpc2ggdGhlbSBmcm9tIHB1bmN0dWF0b3JzIGFuZFxuICAgICAgICAgICAgICAgIC8vIGVuZC1vZi1zdHJpbmcgdG9rZW5zLlxuICAgICAgICAgICAgICAgIGZvciAodmFsdWUgPSBcIkBcIiwgSW5kZXgrKzsgSW5kZXggPCBsZW5ndGg7KSB7XG4gICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA8IDMyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVuZXNjYXBlZCBBU0NJSSBjb250cm9sIGNoYXJhY3RlcnMgKHRob3NlIHdpdGggYSBjb2RlIHVuaXRcbiAgICAgICAgICAgICAgICAgICAgLy8gbGVzcyB0aGFuIHRoZSBzcGFjZSBjaGFyYWN0ZXIpIGFyZSBub3QgcGVybWl0dGVkLlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGFyQ29kZSA9PSA5Mikge1xuICAgICAgICAgICAgICAgICAgICAvLyBBIHJldmVyc2Ugc29saWR1cyAoYFxcYCkgbWFya3MgdGhlIGJlZ2lubmluZyBvZiBhbiBlc2NhcGVkXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnRyb2wgY2hhcmFjdGVyIChpbmNsdWRpbmcgYFwiYCwgYFxcYCwgYW5kIGAvYCkgb3IgVW5pY29kZVxuICAgICAgICAgICAgICAgICAgICAvLyBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDkyOiBjYXNlIDM0OiBjYXNlIDQ3OiBjYXNlIDk4OiBjYXNlIDExNjogY2FzZSAxMTA6IGNhc2UgMTAyOiBjYXNlIDExNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldml2ZSBlc2NhcGVkIGNvbnRyb2wgY2hhcmFjdGVycy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IFVuZXNjYXBlc1tjaGFyQ29kZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTc6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBgXFx1YCBtYXJrcyB0aGUgYmVnaW5uaW5nIG9mIGEgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHRvIHRoZSBmaXJzdCBjaGFyYWN0ZXIgYW5kIHZhbGlkYXRlIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm91ci1kaWdpdCBjb2RlIHBvaW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgYmVnaW4gPSArK0luZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChwb3NpdGlvbiA9IEluZGV4ICsgNDsgSW5kZXggPCBwb3NpdGlvbjsgSW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQSB2YWxpZCBzZXF1ZW5jZSBjb21wcmlzZXMgZm91ciBoZXhkaWdpdHMgKGNhc2UtXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluc2Vuc2l0aXZlKSB0aGF0IGZvcm0gYSBzaW5nbGUgaGV4YWRlY2ltYWwgdmFsdWUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3IHx8IGNoYXJDb2RlID49IDk3ICYmIGNoYXJDb2RlIDw9IDEwMiB8fCBjaGFyQ29kZSA+PSA2NSAmJiBjaGFyQ29kZSA8PSA3MCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldml2ZSB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBmcm9tQ2hhckNvZGUoXCIweFwiICsgc291cmNlLnNsaWNlKGJlZ2luLCBJbmRleCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEludmFsaWQgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDM0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gQW4gdW5lc2NhcGVkIGRvdWJsZS1xdW90ZSBjaGFyYWN0ZXIgbWFya3MgdGhlIGVuZCBvZiB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAvLyBzdHJpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGJlZ2luID0gSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9wdGltaXplIGZvciB0aGUgY29tbW9uIGNhc2Ugd2hlcmUgYSBzdHJpbmcgaXMgdmFsaWQuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChjaGFyQ29kZSA+PSAzMiAmJiBjaGFyQ29kZSAhPSA5MiAmJiBjaGFyQ29kZSAhPSAzNCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwZW5kIHRoZSBzdHJpbmcgYXMtaXMuXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHNvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpID09IDM0KSB7XG4gICAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHRvIHRoZSBuZXh0IGNoYXJhY3RlciBhbmQgcmV0dXJuIHRoZSByZXZpdmVkIHN0cmluZy5cbiAgICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFVudGVybWluYXRlZCBzdHJpbmcuXG4gICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBQYXJzZSBudW1iZXJzIGFuZCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBiZWdpbiA9IEluZGV4O1xuICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgcGFzdCB0aGUgbmVnYXRpdmUgc2lnbiwgaWYgb25lIGlzIHNwZWNpZmllZC5cbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDUpIHtcbiAgICAgICAgICAgICAgICAgIGlzU2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIGFuIGludGVnZXIgb3IgZmxvYXRpbmctcG9pbnQgdmFsdWUuXG4gICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KSB7XG4gICAgICAgICAgICAgICAgICAvLyBMZWFkaW5nIHplcm9lcyBhcmUgaW50ZXJwcmV0ZWQgYXMgb2N0YWwgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4ICsgMSkpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1NykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbCBvY3RhbCBsaXRlcmFsLlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaXNTaWduZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBpbnRlZ2VyIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgICAgIGZvciAoOyBJbmRleCA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBJbmRleCsrKTtcbiAgICAgICAgICAgICAgICAgIC8vIEZsb2F0cyBjYW5ub3QgY29udGFpbiBhIGxlYWRpbmcgZGVjaW1hbCBwb2ludDsgaG93ZXZlciwgdGhpc1xuICAgICAgICAgICAgICAgICAgLy8gY2FzZSBpcyBhbHJlYWR5IGFjY291bnRlZCBmb3IgYnkgdGhlIHBhcnNlci5cbiAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChJbmRleCkgPT0gNDYpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSArK0luZGV4O1xuICAgICAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgZGVjaW1hbCBjb21wb25lbnQuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBwb3NpdGlvbiA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQocG9zaXRpb24pKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBwb3NpdGlvbisrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09IEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbCB0cmFpbGluZyBkZWNpbWFsLlxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgSW5kZXggPSBwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIGV4cG9uZW50cy4gVGhlIGBlYCBkZW5vdGluZyB0aGUgZXhwb25lbnQgaXNcbiAgICAgICAgICAgICAgICAgIC8vIGNhc2UtaW5zZW5zaXRpdmUuXG4gICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSAxMDEgfHwgY2hhckNvZGUgPT0gNjkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2tpcCBwYXN0IHRoZSBzaWduIGZvbGxvd2luZyB0aGUgZXhwb25lbnQsIGlmIG9uZSBpc1xuICAgICAgICAgICAgICAgICAgICAvLyBzcGVjaWZpZWQuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSA0MyB8fCBjaGFyQ29kZSA9PSA0NSkge1xuICAgICAgICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGV4cG9uZW50aWFsIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChwb3NpdGlvbiA9IEluZGV4OyBwb3NpdGlvbiA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQocG9zaXRpb24pKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBwb3NpdGlvbisrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09IEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbCBlbXB0eSBleHBvbmVudC5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIEluZGV4ID0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvLyBDb2VyY2UgdGhlIHBhcnNlZCB2YWx1ZSB0byBhIEphdmFTY3JpcHQgbnVtYmVyLlxuICAgICAgICAgICAgICAgICAgcmV0dXJuICtzb3VyY2Uuc2xpY2UoYmVnaW4sIEluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQSBuZWdhdGl2ZSBzaWduIG1heSBvbmx5IHByZWNlZGUgbnVtYmVycy5cbiAgICAgICAgICAgICAgICBpZiAoaXNTaWduZWQpIHtcbiAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGB0cnVlYCwgYGZhbHNlYCwgYW5kIGBudWxsYCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDQpID09IFwidHJ1ZVwiKSB7XG4gICAgICAgICAgICAgICAgICBJbmRleCArPSA0O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgNSkgPT0gXCJmYWxzZVwiKSB7XG4gICAgICAgICAgICAgICAgICBJbmRleCArPSA1O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDQpID09IFwibnVsbFwiKSB7XG4gICAgICAgICAgICAgICAgICBJbmRleCArPSA0O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFVucmVjb2duaXplZCB0b2tlbi5cbiAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZXR1cm4gdGhlIHNlbnRpbmVsIGAkYCBjaGFyYWN0ZXIgaWYgdGhlIHBhcnNlciBoYXMgcmVhY2hlZCB0aGUgZW5kXG4gICAgICAgICAgLy8gb2YgdGhlIHNvdXJjZSBzdHJpbmcuXG4gICAgICAgICAgcmV0dXJuIFwiJFwiO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBQYXJzZXMgYSBKU09OIGB2YWx1ZWAgdG9rZW4uXG4gICAgICAgIHZhciBnZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0cywgaGFzTWVtYmVycztcbiAgICAgICAgICBpZiAodmFsdWUgPT0gXCIkXCIpIHtcbiAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgZW5kIG9mIGlucHV0LlxuICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAoKGNoYXJJbmRleEJ1Z2d5ID8gdmFsdWUuY2hhckF0KDApIDogdmFsdWVbMF0pID09IFwiQFwiKSB7XG4gICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgc2VudGluZWwgYEBgIGNoYXJhY3Rlci5cbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnNsaWNlKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUGFyc2Ugb2JqZWN0IGFuZCBhcnJheSBsaXRlcmFscy5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIltcIikge1xuICAgICAgICAgICAgICAvLyBQYXJzZXMgYSBKU09OIGFycmF5LCByZXR1cm5pbmcgYSBuZXcgSmF2YVNjcmlwdCBhcnJheS5cbiAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICBmb3IgKDs7IGhhc01lbWJlcnMgfHwgKGhhc01lbWJlcnMgPSB0cnVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgLy8gQSBjbG9zaW5nIHNxdWFyZSBicmFja2V0IG1hcmtzIHRoZSBlbmQgb2YgdGhlIGFycmF5IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiXVwiKSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGFycmF5IGxpdGVyYWwgY29udGFpbnMgZWxlbWVudHMsIHRoZSBjdXJyZW50IHRva2VuXG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGEgY29tbWEgc2VwYXJhdGluZyB0aGUgcHJldmlvdXMgZWxlbWVudCBmcm9tIHRoZVxuICAgICAgICAgICAgICAgIC8vIG5leHQuXG4gICAgICAgICAgICAgICAgaWYgKGhhc01lbWJlcnMpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJdXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRyYWlsaW5nIGAsYCBpbiBhcnJheSBsaXRlcmFsLlxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgYCxgIG11c3Qgc2VwYXJhdGUgZWFjaCBhcnJheSBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBFbGlzaW9ucyBhbmQgbGVhZGluZyBjb21tYXMgYXJlIG5vdCBwZXJtaXR0ZWQuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZ2V0KHZhbHVlKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09IFwie1wiKSB7XG4gICAgICAgICAgICAgIC8vIFBhcnNlcyBhIEpTT04gb2JqZWN0LCByZXR1cm5pbmcgYSBuZXcgSmF2YVNjcmlwdCBvYmplY3QuXG4gICAgICAgICAgICAgIHJlc3VsdHMgPSB7fTtcbiAgICAgICAgICAgICAgZm9yICg7OyBoYXNNZW1iZXJzIHx8IChoYXNNZW1iZXJzID0gdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgIC8vIEEgY2xvc2luZyBjdXJseSBicmFjZSBtYXJrcyB0aGUgZW5kIG9mIHRoZSBvYmplY3QgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJ9XCIpIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgb2JqZWN0IGxpdGVyYWwgY29udGFpbnMgbWVtYmVycywgdGhlIGN1cnJlbnQgdG9rZW5cbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgYmUgYSBjb21tYSBzZXBhcmF0b3IuXG4gICAgICAgICAgICAgICAgaWYgKGhhc01lbWJlcnMpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJ9XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRyYWlsaW5nIGAsYCBpbiBvYmplY3QgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBBIGAsYCBtdXN0IHNlcGFyYXRlIGVhY2ggb2JqZWN0IG1lbWJlci5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gTGVhZGluZyBjb21tYXMgYXJlIG5vdCBwZXJtaXR0ZWQsIG9iamVjdCBwcm9wZXJ0eSBuYW1lcyBtdXN0IGJlXG4gICAgICAgICAgICAgICAgLy8gZG91YmxlLXF1b3RlZCBzdHJpbmdzLCBhbmQgYSBgOmAgbXVzdCBzZXBhcmF0ZSBlYWNoIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgLy8gbmFtZSBhbmQgdmFsdWUuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiIHx8IHR5cGVvZiB2YWx1ZSAhPSBcInN0cmluZ1wiIHx8IChjaGFySW5kZXhCdWdneSA/IHZhbHVlLmNoYXJBdCgwKSA6IHZhbHVlWzBdKSAhPSBcIkBcIiB8fCBsZXgoKSAhPSBcIjpcIikge1xuICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0c1t2YWx1ZS5zbGljZSgxKV0gPSBnZXQobGV4KCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVW5leHBlY3RlZCB0b2tlbiBlbmNvdW50ZXJlZC5cbiAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogVXBkYXRlcyBhIHRyYXZlcnNlZCBvYmplY3QgbWVtYmVyLlxuICAgICAgICB2YXIgdXBkYXRlID0gZnVuY3Rpb24gKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSB3YWxrKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKTtcbiAgICAgICAgICBpZiAoZWxlbWVudCA9PT0gdW5kZWYpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBzb3VyY2VbcHJvcGVydHldO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzb3VyY2VbcHJvcGVydHldID0gZWxlbWVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJlY3Vyc2l2ZWx5IHRyYXZlcnNlcyBhIHBhcnNlZCBKU09OIG9iamVjdCwgaW52b2tpbmcgdGhlXG4gICAgICAgIC8vIGBjYWxsYmFja2AgZnVuY3Rpb24gZm9yIGVhY2ggdmFsdWUuIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhlXG4gICAgICAgIC8vIGBXYWxrKGhvbGRlciwgbmFtZSlgIG9wZXJhdGlvbiBkZWZpbmVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjIuXG4gICAgICAgIHZhciB3YWxrID0gZnVuY3Rpb24gKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gc291cmNlW3Byb3BlcnR5XSwgbGVuZ3RoO1xuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgLy8gYGZvckVhY2hgIGNhbid0IGJlIHVzZWQgdG8gdHJhdmVyc2UgYW4gYXJyYXkgaW4gT3BlcmEgPD0gOC41NFxuICAgICAgICAgICAgLy8gYmVjYXVzZSBpdHMgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgaW1wbGVtZW50YXRpb24gcmV0dXJucyBgZmFsc2VgXG4gICAgICAgICAgICAvLyBmb3IgYXJyYXkgaW5kaWNlcyAoZS5nLiwgYCFbMSwgMiwgM10uaGFzT3duUHJvcGVydHkoXCIwXCIpYCkuXG4gICAgICAgICAgICBpZiAoZ2V0Q2xhc3MuY2FsbCh2YWx1ZSkgPT0gYXJyYXlDbGFzcykge1xuICAgICAgICAgICAgICBmb3IgKGxlbmd0aCA9IHZhbHVlLmxlbmd0aDsgbGVuZ3RoLS07KSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlKHZhbHVlLCBsZW5ndGgsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZm9yRWFjaCh2YWx1ZSwgZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlKHZhbHVlLCBwcm9wZXJ0eSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoc291cmNlLCBwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFB1YmxpYzogYEpTT04ucGFyc2VgLiBTZWUgRVMgNS4xIHNlY3Rpb24gMTUuMTIuMi5cbiAgICAgICAgZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uIChzb3VyY2UsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCwgdmFsdWU7XG4gICAgICAgICAgSW5kZXggPSAwO1xuICAgICAgICAgIFNvdXJjZSA9IFwiXCIgKyBzb3VyY2U7XG4gICAgICAgICAgcmVzdWx0ID0gZ2V0KGxleCgpKTtcbiAgICAgICAgICAvLyBJZiBhIEpTT04gc3RyaW5nIGNvbnRhaW5zIG11bHRpcGxlIHRva2VucywgaXQgaXMgaW52YWxpZC5cbiAgICAgICAgICBpZiAobGV4KCkgIT0gXCIkXCIpIHtcbiAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFJlc2V0IHRoZSBwYXJzZXIgc3RhdGUuXG4gICAgICAgICAgSW5kZXggPSBTb3VyY2UgPSBudWxsO1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayAmJiBnZXRDbGFzcy5jYWxsKGNhbGxiYWNrKSA9PSBmdW5jdGlvbkNsYXNzID8gd2FsaygodmFsdWUgPSB7fSwgdmFsdWVbXCJcIl0gPSByZXN1bHQsIHZhbHVlKSwgXCJcIiwgY2FsbGJhY2spIDogcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIGV4cG9ydHNbXCJydW5JbkNvbnRleHRcIl0gPSBydW5JbkNvbnRleHQ7XG4gICAgcmV0dXJuIGV4cG9ydHM7XG4gIH1cblxuICBpZiAoZnJlZUV4cG9ydHMgJiYgIWlzTG9hZGVyKSB7XG4gICAgLy8gRXhwb3J0IGZvciBDb21tb25KUyBlbnZpcm9ubWVudHMuXG4gICAgcnVuSW5Db250ZXh0KHJvb3QsIGZyZWVFeHBvcnRzKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBFeHBvcnQgZm9yIHdlYiBicm93c2VycyBhbmQgSmF2YVNjcmlwdCBlbmdpbmVzLlxuICAgIHZhciBuYXRpdmVKU09OID0gcm9vdC5KU09OLFxuICAgICAgICBwcmV2aW91c0pTT04gPSByb290W1wiSlNPTjNcIl0sXG4gICAgICAgIGlzUmVzdG9yZWQgPSBmYWxzZTtcblxuICAgIHZhciBKU09OMyA9IHJ1bkluQ29udGV4dChyb290LCAocm9vdFtcIkpTT04zXCJdID0ge1xuICAgICAgLy8gUHVibGljOiBSZXN0b3JlcyB0aGUgb3JpZ2luYWwgdmFsdWUgb2YgdGhlIGdsb2JhbCBgSlNPTmAgb2JqZWN0IGFuZFxuICAgICAgLy8gcmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgYEpTT04zYCBvYmplY3QuXG4gICAgICBcIm5vQ29uZmxpY3RcIjogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWlzUmVzdG9yZWQpIHtcbiAgICAgICAgICBpc1Jlc3RvcmVkID0gdHJ1ZTtcbiAgICAgICAgICByb290LkpTT04gPSBuYXRpdmVKU09OO1xuICAgICAgICAgIHJvb3RbXCJKU09OM1wiXSA9IHByZXZpb3VzSlNPTjtcbiAgICAgICAgICBuYXRpdmVKU09OID0gcHJldmlvdXNKU09OID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSlNPTjM7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgcm9vdC5KU09OID0ge1xuICAgICAgXCJwYXJzZVwiOiBKU09OMy5wYXJzZSxcbiAgICAgIFwic3RyaW5naWZ5XCI6IEpTT04zLnN0cmluZ2lmeVxuICAgIH07XG4gIH1cblxuICAvLyBFeHBvcnQgZm9yIGFzeW5jaHJvbm91cyBtb2R1bGUgbG9hZGVycy5cbiAgaWYgKGlzTG9hZGVyKSB7XG4gICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBKU09OMztcbiAgICB9KTtcbiAgfVxufSkuY2FsbCh0aGlzKTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDoge30pXG59LHt9XSwzNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHkgPSBkICogMzY1LjI1O1xuXG4vKipcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKXtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgdmFsKSByZXR1cm4gcGFyc2UodmFsKTtcbiAgcmV0dXJuIG9wdGlvbnMubG9uZ1xuICAgID8gbG9uZyh2YWwpXG4gICAgOiBzaG9ydCh2YWwpO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHN0ciA9ICcnICsgc3RyO1xuICBpZiAoc3RyLmxlbmd0aCA+IDEwMDAwKSByZXR1cm47XG4gIHZhciBtYXRjaCA9IC9eKCg/OlxcZCspP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoc3RyKTtcbiAgaWYgKCFtYXRjaCkgcmV0dXJuO1xuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZDtcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnaG91cic6XG4gICAgY2FzZSAnaHJzJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gbiAqIGg7XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICBjYXNlICdtaW5zJzpcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG4gKiBtO1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogcztcbiAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICBjYXNlICdtc2Vjcyc6XG4gICAgY2FzZSAnbXNlYyc6XG4gICAgY2FzZSAnbXMnOlxuICAgICAgcmV0dXJuIG47XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzaG9ydChtcykge1xuICBpZiAobXMgPj0gZCkgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcbiAgaWYgKG1zID49IGgpIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG4gIGlmIChtcyA+PSBtKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuICBpZiAobXMgPj0gcykgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvbmcobXMpIHtcbiAgcmV0dXJuIHBsdXJhbChtcywgZCwgJ2RheScpXG4gICAgfHwgcGx1cmFsKG1zLCBoLCAnaG91cicpXG4gICAgfHwgcGx1cmFsKG1zLCBtLCAnbWludXRlJylcbiAgICB8fCBwbHVyYWwobXMsIHMsICdzZWNvbmQnKVxuICAgIHx8IG1zICsgJyBtcyc7XG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBuLCBuYW1lKSB7XG4gIGlmIChtcyA8IG4pIHJldHVybjtcbiAgaWYgKG1zIDwgbiAqIDEuNSkgcmV0dXJuIE1hdGguZmxvb3IobXMgLyBuKSArICcgJyArIG5hbWU7XG4gIHJldHVybiBNYXRoLmNlaWwobXMgLyBuKSArICcgJyArIG5hbWUgKyAncyc7XG59XG5cbn0se31dLDM2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbi8qKlxuICogSlNPTiBwYXJzZS5cbiAqXG4gKiBAc2VlIEJhc2VkIG9uIGpRdWVyeSNwYXJzZUpTT04gKE1JVCkgYW5kIEpTT04yXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG52YXIgcnZhbGlkY2hhcnMgPSAvXltcXF0sOnt9XFxzXSokLztcbnZhciBydmFsaWRlc2NhcGUgPSAvXFxcXCg/OltcIlxcXFxcXC9iZm5ydF18dVswLTlhLWZBLUZdezR9KS9nO1xudmFyIHJ2YWxpZHRva2VucyA9IC9cIlteXCJcXFxcXFxuXFxyXSpcInx0cnVlfGZhbHNlfG51bGx8LT9cXGQrKD86XFwuXFxkKik/KD86W2VFXVsrXFwtXT9cXGQrKT8vZztcbnZhciBydmFsaWRicmFjZXMgPSAvKD86Xnw6fCwpKD86XFxzKlxcWykrL2c7XG52YXIgcnRyaW1MZWZ0ID0gL15cXHMrLztcbnZhciBydHJpbVJpZ2h0ID0gL1xccyskLztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZWpzb24oZGF0YSkge1xuICBpZiAoJ3N0cmluZycgIT0gdHlwZW9mIGRhdGEgfHwgIWRhdGEpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGRhdGEgPSBkYXRhLnJlcGxhY2UocnRyaW1MZWZ0LCAnJykucmVwbGFjZShydHJpbVJpZ2h0LCAnJyk7XG5cbiAgLy8gQXR0ZW1wdCB0byBwYXJzZSB1c2luZyB0aGUgbmF0aXZlIEpTT04gcGFyc2VyIGZpcnN0XG4gIGlmIChnbG9iYWwuSlNPTiAmJiBKU09OLnBhcnNlKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoZGF0YSk7XG4gIH1cblxuICBpZiAocnZhbGlkY2hhcnMudGVzdChkYXRhLnJlcGxhY2UocnZhbGlkZXNjYXBlLCAnQCcpXG4gICAgICAucmVwbGFjZShydmFsaWR0b2tlbnMsICddJylcbiAgICAgIC5yZXBsYWNlKHJ2YWxpZGJyYWNlcywgJycpKSkge1xuICAgIHJldHVybiAobmV3IEZ1bmN0aW9uKCdyZXR1cm4gJyArIGRhdGEpKSgpO1xuICB9XG59O1xufSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDoge30pXG59LHt9XSwzNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIENvbXBpbGVzIGEgcXVlcnlzdHJpbmdcbiAqIFJldHVybnMgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24gKG9iaikge1xuICB2YXIgc3RyID0gJyc7XG5cbiAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICBpZiAoc3RyLmxlbmd0aCkgc3RyICs9ICcmJztcbiAgICAgIHN0ciArPSBlbmNvZGVVUklDb21wb25lbnQoaSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQob2JqW2ldKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3RyO1xufTtcblxuLyoqXG4gKiBQYXJzZXMgYSBzaW1wbGUgcXVlcnlzdHJpbmcgaW50byBhbiBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24ocXMpe1xuICB2YXIgcXJ5ID0ge307XG4gIHZhciBwYWlycyA9IHFzLnNwbGl0KCcmJyk7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gcGFpcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIHBhaXIgPSBwYWlyc1tpXS5zcGxpdCgnPScpO1xuICAgIHFyeVtkZWNvZGVVUklDb21wb25lbnQocGFpclswXSldID0gZGVjb2RlVVJJQ29tcG9uZW50KHBhaXJbMV0pO1xuICB9XG4gIHJldHVybiBxcnk7XG59O1xuXG59LHt9XSwzODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIFBhcnNlcyBhbiBVUklcbiAqXG4gKiBAYXV0aG9yIFN0ZXZlbiBMZXZpdGhhbiA8c3RldmVubGV2aXRoYW4uY29tPiAoTUlUIGxpY2Vuc2UpXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG52YXIgcmUgPSAvXig/Oig/IVteOkBdKzpbXjpAXFwvXSpAKShodHRwfGh0dHBzfHdzfHdzcyk6XFwvXFwvKT8oKD86KChbXjpAXSopKD86OihbXjpAXSopKT8pP0ApPygoPzpbYS1mMC05XXswLDR9Oil7Miw3fVthLWYwLTldezAsNH18W146XFwvPyNdKikoPzo6KFxcZCopKT8pKCgoXFwvKD86W14/I10oPyFbXj8jXFwvXSpcXC5bXj8jXFwvLl0rKD86Wz8jXXwkKSkpKlxcLz8pPyhbXj8jXFwvXSopKSg/OlxcPyhbXiNdKikpPyg/OiMoLiopKT8pLztcblxudmFyIHBhcnRzID0gW1xuICAgICdzb3VyY2UnLCAncHJvdG9jb2wnLCAnYXV0aG9yaXR5JywgJ3VzZXJJbmZvJywgJ3VzZXInLCAncGFzc3dvcmQnLCAnaG9zdCcsICdwb3J0JywgJ3JlbGF0aXZlJywgJ3BhdGgnLCAnZGlyZWN0b3J5JywgJ2ZpbGUnLCAncXVlcnknLCAnYW5jaG9yJ1xuXTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZXVyaShzdHIpIHtcbiAgICB2YXIgc3JjID0gc3RyLFxuICAgICAgICBiID0gc3RyLmluZGV4T2YoJ1snKSxcbiAgICAgICAgZSA9IHN0ci5pbmRleE9mKCddJyk7XG5cbiAgICBpZiAoYiAhPSAtMSAmJiBlICE9IC0xKSB7XG4gICAgICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgYikgKyBzdHIuc3Vic3RyaW5nKGIsIGUpLnJlcGxhY2UoLzovZywgJzsnKSArIHN0ci5zdWJzdHJpbmcoZSwgc3RyLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgdmFyIG0gPSByZS5leGVjKHN0ciB8fCAnJyksXG4gICAgICAgIHVyaSA9IHt9LFxuICAgICAgICBpID0gMTQ7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHVyaVtwYXJ0c1tpXV0gPSBtW2ldIHx8ICcnO1xuICAgIH1cblxuICAgIGlmIChiICE9IC0xICYmIGUgIT0gLTEpIHtcbiAgICAgICAgdXJpLnNvdXJjZSA9IHNyYztcbiAgICAgICAgdXJpLmhvc3QgPSB1cmkuaG9zdC5zdWJzdHJpbmcoMSwgdXJpLmhvc3QubGVuZ3RoIC0gMSkucmVwbGFjZSgvOy9nLCAnOicpO1xuICAgICAgICB1cmkuYXV0aG9yaXR5ID0gdXJpLmF1dGhvcml0eS5yZXBsYWNlKCdbJywgJycpLnJlcGxhY2UoJ10nLCAnJykucmVwbGFjZSgvOy9nLCAnOicpO1xuICAgICAgICB1cmkuaXB2NnVyaSA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVyaTtcbn07XG5cbn0se31dLDM5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbi8qZ2xvYmFsIEJsb2IsRmlsZSovXG5cbi8qKlxuICogTW9kdWxlIHJlcXVpcmVtZW50c1xuICovXG5cbnZhciBpc0FycmF5ID0gX2RlcmVxXygnaXNhcnJheScpO1xudmFyIGlzQnVmID0gX2RlcmVxXygnLi9pcy1idWZmZXInKTtcblxuLyoqXG4gKiBSZXBsYWNlcyBldmVyeSBCdWZmZXIgfCBBcnJheUJ1ZmZlciBpbiBwYWNrZXQgd2l0aCBhIG51bWJlcmVkIHBsYWNlaG9sZGVyLlxuICogQW55dGhpbmcgd2l0aCBibG9icyBvciBmaWxlcyBzaG91bGQgYmUgZmVkIHRocm91Z2ggcmVtb3ZlQmxvYnMgYmVmb3JlIGNvbWluZ1xuICogaGVyZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0IC0gc29ja2V0LmlvIGV2ZW50IHBhY2tldFxuICogQHJldHVybiB7T2JqZWN0fSB3aXRoIGRlY29uc3RydWN0ZWQgcGFja2V0IGFuZCBsaXN0IG9mIGJ1ZmZlcnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5kZWNvbnN0cnVjdFBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCl7XG4gIHZhciBidWZmZXJzID0gW107XG4gIHZhciBwYWNrZXREYXRhID0gcGFja2V0LmRhdGE7XG5cbiAgZnVuY3Rpb24gX2RlY29uc3RydWN0UGFja2V0KGRhdGEpIHtcbiAgICBpZiAoIWRhdGEpIHJldHVybiBkYXRhO1xuXG4gICAgaWYgKGlzQnVmKGRhdGEpKSB7XG4gICAgICB2YXIgcGxhY2Vob2xkZXIgPSB7IF9wbGFjZWhvbGRlcjogdHJ1ZSwgbnVtOiBidWZmZXJzLmxlbmd0aCB9O1xuICAgICAgYnVmZmVycy5wdXNoKGRhdGEpO1xuICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShkYXRhKSkge1xuICAgICAgdmFyIG5ld0RhdGEgPSBuZXcgQXJyYXkoZGF0YS5sZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5ld0RhdGFbaV0gPSBfZGVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3RGF0YTtcbiAgICB9IGVsc2UgaWYgKCdvYmplY3QnID09IHR5cGVvZiBkYXRhICYmICEoZGF0YSBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgICB2YXIgbmV3RGF0YSA9IHt9O1xuICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgICAgbmV3RGF0YVtrZXldID0gX2RlY29uc3RydWN0UGFja2V0KGRhdGFba2V5XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3RGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICB2YXIgcGFjayA9IHBhY2tldDtcbiAgcGFjay5kYXRhID0gX2RlY29uc3RydWN0UGFja2V0KHBhY2tldERhdGEpO1xuICBwYWNrLmF0dGFjaG1lbnRzID0gYnVmZmVycy5sZW5ndGg7IC8vIG51bWJlciBvZiBiaW5hcnkgJ2F0dGFjaG1lbnRzJ1xuICByZXR1cm4ge3BhY2tldDogcGFjaywgYnVmZmVyczogYnVmZmVyc307XG59O1xuXG4vKipcbiAqIFJlY29uc3RydWN0cyBhIGJpbmFyeSBwYWNrZXQgZnJvbSBpdHMgcGxhY2Vob2xkZXIgcGFja2V0IGFuZCBidWZmZXJzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCAtIGV2ZW50IHBhY2tldCB3aXRoIHBsYWNlaG9sZGVyc1xuICogQHBhcmFtIHtBcnJheX0gYnVmZmVycyAtIGJpbmFyeSBidWZmZXJzIHRvIHB1dCBpbiBwbGFjZWhvbGRlciBwb3NpdGlvbnNcbiAqIEByZXR1cm4ge09iamVjdH0gcmVjb25zdHJ1Y3RlZCBwYWNrZXRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5yZWNvbnN0cnVjdFBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCwgYnVmZmVycykge1xuICB2YXIgY3VyUGxhY2VIb2xkZXIgPSAwO1xuXG4gIGZ1bmN0aW9uIF9yZWNvbnN0cnVjdFBhY2tldChkYXRhKSB7XG4gICAgaWYgKGRhdGEgJiYgZGF0YS5fcGxhY2Vob2xkZXIpIHtcbiAgICAgIHZhciBidWYgPSBidWZmZXJzW2RhdGEubnVtXTsgLy8gYXBwcm9wcmlhdGUgYnVmZmVyIChzaG91bGQgYmUgbmF0dXJhbCBvcmRlciBhbnl3YXkpXG4gICAgICByZXR1cm4gYnVmO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShkYXRhKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRhdGFbaV0gPSBfcmVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9IGVsc2UgaWYgKGRhdGEgJiYgJ29iamVjdCcgPT0gdHlwZW9mIGRhdGEpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICAgIGRhdGFba2V5XSA9IF9yZWNvbnN0cnVjdFBhY2tldChkYXRhW2tleV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgcGFja2V0LmRhdGEgPSBfcmVjb25zdHJ1Y3RQYWNrZXQocGFja2V0LmRhdGEpO1xuICBwYWNrZXQuYXR0YWNobWVudHMgPSB1bmRlZmluZWQ7IC8vIG5vIGxvbmdlciB1c2VmdWxcbiAgcmV0dXJuIHBhY2tldDtcbn07XG5cbi8qKlxuICogQXN5bmNocm9ub3VzbHkgcmVtb3ZlcyBCbG9icyBvciBGaWxlcyBmcm9tIGRhdGEgdmlhXG4gKiBGaWxlUmVhZGVyJ3MgcmVhZEFzQXJyYXlCdWZmZXIgbWV0aG9kLiBVc2VkIGJlZm9yZSBlbmNvZGluZ1xuICogZGF0YSBhcyBtc2dwYWNrLiBDYWxscyBjYWxsYmFjayB3aXRoIHRoZSBibG9ibGVzcyBkYXRhLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5yZW1vdmVCbG9icyA9IGZ1bmN0aW9uKGRhdGEsIGNhbGxiYWNrKSB7XG4gIGZ1bmN0aW9uIF9yZW1vdmVCbG9icyhvYmosIGN1cktleSwgY29udGFpbmluZ09iamVjdCkge1xuICAgIGlmICghb2JqKSByZXR1cm4gb2JqO1xuXG4gICAgLy8gY29udmVydCBhbnkgYmxvYlxuICAgIGlmICgoZ2xvYmFsLkJsb2IgJiYgb2JqIGluc3RhbmNlb2YgQmxvYikgfHxcbiAgICAgICAgKGdsb2JhbC5GaWxlICYmIG9iaiBpbnN0YW5jZW9mIEZpbGUpKSB7XG4gICAgICBwZW5kaW5nQmxvYnMrKztcblxuICAgICAgLy8gYXN5bmMgZmlsZXJlYWRlclxuICAgICAgdmFyIGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgZmlsZVJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbigpIHsgLy8gdGhpcy5yZXN1bHQgPT0gYXJyYXlidWZmZXJcbiAgICAgICAgaWYgKGNvbnRhaW5pbmdPYmplY3QpIHtcbiAgICAgICAgICBjb250YWluaW5nT2JqZWN0W2N1cktleV0gPSB0aGlzLnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBibG9ibGVzc0RhdGEgPSB0aGlzLnJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIG5vdGhpbmcgcGVuZGluZyBpdHMgY2FsbGJhY2sgdGltZVxuICAgICAgICBpZighIC0tcGVuZGluZ0Jsb2JzKSB7XG4gICAgICAgICAgY2FsbGJhY2soYmxvYmxlc3NEYXRhKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZmlsZVJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihvYmopOyAvLyBibG9iIC0+IGFycmF5YnVmZmVyXG4gICAgfSBlbHNlIGlmIChpc0FycmF5KG9iaikpIHsgLy8gaGFuZGxlIGFycmF5XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuICAgICAgICBfcmVtb3ZlQmxvYnMob2JqW2ldLCBpLCBvYmopO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob2JqICYmICdvYmplY3QnID09IHR5cGVvZiBvYmogJiYgIWlzQnVmKG9iaikpIHsgLy8gYW5kIG9iamVjdFxuICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBfcmVtb3ZlQmxvYnMob2JqW2tleV0sIGtleSwgb2JqKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgcGVuZGluZ0Jsb2JzID0gMDtcbiAgdmFyIGJsb2JsZXNzRGF0YSA9IGRhdGE7XG4gIF9yZW1vdmVCbG9icyhibG9ibGVzc0RhdGEpO1xuICBpZiAoIXBlbmRpbmdCbG9icykge1xuICAgIGNhbGxiYWNrKGJsb2JsZXNzRGF0YSk7XG4gIH1cbn07XG5cbn0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHt9KVxufSx7XCIuL2lzLWJ1ZmZlclwiOjQxLFwiaXNhcnJheVwiOjMzfV0sNDA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIGRlYnVnID0gX2RlcmVxXygnZGVidWcnKSgnc29ja2V0LmlvLXBhcnNlcicpO1xudmFyIGpzb24gPSBfZGVyZXFfKCdqc29uMycpO1xudmFyIGlzQXJyYXkgPSBfZGVyZXFfKCdpc2FycmF5Jyk7XG52YXIgRW1pdHRlciA9IF9kZXJlcV8oJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgYmluYXJ5ID0gX2RlcmVxXygnLi9iaW5hcnknKTtcbnZhciBpc0J1ZiA9IF9kZXJlcV8oJy4vaXMtYnVmZmVyJyk7XG5cbi8qKlxuICogUHJvdG9jb2wgdmVyc2lvbi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMucHJvdG9jb2wgPSA0O1xuXG4vKipcbiAqIFBhY2tldCB0eXBlcy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMudHlwZXMgPSBbXG4gICdDT05ORUNUJyxcbiAgJ0RJU0NPTk5FQ1QnLFxuICAnRVZFTlQnLFxuICAnQUNLJyxcbiAgJ0VSUk9SJyxcbiAgJ0JJTkFSWV9FVkVOVCcsXG4gICdCSU5BUllfQUNLJ1xuXTtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgY29ubmVjdGAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkNPTk5FQ1QgPSAwO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBkaXNjb25uZWN0YC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuRElTQ09OTkVDVCA9IDE7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGV2ZW50YC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuRVZFTlQgPSAyO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBhY2tgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5BQ0sgPSAzO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBlcnJvcmAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkVSUk9SID0gNDtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSAnYmluYXJ5IGV2ZW50J1xuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5CSU5BUllfRVZFTlQgPSA1O1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBiaW5hcnkgYWNrYC4gRm9yIGFja3Mgd2l0aCBiaW5hcnkgYXJndW1lbnRzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5CSU5BUllfQUNLID0gNjtcblxuLyoqXG4gKiBFbmNvZGVyIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5FbmNvZGVyID0gRW5jb2RlcjtcblxuLyoqXG4gKiBEZWNvZGVyIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5EZWNvZGVyID0gRGVjb2RlcjtcblxuLyoqXG4gKiBBIHNvY2tldC5pbyBFbmNvZGVyIGluc3RhbmNlXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBFbmNvZGVyKCkge31cblxuLyoqXG4gKiBFbmNvZGUgYSBwYWNrZXQgYXMgYSBzaW5nbGUgc3RyaW5nIGlmIG5vbi1iaW5hcnksIG9yIGFzIGFcbiAqIGJ1ZmZlciBzZXF1ZW5jZSwgZGVwZW5kaW5nIG9uIHBhY2tldCB0eXBlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBwYWNrZXQgb2JqZWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIGZ1bmN0aW9uIHRvIGhhbmRsZSBlbmNvZGluZ3MgKGxpa2VseSBlbmdpbmUud3JpdGUpXG4gKiBAcmV0dXJuIENhbGxzIGNhbGxiYWNrIHdpdGggQXJyYXkgb2YgZW5jb2RpbmdzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVuY29kZXIucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uKG9iaiwgY2FsbGJhY2spe1xuICBkZWJ1ZygnZW5jb2RpbmcgcGFja2V0ICVqJywgb2JqKTtcblxuICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT0gb2JqLnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09IG9iai50eXBlKSB7XG4gICAgZW5jb2RlQXNCaW5hcnkob2JqLCBjYWxsYmFjayk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdmFyIGVuY29kaW5nID0gZW5jb2RlQXNTdHJpbmcob2JqKTtcbiAgICBjYWxsYmFjayhbZW5jb2RpbmddKTtcbiAgfVxufTtcblxuLyoqXG4gKiBFbmNvZGUgcGFja2V0IGFzIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAcmV0dXJuIHtTdHJpbmd9IGVuY29kZWRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGVuY29kZUFzU3RyaW5nKG9iaikge1xuICB2YXIgc3RyID0gJyc7XG4gIHZhciBuc3AgPSBmYWxzZTtcblxuICAvLyBmaXJzdCBpcyB0eXBlXG4gIHN0ciArPSBvYmoudHlwZTtcblxuICAvLyBhdHRhY2htZW50cyBpZiB3ZSBoYXZlIHRoZW1cbiAgaWYgKGV4cG9ydHMuQklOQVJZX0VWRU5UID09IG9iai50eXBlIHx8IGV4cG9ydHMuQklOQVJZX0FDSyA9PSBvYmoudHlwZSkge1xuICAgIHN0ciArPSBvYmouYXR0YWNobWVudHM7XG4gICAgc3RyICs9ICctJztcbiAgfVxuXG4gIC8vIGlmIHdlIGhhdmUgYSBuYW1lc3BhY2Ugb3RoZXIgdGhhbiBgL2BcbiAgLy8gd2UgYXBwZW5kIGl0IGZvbGxvd2VkIGJ5IGEgY29tbWEgYCxgXG4gIGlmIChvYmoubnNwICYmICcvJyAhPSBvYmoubnNwKSB7XG4gICAgbnNwID0gdHJ1ZTtcbiAgICBzdHIgKz0gb2JqLm5zcDtcbiAgfVxuXG4gIC8vIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IHRoZSBpZFxuICBpZiAobnVsbCAhPSBvYmouaWQpIHtcbiAgICBpZiAobnNwKSB7XG4gICAgICBzdHIgKz0gJywnO1xuICAgICAgbnNwID0gZmFsc2U7XG4gICAgfVxuICAgIHN0ciArPSBvYmouaWQ7XG4gIH1cblxuICAvLyBqc29uIGRhdGFcbiAgaWYgKG51bGwgIT0gb2JqLmRhdGEpIHtcbiAgICBpZiAobnNwKSBzdHIgKz0gJywnO1xuICAgIHN0ciArPSBqc29uLnN0cmluZ2lmeShvYmouZGF0YSk7XG4gIH1cblxuICBkZWJ1ZygnZW5jb2RlZCAlaiBhcyAlcycsIG9iaiwgc3RyKTtcbiAgcmV0dXJuIHN0cjtcbn1cblxuLyoqXG4gKiBFbmNvZGUgcGFja2V0IGFzICdidWZmZXIgc2VxdWVuY2UnIGJ5IHJlbW92aW5nIGJsb2JzLCBhbmRcbiAqIGRlY29uc3RydWN0aW5nIHBhY2tldCBpbnRvIG9iamVjdCB3aXRoIHBsYWNlaG9sZGVycyBhbmRcbiAqIGEgbGlzdCBvZiBidWZmZXJzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEByZXR1cm4ge0J1ZmZlcn0gZW5jb2RlZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZW5jb2RlQXNCaW5hcnkob2JqLCBjYWxsYmFjaykge1xuXG4gIGZ1bmN0aW9uIHdyaXRlRW5jb2RpbmcoYmxvYmxlc3NEYXRhKSB7XG4gICAgdmFyIGRlY29uc3RydWN0aW9uID0gYmluYXJ5LmRlY29uc3RydWN0UGFja2V0KGJsb2JsZXNzRGF0YSk7XG4gICAgdmFyIHBhY2sgPSBlbmNvZGVBc1N0cmluZyhkZWNvbnN0cnVjdGlvbi5wYWNrZXQpO1xuICAgIHZhciBidWZmZXJzID0gZGVjb25zdHJ1Y3Rpb24uYnVmZmVycztcblxuICAgIGJ1ZmZlcnMudW5zaGlmdChwYWNrKTsgLy8gYWRkIHBhY2tldCBpbmZvIHRvIGJlZ2lubmluZyBvZiBkYXRhIGxpc3RcbiAgICBjYWxsYmFjayhidWZmZXJzKTsgLy8gd3JpdGUgYWxsIHRoZSBidWZmZXJzXG4gIH1cblxuICBiaW5hcnkucmVtb3ZlQmxvYnMob2JqLCB3cml0ZUVuY29kaW5nKTtcbn1cblxuLyoqXG4gKiBBIHNvY2tldC5pbyBEZWNvZGVyIGluc3RhbmNlXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBkZWNvZGVyXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIERlY29kZXIoKSB7XG4gIHRoaXMucmVjb25zdHJ1Y3RvciA9IG51bGw7XG59XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYCB3aXRoIERlY29kZXIuXG4gKi9cblxuRW1pdHRlcihEZWNvZGVyLnByb3RvdHlwZSk7XG5cbi8qKlxuICogRGVjb2RlcyBhbiBlY29kZWQgcGFja2V0IHN0cmluZyBpbnRvIHBhY2tldCBKU09OLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBvYmogLSBlbmNvZGVkIHBhY2tldFxuICogQHJldHVybiB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRGVjb2Rlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24ob2JqKSB7XG4gIHZhciBwYWNrZXQ7XG4gIGlmICgnc3RyaW5nJyA9PSB0eXBlb2Ygb2JqKSB7XG4gICAgcGFja2V0ID0gZGVjb2RlU3RyaW5nKG9iaik7XG4gICAgaWYgKGV4cG9ydHMuQklOQVJZX0VWRU5UID09IHBhY2tldC50eXBlIHx8IGV4cG9ydHMuQklOQVJZX0FDSyA9PSBwYWNrZXQudHlwZSkgeyAvLyBiaW5hcnkgcGFja2V0J3MganNvblxuICAgICAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbmV3IEJpbmFyeVJlY29uc3RydWN0b3IocGFja2V0KTtcblxuICAgICAgLy8gbm8gYXR0YWNobWVudHMsIGxhYmVsZWQgYmluYXJ5IGJ1dCBubyBiaW5hcnkgZGF0YSB0byBmb2xsb3dcbiAgICAgIGlmICh0aGlzLnJlY29uc3RydWN0b3IucmVjb25QYWNrLmF0dGFjaG1lbnRzID09PSAwKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZGVjb2RlZCcsIHBhY2tldCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHsgLy8gbm9uLWJpbmFyeSBmdWxsIHBhY2tldFxuICAgICAgdGhpcy5lbWl0KCdkZWNvZGVkJywgcGFja2V0KTtcbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAoaXNCdWYob2JqKSB8fCBvYmouYmFzZTY0KSB7IC8vIHJhdyBiaW5hcnkgZGF0YVxuICAgIGlmICghdGhpcy5yZWNvbnN0cnVjdG9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dvdCBiaW5hcnkgZGF0YSB3aGVuIG5vdCByZWNvbnN0cnVjdGluZyBhIHBhY2tldCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYWNrZXQgPSB0aGlzLnJlY29uc3RydWN0b3IudGFrZUJpbmFyeURhdGEob2JqKTtcbiAgICAgIGlmIChwYWNrZXQpIHsgLy8gcmVjZWl2ZWQgZmluYWwgYnVmZmVyXG4gICAgICAgIHRoaXMucmVjb25zdHJ1Y3RvciA9IG51bGw7XG4gICAgICAgIHRoaXMuZW1pdCgnZGVjb2RlZCcsIHBhY2tldCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biB0eXBlOiAnICsgb2JqKTtcbiAgfVxufTtcblxuLyoqXG4gKiBEZWNvZGUgYSBwYWNrZXQgU3RyaW5nIChKU09OIGRhdGEpXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGRlY29kZVN0cmluZyhzdHIpIHtcbiAgdmFyIHAgPSB7fTtcbiAgdmFyIGkgPSAwO1xuXG4gIC8vIGxvb2sgdXAgdHlwZVxuICBwLnR5cGUgPSBOdW1iZXIoc3RyLmNoYXJBdCgwKSk7XG4gIGlmIChudWxsID09IGV4cG9ydHMudHlwZXNbcC50eXBlXSkgcmV0dXJuIGVycm9yKCk7XG5cbiAgLy8gbG9vayB1cCBhdHRhY2htZW50cyBpZiB0eXBlIGJpbmFyeVxuICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT0gcC50eXBlIHx8IGV4cG9ydHMuQklOQVJZX0FDSyA9PSBwLnR5cGUpIHtcbiAgICB2YXIgYnVmID0gJyc7XG4gICAgd2hpbGUgKHN0ci5jaGFyQXQoKytpKSAhPSAnLScpIHtcbiAgICAgIGJ1ZiArPSBzdHIuY2hhckF0KGkpO1xuICAgICAgaWYgKGkgPT0gc3RyLmxlbmd0aCkgYnJlYWs7XG4gICAgfVxuICAgIGlmIChidWYgIT0gTnVtYmVyKGJ1ZikgfHwgc3RyLmNoYXJBdChpKSAhPSAnLScpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBhdHRhY2htZW50cycpO1xuICAgIH1cbiAgICBwLmF0dGFjaG1lbnRzID0gTnVtYmVyKGJ1Zik7XG4gIH1cblxuICAvLyBsb29rIHVwIG5hbWVzcGFjZSAoaWYgYW55KVxuICBpZiAoJy8nID09IHN0ci5jaGFyQXQoaSArIDEpKSB7XG4gICAgcC5uc3AgPSAnJztcbiAgICB3aGlsZSAoKytpKSB7XG4gICAgICB2YXIgYyA9IHN0ci5jaGFyQXQoaSk7XG4gICAgICBpZiAoJywnID09IGMpIGJyZWFrO1xuICAgICAgcC5uc3AgKz0gYztcbiAgICAgIGlmIChpID09IHN0ci5sZW5ndGgpIGJyZWFrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwLm5zcCA9ICcvJztcbiAgfVxuXG4gIC8vIGxvb2sgdXAgaWRcbiAgdmFyIG5leHQgPSBzdHIuY2hhckF0KGkgKyAxKTtcbiAgaWYgKCcnICE9PSBuZXh0ICYmIE51bWJlcihuZXh0KSA9PSBuZXh0KSB7XG4gICAgcC5pZCA9ICcnO1xuICAgIHdoaWxlICgrK2kpIHtcbiAgICAgIHZhciBjID0gc3RyLmNoYXJBdChpKTtcbiAgICAgIGlmIChudWxsID09IGMgfHwgTnVtYmVyKGMpICE9IGMpIHtcbiAgICAgICAgLS1pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHAuaWQgKz0gc3RyLmNoYXJBdChpKTtcbiAgICAgIGlmIChpID09IHN0ci5sZW5ndGgpIGJyZWFrO1xuICAgIH1cbiAgICBwLmlkID0gTnVtYmVyKHAuaWQpO1xuICB9XG5cbiAgLy8gbG9vayB1cCBqc29uIGRhdGFcbiAgaWYgKHN0ci5jaGFyQXQoKytpKSkge1xuICAgIHRyeSB7XG4gICAgICBwLmRhdGEgPSBqc29uLnBhcnNlKHN0ci5zdWJzdHIoaSkpO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICByZXR1cm4gZXJyb3IoKTtcbiAgICB9XG4gIH1cblxuICBkZWJ1ZygnZGVjb2RlZCAlcyBhcyAlaicsIHN0ciwgcCk7XG4gIHJldHVybiBwO1xufVxuXG4vKipcbiAqIERlYWxsb2NhdGVzIGEgcGFyc2VyJ3MgcmVzb3VyY2VzXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5EZWNvZGVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnJlY29uc3RydWN0b3IpIHtcbiAgICB0aGlzLnJlY29uc3RydWN0b3IuZmluaXNoZWRSZWNvbnN0cnVjdGlvbigpO1xuICB9XG59O1xuXG4vKipcbiAqIEEgbWFuYWdlciBvZiBhIGJpbmFyeSBldmVudCdzICdidWZmZXIgc2VxdWVuY2UnLiBTaG91bGRcbiAqIGJlIGNvbnN0cnVjdGVkIHdoZW5ldmVyIGEgcGFja2V0IG9mIHR5cGUgQklOQVJZX0VWRU5UIGlzXG4gKiBkZWNvZGVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEByZXR1cm4ge0JpbmFyeVJlY29uc3RydWN0b3J9IGluaXRpYWxpemVkIHJlY29uc3RydWN0b3JcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIEJpbmFyeVJlY29uc3RydWN0b3IocGFja2V0KSB7XG4gIHRoaXMucmVjb25QYWNrID0gcGFja2V0O1xuICB0aGlzLmJ1ZmZlcnMgPSBbXTtcbn1cblxuLyoqXG4gKiBNZXRob2QgdG8gYmUgY2FsbGVkIHdoZW4gYmluYXJ5IGRhdGEgcmVjZWl2ZWQgZnJvbSBjb25uZWN0aW9uXG4gKiBhZnRlciBhIEJJTkFSWV9FVkVOVCBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXIgfCBBcnJheUJ1ZmZlcn0gYmluRGF0YSAtIHRoZSByYXcgYmluYXJ5IGRhdGEgcmVjZWl2ZWRcbiAqIEByZXR1cm4ge251bGwgfCBPYmplY3R9IHJldHVybnMgbnVsbCBpZiBtb3JlIGJpbmFyeSBkYXRhIGlzIGV4cGVjdGVkIG9yXG4gKiAgIGEgcmVjb25zdHJ1Y3RlZCBwYWNrZXQgb2JqZWN0IGlmIGFsbCBidWZmZXJzIGhhdmUgYmVlbiByZWNlaXZlZC5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkJpbmFyeVJlY29uc3RydWN0b3IucHJvdG90eXBlLnRha2VCaW5hcnlEYXRhID0gZnVuY3Rpb24oYmluRGF0YSkge1xuICB0aGlzLmJ1ZmZlcnMucHVzaChiaW5EYXRhKTtcbiAgaWYgKHRoaXMuYnVmZmVycy5sZW5ndGggPT0gdGhpcy5yZWNvblBhY2suYXR0YWNobWVudHMpIHsgLy8gZG9uZSB3aXRoIGJ1ZmZlciBsaXN0XG4gICAgdmFyIHBhY2tldCA9IGJpbmFyeS5yZWNvbnN0cnVjdFBhY2tldCh0aGlzLnJlY29uUGFjaywgdGhpcy5idWZmZXJzKTtcbiAgICB0aGlzLmZpbmlzaGVkUmVjb25zdHJ1Y3Rpb24oKTtcbiAgICByZXR1cm4gcGFja2V0O1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBDbGVhbnMgdXAgYmluYXJ5IHBhY2tldCByZWNvbnN0cnVjdGlvbiB2YXJpYWJsZXMuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQmluYXJ5UmVjb25zdHJ1Y3Rvci5wcm90b3R5cGUuZmluaXNoZWRSZWNvbnN0cnVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnJlY29uUGFjayA9IG51bGw7XG4gIHRoaXMuYnVmZmVycyA9IFtdO1xufTtcblxuZnVuY3Rpb24gZXJyb3IoZGF0YSl7XG4gIHJldHVybiB7XG4gICAgdHlwZTogZXhwb3J0cy5FUlJPUixcbiAgICBkYXRhOiAncGFyc2VyIGVycm9yJ1xuICB9O1xufVxuXG59LHtcIi4vYmluYXJ5XCI6MzksXCIuL2lzLWJ1ZmZlclwiOjQxLFwiY29tcG9uZW50LWVtaXR0ZXJcIjo0MixcImRlYnVnXCI6MTQsXCJpc2FycmF5XCI6MzMsXCJqc29uM1wiOjM0fV0sNDE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQnVmO1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBvYmogaXMgYSBidWZmZXIgb3IgYW4gYXJyYXlidWZmZXIuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaXNCdWYob2JqKSB7XG4gIHJldHVybiAoZ2xvYmFsLkJ1ZmZlciAmJiBnbG9iYWwuQnVmZmVyLmlzQnVmZmVyKG9iaikpIHx8XG4gICAgICAgICAoZ2xvYmFsLkFycmF5QnVmZmVyICYmIG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKTtcbn1cblxufSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDoge30pXG59LHt9XSw0MjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5hcmd1bWVudHNbNF1bMjZdWzBdLmFwcGx5KGV4cG9ydHMsYXJndW1lbnRzKVxufSx7XCJkdXBcIjoyNn1dLDQzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gdG9BcnJheVxuXG5mdW5jdGlvbiB0b0FycmF5KGxpc3QsIGluZGV4KSB7XG4gICAgdmFyIGFycmF5ID0gW11cblxuICAgIGluZGV4ID0gaW5kZXggfHwgMFxuXG4gICAgZm9yICh2YXIgaSA9IGluZGV4IHx8IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycmF5W2kgLSBpbmRleF0gPSBsaXN0W2ldXG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5XG59XG5cbn0se31dLDQ0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbi8qISBodHRwczovL210aHMuYmUvdXRmOGpzIHYyLjAuMCBieSBAbWF0aGlhcyAqL1xuOyhmdW5jdGlvbihyb290KSB7XG5cblx0Ly8gRGV0ZWN0IGZyZWUgdmFyaWFibGVzIGBleHBvcnRzYFxuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzO1xuXG5cdC8vIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgXG5cdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHRtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cyAmJiBtb2R1bGU7XG5cblx0Ly8gRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAsIGZyb20gTm9kZS5qcyBvciBCcm93c2VyaWZpZWQgY29kZSxcblx0Ly8gYW5kIHVzZSBpdCBhcyBgcm9vdGBcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsKSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHR2YXIgc3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcblxuXHQvLyBUYWtlbiBmcm9tIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZVxuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdHZhciBvdXRwdXQgPSBbXTtcblx0XHR2YXIgY291bnRlciA9IDA7XG5cdFx0dmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG5cdFx0dmFyIHZhbHVlO1xuXHRcdHZhciBleHRyYTtcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvLyBUYWtlbiBmcm9tIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZVxuXHRmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XHR2YXIgaW5kZXggPSAtMTtcblx0XHR2YXIgdmFsdWU7XG5cdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IGFycmF5W2luZGV4XTtcblx0XHRcdGlmICh2YWx1ZSA+IDB4RkZGRikge1xuXHRcdFx0XHR2YWx1ZSAtPSAweDEwMDAwO1xuXHRcdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRcdFx0dmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHRmdW5jdGlvbiBjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCkge1xuXHRcdGlmIChjb2RlUG9pbnQgPj0gMHhEODAwICYmIGNvZGVQb2ludCA8PSAweERGRkYpIHtcblx0XHRcdHRocm93IEVycm9yKFxuXHRcdFx0XHQnTG9uZSBzdXJyb2dhdGUgVSsnICsgY29kZVBvaW50LnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpICtcblx0XHRcdFx0JyBpcyBub3QgYSBzY2FsYXIgdmFsdWUnXG5cdFx0XHQpO1xuXHRcdH1cblx0fVxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHRmdW5jdGlvbiBjcmVhdGVCeXRlKGNvZGVQb2ludCwgc2hpZnQpIHtcblx0XHRyZXR1cm4gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IHNoaWZ0KSAmIDB4M0YpIHwgMHg4MCk7XG5cdH1cblxuXHRmdW5jdGlvbiBlbmNvZGVDb2RlUG9pbnQoY29kZVBvaW50KSB7XG5cdFx0aWYgKChjb2RlUG9pbnQgJiAweEZGRkZGRjgwKSA9PSAwKSB7IC8vIDEtYnl0ZSBzZXF1ZW5jZVxuXHRcdFx0cmV0dXJuIHN0cmluZ0Zyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuXHRcdH1cblx0XHR2YXIgc3ltYm9sID0gJyc7XG5cdFx0aWYgKChjb2RlUG9pbnQgJiAweEZGRkZGODAwKSA9PSAwKSB7IC8vIDItYnl0ZSBzZXF1ZW5jZVxuXHRcdFx0c3ltYm9sID0gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IDYpICYgMHgxRikgfCAweEMwKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoKGNvZGVQb2ludCAmIDB4RkZGRjAwMDApID09IDApIHsgLy8gMy1ieXRlIHNlcXVlbmNlXG5cdFx0XHRjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCk7XG5cdFx0XHRzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gMTIpICYgMHgwRikgfCAweEUwKTtcblx0XHRcdHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgNik7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKChjb2RlUG9pbnQgJiAweEZGRTAwMDAwKSA9PSAwKSB7IC8vIDQtYnl0ZSBzZXF1ZW5jZVxuXHRcdFx0c3ltYm9sID0gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IDE4KSAmIDB4MDcpIHwgMHhGMCk7XG5cdFx0XHRzeW1ib2wgKz0gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIDEyKTtcblx0XHRcdHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgNik7XG5cdFx0fVxuXHRcdHN5bWJvbCArPSBzdHJpbmdGcm9tQ2hhckNvZGUoKGNvZGVQb2ludCAmIDB4M0YpIHwgMHg4MCk7XG5cdFx0cmV0dXJuIHN5bWJvbDtcblx0fVxuXG5cdGZ1bmN0aW9uIHV0ZjhlbmNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIGNvZGVQb2ludHMgPSB1Y3MyZGVjb2RlKHN0cmluZyk7XG5cdFx0dmFyIGxlbmd0aCA9IGNvZGVQb2ludHMubGVuZ3RoO1xuXHRcdHZhciBpbmRleCA9IC0xO1xuXHRcdHZhciBjb2RlUG9pbnQ7XG5cdFx0dmFyIGJ5dGVTdHJpbmcgPSAnJztcblx0XHR3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHRcdFx0Y29kZVBvaW50ID0gY29kZVBvaW50c1tpbmRleF07XG5cdFx0XHRieXRlU3RyaW5nICs9IGVuY29kZUNvZGVQb2ludChjb2RlUG9pbnQpO1xuXHRcdH1cblx0XHRyZXR1cm4gYnl0ZVN0cmluZztcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdGZ1bmN0aW9uIHJlYWRDb250aW51YXRpb25CeXRlKCkge1xuXHRcdGlmIChieXRlSW5kZXggPj0gYnl0ZUNvdW50KSB7XG5cdFx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBieXRlIGluZGV4Jyk7XG5cdFx0fVxuXG5cdFx0dmFyIGNvbnRpbnVhdGlvbkJ5dGUgPSBieXRlQXJyYXlbYnl0ZUluZGV4XSAmIDB4RkY7XG5cdFx0Ynl0ZUluZGV4Kys7XG5cblx0XHRpZiAoKGNvbnRpbnVhdGlvbkJ5dGUgJiAweEMwKSA9PSAweDgwKSB7XG5cdFx0XHRyZXR1cm4gY29udGludWF0aW9uQnl0ZSAmIDB4M0Y7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgd2UgZW5kIHVwIGhlcmUsIGl04oCZcyBub3QgYSBjb250aW51YXRpb24gYnl0ZVxuXHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlJyk7XG5cdH1cblxuXHRmdW5jdGlvbiBkZWNvZGVTeW1ib2woKSB7XG5cdFx0dmFyIGJ5dGUxO1xuXHRcdHZhciBieXRlMjtcblx0XHR2YXIgYnl0ZTM7XG5cdFx0dmFyIGJ5dGU0O1xuXHRcdHZhciBjb2RlUG9pbnQ7XG5cblx0XHRpZiAoYnl0ZUluZGV4ID4gYnl0ZUNvdW50KSB7XG5cdFx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBieXRlIGluZGV4Jyk7XG5cdFx0fVxuXG5cdFx0aWYgKGJ5dGVJbmRleCA9PSBieXRlQ291bnQpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBSZWFkIGZpcnN0IGJ5dGVcblx0XHRieXRlMSA9IGJ5dGVBcnJheVtieXRlSW5kZXhdICYgMHhGRjtcblx0XHRieXRlSW5kZXgrKztcblxuXHRcdC8vIDEtYnl0ZSBzZXF1ZW5jZSAobm8gY29udGludWF0aW9uIGJ5dGVzKVxuXHRcdGlmICgoYnl0ZTEgJiAweDgwKSA9PSAwKSB7XG5cdFx0XHRyZXR1cm4gYnl0ZTE7XG5cdFx0fVxuXG5cdFx0Ly8gMi1ieXRlIHNlcXVlbmNlXG5cdFx0aWYgKChieXRlMSAmIDB4RTApID09IDB4QzApIHtcblx0XHRcdHZhciBieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgxRikgPDwgNikgfCBieXRlMjtcblx0XHRcdGlmIChjb2RlUG9pbnQgPj0gMHg4MCkge1xuXHRcdFx0XHRyZXR1cm4gY29kZVBvaW50O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyAzLWJ5dGUgc2VxdWVuY2UgKG1heSBpbmNsdWRlIHVucGFpcmVkIHN1cnJvZ2F0ZXMpXG5cdFx0aWYgKChieXRlMSAmIDB4RjApID09IDB4RTApIHtcblx0XHRcdGJ5dGUyID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGJ5dGUzID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGNvZGVQb2ludCA9ICgoYnl0ZTEgJiAweDBGKSA8PCAxMikgfCAoYnl0ZTIgPDwgNikgfCBieXRlMztcblx0XHRcdGlmIChjb2RlUG9pbnQgPj0gMHgwODAwKSB7XG5cdFx0XHRcdGNoZWNrU2NhbGFyVmFsdWUoY29kZVBvaW50KTtcblx0XHRcdFx0cmV0dXJuIGNvZGVQb2ludDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlJyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gNC1ieXRlIHNlcXVlbmNlXG5cdFx0aWYgKChieXRlMSAmIDB4RjgpID09IDB4RjApIHtcblx0XHRcdGJ5dGUyID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGJ5dGUzID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGJ5dGU0ID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGNvZGVQb2ludCA9ICgoYnl0ZTEgJiAweDBGKSA8PCAweDEyKSB8IChieXRlMiA8PCAweDBDKSB8XG5cdFx0XHRcdChieXRlMyA8PCAweDA2KSB8IGJ5dGU0O1xuXHRcdFx0aWYgKGNvZGVQb2ludCA+PSAweDAxMDAwMCAmJiBjb2RlUG9pbnQgPD0gMHgxMEZGRkYpIHtcblx0XHRcdFx0cmV0dXJuIGNvZGVQb2ludDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBVVEYtOCBkZXRlY3RlZCcpO1xuXHR9XG5cblx0dmFyIGJ5dGVBcnJheTtcblx0dmFyIGJ5dGVDb3VudDtcblx0dmFyIGJ5dGVJbmRleDtcblx0ZnVuY3Rpb24gdXRmOGRlY29kZShieXRlU3RyaW5nKSB7XG5cdFx0Ynl0ZUFycmF5ID0gdWNzMmRlY29kZShieXRlU3RyaW5nKTtcblx0XHRieXRlQ291bnQgPSBieXRlQXJyYXkubGVuZ3RoO1xuXHRcdGJ5dGVJbmRleCA9IDA7XG5cdFx0dmFyIGNvZGVQb2ludHMgPSBbXTtcblx0XHR2YXIgdG1wO1xuXHRcdHdoaWxlICgodG1wID0gZGVjb2RlU3ltYm9sKCkpICE9PSBmYWxzZSkge1xuXHRcdFx0Y29kZVBvaW50cy5wdXNoKHRtcCk7XG5cdFx0fVxuXHRcdHJldHVybiB1Y3MyZW5jb2RlKGNvZGVQb2ludHMpO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0dmFyIHV0ZjggPSB7XG5cdFx0J3ZlcnNpb24nOiAnMi4wLjAnLFxuXHRcdCdlbmNvZGUnOiB1dGY4ZW5jb2RlLFxuXHRcdCdkZWNvZGUnOiB1dGY4ZGVjb2RlXG5cdH07XG5cblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0aWYgKFxuXHRcdHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmXG5cdFx0ZGVmaW5lLmFtZFxuXHQpIHtcblx0XHRkZWZpbmUoZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdXRmODtcblx0XHR9KTtcblx0fVx0ZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgIWZyZWVFeHBvcnRzLm5vZGVUeXBlKSB7XG5cdFx0aWYgKGZyZWVNb2R1bGUpIHsgLy8gaW4gTm9kZS5qcyBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHV0Zjg7XG5cdFx0fSBlbHNlIHsgLy8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cblx0XHRcdHZhciBvYmplY3QgPSB7fTtcblx0XHRcdHZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdC5oYXNPd25Qcm9wZXJ0eTtcblx0XHRcdGZvciAodmFyIGtleSBpbiB1dGY4KSB7XG5cdFx0XHRcdGhhc093blByb3BlcnR5LmNhbGwodXRmOCwga2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHV0Zjhba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgeyAvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC51dGY4ID0gdXRmODtcblx0fVxuXG59KHRoaXMpKTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDoge30pXG59LHt9XSw0NTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBhbHBoYWJldCA9ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ei1fJy5zcGxpdCgnJylcbiAgLCBsZW5ndGggPSA2NFxuICAsIG1hcCA9IHt9XG4gICwgc2VlZCA9IDBcbiAgLCBpID0gMFxuICAsIHByZXY7XG5cbi8qKlxuICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgc3BlY2lmaWVkIG51bWJlci5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbnVtIFRoZSBudW1iZXIgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG51bWJlci5cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIGVuY29kZShudW0pIHtcbiAgdmFyIGVuY29kZWQgPSAnJztcblxuICBkbyB7XG4gICAgZW5jb2RlZCA9IGFscGhhYmV0W251bSAlIGxlbmd0aF0gKyBlbmNvZGVkO1xuICAgIG51bSA9IE1hdGguZmxvb3IobnVtIC8gbGVuZ3RoKTtcbiAgfSB3aGlsZSAobnVtID4gMCk7XG5cbiAgcmV0dXJuIGVuY29kZWQ7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBpbnRlZ2VyIHZhbHVlIHNwZWNpZmllZCBieSB0aGUgZ2l2ZW4gc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge051bWJlcn0gVGhlIGludGVnZXIgdmFsdWUgcmVwcmVzZW50ZWQgYnkgdGhlIHN0cmluZy5cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIGRlY29kZShzdHIpIHtcbiAgdmFyIGRlY29kZWQgPSAwO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBkZWNvZGVkID0gZGVjb2RlZCAqIGxlbmd0aCArIG1hcFtzdHIuY2hhckF0KGkpXTtcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVkO1xufVxuXG4vKipcbiAqIFllYXN0OiBBIHRpbnkgZ3Jvd2luZyBpZCBnZW5lcmF0b3IuXG4gKlxuICogQHJldHVybnMge1N0cmluZ30gQSB1bmlxdWUgaWQuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiB5ZWFzdCgpIHtcbiAgdmFyIG5vdyA9IGVuY29kZSgrbmV3IERhdGUoKSk7XG5cbiAgaWYgKG5vdyAhPT0gcHJldikgcmV0dXJuIHNlZWQgPSAwLCBwcmV2ID0gbm93O1xuICByZXR1cm4gbm93ICsnLicrIGVuY29kZShzZWVkKyspO1xufVxuXG4vL1xuLy8gTWFwIGVhY2ggY2hhcmFjdGVyIHRvIGl0cyBpbmRleC5cbi8vXG5mb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSBtYXBbYWxwaGFiZXRbaV1dID0gaTtcblxuLy9cbi8vIEV4cG9zZSB0aGUgYHllYXN0YCwgYGVuY29kZWAgYW5kIGBkZWNvZGVgIGZ1bmN0aW9ucy5cbi8vXG55ZWFzdC5lbmNvZGUgPSBlbmNvZGU7XG55ZWFzdC5kZWNvZGUgPSBkZWNvZGU7XG5tb2R1bGUuZXhwb3J0cyA9IHllYXN0O1xuXG59LHt9XX0se30sWzFdKSgxKVxufSk7XG4iLCJ2YXIgZ2xvYmFscyA9IHt9O1xuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0Z2xvYmFscy53aW5kb3cgPSB3aW5kb3c7XG59XG5cbmlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG5cdGdsb2JhbHMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2xvYmFscztcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBBIGNvbGxlY3Rpb24gb2YgY29yZSB1dGlsaXR5IGZ1bmN0aW9ucy5cbiAqIEBjb25zdFxuICovXG5jbGFzcyBjb3JlIHtcblx0LyoqXG5cdCAqIFdoZW4gZGVmaW5pbmcgYSBjbGFzcyBGb28gd2l0aCBhbiBhYnN0cmFjdCBtZXRob2QgYmFyKCksIHlvdSBjYW4gZG86XG5cdCAqIEZvby5wcm90b3R5cGUuYmFyID0gY29yZS5hYnN0cmFjdE1ldGhvZFxuXHQgKlxuXHQgKiBOb3cgaWYgYSBzdWJjbGFzcyBvZiBGb28gZmFpbHMgdG8gb3ZlcnJpZGUgYmFyKCksIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duXG5cdCAqIHdoZW4gYmFyKCkgaXMgaW52b2tlZC5cblx0ICpcblx0ICogQHR5cGUgeyFGdW5jdGlvbn1cblx0ICogQHRocm93cyB7RXJyb3J9IHdoZW4gaW52b2tlZCB0byBpbmRpY2F0ZSB0aGUgbWV0aG9kIHNob3VsZCBiZSBvdmVycmlkZGVuLlxuXHQgKi9cblx0c3RhdGljIGFic3RyYWN0TWV0aG9kKCkge1xuXHRcdHRocm93IEVycm9yKCdVbmltcGxlbWVudGVkIGFic3RyYWN0IG1ldGhvZCcpO1xuXHR9XG5cblx0LyoqXG5cdCAqIExvb3BzIGNvbnN0cnVjdG9yIHN1cGVyIGNsYXNzZXMgY29sbGVjdGluZyBpdHMgcHJvcGVydGllcyB2YWx1ZXMuIElmXG5cdCAqIHByb3BlcnR5IGlzIG5vdCBhdmFpbGFibGUgb24gdGhlIHN1cGVyIGNsYXNzIGB1bmRlZmluZWRgIHdpbGwgYmVcblx0ICogY29sbGVjdGVkIGFzIHZhbHVlIGZvciB0aGUgY2xhc3MgaGllcmFyY2h5IHBvc2l0aW9uLlxuXHQgKiBAcGFyYW0geyFmdW5jdGlvbigpfSBjb25zdHJ1Y3RvciBDbGFzcyBjb25zdHJ1Y3Rvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5TmFtZSBQcm9wZXJ0eSBuYW1lIHRvIGJlIGNvbGxlY3RlZC5cblx0ICogQHJldHVybiB7QXJyYXkuPCo+fSBBcnJheSBvZiBjb2xsZWN0ZWQgdmFsdWVzLlxuXHQgKiBUT0RPKCopOiBSZXRoaW5rIHN1cGVyY2xhc3MgbG9vcC5cblx0ICovXG5cdHN0YXRpYyBjb2xsZWN0U3VwZXJDbGFzc2VzUHJvcGVydHkoY29uc3RydWN0b3IsIHByb3BlcnR5TmFtZSkge1xuXHRcdHZhciBwcm9wZXJ0eVZhbHVlcyA9IFtjb25zdHJ1Y3Rvcltwcm9wZXJ0eU5hbWVdXTtcblx0XHR3aGlsZSAoY29uc3RydWN0b3IuX19wcm90b19fICYmICFjb25zdHJ1Y3Rvci5fX3Byb3RvX18uaXNQcm90b3R5cGVPZihGdW5jdGlvbikpIHtcblx0XHRcdGNvbnN0cnVjdG9yID0gY29uc3RydWN0b3IuX19wcm90b19fO1xuXHRcdFx0cHJvcGVydHlWYWx1ZXMucHVzaChjb25zdHJ1Y3Rvcltwcm9wZXJ0eU5hbWVdKTtcblx0XHR9XG5cdFx0cmV0dXJuIHByb3BlcnR5VmFsdWVzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIG5hbWUgb2YgdGhlIGdpdmVuIGZ1bmN0aW9uLiBJZiB0aGUgY3VycmVudCBicm93c2VyIGRvZXNuJ3Rcblx0ICogc3VwcG9ydCB0aGUgYG5hbWVgIHByb3BlcnR5LCB0aGlzIHdpbGwgY2FsY3VsYXRlIGl0IGZyb20gdGhlIGZ1bmN0aW9uJ3Ncblx0ICogY29udGVudCBzdHJpbmcuXG5cdCAqIEBwYXJhbSB7IWZ1bmN0aW9uKCl9IGZuXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdHN0YXRpYyBnZXRGdW5jdGlvbk5hbWUoZm4pIHtcblx0XHRpZiAoIWZuLm5hbWUpIHtcblx0XHRcdHZhciBzdHIgPSBmbi50b1N0cmluZygpO1xuXHRcdFx0Zm4ubmFtZSA9IHN0ci5zdWJzdHJpbmcoOSwgc3RyLmluZGV4T2YoJygnKSk7XG5cdFx0fVxuXHRcdHJldHVybiBmbi5uYW1lO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgYW4gdW5pcXVlIGlkLiBJZiBgb3B0X29iamVjdGAgYXJndW1lbnQgaXMgcGFzc2VkLCB0aGUgb2JqZWN0IGlzXG5cdCAqIG11dGF0ZWQgd2l0aCBhbiB1bmlxdWUgaWQuIENvbnNlY3V0aXZlIGNhbGxzIHdpdGggdGhlIHNhbWUgb2JqZWN0XG5cdCAqIHJlZmVyZW5jZSB3b24ndCBtdXRhdGUgdGhlIG9iamVjdCBhZ2FpbiwgaW5zdGVhZCB0aGUgY3VycmVudCBvYmplY3QgdWlkXG5cdCAqIHJldHVybnMuIFNlZSB7QGxpbmsgY29yZS5VSURfUFJPUEVSVFl9LlxuXHQgKiBAcGFyYW0ge09iamVjdD19IG9wdF9vYmplY3QgT3B0aW9uYWwgb2JqZWN0IHRvIGJlIG11dGF0ZWQgd2l0aCB0aGUgdWlkLiBJZlxuXHQgKiAgICAgbm90IHNwZWNpZmllZCB0aGlzIG1ldGhvZCBvbmx5IHJldHVybnMgdGhlIHVpZC5cblx0ICogQHBhcmFtIHtib29sZWFuPX0gb3B0X25vSW5oZXJpdGFuY2UgT3B0aW9uYWwgZmxhZyBpbmRpY2F0aW5nIGlmIHRoaXNcblx0ICogICAgIG9iamVjdCdzIHVpZCBwcm9wZXJ0eSBjYW4gYmUgaW5oZXJpdGVkIGZyb20gcGFyZW50cyBvciBub3QuXG5cdCAqIEB0aHJvd3Mge0Vycm9yfSB3aGVuIGludm9rZWQgdG8gaW5kaWNhdGUgdGhlIG1ldGhvZCBzaG91bGQgYmUgb3ZlcnJpZGRlbi5cblx0ICovXG5cdHN0YXRpYyBnZXRVaWQob3B0X29iamVjdCwgb3B0X25vSW5oZXJpdGFuY2UpIHtcblx0XHRpZiAob3B0X29iamVjdCkge1xuXHRcdFx0dmFyIGlkID0gb3B0X29iamVjdFtjb3JlLlVJRF9QUk9QRVJUWV07XG5cdFx0XHRpZiAob3B0X25vSW5oZXJpdGFuY2UgJiYgIW9wdF9vYmplY3QuaGFzT3duUHJvcGVydHkoY29yZS5VSURfUFJPUEVSVFkpKSB7XG5cdFx0XHRcdGlkID0gbnVsbDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBpZCB8fCAob3B0X29iamVjdFtjb3JlLlVJRF9QUk9QRVJUWV0gPSBjb3JlLnVuaXF1ZUlkQ291bnRlcl8rKyk7XG5cdFx0fVxuXHRcdHJldHVybiBjb3JlLnVuaXF1ZUlkQ291bnRlcl8rKztcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgaWRlbnRpdHkgZnVuY3Rpb24uIFJldHVybnMgaXRzIGZpcnN0IGFyZ3VtZW50LlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfcmV0dXJuVmFsdWUgVGhlIHNpbmdsZSB2YWx1ZSB0aGF0IHdpbGwgYmUgcmV0dXJuZWQuXG5cdCAqIEByZXR1cm4gez99IFRoZSBmaXJzdCBhcmd1bWVudC5cblx0ICovXG5cdHN0YXRpYyBpZGVudGl0eUZ1bmN0aW9uKG9wdF9yZXR1cm5WYWx1ZSkge1xuXHRcdHJldHVybiBvcHRfcmV0dXJuVmFsdWU7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYSBib29sZWFuLlxuXHQgKiBAcGFyYW0gez99IHZhbCBWYXJpYWJsZSB0byB0ZXN0LlxuXHQgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHZhcmlhYmxlIGlzIGJvb2xlYW4uXG5cdCAqL1xuXHRzdGF0aWMgaXNCb29sZWFuKHZhbCkge1xuXHRcdHJldHVybiB0eXBlb2YgdmFsID09PSAnYm9vbGVhbic7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgbm90IHVuZGVmaW5lZC5cblx0ICogQHBhcmFtIHs/fSB2YWwgVmFyaWFibGUgdG8gdGVzdC5cblx0ICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB2YXJpYWJsZSBpcyBkZWZpbmVkLlxuXHQgKi9cblx0c3RhdGljIGlzRGVmKHZhbCkge1xuXHRcdHJldHVybiB2YWwgIT09IHVuZGVmaW5lZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgbm90IHVuZGVmaW5lZCBvciBudWxsLlxuXHQgKiBAcGFyYW0geyp9IHZhbFxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cblx0c3RhdGljIGlzRGVmQW5kTm90TnVsbCh2YWwpIHtcblx0XHRyZXR1cm4gY29yZS5pc0RlZih2YWwpICYmICFjb3JlLmlzTnVsbCh2YWwpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBhIGRvY3VtZW50LlxuXHQgKiBAcGFyYW0geyp9IHZhbFxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cblx0c3RhdGljIGlzRG9jdW1lbnQodmFsKSB7XG5cdFx0cmV0dXJuIHZhbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJiB2YWwubm9kZVR5cGUgPT09IDk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIGEgZG9tIGVsZW1lbnQuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqL1xuXHRzdGF0aWMgaXNFbGVtZW50KHZhbCkge1xuXHRcdHJldHVybiB2YWwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgdmFsLm5vZGVUeXBlID09PSAxO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGEgZnVuY3Rpb24uXG5cdCAqIEBwYXJhbSB7P30gdmFsIFZhcmlhYmxlIHRvIHRlc3QuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdmFyaWFibGUgaXMgYSBmdW5jdGlvbi5cblx0ICovXG5cdHN0YXRpYyBpc0Z1bmN0aW9uKHZhbCkge1xuXHRcdHJldHVybiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBudWxsLlxuXHQgKiBAcGFyYW0geyp9IHZhbFxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cblx0c3RhdGljIGlzTnVsbCh2YWwpIHtcblx0XHRyZXR1cm4gdmFsID09PSBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGEgbnVtYmVyLlxuXHQgKiBAcGFyYW0gez99IHZhbCBWYXJpYWJsZSB0byB0ZXN0LlxuXHQgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHZhcmlhYmxlIGlzIGEgbnVtYmVyLlxuXHQgKi9cblx0c3RhdGljIGlzTnVtYmVyKHZhbCkge1xuXHRcdHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJztcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgYSB3aW5kb3cuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqL1xuXHRzdGF0aWMgaXNXaW5kb3codmFsKSB7XG5cdFx0cmV0dXJuIHZhbCAhPT0gbnVsbCAmJiB2YWwgPT09IHZhbC53aW5kb3c7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYW4gb2JqZWN0LiBUaGlzIGluY2x1ZGVzIGFycmF5c1xuXHQgKiBhbmQgZnVuY3Rpb25zLlxuXHQgKiBAcGFyYW0gez99IHZhbCBWYXJpYWJsZSB0byB0ZXN0LlxuXHQgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHZhcmlhYmxlIGlzIGFuIG9iamVjdC5cblx0ICovXG5cdHN0YXRpYyBpc09iamVjdCh2YWwpIHtcblx0XHR2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG5cdFx0cmV0dXJuIHR5cGUgPT09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbCB8fCB0eXBlID09PSAnZnVuY3Rpb24nO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBhIFByb21pc2UuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqL1xuXHRzdGF0aWMgaXNQcm9taXNlKHZhbCkge1xuXHRcdHJldHVybiB2YWwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbC50aGVuID09PSAnZnVuY3Rpb24nO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBhIHN0cmluZy5cblx0ICogQHBhcmFtIHsqfSB2YWxcblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICovXG5cdHN0YXRpYyBpc1N0cmluZyh2YWwpIHtcblx0XHRyZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgfHwgdmFsIGluc3RhbmNlb2YgU3RyaW5nO1xuXHR9XG5cblx0LyoqXG5cdCAqIE1lcmdlcyB0aGUgdmFsdWVzIG9mIGEgc3RhdGljIHByb3BlcnR5IGEgY2xhc3Mgd2l0aCB0aGUgdmFsdWVzIG9mIHRoYXRcblx0ICogcHJvcGVydHkgZm9yIGFsbCBpdHMgc3VwZXIgY2xhc3NlcywgYW5kIHN0b3JlcyBpdCBhcyBhIG5ldyBzdGF0aWNcblx0ICogcHJvcGVydHkgb2YgdGhhdCBjbGFzcy4gSWYgdGhlIHN0YXRpYyBwcm9wZXJ0eSBhbHJlYWR5IGV4aXN0ZWQsIGl0IHdvbid0XG5cdCAqIGJlIHJlY2FsY3VsYXRlZC5cblx0ICogQHBhcmFtIHshZnVuY3Rpb24oKX0gY29uc3RydWN0b3IgQ2xhc3MgY29uc3RydWN0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eU5hbWUgUHJvcGVydHkgbmFtZSB0byBiZSBjb2xsZWN0ZWQuXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgKik6Kj19IG9wdF9tZXJnZUZuIEZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgYW4gYXJyYXkgZmlsbGVkXG5cdCAqICAgd2l0aCB0aGUgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0eSBmb3IgdGhlIGN1cnJlbnQgY2xhc3MgYW5kIGFsbCBpdHMgc3VwZXIgY2xhc3Nlcy5cblx0ICogICBTaG91bGQgcmV0dXJuIHRoZSBtZXJnZWQgdmFsdWUgdG8gYmUgc3RvcmVkIG9uIHRoZSBjdXJyZW50IGNsYXNzLlxuXHQgKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgbWVyZ2UgaGFwcGVucywgZmFsc2Ugb3RoZXJ3aXNlLlxuXHQgKi9cblx0c3RhdGljIG1lcmdlU3VwZXJDbGFzc2VzUHJvcGVydHkoY29uc3RydWN0b3IsIHByb3BlcnR5TmFtZSwgb3B0X21lcmdlRm4pIHtcblx0XHR2YXIgbWVyZ2VkTmFtZSA9IHByb3BlcnR5TmFtZSArICdfTUVSR0VEJztcblx0XHRpZiAoY29uc3RydWN0b3IuaGFzT3duUHJvcGVydHkobWVyZ2VkTmFtZSkpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHR2YXIgbWVyZ2VkID0gY29yZS5jb2xsZWN0U3VwZXJDbGFzc2VzUHJvcGVydHkoY29uc3RydWN0b3IsIHByb3BlcnR5TmFtZSk7XG5cdFx0aWYgKG9wdF9tZXJnZUZuKSB7XG5cdFx0XHRtZXJnZWQgPSBvcHRfbWVyZ2VGbihtZXJnZWQpO1xuXHRcdH1cblx0XHRjb25zdHJ1Y3RvclttZXJnZWROYW1lXSA9IG1lcmdlZDtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBOdWxsIGZ1bmN0aW9uIHVzZWQgZm9yIGRlZmF1bHQgdmFsdWVzIG9mIGNhbGxiYWNrcywgZXRjLlxuXHQgKiBAcmV0dXJuIHt2b2lkfSBOb3RoaW5nLlxuXHQgKi9cblx0c3RhdGljIG51bGxGdW5jdGlvbigpIHt9XG59XG5cbi8qKlxuICogVW5pcXVlIGlkIHByb3BlcnR5IHByZWZpeC5cbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAcHJvdGVjdGVkXG4gKi9cbmNvcmUuVUlEX1BST1BFUlRZID0gJ2NvcmVfJyArICgoTWF0aC5yYW5kb20oKSAqIDFlOSkgPj4+IDApO1xuXG4vKipcbiAqIENvdW50ZXIgZm9yIHVuaXF1ZSBpZC5cbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5jb3JlLnVuaXF1ZUlkQ291bnRlcl8gPSAxO1xuXG5leHBvcnQgZGVmYXVsdCBjb3JlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgY29yZSBmcm9tICcuLi9jb3JlJztcblxuY2xhc3MgYXJyYXkge1xuXHQvKipcblx0ICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBhcnJheXMgaGF2ZSB0aGUgc2FtZSBjb250ZW50LlxuXHQgKiBAcGFyYW0geyFBcnJheTwqPn0gYXJyMVxuXHQgKiBAcGFyYW0geyFBcnJheTwqPn0gYXJyMlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cblx0c3RhdGljIGVxdWFsKGFycjEsIGFycjIpIHtcblx0XHRpZiAoYXJyMS5sZW5ndGggIT09IGFycjIubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyMS5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKGFycjFbaV0gIT09IGFycjJbaV0pIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBmaXJzdCB2YWx1ZSBpbiB0aGUgZ2l2ZW4gYXJyYXkgdGhhdCBpc24ndCB1bmRlZmluZWQuXG5cdCAqIEBwYXJhbSB7IUFycmF5fSBhcnJcblx0ICogQHJldHVybiB7Kn1cblx0ICovXG5cdHN0YXRpYyBmaXJzdERlZmluZWRWYWx1ZShhcnIpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKGFycltpXSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHJldHVybiBhcnJbaV07XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFRyYW5zZm9ybXMgdGhlIGlucHV0IG5lc3RlZCBhcnJheSB0byBiZWNvbWUgZmxhdC5cblx0ICogQHBhcmFtIHtBcnJheS48KnxBcnJheS48Kj4+fSBhcnIgTmVzdGVkIGFycmF5IHRvIGZsYXR0ZW4uXG5cdCAqIEBwYXJhbSB7QXJyYXkuPCo+fSBvcHRfb3V0cHV0IE9wdGlvbmFsIG91dHB1dCBhcnJheS5cblx0ICogQHJldHVybiB7QXJyYXkuPCo+fSBGbGF0IGFycmF5LlxuXHQgKi9cblx0c3RhdGljIGZsYXR0ZW4oYXJyLCBvcHRfb3V0cHV0KSB7XG5cdFx0dmFyIG91dHB1dCA9IG9wdF9vdXRwdXQgfHwgW107XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGFycltpXSkpIHtcblx0XHRcdFx0YXJyYXkuZmxhdHRlbihhcnJbaV0sIG91dHB1dCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaChhcnJbaV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYSBwYXJ0aWN1bGFyIHZhbHVlIGZyb20gYW4gYXJyYXkuXG5cdCAqIEBwYXJhbSB7QXJyYXkuPFQ+fSBhcnIgQXJyYXkgZnJvbSB3aGljaCB0byByZW1vdmUgdmFsdWUuXG5cdCAqIEBwYXJhbSB7VH0gb2JqIE9iamVjdCB0byByZW1vdmUuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYW4gZWxlbWVudCB3YXMgcmVtb3ZlZC5cblx0ICogQHRlbXBsYXRlIFRcblx0ICovXG5cdHN0YXRpYyByZW1vdmUoYXJyLCBvYmopIHtcblx0XHR2YXIgaSA9IGFyci5pbmRleE9mKG9iaik7XG5cdFx0dmFyIHJ2O1xuXHRcdGlmICggKHJ2ID0gaSA+PSAwKSApIHtcblx0XHRcdGFycmF5LnJlbW92ZUF0KGFyciwgaSk7XG5cdFx0fVxuXHRcdHJldHVybiBydjtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIGZyb20gYW4gYXJyYXkgdGhlIGVsZW1lbnQgYXQgaW5kZXggaVxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnIgQXJyYXkgb3IgYXJyYXkgbGlrZSBvYmplY3QgZnJvbSB3aGljaCB0byByZW1vdmUgdmFsdWUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBpbmRleCB0byByZW1vdmUuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYW4gZWxlbWVudCB3YXMgcmVtb3ZlZC5cblx0ICovXG5cdHN0YXRpYyByZW1vdmVBdChhcnIsIGkpIHtcblx0XHRyZXR1cm4gQXJyYXkucHJvdG90eXBlLnNwbGljZS5jYWxsKGFyciwgaSwgMSkubGVuZ3RoID09PSAxO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNsaWNlcyB0aGUgZ2l2ZW4gYXJyYXksIGp1c3QgbGlrZSBBcnJheS5wcm90b3R5cGUuc2xpY2UsIGJ1dCB0aGlzXG5cdCAqIGlzIGZhc3RlciBhbmQgd29ya2luZyBvbiBhbGwgYXJyYXktbGlrZSBvYmplY3RzIChsaWtlIGFyZ3VtZW50cykuXG5cdCAqIEBwYXJhbSB7IU9iamVjdH0gYXJyIEFycmF5LWxpa2Ugb2JqZWN0IHRvIHNsaWNlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIGluZGV4IHRoYXQgc2hvdWxkIHN0YXJ0IHRoZSBzbGljZS5cblx0ICogQHBhcmFtIHtudW1iZXI9fSBvcHRfZW5kIFRoZSBpbmRleCB3aGVyZSB0aGUgc2xpY2Ugc2hvdWxkIGVuZCwgbm90XG5cdCAqICAgaW5jbHVkZWQgaW4gdGhlIGZpbmFsIGFycmF5LiBJZiBub3QgZ2l2ZW4sIGFsbCBlbGVtZW50cyBhZnRlciB0aGVcblx0ICogICBzdGFydCBpbmRleCB3aWxsIGJlIGluY2x1ZGVkLlxuXHQgKiBAcmV0dXJuIHshQXJyYXl9XG5cdCAqL1xuXHRzdGF0aWMgc2xpY2UoYXJyLCBzdGFydCwgb3B0X2VuZCkge1xuXHRcdHZhciBzbGljZWQgPSBbXTtcblx0XHR2YXIgZW5kID0gY29yZS5pc0RlZihvcHRfZW5kKSA/IG9wdF9lbmQgOiBhcnIubGVuZ3RoO1xuXHRcdGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG5cdFx0XHRzbGljZWQucHVzaChhcnJbaV0pO1xuXHRcdH1cblx0XHRyZXR1cm4gc2xpY2VkO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFycmF5O1xuIiwiLyohXG4gKiBQb2x5ZmlsbCBmcm9tIEdvb2dsZSdzIENsb3N1cmUgTGlicmFyeS5cbiAqIENvcHlyaWdodCAyMDEzIFRoZSBDbG9zdXJlIExpYnJhcnkgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBhc3luYyA9IHt9O1xuXG5cbi8qKlxuICogVGhyb3cgYW4gaXRlbSB3aXRob3V0IGludGVycnVwdGluZyB0aGUgY3VycmVudCBleGVjdXRpb24gY29udGV4dC4gIEZvclxuICogZXhhbXBsZSwgaWYgcHJvY2Vzc2luZyBhIGdyb3VwIG9mIGl0ZW1zIGluIGEgbG9vcCwgc29tZXRpbWVzIGl0IGlzIHVzZWZ1bFxuICogdG8gcmVwb3J0IGFuIGVycm9yIHdoaWxlIHN0aWxsIGFsbG93aW5nIHRoZSByZXN0IG9mIHRoZSBiYXRjaCB0byBiZVxuICogcHJvY2Vzc2VkLlxuICogQHBhcmFtIHsqfSBleGNlcHRpb25cbiAqL1xuYXN5bmMudGhyb3dFeGNlcHRpb24gPSBmdW5jdGlvbihleGNlcHRpb24pIHtcblx0Ly8gRWFjaCB0aHJvdyBuZWVkcyB0byBiZSBpbiBpdHMgb3duIGNvbnRleHQuXG5cdGFzeW5jLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuXHRcdHRocm93IGV4Y2VwdGlvbjtcblx0fSk7XG59O1xuXG5cbi8qKlxuICogRmlyZXMgdGhlIHByb3ZpZGVkIGNhbGxiYWNrIGp1c3QgYmVmb3JlIHRoZSBjdXJyZW50IGNhbGxzdGFjayB1bndpbmRzLCBvciBhc1xuICogc29vbiBhcyBwb3NzaWJsZSBhZnRlciB0aGUgY3VycmVudCBKUyBleGVjdXRpb24gY29udGV4dC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24odGhpczpUSElTKX0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7VEhJUz19IG9wdF9jb250ZXh0IE9iamVjdCB0byB1c2UgYXMgdGhlIFwidGhpcyB2YWx1ZVwiIHdoZW4gY2FsbGluZ1xuICogICAgIHRoZSBwcm92aWRlZCBmdW5jdGlvbi5cbiAqIEB0ZW1wbGF0ZSBUSElTXG4gKi9cbmFzeW5jLnJ1biA9IGZ1bmN0aW9uKGNhbGxiYWNrLCBvcHRfY29udGV4dCkge1xuXHRpZiAoIWFzeW5jLnJ1bi53b3JrUXVldWVTY2hlZHVsZWRfKSB7XG5cdFx0Ly8gTm90aGluZyBpcyBjdXJyZW50bHkgc2NoZWR1bGVkLCBzY2hlZHVsZSBpdCBub3cuXG5cdFx0YXN5bmMubmV4dFRpY2soYXN5bmMucnVuLnByb2Nlc3NXb3JrUXVldWUpO1xuXHRcdGFzeW5jLnJ1bi53b3JrUXVldWVTY2hlZHVsZWRfID0gdHJ1ZTtcblx0fVxuXG5cdGFzeW5jLnJ1bi53b3JrUXVldWVfLnB1c2goXG5cdFx0bmV3IGFzeW5jLnJ1bi5Xb3JrSXRlbV8oY2FsbGJhY2ssIG9wdF9jb250ZXh0KSk7XG59O1xuXG5cbi8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gKi9cbmFzeW5jLnJ1bi53b3JrUXVldWVTY2hlZHVsZWRfID0gZmFsc2U7XG5cblxuLyoqIEBwcml2YXRlIHshQXJyYXkuPCFhc3luYy5ydW4uV29ya0l0ZW1fPn0gKi9cbmFzeW5jLnJ1bi53b3JrUXVldWVfID0gW107XG5cbi8qKlxuICogUnVuIGFueSBwZW5kaW5nIGFzeW5jLnJ1biB3b3JrIGl0ZW1zLiBUaGlzIGZ1bmN0aW9uIGlzIG5vdCBpbnRlbmRlZFxuICogZm9yIGdlbmVyYWwgdXNlLCBidXQgZm9yIHVzZSBieSBlbnRyeSBwb2ludCBoYW5kbGVycyB0byBydW4gaXRlbXMgYWhlYWQgb2ZcbiAqIGFzeW5jLm5leHRUaWNrLlxuICovXG5hc3luYy5ydW4ucHJvY2Vzc1dvcmtRdWV1ZSA9IGZ1bmN0aW9uKCkge1xuXHQvLyBOT1RFOiBhZGRpdGlvbmFsIHdvcmsgcXVldWUgaXRlbXMgbWF5IGJlIHB1c2hlZCB3aGlsZSBwcm9jZXNzaW5nLlxuXHR3aGlsZSAoYXN5bmMucnVuLndvcmtRdWV1ZV8ubGVuZ3RoKSB7XG5cdFx0Ly8gRG9uJ3QgbGV0IHRoZSB3b3JrIHF1ZXVlIGdyb3cgaW5kZWZpbml0ZWx5LlxuXHRcdHZhciB3b3JrSXRlbXMgPSBhc3luYy5ydW4ud29ya1F1ZXVlXztcblx0XHRhc3luYy5ydW4ud29ya1F1ZXVlXyA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgd29ya0l0ZW1zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgd29ya0l0ZW0gPSB3b3JrSXRlbXNbaV07XG5cdFx0XHR0cnkge1xuXHRcdFx0XHR3b3JrSXRlbS5mbi5jYWxsKHdvcmtJdGVtLnNjb3BlKTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0YXN5bmMudGhyb3dFeGNlcHRpb24oZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gVGhlcmUgYXJlIG5vIG1vcmUgd29yayBpdGVtcywgcmVzZXQgdGhlIHdvcmsgcXVldWUuXG5cdGFzeW5jLnJ1bi53b3JrUXVldWVTY2hlZHVsZWRfID0gZmFsc2U7XG59O1xuXG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZmluYWxcbiAqIEBzdHJ1Y3RcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbigpfSBmblxuICogQHBhcmFtIHtPYmplY3R8bnVsbHx1bmRlZmluZWR9IHNjb3BlXG4gKi9cbmFzeW5jLnJ1bi5Xb3JrSXRlbV8gPSBmdW5jdGlvbihmbiwgc2NvcGUpIHtcblx0LyoqIEBjb25zdCAqL1xuXHR0aGlzLmZuID0gZm47XG5cdC8qKiBAY29uc3QgKi9cblx0dGhpcy5zY29wZSA9IHNjb3BlO1xufTtcblxuXG4vKipcbiAqIEZpcmVzIHRoZSBwcm92aWRlZCBjYWxsYmFja3MgYXMgc29vbiBhcyBwb3NzaWJsZSBhZnRlciB0aGUgY3VycmVudCBKU1xuICogZXhlY3V0aW9uIGNvbnRleHQuIHNldFRpbWVvdXQo4oCmLCAwKSBhbHdheXMgdGFrZXMgYXQgbGVhc3QgNW1zIGZvciBsZWdhY3lcbiAqIHJlYXNvbnMuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6U0NPUEUpfSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvbiB0byBmaXJlIGFzIHNvb24gYXNcbiAqICAgICBwb3NzaWJsZS5cbiAqIEBwYXJhbSB7U0NPUEU9fSBvcHRfY29udGV4dCBPYmplY3QgaW4gd2hvc2Ugc2NvcGUgdG8gY2FsbCB0aGUgbGlzdGVuZXIuXG4gKiBAdGVtcGxhdGUgU0NPUEVcbiAqL1xuYXN5bmMubmV4dFRpY2sgPSBmdW5jdGlvbihjYWxsYmFjaywgb3B0X2NvbnRleHQpIHtcblx0dmFyIGNiID0gY2FsbGJhY2s7XG5cdGlmIChvcHRfY29udGV4dCkge1xuXHRcdGNiID0gY2FsbGJhY2suYmluZChvcHRfY29udGV4dCk7XG5cdH1cblx0Y2IgPSBhc3luYy5uZXh0VGljay53cmFwQ2FsbGJhY2tfKGNiKTtcblx0Ly8gSW50cm9kdWNlZCBhbmQgY3VycmVudGx5IG9ubHkgc3VwcG9ydGVkIGJ5IElFMTAuXG5cdC8vIFZlcmlmeSBpZiB2YXJpYWJsZSBpcyBkZWZpbmVkIG9uIHRoZSBjdXJyZW50IHJ1bnRpbWUgKGkuZS4sIG5vZGUsIGJyb3dzZXIpLlxuXHQvLyBDYW4ndCB1c2UgdHlwZW9mIGVuY2xvc2VkIGluIGEgZnVuY3Rpb24gKHN1Y2ggYXMgY29yZS5pc0Z1bmN0aW9uKSBvciBhblxuXHQvLyBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24gd2hlbiB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGFuIGVudmlyb25tZW50XG5cdC8vIHdoZXJlIHRoZSB2YXJpYWJsZSBpcyB1bmRlZmluZWQuXG5cdGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0c2V0SW1tZWRpYXRlKGNiKTtcblx0XHRyZXR1cm47XG5cdH1cblx0Ly8gTG9vayBmb3IgYW5kIGNhY2hlIHRoZSBjdXN0b20gZmFsbGJhY2sgdmVyc2lvbiBvZiBzZXRJbW1lZGlhdGUuXG5cdGlmICghYXN5bmMubmV4dFRpY2suc2V0SW1tZWRpYXRlXykge1xuXHRcdGFzeW5jLm5leHRUaWNrLnNldEltbWVkaWF0ZV8gPSBhc3luYy5uZXh0VGljay5nZXRTZXRJbW1lZGlhdGVFbXVsYXRvcl8oKTtcblx0fVxuXHRhc3luYy5uZXh0VGljay5zZXRJbW1lZGlhdGVfKGNiKTtcbn07XG5cblxuLyoqXG4gKiBDYWNoZSBmb3IgdGhlIHNldEltbWVkaWF0ZSBpbXBsZW1lbnRhdGlvbi5cbiAqIEB0eXBlIHtmdW5jdGlvbihmdW5jdGlvbigpKX1cbiAqIEBwcml2YXRlXG4gKi9cbmFzeW5jLm5leHRUaWNrLnNldEltbWVkaWF0ZV8gPSBudWxsO1xuXG5cbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgYmVzdCBwb3NzaWJsZSBpbXBsZW1lbnRhdGlvbiB0byBydW4gYSBmdW5jdGlvbiBhcyBzb29uIGFzXG4gKiB0aGUgSlMgZXZlbnQgbG9vcCBpcyBpZGxlLlxuICogQHJldHVybiB7ZnVuY3Rpb24oZnVuY3Rpb24oKSl9IFRoZSBcInNldEltbWVkaWF0ZVwiIGltcGxlbWVudGF0aW9uLlxuICogQHByaXZhdGVcbiAqL1xuYXN5bmMubmV4dFRpY2suZ2V0U2V0SW1tZWRpYXRlRW11bGF0b3JfID0gZnVuY3Rpb24oKSB7XG5cdC8vIENyZWF0ZSBhIHByaXZhdGUgbWVzc2FnZSBjaGFubmVsIGFuZCB1c2UgaXQgdG8gcG9zdE1lc3NhZ2UgZW1wdHkgbWVzc2FnZXNcblx0Ly8gdG8gb3Vyc2VsdmVzLlxuXHR2YXIgQ2hhbm5lbDtcblxuXHQvLyBWZXJpZnkgaWYgdmFyaWFibGUgaXMgZGVmaW5lZCBvbiB0aGUgY3VycmVudCBydW50aW1lIChpLmUuLCBub2RlLCBicm93c2VyKS5cblx0Ly8gQ2FuJ3QgdXNlIHR5cGVvZiBlbmNsb3NlZCBpbiBhIGZ1bmN0aW9uIChzdWNoIGFzIGNvcmUuaXNGdW5jdGlvbikgb3IgYW5cblx0Ly8gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duIHdoZW4gdGhlIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBhbiBlbnZpcm9ubWVudFxuXHQvLyB3aGVyZSB0aGUgdmFyaWFibGUgaXMgdW5kZWZpbmVkLlxuXHRpZiAodHlwZW9mIE1lc3NhZ2VDaGFubmVsID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0Q2hhbm5lbCA9IE1lc3NhZ2VDaGFubmVsO1xuXHR9XG5cblx0Ly8gSWYgTWVzc2FnZUNoYW5uZWwgaXMgbm90IGF2YWlsYWJsZSBhbmQgd2UgYXJlIGluIGEgYnJvd3NlciwgaW1wbGVtZW50XG5cdC8vIGFuIGlmcmFtZSBiYXNlZCBwb2x5ZmlsbCBpbiBicm93c2VycyB0aGF0IGhhdmUgcG9zdE1lc3NhZ2UgYW5kXG5cdC8vIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIuIFRoZSBsYXR0ZXIgZXhjbHVkZXMgSUU4IGJlY2F1c2UgaXQgaGFzIGFcblx0Ly8gc3luY2hyb25vdXMgcG9zdE1lc3NhZ2UgaW1wbGVtZW50YXRpb24uXG5cdGlmICh0eXBlb2YgQ2hhbm5lbCA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcblx0XHR3aW5kb3cucG9zdE1lc3NhZ2UgJiYgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIpIHtcblx0XHQvKiogQGNvbnN0cnVjdG9yICovXG5cdFx0Q2hhbm5lbCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gTWFrZSBhbiBlbXB0eSwgaW52aXNpYmxlIGlmcmFtZS5cblx0XHRcdHZhciBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcblx0XHRcdGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXHRcdFx0aWZyYW1lLnNyYyA9ICcnO1xuXHRcdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKGlmcmFtZSk7XG5cdFx0XHR2YXIgd2luID0gaWZyYW1lLmNvbnRlbnRXaW5kb3c7XG5cdFx0XHR2YXIgZG9jID0gd2luLmRvY3VtZW50O1xuXHRcdFx0ZG9jLm9wZW4oKTtcblx0XHRcdGRvYy53cml0ZSgnJyk7XG5cdFx0XHRkb2MuY2xvc2UoKTtcblx0XHRcdHZhciBtZXNzYWdlID0gJ2NhbGxJbW1lZGlhdGUnICsgTWF0aC5yYW5kb20oKTtcblx0XHRcdHZhciBvcmlnaW4gPSB3aW4ubG9jYXRpb24ucHJvdG9jb2wgKyAnLy8nICsgd2luLmxvY2F0aW9uLmhvc3Q7XG5cdFx0XHR2YXIgb25tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuXHRcdFx0XHQvLyBWYWxpZGF0ZSBvcmlnaW4gYW5kIG1lc3NhZ2UgdG8gbWFrZSBzdXJlIHRoYXQgdGhpcyBtZXNzYWdlIHdhc1xuXHRcdFx0XHQvLyBpbnRlbmRlZCBmb3IgdXMuXG5cdFx0XHRcdGlmIChlLm9yaWdpbiAhPT0gb3JpZ2luICYmIGUuZGF0YSAhPT0gbWVzc2FnZSkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnBvcnQxLm9ubWVzc2FnZSgpO1xuXHRcdFx0fS5iaW5kKHRoaXMpO1xuXHRcdFx0d2luLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBvbm1lc3NhZ2UsIGZhbHNlKTtcblx0XHRcdHRoaXMucG9ydDEgPSB7fTtcblx0XHRcdHRoaXMucG9ydDIgPSB7XG5cdFx0XHRcdHBvc3RNZXNzYWdlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR3aW4ucG9zdE1lc3NhZ2UobWVzc2FnZSwgb3JpZ2luKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9O1xuXHR9XG5cdGlmICh0eXBlb2YgQ2hhbm5lbCAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHR2YXIgY2hhbm5lbCA9IG5ldyBDaGFubmVsKCk7XG5cdFx0Ly8gVXNlIGEgZmlmbyBsaW5rZWQgbGlzdCB0byBjYWxsIGNhbGxiYWNrcyBpbiB0aGUgcmlnaHQgb3JkZXIuXG5cdFx0dmFyIGhlYWQgPSB7fTtcblx0XHR2YXIgdGFpbCA9IGhlYWQ7XG5cdFx0Y2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcblx0XHRcdGhlYWQgPSBoZWFkLm5leHQ7XG5cdFx0XHR2YXIgY2IgPSBoZWFkLmNiO1xuXHRcdFx0aGVhZC5jYiA9IG51bGw7XG5cdFx0XHRjYigpO1xuXHRcdH07XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKGNiKSB7XG5cdFx0XHR0YWlsLm5leHQgPSB7XG5cdFx0XHRcdGNiOiBjYlxuXHRcdFx0fTtcblx0XHRcdHRhaWwgPSB0YWlsLm5leHQ7XG5cdFx0XHRjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKDApO1xuXHRcdH07XG5cdH1cblx0Ly8gSW1wbGVtZW50YXRpb24gZm9yIElFNi04OiBTY3JpcHQgZWxlbWVudHMgZmlyZSBhbiBhc3luY2hyb25vdXNcblx0Ly8gb25yZWFkeXN0YXRlY2hhbmdlIGV2ZW50IHdoZW4gaW5zZXJ0ZWQgaW50byB0aGUgRE9NLlxuXHRpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiAnb25yZWFkeXN0YXRlY2hhbmdlJyBpblxuXHRcdGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKGNiKSB7XG5cdFx0XHR2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG5cdFx0XHRzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdC8vIENsZWFuIHVwIGFuZCBjYWxsIHRoZSBjYWxsYmFjay5cblx0XHRcdFx0c2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG5cdFx0XHRcdHNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG5cdFx0XHRcdHNjcmlwdCA9IG51bGw7XG5cdFx0XHRcdGNiKCk7XG5cdFx0XHRcdGNiID0gbnVsbDtcblx0XHRcdH07XG5cdFx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcblx0XHR9O1xuXHR9XG5cdC8vIEZhbGwgYmFjayB0byBzZXRUaW1lb3V0IHdpdGggMC4gSW4gYnJvd3NlcnMgdGhpcyBjcmVhdGVzIGEgZGVsYXkgb2YgNW1zXG5cdC8vIG9yIG1vcmUuXG5cdHJldHVybiBmdW5jdGlvbihjYikge1xuXHRcdHNldFRpbWVvdXQoY2IsIDApO1xuXHR9O1xufTtcblxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGlzIG92ZXJyaWRlZCB0byBwcm90ZWN0IGNhbGxiYWNrcyB3aXRoIGVudHJ5IHBvaW50XG4gKiBtb25pdG9yIGlmIHRoZSBhcHBsaWNhdGlvbiBtb25pdG9ycyBlbnRyeSBwb2ludHMuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGZpcmUgYXMgc29vbiBhcyBwb3NzaWJsZS5cbiAqIEByZXR1cm4ge2Z1bmN0aW9uKCl9IFRoZSB3cmFwcGVkIGNhbGxiYWNrLlxuICogQHByaXZhdGVcbiAqL1xuYXN5bmMubmV4dFRpY2sud3JhcENhbGxiYWNrXyA9IGZ1bmN0aW9uKG9wdF9yZXR1cm5WYWx1ZSkge1xuXHRyZXR1cm4gb3B0X3JldHVyblZhbHVlO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmM7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRGlzcG9zYWJsZSB1dGlsaXR5LiBXaGVuIGluaGVyaXRlZCBwcm92aWRlcyB0aGUgYGRpc3Bvc2VgIGZ1bmN0aW9uIHRvIGl0c1xuICogc3ViY2xhc3MsIHdoaWNoIGlzIHJlc3BvbnNpYmxlIGZvciBkaXNwb3Npbmcgb2YgYW55IG9iamVjdCByZWZlcmVuY2VzXG4gKiB3aGVuIGFuIGluc3RhbmNlIHdvbid0IGJlIHVzZWQgYW55bW9yZS4gU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGVcbiAqIGBkaXNwb3NlSW50ZXJuYWxgIHRvIGltcGxlbWVudCBhbnkgc3BlY2lmaWMgZGlzcG9zaW5nIGxvZ2ljLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIERpc3Bvc2FibGUge1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHQvKipcblx0XHQgKiBGbGFnIGluZGljYXRpbmcgaWYgdGhpcyBpbnN0YW5jZSBoYXMgYWxyZWFkeSBiZWVuIGRpc3Bvc2VkLlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLmRpc3Bvc2VkXyA9IGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIERpc3Bvc2VzIG9mIHRoaXMgaW5zdGFuY2UncyBvYmplY3QgcmVmZXJlbmNlcy4gQ2FsbHMgYGRpc3Bvc2VJbnRlcm5hbGAuXG5cdCAqL1xuXHRkaXNwb3NlKCkge1xuXHRcdGlmICghdGhpcy5kaXNwb3NlZF8pIHtcblx0XHRcdHRoaXMuZGlzcG9zZUludGVybmFsKCk7XG5cdFx0XHR0aGlzLmRpc3Bvc2VkXyA9IHRydWU7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGltcGxlbWVudCBhbnkgc3BlY2lmaWNcblx0ICogZGlzcG9zaW5nIGxvZ2ljIChsaWtlIGNsZWFyaW5nIHJlZmVyZW5jZXMgYW5kIGNhbGxpbmcgYGRpc3Bvc2VgIG9uIG90aGVyXG5cdCAqIGRpc3Bvc2FibGVzKS5cblx0ICovXG5cdGRpc3Bvc2VJbnRlcm5hbCgpIHt9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiB0aGlzIGluc3RhbmNlIGhhcyBhbHJlYWR5IGJlZW4gZGlzcG9zZWQuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqL1xuXHRpc0Rpc3Bvc2VkKCkge1xuXHRcdHJldHVybiB0aGlzLmRpc3Bvc2VkXztcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBEaXNwb3NhYmxlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jbGFzcyBzdHJpbmcge1xuXHQvKipcblx0ICogUmVtb3ZlcyB0aGUgYnJlYWtpbmcgc3BhY2VzIGZyb20gdGhlIGxlZnQgYW5kIHJpZ2h0IG9mIHRoZSBzdHJpbmcgYW5kXG5cdCAqIGNvbGxhcHNlcyB0aGUgc2VxdWVuY2VzIG9mIGJyZWFraW5nIHNwYWNlcyBpbiB0aGUgbWlkZGxlIGludG8gc2luZ2xlIHNwYWNlcy5cblx0ICogVGhlIG9yaWdpbmFsIGFuZCB0aGUgcmVzdWx0IHN0cmluZ3MgcmVuZGVyIHRoZSBzYW1lIHdheSBpbiBIVE1MLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc3RyIEEgc3RyaW5nIGluIHdoaWNoIHRvIGNvbGxhcHNlIHNwYWNlcy5cblx0ICogQHJldHVybiB7c3RyaW5nfSBDb3B5IG9mIHRoZSBzdHJpbmcgd2l0aCBub3JtYWxpemVkIGJyZWFraW5nIHNwYWNlcy5cblx0ICovXG5cdHN0YXRpYyBjb2xsYXBzZUJyZWFraW5nU3BhY2VzKHN0cikge1xuXHRcdHJldHVybiBzdHIucmVwbGFjZSgvW1xcdFxcclxcbiBdKy9nLCAnICcpLnJlcGxhY2UoL15bXFx0XFxyXFxuIF0rfFtcXHRcXHJcXG4gXSskL2csICcnKTtcblx0fVxuXG5cdC8qKlxuXHQqIEVzY2FwZXMgY2hhcmFjdGVycyBpbiB0aGUgc3RyaW5nIHRoYXQgYXJlIG5vdCBzYWZlIHRvIHVzZSBpbiBhIFJlZ0V4cC5cblx0KiBAcGFyYW0geyp9IHN0ciBUaGUgc3RyaW5nIHRvIGVzY2FwZS4gSWYgbm90IGEgc3RyaW5nLCBpdCB3aWxsIGJlIGNhc3RlZFxuXHQqICAgICB0byBvbmUuXG5cdCogQHJldHVybiB7c3RyaW5nfSBBIFJlZ0V4cCBzYWZlLCBlc2NhcGVkIGNvcHkgb2Yge0Bjb2RlIHN9LlxuXHQqL1xuXHRzdGF0aWMgZXNjYXBlUmVnZXgoc3RyKSB7XG5cdFx0cmV0dXJuIFN0cmluZyhzdHIpXG5cdFx0XHQucmVwbGFjZSgvKFstKClcXFtcXF17fSs/Ki4kXFxefCw6IzwhXFxcXF0pL2csICdcXFxcJDEnKVxuXHRcdFx0LnJlcGxhY2UoL1xceDA4L2csICdcXFxceDA4Jyk7XG5cdH1cblxuXHQvKipcblx0KiBSZXR1cm5zIGEgc3RyaW5nIHdpdGggYXQgbGVhc3QgNjQtYml0cyBvZiByYW5kb21uZXNzLlxuXHQqIEByZXR1cm4ge3N0cmluZ30gQSByYW5kb20gc3RyaW5nLCBlLmcuIHNuMXM3dmI0Z2NpYy5cblx0Ki9cblx0c3RhdGljIGdldFJhbmRvbVN0cmluZygpIHtcblx0XHR2YXIgeCA9IDIxNDc0ODM2NDg7XG5cdFx0cmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHgpLnRvU3RyaW5nKDM2KSArXG5cdFx0XHRNYXRoLmFicyhNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB4KSBeIERhdGUubm93KCkpLnRvU3RyaW5nKDM2KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDYWxjdWxhdGVzIHRoZSBoYXNoY29kZSBmb3IgYSBzdHJpbmcuIFRoZSBoYXNoY29kZSB2YWx1ZSBpcyBjb21wdXRlZCBieVxuXHQgKiB0aGUgc3VtIGFsZ29yaXRobTogc1swXSozMV4obi0xKSArIHNbMV0qMzFeKG4tMikgKyAuLi4gKyBzW24tMV0uIEEgbmljZVxuXHQgKiBwcm9wZXJ0eSBvZiB1c2luZyAzMSBwcmltZSBpcyB0aGF0IHRoZSBtdWx0aXBsaWNhdGlvbiBjYW4gYmUgcmVwbGFjZWQgYnlcblx0ICogYSBzaGlmdCBhbmQgYSBzdWJ0cmFjdGlvbiBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlOiAzMSppID09IChpPDw1KS1pLlxuXHQgKiBNb2Rlcm4gVk1zIGRvIHRoaXMgc29ydCBvZiBvcHRpbWl6YXRpb24gYXV0b21hdGljYWxseS5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHZhbCBUYXJnZXQgc3RyaW5nLlxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IFJldHVybnMgdGhlIHN0cmluZyBoYXNoY29kZS5cblx0ICovXG5cdHN0YXRpYyBoYXNoQ29kZSh2YWwpIHtcblx0XHR2YXIgaGFzaCA9IDA7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHZhbC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aGFzaCA9IDMxICogaGFzaCArIHZhbC5jaGFyQ29kZUF0KGkpO1xuXHRcdFx0aGFzaCAlPSAweDEwMDAwMDAwMDtcblx0XHR9XG5cdFx0cmV0dXJuIGhhc2g7XG5cdH1cblxuXHQvKipcblx0ICogUmVwbGFjZXMgaW50ZXJ2YWwgaW50byB0aGUgc3RyaW5nIHdpdGggc3BlY2lmaWVkIHZhbHVlLCBlLmcuXG5cdCAqIGByZXBsYWNlSW50ZXJ2YWwoXCJhYmNkZVwiLCAxLCA0LCBcIlwiKWAgcmV0dXJucyBcImFlXCIuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIGlucHV0IHN0cmluZy5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0IFN0YXJ0IGludGVydmFsIHBvc2l0aW9uIHRvIGJlIHJlcGxhY2VkLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gZW5kIEVuZCBpbnRlcnZhbCBwb3NpdGlvbiB0byBiZSByZXBsYWNlZC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFRoZSB2YWx1ZSB0aGF0IHJlcGxhY2VzIHRoZSBzcGVjaWZpZWQgaW50ZXJ2YWwuXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdHN0YXRpYyByZXBsYWNlSW50ZXJ2YWwoc3RyLCBzdGFydCwgZW5kLCB2YWx1ZSkge1xuXHRcdHJldHVybiBzdHIuc3Vic3RyaW5nKDAsIHN0YXJ0KSArIHZhbHVlICsgc3RyLnN1YnN0cmluZyhlbmQpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0cmluZztcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDbGFzcyByZXNwb25zaWJsZSBmb3Igc3RvcmluZyBhbiBvYmplY3QgdGhhdCB3aWxsIGJlIHByaW50ZWQgYXMgSlNPTlxuICogd2hlbiB0aGUgYHRvU3RyaW5nYCBtZXRob2QgaXMgY2FsbGVkLlxuICovXG5jbGFzcyBFbWJvZGllZCB7XG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgRW1ib2RpZWQgaW5zdGFuY2UuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0dGhpcy5ib2R5XyA9IHt9O1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGpzb24gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGlzIGluc3RhbmNlLlxuXHQgKiBAcmV0dXJuIHshT2JqZWN0fVxuXHQgKi9cblx0Ym9keSgpIHtcblx0XHRyZXR1cm4gdGhpcy5ib2R5Xztcblx0fVxuXG5cdC8qKlxuXHQgKiBJZiB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGFuIGluc3RhbmNlIG9mIEVtYm9kaWVkLCB0aGlzIHdpbGxcblx0ICogcmV0dXJuIGl0cyBib2R5IGNvbnRlbnQuIE90aGVyd2lzZSB0aGlzIHdpbGwgcmV0dXJuIHRoZVxuXHQgKiBvcmlnaW5hbCBvYmplY3QuXG5cdCAqIEBwYXJhbSB7Kn0gb2JqXG5cdCAqIEByZXR1cm4geyp9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyB0b0JvZHkob2JqKSB7XG5cdFx0cmV0dXJuIChvYmogaW5zdGFuY2VvZiBFbWJvZGllZCkgPyBvYmouYm9keSgpIDogb2JqO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGpzb24gc3RyaW5nIHRoYXQgcmVwcmVzZW50cyB0aGlzIGluc3RhbmNlLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy5ib2R5KCkpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEVtYm9kaWVkO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgeyBjb3JlIH0gZnJvbSAnbWV0YWwnO1xuaW1wb3J0IEVtYm9kaWVkIGZyb20gJy4vRW1ib2RpZWQnO1xuXG4vKipcbiAqIENsYXNzIHJlc3BvbnNpYmxlIGZvciBzdG9yaW5nIGFuZCBoYW5kbGluZyB0aGUgYm9keSBjb250ZW50c1xuICogb2YgYSBGaWx0ZXIgaW5zdGFuY2UuXG4gKi9cbmNsYXNzIEZpbHRlckJvZHkge1xuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIHtAbGluayBGaWx0ZXJCb2R5fSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7Kn0gb3BlcmF0b3JPclZhbHVlIElmIGEgdGhpcmQgcGFyYW0gaXMgZ2l2ZW4sIHRoaXMgc2hvdWxkXG5cdCAqICAgYmUgdGhlIGZpbHRlcidzIG9wZXJhdG9yIChsaWtlIFwiPj1cIikuIE90aGVyd2lzZSwgdGhpcyB3aWxsIGJlXG5cdCAqICAgdXNlZCBhcyB0aGUgZmlsdGVyJ3MgdmFsdWUsIGFuZCB0aGUgZmlsdGVyJ3Mgb3BlcmF0b3Igd2lsbCBiZSBcIj1cIi5cblx0ICogQHBhcmFtIHsqPX0gb3B0X3ZhbHVlIFRoZSBmaWx0ZXIncyB2YWx1ZS5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihmaWVsZCwgb3BlcmF0b3JPclZhbHVlLCBvcHRfdmFsdWUpIHtcblx0XHR2YXIgb2JqID0ge1xuXHRcdFx0b3BlcmF0b3I6IGNvcmUuaXNEZWYob3B0X3ZhbHVlKSA/IG9wZXJhdG9yT3JWYWx1ZSA6ICc9J1xuXHRcdH07XG5cblx0XHR2YXIgdmFsdWUgPSBjb3JlLmlzRGVmKG9wdF92YWx1ZSkgPyBvcHRfdmFsdWUgOiBvcGVyYXRvck9yVmFsdWU7XG5cblx0XHRpZiAoY29yZS5pc0RlZkFuZE5vdE51bGwodmFsdWUpKSB7XG5cdFx0XHRpZiAodmFsdWUgaW5zdGFuY2VvZiBFbWJvZGllZCkge1xuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlLmJvZHkoKTtcblx0XHRcdH1cblx0XHRcdG9iai52YWx1ZSA9IHZhbHVlO1xuXHRcdH1cblxuXHRcdGlmIChjb3JlLmlzRGVmQW5kTm90TnVsbChmaWVsZCkpIHtcblx0XHRcdHRoaXMuY3JlYXRlQm9keV8oZmllbGQsIG9iaik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuY3JlYXRlQm9keV8oJ2FuZCcsIFtdKTtcblx0XHR9XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDb21wb3NlcyB0aGUgY3VycmVudCBmaWx0ZXIgd2l0aCB0aGUgZ2l2ZW4gb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBvcGVyYXRvclxuXHQgKiBAcGFyYW0ge0ZpbHRlcj19IG9wdF9maWx0ZXIgQW5vdGhlciBmaWx0ZXIgdG8gY29tcG9zZSB0aGlzIGZpbHRlciB3aXRoLFxuXHQgKiAgIGlmIHRoZSBvcGVyYXRvciBpcyBub3QgdW5hcnkuXG5cdCAqL1xuXHRhZGQob3BlcmF0b3IsIG9wdF9maWx0ZXIpIHtcblx0XHRpZiAob3B0X2ZpbHRlcikge1xuXHRcdFx0dGhpcy5hZGRBcnJheU9wZXJhdG9yXyhvcGVyYXRvciwgb3B0X2ZpbHRlcik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuY3JlYXRlQm9keV8ob3BlcmF0b3IsIHRoaXMuYm9keV8pO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBDb21wb3NlcyB0aGUgY3VycmVudCBmaWx0ZXIgd2l0aCBhbiBvcGVyYXRvciB0aGF0IHN0b3JlcyBpdHMgdmFsdWVzIGluIGFuIGFycmF5LlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3Jcblx0ICogQHBhcmFtIHshRmlsdGVyfSBmaWx0ZXJcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0YWRkQXJyYXlPcGVyYXRvcl8ob3BlcmF0b3IsIGZpbHRlcikge1xuXHRcdGlmICghKHRoaXMuYm9keV9bb3BlcmF0b3JdIGluc3RhbmNlb2YgQXJyYXkpKSB7XG5cdFx0XHR0aGlzLmNyZWF0ZUJvZHlfKG9wZXJhdG9yLCBbdGhpcy5ib2R5X10pO1xuXHRcdH1cblx0XHR0aGlzLmJvZHlfW29wZXJhdG9yXS5wdXNoKGZpbHRlci5ib2R5KCkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgZmlsdGVycyB0byBiZSBjb21wb3NlZCB3aXRoIHRoaXMgZmlsdGVyIGJvZHkgdXNpbmcgdGhlIGdpdmVuIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3Jcblx0ICogQHBhcmFtIHsuLi4qfSBmaWx0ZXJzIEEgdmFyaWFibGUgYW1vdW50IG9mIGZpbHRlcnMgdG8gYmUgY29tcG9zZWQuXG5cdCAqL1xuXHRhZGRNYW55KG9wZXJhdG9yLCAuLi5maWx0ZXJzKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBmaWx0ZXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR0aGlzLmFkZChvcGVyYXRvciwgZmlsdGVyc1tpXSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBuZXcgYm9keSBvYmplY3QsIHNldHRpbmcgdGhlIHJlcXVlc3RkIGtleSB0byB0aGUgZ2l2ZW4gdmFsdWUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSB0byBzZXQgaW4gdGhlIG5ldyBib2R5IG9iamVjdFxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0aGUgcmVxdWVzdGVkIGtleSBzaG91bGQgaGF2ZSBpbiB0aGUgbmV3IGJvZHkgb2JqZWN0LlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRjcmVhdGVCb2R5XyhrZXksIHZhbHVlKSB7XG5cdFx0dGhpcy5ib2R5XyA9IHt9O1xuXHRcdHRoaXMuYm9keV9ba2V5XSA9IHZhbHVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGpzb24gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGlzIGZpbHRlcidzIGJvZHkuXG5cdCAqIEByZXR1cm4geyFPYmplY3R9XG5cdCAqL1xuXHRnZXRPYmplY3QoKSB7XG5cdFx0cmV0dXJuIHRoaXMuYm9keV87XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRmlsdGVyQm9keTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEVtYm9kaWVkIGZyb20gJy4vRW1ib2RpZWQnO1xuXG4vKipcbiAqIENsYXNzIHJlc3BvbnNpYmxlIGZvciBidWlsZGluZyBkaWZmZXJlbnQgdHlwZXMgb2YgZ2VvbWV0cmljXG4gKiBzaGFwZXMuXG4gKi9cbmNsYXNzIEdlbyB7XG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgbmV3IHtAbGluayBCb3VuZGluZ0JveH0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7Kn0gdXBwZXJMZWZ0IFRoZSB1cHBlciBsZWZ0IHBvaW50LlxuXHQgKiBAcGFyYW0geyp9IGxvd2VyUmlnaHQgVGhlIGxvd2VyIHJpZ2h0IHBvaW50LlxuXHQgKiBAcmV0dXJuIHshQm91bmRpbmdCb3h9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBib3VuZGluZ0JveCh1cHBlckxlZnQsIGxvd2VyUmlnaHQpIHtcblx0XHRyZXR1cm4gbmV3IEdlby5Cb3VuZGluZ0JveCh1cHBlckxlZnQsIGxvd2VyUmlnaHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBuZXcge0BsaW5rIENpcmNsZX0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7Kn0gY2VudGVyIFRoZSBjaXJjbGUncyBjZW50ZXIgY29vcmRpbmF0ZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHJhZGl1cyBUaGUgY2lyY2xlJ3MgcmFkaXVzLlxuXHQgKiBAcmV0dXJuIHshQ2lyY2xlfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgY2lyY2xlKGNlbnRlciwgcmFkaXVzKSB7XG5cdFx0cmV0dXJuIG5ldyBHZW8uQ2lyY2xlKGNlbnRlciwgcmFkaXVzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgbmV3IHtAbGluayBMaW5lfSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHsuLi4qfSBwb2ludHMgVGhpcyBsaW5lJ3MgcG9pbnRzLlxuXHQgKiBAcmV0dXJuIHshTGluZX1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGxpbmUoLi4ucG9pbnRzKSB7XG5cdFx0cmV0dXJuIG5ldyBHZW8uTGluZSguLi5wb2ludHMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBuZXcge0BsaW5rIFBvaW50fSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGxhdCBUaGUgbGF0aXR1ZGUgY29vcmRpbmF0ZVxuXHQgKiBAcGFyYW0ge251bWJlcn0gbG9uIFRoZSBsb25naXR1ZGUgY29vcmRpbmF0ZVxuXHQgKiBAcmV0dXJuIHshUG9pbnR9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBwb2ludChsYXQsIGxvbikge1xuXHRcdHJldHVybiBuZXcgR2VvLlBvaW50KGxhdCwgbG9uKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgbmV3IHtAbGluayBQb2x5Z29ufSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHsuLi4qfSBwb2ludHMgVGhpcyBwb2x5Z29uJ3MgcG9pbnRzLlxuXHQgKiBAcmV0dXJuIHshUG9seWdvbn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIHBvbHlnb24oLi4ucG9pbnRzKSB7XG5cdFx0cmV0dXJuIG5ldyBHZW8uUG9seWdvbiguLi5wb2ludHMpO1xuXHR9XG59XG5cbi8qKlxuICogQ2xhc3MgdGhhdCByZXByZXNlbnRzIGEgcG9pbnQgY29vcmRpbmF0ZS5cbiAqIEBleHRlbmRzIHtFbWJvZGllZH1cbiAqL1xuY2xhc3MgUG9pbnQgZXh0ZW5kcyBFbWJvZGllZCB7XG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEge0BsaW5rIFBvaW50fSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGxhdCBUaGUgbGF0aXR1ZGUgY29vcmRpbmF0ZVxuXHQgKiBAcGFyYW0ge251bWJlcn0gbG9uIFRoZSBsb25naXR1ZGUgY29vcmRpbmF0ZVxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGNvbnN0cnVjdG9yKGxhdCwgbG9uKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLmJvZHlfID0gW2xhdCwgbG9uXTtcblx0fVxufVxuR2VvLlBvaW50ID0gUG9pbnQ7XG5cbi8qKlxuICogQ2xhc3MgdGhhdCByZXByZXNlbnRzIGEgbGluZS5cbiAqIEBleHRlbmRzIHtFbWJvZGllZH1cbiAqL1xuY2xhc3MgTGluZSBleHRlbmRzIEVtYm9kaWVkIHtcblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSB7QGxpbmsgTGluZX0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7Li4uKn0gcG9pbnRzIFRoaXMgbGluZSdzIHBvaW50cy5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciguLi5wb2ludHMpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuYm9keV8gPSB7XG5cdFx0XHR0eXBlOiAnbGluZXN0cmluZycsXG5cdFx0XHRjb29yZGluYXRlczogcG9pbnRzLm1hcChwb2ludCA9PiBFbWJvZGllZC50b0JvZHkocG9pbnQpKVxuXHRcdH07XG5cdH1cbn1cbkdlby5MaW5lID0gTGluZTtcblxuLyoqXG4gKiBDbGFzcyB0aGF0IHJlcHJlc2VudHMgYSBib3VuZGluZyBib3guXG4gKiBAZXh0ZW5kcyB7RW1ib2RpZWR9XG4gKi9cbmNsYXNzIEJvdW5kaW5nQm94IGV4dGVuZHMgRW1ib2RpZWQge1xuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIHtAbGluayBCb3VuZGluZ0JveH0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7Kn0gdXBwZXJMZWZ0IFRoZSB1cHBlciBsZWZ0IHBvaW50LlxuXHQgKiBAcGFyYW0geyp9IGxvd2VyUmlnaHQgVGhlIGxvd2VyIHJpZ2h0IHBvaW50LlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGNvbnN0cnVjdG9yKHVwcGVyTGVmdCwgbG93ZXJSaWdodCkge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy5ib2R5XyA9IHtcblx0XHRcdHR5cGU6ICdlbnZlbG9wZScsXG5cdFx0XHRjb29yZGluYXRlczogW0VtYm9kaWVkLnRvQm9keSh1cHBlckxlZnQpLCBFbWJvZGllZC50b0JvZHkobG93ZXJSaWdodCldXG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoaXMgYm91bmRpbmcgYm94J3MgcG9pbnRzLlxuXHQgKiBAcmV0dXJuIHshQXJyYXl9XG5cdCAqL1xuXHRnZXRQb2ludHMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuYm9keV8uY29vcmRpbmF0ZXM7XG5cdH1cbn1cbkdlby5Cb3VuZGluZ0JveCA9IEJvdW5kaW5nQm94O1xuXG4vKipcbiAqIENsYXNzIHRoYXQgcmVwcmVzZW50cyBhIGNpcmNsZS5cbiAqIEBleHRlbmRzIHtFbWJvZGllZH1cbiAqL1xuY2xhc3MgQ2lyY2xlIGV4dGVuZHMgRW1ib2RpZWQge1xuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIHtAbGluayBDaXJjbGV9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0geyp9IGNlbnRlciBUaGUgY2lyY2xlJ3MgY2VudGVyIGNvb3JkaW5hdGUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSByYWRpdXMgVGhlIGNpcmNsZSdzIHJhZGl1cy5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihjZW50ZXIsIHJhZGl1cykge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy5ib2R5XyA9IHtcblx0XHRcdHR5cGU6ICdjaXJjbGUnLFxuXHRcdFx0Y29vcmRpbmF0ZXM6IEVtYm9kaWVkLnRvQm9keShjZW50ZXIpLFxuXHRcdFx0cmFkaXVzOiByYWRpdXNcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhpcyBjaXJjbGUncyBjZW50ZXIgY29vcmRpbmF0ZS5cblx0ICogQHJldHVybiB7Kn1cblx0ICovXG5cdGdldENlbnRlcigpIHtcblx0XHRyZXR1cm4gdGhpcy5ib2R5Xy5jb29yZGluYXRlcztcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoaXMgY2lyY2xlJ3MgcmFkaXVzLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuXHRnZXRSYWRpdXMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuYm9keV8ucmFkaXVzO1xuXHR9XG59XG5HZW8uQ2lyY2xlID0gQ2lyY2xlO1xuXG4vKipcbiAqIENsYXNzIHRoYXQgcmVwcmVzZW50cyBhIHBvbHlnb24uXG4gKiBAZXh0ZW5kcyB7RW1ib2RpZWR9XG4gKi9cbmNsYXNzIFBvbHlnb24gZXh0ZW5kcyBFbWJvZGllZCB7XG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEge0BsaW5rIFBvbHlnb259IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0gey4uLip9IHBvaW50cyBUaGlzIHBvbHlnb24ncyBwb2ludHMuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0Y29uc3RydWN0b3IoLi4ucG9pbnRzKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLmJvZHlfID0ge1xuXHRcdFx0dHlwZTogJ3BvbHlnb24nLFxuXHRcdFx0Y29vcmRpbmF0ZXM6IFtdXG5cdFx0fTtcblx0XHR0aGlzLmFkZENvb3JkaW5hdGVzXyguLi5wb2ludHMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgdGhlIGdpdmVuIHBvaW50cyBhcyBjb29yZGluYXRlcyBmb3IgdGhpcyBwb2x5Z29uLlxuXHQgKiBAcGFyYW0gey4uLip9IHBvaW50c1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRhZGRDb29yZGluYXRlc18oLi4ucG9pbnRzKSB7XG5cdFx0dGhpcy5ib2R5Xy5jb29yZGluYXRlcy5wdXNoKHBvaW50cy5tYXAocG9pbnQgPT4gRW1ib2RpZWQudG9Cb2R5KHBvaW50KSkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgdGhlIGdpdmVuIHBvaW50cyBhcyBhIGhvbGUgaW5zaWRlIHRoaXMgcG9seWdvbi5cblx0ICogQHBhcmFtICB7Li4uKn0gcG9pbnRzXG5cdCAqIEBjaGFpbm5hYmxlXG5cdCAqL1xuXHRob2xlKC4uLnBvaW50cykge1xuXHRcdHRoaXMuYWRkQ29vcmRpbmF0ZXNfKC4uLnBvaW50cyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn1cbkdlby5Qb2x5Z29uID0gUG9seWdvbjtcblxuZXhwb3J0IGRlZmF1bHQgR2VvO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgeyBjb3JlIH0gZnJvbSAnbWV0YWwnO1xuaW1wb3J0IEVtYm9kaWVkIGZyb20gJy4vRW1ib2RpZWQnO1xuXG4vKipcbiAqIENsYXNzIHJlc3BvbnNpYmxlIGZvciBidWlsZGluZyByYW5nZSBvYmplY3RzIHRvIGJlIHVzZWQgYnkgYEZpbHRlcmAuXG4gKiBAZXh0ZW5kcyB7RW1ib2RpZWR9XG4gKi9cbmNsYXNzIFJhbmdlIGV4dGVuZHMgRW1ib2RpZWQge1xuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIHtAbGluayBSYW5nZX0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7Kn0gZnJvbVxuXHQgKiBAcGFyYW0geyp9IG9wdF90b1xuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGNvbnN0cnVjdG9yKGZyb20sIG9wdF90bykge1xuXHRcdHN1cGVyKCk7XG5cdFx0aWYgKGNvcmUuaXNEZWZBbmROb3ROdWxsKGZyb20pKSB7XG5cdFx0XHR0aGlzLmJvZHlfLmZyb20gPSBmcm9tO1xuXHRcdH1cblx0XHRpZiAoY29yZS5pc0RlZkFuZE5vdE51bGwob3B0X3RvKSkge1xuXHRcdFx0dGhpcy5ib2R5Xy50byA9IG9wdF90bztcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIHtAbGluayBSYW5nZX0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7Kn0gZnJvbVxuXHQgKiBAcmV0dXJuIHshUmFuZ2V9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBmcm9tKGZyb20pIHtcblx0XHRyZXR1cm4gbmV3IFJhbmdlKGZyb20pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSB7QGxpbmsgUmFuZ2V9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0geyp9IGZyb21cblx0ICogQHBhcmFtIHsqfSB0b1xuXHQgKiBAcmV0dXJuIHshUmFuZ2V9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyByYW5nZShmcm9tLCB0bykge1xuXHRcdHJldHVybiBuZXcgUmFuZ2UoZnJvbSwgdG8pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSB7QGxpbmsgUmFuZ2V9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0geyp9IHRvXG5cdCAqIEByZXR1cm4geyFSYW5nZX1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIHRvKHRvKSB7XG5cdFx0cmV0dXJuIG5ldyBSYW5nZShudWxsLCB0byk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUmFuZ2U7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7IGNvcmUgfSBmcm9tICdtZXRhbCc7XG5pbXBvcnQgRW1ib2RpZWQgZnJvbSAnLi9FbWJvZGllZCc7XG5pbXBvcnQgRmlsdGVyQm9keSBmcm9tICcuL0ZpbHRlckJvZHknO1xuaW1wb3J0IEdlbyBmcm9tICcuL0dlbyc7XG5pbXBvcnQgUmFuZ2UgZnJvbSAnLi9SYW5nZSc7XG5cbi8qKlxuICogQ2xhc3MgcmVzcG9uc2libGUgZm9yIGJ1aWxkaW5nIGZpbHRlcnMuXG4gKiBAZXh0ZW5kcyB7RW1ib2RpZWR9XG4gKi9cbmNsYXNzIEZpbHRlciBleHRlbmRzIEVtYm9kaWVkIHtcblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7Kn0gb3BlcmF0b3JPclZhbHVlIElmIGEgdGhpcmQgcGFyYW0gaXMgZ2l2ZW4sIHRoaXMgc2hvdWxkXG5cdCAqICAgYmUgdGhlIGZpbHRlcidzIG9wZXJhdG9yIChsaWtlIFwiPj1cIikuIE90aGVyd2lzZSwgdGhpcyB3aWxsIGJlXG5cdCAqICAgdXNlZCBhcyB0aGUgZmlsdGVyJ3MgdmFsdWUsIGFuZCB0aGUgZmlsdGVyJ3Mgb3BlcmF0b3Igd2lsbCBiZSBcIj1cIi5cblx0ICogQHBhcmFtIHsqPX0gb3B0X3ZhbHVlIFRoZSBmaWx0ZXIncyB2YWx1ZS5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihmaWVsZCwgb3BlcmF0b3JPclZhbHVlLCBvcHRfdmFsdWUpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuYm9keV8gPSBuZXcgRmlsdGVyQm9keShmaWVsZCwgb3BlcmF0b3JPclZhbHVlLCBvcHRfdmFsdWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBmaWx0ZXIgdG8gYmUgY29tcG9zZWQgd2l0aCB0aGlzIGZpbHRlciB1c2luZyB0aGUgZ2l2ZW4gb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBvcGVyYXRvclxuXHQgKiBAcGFyYW0geyFGaWx0ZXJ8c3RyaW5nfSBmaWVsZE9yRmlsdGVyIEVpdGhlciBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIG9yIHRoZVxuXHQgKiAgIG5hbWUgb2YgdGhlIGZpZWxkIHRvIGZpbHRlciBieS5cblx0ICogQHBhcmFtIHsqPX0gb3B0X29wZXJhdG9yT3JWYWx1ZSBFaXRoZXIgdGhlIGZpZWxkJ3Mgb3BlcmF0b3Igb3IgaXRzIHZhbHVlLlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfdmFsdWUgVGhlIGZpbHRlcidzIHZhbHVlLlxuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cblx0YWRkKG9wZXJhdG9yLCBmaWVsZE9yRmlsdGVyLCBvcHRfb3BlcmF0b3JPclZhbHVlLCBvcHRfdmFsdWUpIHtcblx0XHR2YXIgZmlsdGVyID0gZmllbGRPckZpbHRlciA/IEZpbHRlci50b0ZpbHRlcihmaWVsZE9yRmlsdGVyLCBvcHRfb3BlcmF0b3JPclZhbHVlLCBvcHRfdmFsdWUpIDogbnVsbDtcblx0XHR0aGlzLmJvZHlfLmFkZChvcGVyYXRvciwgZmlsdGVyKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGZpbHRlcnMgdG8gYmUgY29tcG9zZWQgd2l0aCB0aGlzIGZpbHRlciB1c2luZyB0aGUgZ2l2ZW4gb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBvcGVyYXRvclxuXHQgKiBAcGFyYW0gey4uLip9IGZpbHRlcnMgQSB2YXJpYWJsZSBhbW91bnQgb2YgZmlsdGVycyB0byBiZSBjb21wb3NlZC5cblx0ICogQGNoYWlubmFibGVcblx0ICovXG5cdGFkZE1hbnkob3BlcmF0b3IsIC4uLmZpbHRlcnMpIHtcblx0XHR0aGlzLmJvZHlfLmFkZE1hbnkob3BlcmF0b3IsIC4uLmZpbHRlcnMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBmaWx0ZXIgdG8gYmUgY29tcG9zZWQgd2l0aCB0aGlzIGZpbHRlciB1c2luZyB0aGUgXCJhbmRcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHshRmlsdGVyfHN0cmluZ30gZmllbGRPckZpbHRlciBFaXRoZXIgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSBvciB0aGVcblx0ICogICBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF9vcGVyYXRvck9yVmFsdWUgRWl0aGVyIHRoZSBmaWVsZCdzIG9wZXJhdG9yIG9yIGl0cyB2YWx1ZS5cblx0ICogQHBhcmFtIHsqPX0gb3B0X3ZhbHVlIFRoZSBmaWx0ZXIncyB2YWx1ZS5cblx0ICogQGNoYWlubmFibGVcblx0ICovXG5cdGFuZChmaWVsZE9yRmlsdGVyLCBvcHRfb3BlcmF0b3JPclZhbHVlLCBvcHRfdmFsdWUpIHtcblx0XHRyZXR1cm4gdGhpcy5hZGQoJ2FuZCcsIGZpZWxkT3JGaWx0ZXIsIG9wdF9vcGVyYXRvck9yVmFsdWUsIG9wdF92YWx1ZSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIHRoYXQgdXNlcyB0aGUgXCJhbnlcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7IShBcnJheXwuLi4qKX0gdmFsdWVzIEEgdmFyaWFibGUgYW1vdW50IG9mIHZhbHVlcyB0byBiZSB1c2VkIHdpdGhcblx0ICogICB0aGUgXCJub25lXCIgb3BlcmF0b3IuIENhbiBiZSBwYXNzZWQgZWl0aGVyIGFzIGEgc2luZ2xlIGFycmF5IG9yIGFzXG5cdCAqICAgc2VwYXJhdGUgcGFyYW1zLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgYW55KGZpZWxkKSB7XG5cdFx0dmFyIHZhbHVlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cdFx0aWYgKHZhbHVlcy5sZW5ndGggPT09IDEgJiYgdmFsdWVzWzBdIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdHZhbHVlcyA9IHZhbHVlc1swXTtcblx0XHR9XG5cdFx0cmV0dXJuIG5ldyBGaWx0ZXIoZmllbGQsICdhbnknLCB2YWx1ZXMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSB0aGF0IHVzZXMgdGhlIFwiZ3BcIiBvcGVyYXRvci5cblx0ICogVGhpcyBpcyBhIHNwZWNpYWwgdXNlIGNhc2Ugb2YgYEZpbHRlci5wb2x5Z29uYCBmb3IgYm91bmRpbmdcblx0ICogYm94ZXMuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQncyBuYW1lLlxuXHQgKiBAcGFyYW0geyp9IGJveE9yVXBwZXJMZWZ0IEVpdGhlciBhIGBHZW8uQm91bmRpbmdCb3hgIGluc3RhbmNlLCBvclxuXHQgKiAgIGEgYm91bmRpbmcgYm94J3MgdXBwZXIgbGVmdCBjb29yZGluYXRlLlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfbG93ZXJSaWdodCBBIGJvdW5kaW5nIGJveCdzIGxvd2VyIHJpZ2h0IGNvb3JkaW5hdGUuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBib3VuZGluZ0JveChmaWVsZCwgYm94T3JVcHBlckxlZnQsIG9wdF9sb3dlclJpZ2h0KSB7XG5cdFx0aWYgKGJveE9yVXBwZXJMZWZ0IGluc3RhbmNlb2YgR2VvLkJvdW5kaW5nQm94KSB7XG5cdFx0XHRyZXR1cm4gRmlsdGVyLnBvbHlnb24oZmllbGQsIC4uLmJveE9yVXBwZXJMZWZ0LmdldFBvaW50cygpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIEZpbHRlci5wb2x5Z29uKGZpZWxkLCBib3hPclVwcGVyTGVmdCwgb3B0X2xvd2VyUmlnaHQpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBqc29uIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhpcyBmaWx0ZXIuXG5cdCAqIEByZXR1cm4geyFPYmplY3R9XG5cdCAqL1xuXHRib2R5KCkge1xuXHRcdHJldHVybiB0aGlzLmJvZHlfLmdldE9iamVjdCgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSB0aGF0IHVzZXMgdGhlIFwiZ2RcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBmaWVsZCdzIG5hbWUuXG5cdCAqIEBwYXJhbSB7Kn0gbG9jYXRpb25PckNpcmNsZSBFaXRoZXIgYSBgR2VvLkNpcmNsZWAgaW5zdGFuY2Ugb3IgYSBjb29yZGluYXRlLlxuXHQgKiBAcGFyYW0ge1JhbmdlfHN0cmluZz19IG9wdF9yYW5nZU9yRGlzdGFuY2UgRWl0aGVyIGEgYFJhbmdlYCBpbnN0YW5jZSBvclxuXHQgKiAgIHRoZSBkaXN0YW5jZSB2YWx1ZS5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGRpc3RhbmNlKGZpZWxkLCBsb2NhdGlvbk9yQ2lyY2xlLCBvcHRfcmFuZ2VPckRpc3RhbmNlKSB7XG5cdFx0dmFyIGxvY2F0aW9uID0gbG9jYXRpb25PckNpcmNsZTtcblx0XHR2YXIgcmFuZ2UgPSBvcHRfcmFuZ2VPckRpc3RhbmNlO1xuXHRcdGlmIChsb2NhdGlvbk9yQ2lyY2xlIGluc3RhbmNlb2YgR2VvLkNpcmNsZSkge1xuXHRcdFx0bG9jYXRpb24gPSBsb2NhdGlvbk9yQ2lyY2xlLmdldENlbnRlcigpO1xuXHRcdFx0cmFuZ2UgPSBSYW5nZS50byhsb2NhdGlvbk9yQ2lyY2xlLmdldFJhZGl1cygpKTtcblx0XHR9IGVsc2UgaWYgKCEob3B0X3JhbmdlT3JEaXN0YW5jZSBpbnN0YW5jZW9mIFJhbmdlKSkge1xuXHRcdFx0cmFuZ2UgPSBSYW5nZS50byhvcHRfcmFuZ2VPckRpc3RhbmNlKTtcblx0XHR9XG5cdFx0cmV0dXJuIEZpbHRlci5kaXN0YW5jZUludGVybmFsXyhmaWVsZCwgbG9jYXRpb24sIHJhbmdlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcImdkXCIgb3BlcmF0b3IuIFRoaXNcblx0ICogaXMganVzdCBhbiBpbnRlcm5hbCBoZWxwZXIgdXNlZCBieSBgRmlsdGVyLmRpc3RhbmNlYC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBmaWVsZCdzIG5hbWUuXG5cdCAqIEBwYXJhbSB7Kn0gbG9jYXRpb24gQSBsb2NhdGlvbiBjb29yZGluYXRlLlxuXHQgKiBAcGFyYW0ge1JhbmdlfSByYW5nZSBBIGBSYW5nZWAgaW5zdGFuY2UuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGRpc3RhbmNlSW50ZXJuYWxfKGZpZWxkLCBsb2NhdGlvbiwgcmFuZ2UpIHtcblx0XHR2YXIgdmFsdWUgPSB7XG5cdFx0XHRsb2NhdGlvbjogRW1ib2RpZWQudG9Cb2R5KGxvY2F0aW9uKVxuXHRcdH07XG5cdFx0cmFuZ2UgPSByYW5nZS5ib2R5KCk7XG5cdFx0aWYgKHJhbmdlLmZyb20pIHtcblx0XHRcdHZhbHVlLm1pbiA9IHJhbmdlLmZyb207XG5cdFx0fVxuXHRcdGlmIChyYW5nZS50bykge1xuXHRcdFx0dmFsdWUubWF4ID0gcmFuZ2UudG87XG5cdFx0fVxuXHRcdHJldHVybiBGaWx0ZXIuZmllbGQoZmllbGQsICdnZCcsIHZhbHVlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcIj1cIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIGZpbHRlcidzIHZhbHVlLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuICAgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgZXF1YWwoZmllbGQsIHZhbHVlKSB7XG5cdFx0cmV0dXJuIG5ldyBGaWx0ZXIoZmllbGQsICc9JywgdmFsdWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSB0aGF0IHVzZXMgdGhlIFwiZXhpc3RzXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQncyBuYW1lLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgZXhpc3RzKGZpZWxkKSB7XG5cdFx0cmV0dXJuIEZpbHRlci5maWVsZChmaWVsZCwgJ2V4aXN0cycsIG51bGwpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSB0aGF0IHVzZXMgdGhlIFwiZnV6enlcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkT3JRdWVyeSBJZiBubyBzZWNvbmQgc3RyaW5nIGFyZ3VtZW50IGlzIGdpdmVuLCB0aGlzXG5cdCAqICAgc2hvdWxkIGJlIHRoZSBxdWVyeSBzdHJpbmcsIGluIHdoaWNoIGNhc2UgYWxsIGZpZWxkcyB3aWxsIGJlIG1hdGNoZWQuXG5cdCAqICAgT3RoZXJ3aXNlLCB0aGlzIHNob3VsZCBiZSB0aGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gbWF0Y2guXG5cdCAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcj19IG9wdF9xdWVyeU9yRnV6emluZXNzIElmIHRoaXMgaXMgYSBzdHJpbmcsIGl0IHNob3VsZFxuXHQgKiAgIGJlIHRoZSBxdWVyeSwgb3RoZXJ3aXNlIGl0IHNob3VsZCBiZSB0aGUgZnV6emluZXNzIHZhbHVlLlxuXHQgKiBAcGFyYW0ge251bWJlcj19IG9wdF9mdXp6aW5lc3MgVGhlIGZ1enppbmVzcyB2YWx1ZS5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGZ1enp5KGZpZWxkT3JRdWVyeSwgb3B0X3F1ZXJ5T3JGdXp6aW5lc3MsIG9wdF9mdXp6aW5lc3MpIHtcblx0XHRyZXR1cm4gRmlsdGVyLmZ1enp5SW50ZXJuYWxfKCdmdXp6eScsIGZpZWxkT3JRdWVyeSwgb3B0X3F1ZXJ5T3JGdXp6aW5lc3MsIG9wdF9mdXp6aW5lc3MpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSB0aGF0IHVzZXMgdGhlIGdpdmVuIGZ1enp5IG9wZXJhdG9yLiBUaGlzXG5cdCAqIGlzIGFuIGludGVybmFsIGltcGxlbWVudGF0aW9uIHVzZWQgYnkgdGhlIGBGaWx0ZXIuZnV6enlgIG1ldGhvZC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhdG9yIFRoZSBmdXp6eSBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkT3JRdWVyeSBJZiBubyBzZWNvbmQgc3RyaW5nIGFyZ3VtZW50IGlzIGdpdmVuLCB0aGlzXG5cdCAqICAgc2hvdWxkIGJlIHRoZSBxdWVyeSBzdHJpbmcsIGluIHdoaWNoIGNhc2UgYWxsIGZpZWxkcyB3aWxsIGJlIG1hdGNoZWQuXG5cdCAqICAgT3RoZXJ3aXNlLCB0aGlzIHNob3VsZCBiZSB0aGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gbWF0Y2guXG5cdCAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcj19IG9wdF9xdWVyeU9yRnV6emluZXNzIElmIHRoaXMgaXMgYSBzdHJpbmcsIGl0IHNob3VsZFxuXHQgKiAgIGJlIHRoZSBxdWVyeSwgb3RoZXJ3aXNlIGl0IHNob3VsZCBiZSB0aGUgZnV6emluZXNzIHZhbHVlLlxuXHQgKiBAcGFyYW0ge251bWJlcj19IG9wdF9mdXp6aW5lc3MgVGhlIGZ1enppbmVzcyB2YWx1ZS5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgZnV6enlJbnRlcm5hbF8ob3BlcmF0b3IsIGZpZWxkT3JRdWVyeSwgb3B0X3F1ZXJ5T3JGdXp6aW5lc3MsIG9wdF9mdXp6aW5lc3MpIHtcblx0XHR2YXIgYXJnMklzU3RyaW5nID0gY29yZS5pc1N0cmluZyhvcHRfcXVlcnlPckZ1enppbmVzcyk7XG5cblx0XHR2YXIgdmFsdWUgPSB7XG5cdFx0XHRxdWVyeTogYXJnMklzU3RyaW5nID8gb3B0X3F1ZXJ5T3JGdXp6aW5lc3MgOiBmaWVsZE9yUXVlcnlcblx0XHR9O1xuXHRcdHZhciBmdXp6aW5lc3MgPSBhcmcySXNTdHJpbmcgPyBvcHRfZnV6emluZXNzIDogb3B0X3F1ZXJ5T3JGdXp6aW5lc3M7XG5cdFx0aWYgKGZ1enppbmVzcykge1xuXHRcdFx0dmFsdWUuZnV6emluZXNzID0gZnV6emluZXNzO1xuXHRcdH1cblxuXHRcdHZhciBmaWVsZCA9IGFyZzJJc1N0cmluZyA/IGZpZWxkT3JRdWVyeSA6IEZpbHRlci5BTEw7XG5cdFx0cmV0dXJuIEZpbHRlci5maWVsZChmaWVsZCwgb3BlcmF0b3IsIHZhbHVlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcIj5cIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIGZpbHRlcidzIHZhbHVlLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuICAgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgZ3QoZmllbGQsIHZhbHVlKSB7XG5cdFx0cmV0dXJuIG5ldyBGaWx0ZXIoZmllbGQsICc+JywgdmFsdWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSB0aGF0IHVzZXMgdGhlIFwiPj1cIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIGZpbHRlcidzIHZhbHVlLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuICAgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgZ3RlKGZpZWxkLCB2YWx1ZSkge1xuXHRcdHJldHVybiBuZXcgRmlsdGVyKGZpZWxkLCAnPj0nLCB2YWx1ZSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIHRoYXQgdXNlcyB0aGUgXCJtYXRjaFwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGRPclF1ZXJ5IElmIG5vIHNlY29uZCBzdHJpbmcgYXJndW1lbnQgaXMgZ2l2ZW4sIHRoaXNcblx0ICogICBzaG91bGQgYmUgdGhlIHF1ZXJ5IHN0cmluZywgaW4gd2hpY2ggY2FzZSBhbGwgZmllbGRzIHdpbGwgYmUgbWF0Y2hlZC5cblx0ICogICBPdGhlcndpc2UsIHRoaXMgc2hvdWxkIGJlIHRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBtYXRjaC5cblx0ICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfcXVlcnkgVGhlIHF1ZXJ5IHN0cmluZy5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIG1hdGNoKGZpZWxkT3JRdWVyeSwgb3B0X3F1ZXJ5KSB7XG5cdFx0dmFyIGZpZWxkID0gY29yZS5pc1N0cmluZyhvcHRfcXVlcnkpID8gZmllbGRPclF1ZXJ5IDogRmlsdGVyLkFMTDtcblx0XHR2YXIgcXVlcnkgPSBjb3JlLmlzU3RyaW5nKG9wdF9xdWVyeSkgPyBvcHRfcXVlcnkgOiBmaWVsZE9yUXVlcnk7XG5cdFx0cmV0dXJuIEZpbHRlci5maWVsZChmaWVsZCwgJ21hdGNoJywgcXVlcnkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSB0aGF0IHVzZXMgdGhlIFwibWlzc2luZ1wiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGZpZWxkJ3MgbmFtZS5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIG1pc3NpbmcoZmllbGQpIHtcblx0XHRyZXR1cm4gRmlsdGVyLmZpZWxkKGZpZWxkLCAnbWlzc2luZycsIG51bGwpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSB0aGF0IHVzZXMgdGhlIFwicGhyYXNlXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZE9yUXVlcnkgSWYgbm8gc2Vjb25kIHN0cmluZyBhcmd1bWVudCBpcyBnaXZlbiwgdGhpc1xuXHQgKiAgIHNob3VsZCBiZSB0aGUgcXVlcnkgc3RyaW5nLCBpbiB3aGljaCBjYXNlIGFsbCBmaWVsZHMgd2lsbCBiZSBtYXRjaGVkLlxuXHQgKiAgIE90aGVyd2lzZSwgdGhpcyBzaG91bGQgYmUgdGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIG1hdGNoLlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9xdWVyeSBUaGUgcXVlcnkgc3RyaW5nLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgcGhyYXNlKGZpZWxkT3JRdWVyeSwgb3B0X3F1ZXJ5KSB7XG5cdFx0dmFyIGZpZWxkID0gY29yZS5pc1N0cmluZyhvcHRfcXVlcnkpID8gZmllbGRPclF1ZXJ5IDogRmlsdGVyLkFMTDtcblx0XHR2YXIgcXVlcnkgPSBjb3JlLmlzU3RyaW5nKG9wdF9xdWVyeSkgPyBvcHRfcXVlcnkgOiBmaWVsZE9yUXVlcnk7XG5cdFx0cmV0dXJuIEZpbHRlci5maWVsZChmaWVsZCwgJ3BocmFzZScsIHF1ZXJ5KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcImdwXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgbmFtZSBvZiB0aGUgZmllbGQuXG5cdCAqIEBwYXJhbSB7Li4uIU9iamVjdH0gcG9pbnRzIE9iamVjdHMgcmVwcmVzZW50aW5nIHBvaW50cyBpbiB0aGUgcG9seWdvbi5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIHBvbHlnb24oZmllbGQsIC4uLnBvaW50cykge1xuXHRcdHBvaW50cyA9IHBvaW50cy5tYXAocG9pbnQgPT4gRW1ib2RpZWQudG9Cb2R5KHBvaW50KSk7XG5cdFx0cmV0dXJuIEZpbHRlci5maWVsZChmaWVsZCwgJ2dwJywgcG9pbnRzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcInByZWZpeFwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGRPclF1ZXJ5IElmIG5vIHNlY29uZCBhcmd1bWVudCBpcyBnaXZlbiwgdGhpcyBzaG91bGRcblx0ICogICBiZSB0aGUgcXVlcnkgc3RyaW5nLCBpbiB3aGljaCBjYXNlIGFsbCBmaWVsZHMgd2lsbCBiZSBtYXRjaGVkLiBPdGhlcndpc2UsXG5cdCAqICAgdGhpcyBzaG91bGQgYmUgdGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIG1hdGNoLlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9xdWVyeSBUaGUgcXVlcnkgc3RyaW5nLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgcHJlZml4KGZpZWxkT3JRdWVyeSwgb3B0X3F1ZXJ5KSB7XG5cdFx0dmFyIGZpZWxkID0gb3B0X3F1ZXJ5ID8gZmllbGRPclF1ZXJ5IDogRmlsdGVyLkFMTDtcblx0XHR2YXIgcXVlcnkgPSBvcHRfcXVlcnkgPyBvcHRfcXVlcnkgOiBmaWVsZE9yUXVlcnk7XG5cdFx0cmV0dXJuIEZpbHRlci5maWVsZChmaWVsZCwgJ3ByZWZpeCcsIHF1ZXJ5KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcInJhbmdlXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQncyBuYW1lLlxuXHQgKiBAcGFyYW0geyp9IHJhbmdlT3JNaW4gRWl0aGVyIGEgYFJhbmdlYCBpbnN0YW5jZSBvciBhIHRoZSByYW5nZSdzIG1pbiB2YWx1ZS5cblx0ICogQHBhcmFtIHsqPX0gb3B0X21heCBUaGUgcmFuZ2UncyBtYXggdmFsdWUuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyByYW5nZShmaWVsZCwgcmFuZ2VPck1pbiwgb3B0X21heCkge1xuXHRcdHZhciByYW5nZSA9IHJhbmdlT3JNaW47XG5cdFx0aWYgKCEocmFuZ2UgaW5zdGFuY2VvZiBSYW5nZSkpIHtcblx0XHRcdHJhbmdlID0gUmFuZ2UucmFuZ2UocmFuZ2VPck1pbiwgb3B0X21heCk7XG5cdFx0fVxuXHRcdHJldHVybiBGaWx0ZXIuZmllbGQoZmllbGQsICdyYW5nZScsIHJhbmdlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcIn5cIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIGZpbHRlcidzIHZhbHVlLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuICAgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgcmVnZXgoZmllbGQsIHZhbHVlKSB7XG5cdFx0cmV0dXJuIG5ldyBGaWx0ZXIoZmllbGQsICd+JywgdmFsdWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSB0aGF0IHVzZXMgdGhlIFwiZ3NcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBmaWVsZCdzIG5hbWUuXG5cdCAqIEBwYXJhbSB7Li4uIU9iamVjdH0gc2hhcGVzIE9iamVjdHMgcmVwcmVzZW50aW5nIHNoYXBlcy5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIHNoYXBlKGZpZWxkLCAuLi5zaGFwZXMpIHtcblx0XHRzaGFwZXMgPSBzaGFwZXMubWFwKHNoYXBlID0+IEVtYm9kaWVkLnRvQm9keShzaGFwZSkpO1xuXHRcdHZhciB2YWx1ZSA9IHtcblx0XHRcdHR5cGU6ICdnZW9tZXRyeWNvbGxlY3Rpb24nLFxuXHRcdFx0Z2VvbWV0cmllczogc2hhcGVzXG5cdFx0fTtcblx0XHRyZXR1cm4gRmlsdGVyLmZpZWxkKGZpZWxkLCAnZ3MnLCB2YWx1ZSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIHRoYXQgdXNlcyB0aGUgXCJzaW1pbGFyXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZE9yUXVlcnkgSWYgbm8gc2Vjb25kIHN0cmluZyBhcmd1bWVudCBpcyBnaXZlbiwgdGhpc1xuXHQgKiAgIHNob3VsZCBiZSB0aGUgcXVlcnkgc3RyaW5nLCBpbiB3aGljaCBjYXNlIGFsbCBmaWVsZHMgd2lsbCBiZSBtYXRjaGVkLlxuXHQgKiAgIE90aGVyd2lzZSwgdGhpcyBzaG91bGQgYmUgdGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIG1hdGNoLlxuXHQgKiBAcGFyYW0gez9zdHJpbmd9IHF1ZXJ5IFRoZSBxdWVyeSBzdHJpbmcuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBzaW1pbGFyKGZpZWxkT3JRdWVyeSwgcXVlcnkpIHtcblx0XHR2YXIgZmllbGQgPSBjb3JlLmlzU3RyaW5nKHF1ZXJ5KSA/IGZpZWxkT3JRdWVyeSA6IEZpbHRlci5BTEw7XG5cdFx0dmFyIHZhbHVlID0ge1xuXHRcdFx0cXVlcnk6IGNvcmUuaXNTdHJpbmcocXVlcnkpID8gcXVlcnkgOiBmaWVsZE9yUXVlcnlcblx0XHR9O1xuXHRcdHJldHVybiBGaWx0ZXIuZmllbGQoZmllbGQsICdzaW1pbGFyJywgdmFsdWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSB0aGF0IHVzZXMgdGhlIFwiPFwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIGZpbHRlciBieS5cblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgZmlsdGVyJ3MgdmFsdWUuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG4gICAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBsdChmaWVsZCwgdmFsdWUpIHtcblx0XHRyZXR1cm4gbmV3IEZpbHRlcihmaWVsZCwgJzwnLCB2YWx1ZSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIHRoYXQgdXNlcyB0aGUgXCI8PVwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIGZpbHRlciBieS5cblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgZmlsdGVyJ3MgdmFsdWUuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG4gICAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBsdGUoZmllbGQsIHZhbHVlKSB7XG5cdFx0cmV0dXJuIG5ldyBGaWx0ZXIoZmllbGQsICc8PScsIHZhbHVlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcIm5vbmVcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7IShBcnJheXwuLi4qKX0gdmFsdWUgQSB2YXJpYWJsZSBhbW91bnQgb2YgdmFsdWVzIHRvIGJlIHVzZWQgd2l0aFxuXHQgKiB0aGUgXCJub25lXCIgb3BlcmF0b3IuIENhbiBiZSBwYXNzZWQgZWl0aGVyIGFzIGEgc2luZ2xlIGFycmF5IG9yIGFzXG5cdCAqIHNlcGFyYXRlIHBhcmFtcy5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIG5vbmUoZmllbGQpIHtcblx0XHR2YXIgdmFsdWVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblx0XHRpZiAodmFsdWVzLmxlbmd0aCA9PT0gMSAmJiB2YWx1ZXNbMF0gaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdFx0dmFsdWVzID0gdmFsdWVzWzBdO1xuXHRcdH1cblx0XHRyZXR1cm4gbmV3IEZpbHRlcihmaWVsZCwgJ25vbmUnLCB2YWx1ZXMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSB0aGF0IHVzZXMgdGhlIFwiIT1cIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIGZpbHRlcidzIHZhbHVlLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgbm90RXF1YWwoZmllbGQsIHZhbHVlKSB7XG5cdFx0cmV0dXJuIG5ldyBGaWx0ZXIoZmllbGQsICchPScsIHZhbHVlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcIm5vdFwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0geyFGaWx0ZXJ8c3RyaW5nfSBmaWVsZE9yRmlsdGVyIEVpdGhlciBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIG9yXG5cdCAqIHRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF9vcGVyYXRvck9yVmFsdWUgRWl0aGVyIHRoZSBmaWVsZCdzIG9wZXJhdG9yIG9yIGl0cyB2YWx1ZS5cblx0ICogQHBhcmFtIHsqPX0gb3B0X3ZhbHVlIFRoZSBmaWx0ZXIncyB2YWx1ZS5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIG5vdChmaWVsZE9yRmlsdGVyLCBvcHRfb3BlcmF0b3JPclZhbHVlLCBvcHRfdmFsdWUpIHtcblx0XHRyZXR1cm4gRmlsdGVyLnRvRmlsdGVyKGZpZWxkT3JGaWx0ZXIsIG9wdF9vcGVyYXRvck9yVmFsdWUsIG9wdF92YWx1ZSkuYWRkKCdub3QnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gZmlsdGVyIGJ5LlxuXHQgKiBAcGFyYW0geyp9IG9wZXJhdG9yT3JWYWx1ZSBJZiBhIHRoaXJkIHBhcmFtIGlzIGdpdmVuLCB0aGlzIHNob3VsZCBiZSB0aGVcblx0ICogZmlsdGVyJ3Mgb3BlcmF0b3IgKGxpa2UgXCI+PVwiKS4gT3RoZXJ3aXNlLCB0aGlzIHdpbGwgYmUgdXNlZCBhcyB0aGVcblx0ICogZmlsdGVyJ3MgdmFsdWUsIGFuZCB0aGUgZmlsdGVyJ3Mgb3BlcmF0b3Igd2lsbCBiZSBcIj1cIi5cblx0ICogQHBhcmFtIHsqPX0gb3B0X3ZhbHVlIFRoZSBmaWx0ZXIncyB2YWx1ZS5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGZpZWxkKGZpZWxkLCBvcGVyYXRvck9yVmFsdWUsIG9wdF92YWx1ZSkge1xuXHRcdHJldHVybiBuZXcgRmlsdGVyKGZpZWxkLCBvcGVyYXRvck9yVmFsdWUsIG9wdF92YWx1ZSk7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIGZpbHRlciB0byBiZSBjb21wb3NlZCB3aXRoIHRoaXMgZmlsdGVyIHVzaW5nIHRoZSBcIm9yXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7IUZpbHRlcnxzdHJpbmd9IGZpZWxkT3JGaWx0ZXIgRWl0aGVyIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2Ugb3Jcblx0ICogdGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIGZpbHRlciBieS5cblx0ICogQHBhcmFtIHsqPX0gb3B0X29wZXJhdG9yT3JWYWx1ZSBFaXRoZXIgdGhlIGZpZWxkJ3Mgb3BlcmF0b3Igb3IgaXRzIHZhbHVlLlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfdmFsdWUgVGhlIGZpbHRlcidzIHZhbHVlLlxuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cblx0b3IoZmllbGRPckZpbHRlciwgb3B0X29wZXJhdG9yT3JWYWx1ZSwgb3B0X3ZhbHVlKSB7XG5cdFx0cmV0dXJuIHRoaXMuYWRkKCdvcicsIGZpZWxkT3JGaWx0ZXIsIG9wdF9vcGVyYXRvck9yVmFsdWUsIG9wdF92YWx1ZSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgdGhlIGdpdmVuIGFyZ3VtZW50cyBpbnRvIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7IUZpbHRlcnxzdHJpbmd9IGZpZWxkT3JGaWx0ZXIgRWl0aGVyIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2Ugb3Jcblx0ICogdGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIGZpbHRlciBieS5cblx0ICogQHBhcmFtIHsqPX0gb3B0X29wZXJhdG9yT3JWYWx1ZSBFaXRoZXIgdGhlIGZpZWxkJ3Mgb3BlcmF0b3Igb3IgaXRzIHZhbHVlLlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfdmFsdWUgVGhlIGZpbHRlcidzIHZhbHVlLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuXHQgKi9cblx0c3RhdGljIHRvRmlsdGVyKGZpZWxkT3JGaWx0ZXIsIG9wdF9vcGVyYXRvck9yVmFsdWUsIG9wdF92YWx1ZSkge1xuXHRcdHZhciBmaWx0ZXIgPSBmaWVsZE9yRmlsdGVyO1xuXHRcdGlmICghKGZpbHRlciBpbnN0YW5jZW9mIEZpbHRlcikpIHtcblx0XHRcdGZpbHRlciA9IEZpbHRlci5maWVsZChmaWVsZE9yRmlsdGVyLCBvcHRfb3BlcmF0b3JPclZhbHVlLCBvcHRfdmFsdWUpO1xuXHRcdH1cblx0XHRyZXR1cm4gZmlsdGVyO1xuXHR9XG59XG5cbi8qKlxuICogU3RyaW5nIGNvbnN0YW50IHRoYXQgcmVwcmVzZW50cyBhbGwgZmllbGRzLlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBzdGF0aWNcbiAqL1xuRmlsdGVyLkFMTCA9ICcqJztcblxuZXhwb3J0IGRlZmF1bHQgRmlsdGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFBhcnNlcyB0aGUgZ2l2ZW4gdXJpIHN0cmluZyBpbnRvIGFuIG9iamVjdC5cbiAqIEBwYXJhbSB7Kj19IG9wdF91cmkgT3B0aW9uYWwgc3RyaW5nIFVSSSB0byBwYXJzZVxuICovXG5mdW5jdGlvbiBwYXJzZUZyb21BbmNob3Iob3B0X3VyaSkge1xuXHR2YXIgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcblx0bGluay5ocmVmID0gb3B0X3VyaTtcblx0cmV0dXJuIHtcblx0XHRoYXNoOiBsaW5rLmhhc2gsXG5cdFx0aG9zdG5hbWU6IGxpbmsuaG9zdG5hbWUsXG5cdFx0cGFzc3dvcmQ6IGxpbmsucGFzc3dvcmQsXG5cdFx0cGF0aG5hbWU6IGxpbmsucGF0aG5hbWVbMF0gPT09ICcvJyA/IGxpbmsucGF0aG5hbWUgOiAnLycgKyBsaW5rLnBhdGhuYW1lLFxuXHRcdHBvcnQ6IGxpbmsucG9ydCxcblx0XHRwcm90b2NvbDogbGluay5wcm90b2NvbCxcblx0XHRzZWFyY2g6IGxpbmsuc2VhcmNoLFxuXHRcdHVzZXJuYW1lOiBsaW5rLnVzZXJuYW1lXG5cdH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IHBhcnNlRnJvbUFuY2hvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHsgY29yZSB9IGZyb20gJ21ldGFsJztcbmltcG9ydCBwYXJzZUZyb21BbmNob3IgZnJvbSAnLi9wYXJzZUZyb21BbmNob3InO1xuXG4vKipcbiAqIFBhcnNlcyB0aGUgZ2l2ZW4gdXJpIHN0cmluZyBpbnRvIGFuIG9iamVjdC4gVGhlIFVSTCBmdW5jdGlvbiB3aWxsIGJlIHVzZWRcbiAqIHdoZW4gcHJlc2VudCwgb3RoZXJ3aXNlIHdlJ2xsIGZhbGwgYmFjayB0byB0aGUgYW5jaG9yIG5vZGUgZWxlbWVudC5cbiAqIEBwYXJhbSB7Kj19IG9wdF91cmkgT3B0aW9uYWwgc3RyaW5nIFVSSSB0byBwYXJzZVxuICovXG5mdW5jdGlvbiBwYXJzZShvcHRfdXJpKSB7XG5cdGlmIChjb3JlLmlzRnVuY3Rpb24oVVJMKSAmJiBVUkwubGVuZ3RoKSB7XG5cdFx0cmV0dXJuIG5ldyBVUkwob3B0X3VyaSk7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIHBhcnNlRnJvbUFuY2hvcihvcHRfdXJpKTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBwYXJzZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHsgRGlzcG9zYWJsZSB9IGZyb20gJ21ldGFsJztcblxuLyoqXG4gKiBBIGNhY2hlZCByZWZlcmVuY2UgdG8gdGhlIGNyZWF0ZSBmdW5jdGlvbi5cbiAqL1xudmFyIGNyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG5cbi8qKlxuICogQ2FzZSBpbnNlbnNpdGl2ZSBzdHJpbmcgTXVsdGltYXAgaW1wbGVtZW50YXRpb24uIEFsbG93cyBtdWx0aXBsZSB2YWx1ZXMgZm9yXG4gKiB0aGUgc2FtZSBrZXkgbmFtZS5cbiAqIEBleHRlbmRzIHtEaXNwb3NhYmxlfVxuICovXG5jbGFzcyBNdWx0aU1hcCBleHRlbmRzIERpc3Bvc2FibGUge1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMua2V5cyA9IGNyZWF0ZShudWxsKTtcblx0XHR0aGlzLnZhbHVlcyA9IGNyZWF0ZShudWxsKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIHZhbHVlIHRvIGEga2V5IG5hbWUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWVcblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0YWRkKG5hbWUsIHZhbHVlKSB7XG5cdFx0dGhpcy5rZXlzW25hbWUudG9Mb3dlckNhc2UoKV0gPSBuYW1lO1xuXHRcdHRoaXMudmFsdWVzW25hbWUudG9Mb3dlckNhc2UoKV0gPSB0aGlzLnZhbHVlc1tuYW1lLnRvTG93ZXJDYXNlKCldIHx8IFtdO1xuXHRcdHRoaXMudmFsdWVzW25hbWUudG9Mb3dlckNhc2UoKV0ucHVzaCh2YWx1ZSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQ2xlYXJzIG1hcCBuYW1lcyBhbmQgdmFsdWVzLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRjbGVhcigpIHtcblx0XHR0aGlzLmtleXMgPSBjcmVhdGUobnVsbCk7XG5cdFx0dGhpcy52YWx1ZXMgPSBjcmVhdGUobnVsbCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIG1hcCBjb250YWlucyBhIHZhbHVlIHRvIHRoZSBrZXkgbmFtZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0Y29udGFpbnMobmFtZSkge1xuXHRcdHJldHVybiBuYW1lLnRvTG93ZXJDYXNlKCkgaW4gdGhpcy52YWx1ZXM7XG5cdH1cblxuXHQvKipcblx0ICogQGluaGVyaXREb2Ncblx0ICovXG5cdGRpc3Bvc2VJbnRlcm5hbCgpIHtcblx0XHR0aGlzLnZhbHVlcyA9IG51bGw7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIGBNdWx0aU1hcGAgaW5zdGFuY2UgZnJvbSB0aGUgZ2l2ZW4gb2JqZWN0LlxuXHQgKiBAcGFyYW0geyFPYmplY3R9IG9ialxuXHQgKiBAcmV0dXJuIHshTXVsdGlNYXB9XG5cdCAqL1xuXHRzdGF0aWMgZnJvbU9iamVjdChvYmopIHtcblx0XHR2YXIgbWFwID0gbmV3IE11bHRpTWFwKCk7XG5cdFx0dmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0bWFwLnNldChrZXlzW2ldLCBvYmpba2V5c1tpXV0pO1xuXHRcdH1cblx0XHRyZXR1cm4gbWFwO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGZpcnN0IGFkZGVkIHZhbHVlIGZyb20gYSBrZXkgbmFtZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcblx0ICogQHJldHVybiB7Kn1cblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0Z2V0KG5hbWUpIHtcblx0XHR2YXIgdmFsdWVzID0gdGhpcy52YWx1ZXNbbmFtZS50b0xvd2VyQ2FzZSgpXTtcblx0XHRpZiAodmFsdWVzKSB7XG5cdFx0XHRyZXR1cm4gdmFsdWVzWzBdO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIGFsbCB2YWx1ZXMgZnJvbSBhIGtleSBuYW1lLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuXHQgKiBAcmV0dXJuIHtBcnJheS48Kj59XG5cdCAqL1xuXHRnZXRBbGwobmFtZSkge1xuXHRcdHJldHVybiB0aGlzLnZhbHVlc1tuYW1lLnRvTG93ZXJDYXNlKCldO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgbWFwIGlzIGVtcHR5LCBmYWxzZSBvdGhlcndpc2UuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqL1xuXHRpc0VtcHR5KCkge1xuXHRcdHJldHVybiB0aGlzLnNpemUoKSA9PT0gMDtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIGFycmF5IG9mIGtleSBuYW1lcy5cblx0ICogQHJldHVybiB7QXJyYXkuPHN0cmluZz59XG5cdCAqL1xuXHRuYW1lcygpIHtcblx0XHRyZXR1cm4gT2JqZWN0LmtleXModGhpcy52YWx1ZXMpLm1hcCgoa2V5KSA9PiB0aGlzLmtleXNba2V5XSk7XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlcyBhbGwgdmFsdWVzIGZyb20gYSBrZXkgbmFtZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0cmVtb3ZlKG5hbWUpIHtcblx0XHRkZWxldGUgdGhpcy5rZXlzW25hbWUudG9Mb3dlckNhc2UoKV07XG5cdFx0ZGVsZXRlIHRoaXMudmFsdWVzW25hbWUudG9Mb3dlckNhc2UoKV07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgdmFsdWUgb2YgYSBrZXkgbmFtZS4gUmVsZXZhbnQgdG8gcmVwbGFjZSB0aGUgY3VycmVudCB2YWx1ZXMgd2l0aFxuXHQgKiBhIG5ldyBvbmUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWVcblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0c2V0KG5hbWUsIHZhbHVlKSB7XG5cdFx0dGhpcy5rZXlzW25hbWUudG9Mb3dlckNhc2UoKV0gPSBuYW1lO1xuXHRcdHRoaXMudmFsdWVzW25hbWUudG9Mb3dlckNhc2UoKV0gPSBbdmFsdWVdO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIHNpemUgb2YgdGhlIG1hcCBrZXkgbmFtZXMuXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG5cdHNpemUoKSB7XG5cdFx0cmV0dXJuIHRoaXMubmFtZXMoKS5sZW5ndGg7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgcGFyc2VkIHZhbHVlcyBhcyBhIHN0cmluZy5cblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMudmFsdWVzKTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBNdWx0aU1hcDtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHsgYXJyYXkgfSBmcm9tICdtZXRhbCc7XG5cbi8qKlxuICogR2VuZXJpYyB0cmVlIG5vZGUgZGF0YSBzdHJ1Y3R1cmUgd2l0aCBhcmJpdHJhcnkgbnVtYmVyIG9mIGNoaWxkIG5vZGVzLlxuICogQHBhcmFtIHtWfSB2YWx1ZSBWYWx1ZS5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBUcmVlTm9kZSB7XG5cblx0Y29uc3RydWN0b3IodmFsdWUpIHtcblx0XHQvKipcblx0XHQgKiBUaGUgdmFsdWUuXG5cdFx0ICogQHByaXZhdGUge1Z9XG5cdFx0ICovXG5cdFx0dGhpcy52YWx1ZV8gPSB2YWx1ZTtcblxuXHRcdC8qKlxuXHRcdCAqIFJlZmVyZW5jZSB0byB0aGUgcGFyZW50IG5vZGUgb3IgbnVsbCBpZiBpdCBoYXMgbm8gcGFyZW50LlxuXHRcdCAqIEBwcml2YXRlIHtUcmVlTm9kZX1cblx0XHQgKi9cblx0XHR0aGlzLnBhcmVudF8gPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQ2hpbGQgbm9kZXMgb3IgbnVsbCBpbiBjYXNlIG9mIGxlYWYgbm9kZS5cblx0XHQgKiBAcHJpdmF0ZSB7QXJyYXk8IVRyZWVOb2RlPn1cblx0XHQgKi9cblx0XHR0aGlzLmNoaWxkcmVuXyA9IG51bGw7XG5cdH1cblxuXHQvKipcblx0ICogQXBwZW5kcyBhIGNoaWxkIG5vZGUgdG8gdGhpcyBub2RlLlxuXHQgKiBAcGFyYW0geyFUcmVlTm9kZX0gY2hpbGQgT3JwaGFuIGNoaWxkIG5vZGUuXG5cdCAqL1xuXHRhZGRDaGlsZChjaGlsZCkge1xuXHRcdGFzc2VydENoaWxkSGFzTm9QYXJlbnQoY2hpbGQpO1xuXHRcdGNoaWxkLnNldFBhcmVudCh0aGlzKTtcblx0XHR0aGlzLmNoaWxkcmVuXyA9IHRoaXMuY2hpbGRyZW5fIHx8IFtdO1xuXHRcdHRoaXMuY2hpbGRyZW5fLnB1c2goY2hpbGQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRlbGxzIHdoZXRoZXIgdGhpcyBub2RlIGlzIHRoZSBhbmNlc3RvciBvZiB0aGUgZ2l2ZW4gbm9kZS5cblx0ICogQHBhcmFtIHshVHJlZU5vZGV9IG5vZGUgQSBub2RlLlxuXHQgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoaXMgbm9kZSBpcyB0aGUgYW5jZXN0b3Igb2Yge0Bjb2RlIG5vZGV9LlxuXHQgKi9cblx0Y29udGFpbnMobm9kZSkge1xuXHRcdGxldCBjdXJyZW50ID0gbm9kZS5nZXRQYXJlbnQoKTtcblx0XHR3aGlsZSAoY3VycmVudCkge1xuXHRcdFx0aWYgKGN1cnJlbnQgPT09IHRoaXMpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRjdXJyZW50ID0gY3VycmVudC5nZXRQYXJlbnQoKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm4geyFBcnJheTxUcmVlTm9kZT59IEFsbCBhbmNlc3RvciBub2RlcyBpbiBib3R0b20tdXAgb3JkZXIuXG5cdCAqL1xuXHRnZXRBbmNlc3RvcnMoKSB7XG5cdFx0bGV0IGFuY2VzdG9ycyA9IFtdO1xuXHRcdGxldCBub2RlID0gdGhpcy5nZXRQYXJlbnQoKTtcblx0XHR3aGlsZSAobm9kZSkge1xuXHRcdFx0YW5jZXN0b3JzLnB1c2gobm9kZSk7XG5cdFx0XHRub2RlID0gbm9kZS5nZXRQYXJlbnQoKTtcblx0XHR9XG5cdFx0cmV0dXJuIGFuY2VzdG9ycztcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBjaGlsZCBub2RlIG9mIHRoaXMgbm9kZSBhdCB0aGUgZ2l2ZW4gaW5kZXguXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBDaGlsZCBpbmRleC5cblx0ICogQHJldHVybiB7P1RyZWVOb2RlfSBUaGUgbm9kZSBhdCB0aGUgZ2l2ZW4gaW5kZXhcblx0ICogb3IgbnVsbCBpZiBub3QgZm91bmQuXG5cdCAqL1xuXHRnZXRDaGlsZEF0KGluZGV4KSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Q2hpbGRyZW4oKVtpbmRleF0gfHwgbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJuIHs/QXJyYXk8IVRyZWVOb2RlPn0gQ2hpbGQgbm9kZXMgb3IgbnVsbCBpbiBjYXNlIG9mIGxlYWYgbm9kZS5cblx0ICovXG5cdGdldENoaWxkcmVuKCkge1xuXHRcdHJldHVybiB0aGlzLmNoaWxkcmVuXyB8fCBUcmVlTm9kZS5FTVBUWV9BUlJBWTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4uXG5cdCAqL1xuXHRnZXRDaGlsZENvdW50KCkge1xuXHRcdHJldHVybiB0aGlzLmdldENoaWxkcmVuKCkubGVuZ3RoO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBhbmNlc3RvcnMgb2YgdGhlIG5vZGUuXG5cdCAqL1xuXHRnZXREZXB0aCgpIHtcblx0XHRsZXQgZGVwdGggPSAwO1xuXHRcdGxldCBub2RlID0gdGhpcztcblx0XHR3aGlsZSAobm9kZS5nZXRQYXJlbnQoKSkge1xuXHRcdFx0ZGVwdGgrKztcblx0XHRcdG5vZGUgPSBub2RlLmdldFBhcmVudCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gZGVwdGg7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybiB7P1RyZWVOb2RlfSBQYXJlbnQgbm9kZSBvciBudWxsIGlmIGl0IGhhcyBubyBwYXJlbnQuXG5cdCAqL1xuXHRnZXRQYXJlbnQoKSB7XG5cdFx0cmV0dXJuIHRoaXMucGFyZW50Xztcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJuIHshVHJlZU5vZGV9IFRoZSByb290IG9mIHRoZSB0cmVlIHN0cnVjdHVyZSwgaS5lLiB0aGUgZmFydGhlc3Rcblx0ICogYW5jZXN0b3Igb2YgdGhlIG5vZGUgb3IgdGhlIG5vZGUgaXRzZWxmIGlmIGl0IGhhcyBubyBwYXJlbnRzLlxuXHQgKi9cblx0Z2V0Um9vdCgpIHtcblx0XHRsZXQgcm9vdCA9IHRoaXM7XG5cdFx0d2hpbGUgKHJvb3QuZ2V0UGFyZW50KCkpIHtcblx0XHRcdHJvb3QgPSByb290LmdldFBhcmVudCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gcm9vdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSB2YWx1ZS5cblx0ICogQHJldHVybiB7Vn0gVGhlIHZhbHVlLlxuXHQgKi9cblx0Z2V0VmFsdWUoKSB7XG5cdFx0cmV0dXJuIHRoaXMudmFsdWVfO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIG5vZGUgaXMgYSBsZWFmIG5vZGUuXG5cdCAqL1xuXHRpc0xlYWYoKSB7XG5cdFx0cmV0dXJuICF0aGlzLmdldENoaWxkQ291bnQoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIHRoZSBnaXZlbiBjaGlsZCBub2RlIG9mIHRoaXMgbm9kZS5cblx0ICogQHBhcmFtIHtUcmVlTm9kZX0gY2hpbGQgVGhlIG5vZGUgdG8gcmVtb3ZlLlxuXHQgKiBAcmV0dXJuIHtUcmVlTm9kZX0gVGhlIHJlbW92ZWQgbm9kZSBpZiBhbnksIG51bGwgb3RoZXJ3aXNlLlxuXHQgKi9cblx0cmVtb3ZlQ2hpbGQoY2hpbGQpIHtcblx0XHRpZiAoYXJyYXkucmVtb3ZlKHRoaXMuZ2V0Q2hpbGRyZW4oKSwgY2hpbGQpKSB7XG5cdFx0XHRyZXR1cm4gY2hpbGQ7XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHBhcmVudCBub2RlIG9mIHRoaXMgbm9kZS4gVGhlIGNhbGxlcnMgbXVzdCBlbnN1cmUgdGhhdCB0aGVcblx0ICogcGFyZW50IG5vZGUgYW5kIG9ubHkgdGhhdCBoYXMgdGhpcyBub2RlIGFtb25nIGl0cyBjaGlsZHJlbi5cblx0ICogQHBhcmFtIHtUcmVlTm9kZX0gcGFyZW50IFRoZSBwYXJlbnQgdG8gc2V0LiBJZiBudWxsLCB0aGUgbm9kZSB3aWxsIGJlXG5cdCAqIGRldGFjaGVkIGZyb20gdGhlIHRyZWUuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHNldFBhcmVudChwYXJlbnQpIHtcblx0XHR0aGlzLnBhcmVudF8gPSBwYXJlbnQ7XG5cdH1cblxuXHQvKipcblx0ICogVHJhdmVyc2VzIHRoZSBzdWJ0cmVlLiBUaGUgZmlyc3QgY2FsbGJhY2sgc3RhcnRzIHdpdGggdGhpcyBub2RlLFxuXHQgKiBhbmQgdmlzaXRzIHRoZSBkZXNjZW5kYW50IG5vZGVzIGRlcHRoLWZpcnN0LCBpbiBwcmVvcmRlci5cblx0ICogVGhlIHNlY29uZCBjYWxsYmFjaywgc3RhcnRzIHdpdGggZGVlcGVzdCBjaGlsZCB0aGVuIHZpc2l0c1xuXHQgKiB0aGUgYW5jZXN0b3Igbm9kZXMgZGVwdGgtZmlyc3QsIGluIHBvc3RvcmRlci4gRS5nLlxuXHQgKlxuXHQgKiAgXHQgQVxuXHQgKiAgICAvIFxcXG5cdCAqICAgQiAgIENcblx0ICogIC8gICAvIFxcXG5cdCAqIEQgICBFICAgRlxuXHQgKlxuXHQgKiBwcmVvcmRlciAtPiBbJ0EnLCAnQicsICdEJywgJ0MnLCAnRScsICdGJ11cblx0ICogcG9zdG9yZGVyIC0+IFsnRCcsICdCJywgJ0UnLCAnRicsICdDJywgJ0EnXVxuXHQgKlxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9uPX0gb3B0X3ByZW9yZGVyRm4gVGhlIGNhbGxiYWNrIHRvIGV4ZWN1dGUgd2hlbiB2aXNpdGluZyBhIG5vZGUuXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb249fSBvcHRfcG9zdG9yZGVyRm4gVGhlIGNhbGxiYWNrIHRvIGV4ZWN1dGUgYmVmb3JlIGxlYXZpbmcgYSBub2RlLlxuXHQgKi9cblx0dHJhdmVyc2Uob3B0X3ByZW9yZGVyRm4sIG9wdF9wb3N0b3JkZXJGbikge1xuXHRcdGlmIChvcHRfcHJlb3JkZXJGbikge1xuXHRcdFx0b3B0X3ByZW9yZGVyRm4odGhpcyk7XG5cdFx0fVxuXHRcdHRoaXMuZ2V0Q2hpbGRyZW4oKS5mb3JFYWNoKChjaGlsZCkgPT4gY2hpbGQudHJhdmVyc2Uob3B0X3ByZW9yZGVyRm4sIG9wdF9wb3N0b3JkZXJGbikpO1xuXHRcdGlmIChvcHRfcG9zdG9yZGVyRm4pIHtcblx0XHRcdG9wdF9wb3N0b3JkZXJGbih0aGlzKTtcblx0XHR9XG5cdH1cblxufVxuXG4vKipcbiAqIENvbnN0YW50IGZvciBlbXB0eSBhcnJheSB0byBhdm9pZCB1bm5lY2Vzc2FyeSBhbGxvY2F0aW9ucy5cbiAqIEBwcml2YXRlXG4gKi9cblRyZWVOb2RlLkVNUFRZX0FSUkFZID0gW107XG5cbi8qKlxuICogQXNzZXJ0cyB0aGF0IGNoaWxkIGhhcyBubyBwYXJlbnQuXG4gKiBAcGFyYW0ge1RyZWVOb2RlfSBjaGlsZCBBIGNoaWxkLlxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgYXNzZXJ0Q2hpbGRIYXNOb1BhcmVudCA9IGZ1bmN0aW9uKGNoaWxkKSB7XG5cdGlmIChjaGlsZC5nZXRQYXJlbnQoKSkge1xuXHRcdHRocm93IG5ldyBFcnJvcignQ2Fubm90IGFkZCBjaGlsZCB3aXRoIHBhcmVudC4nKTtcblx0fVxufTtcblxuZXhwb3J0IGRlZmF1bHQgVHJlZU5vZGU7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7IGNvcmUsIHN0cmluZyB9IGZyb20gJ21ldGFsJztcbmltcG9ydCBwYXJzZSBmcm9tICcuL3BhcnNlJztcbmltcG9ydCB7IE11bHRpTWFwIH0gZnJvbSAnbWV0YWwtc3RydWN0cyc7XG5cbnZhciBwYXJzZUZuXyA9IHBhcnNlO1xuXG5jbGFzcyBVcmkge1xuXG5cdC8qKlxuXHQgKiBUaGlzIGNsYXNzIGNvbnRhaW5zIHNldHRlcnMgYW5kIGdldHRlcnMgZm9yIHRoZSBwYXJ0cyBvZiB0aGUgVVJJLlxuXHQgKiBUaGUgZm9sbG93aW5nIGZpZ3VyZSBkaXNwbGF5cyBhbiBleGFtcGxlIFVSSXMgYW5kIHRoZWlyIGNvbXBvbmVudCBwYXJ0cy5cblx0ICpcblx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aFxuXHQgKlx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIzilIDilIDilIDilLTilIDilIDilIDilIDilJBcblx0ICpcdCAgYWJjOi8vZXhhbXBsZS5jb206MTIzL3BhdGgvZGF0YT9rZXk9dmFsdWUjZnJhZ2lkMVxuXHQgKlx0ICDilJTilKzilJggICDilJTilIDilIDilIDilIDilKzilIDilIDilIDilIDilJgg4pSU4pSs4pSYICAgICAgICAgICDilJTilIDilIDilIDilKzilIDilIDilIDilJgg4pSU4pSA4pSA4pSs4pSA4pSA4pSYXG5cdCAqIHByb3RvY29sICBob3N0bmFtZSAgcG9ydCAgICAgICAgICAgIHNlYXJjaCAgICBoYXNoXG5cdCAqICAgICAgICAgIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUrOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmFxuXHQgKiAgICAgICAgICAgICAgICBob3N0XG5cdCAqXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF91cmkgT3B0aW9uYWwgc3RyaW5nIFVSSSB0byBwYXJzZVxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGNvbnN0cnVjdG9yKG9wdF91cmkgPSAnJykge1xuXHRcdHRoaXMudXJsID0gVXJpLnBhcnNlKHRoaXMubWF5YmVBZGRQcm90b2NvbEFuZEhvc3RuYW1lXyhvcHRfdXJpKSk7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBwYXJhbWV0ZXJzIHRvIHVyaSBmcm9tIGEgPGNvZGU+TXVsdGlNYXA8L2NvZGU+IGFzIHNvdXJjZS5cblx0ICogQHBhcmFtIHtNdWx0aU1hcH0gbXVsdGltYXAgVGhlIDxjb2RlPk11bHRpTWFwPC9jb2RlPiBjb250YWluaW5nIHRoZVxuXHQgKiAgIHBhcmFtZXRlcnMuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0YWRkUGFyYW1ldGVyc0Zyb21NdWx0aU1hcChtdWx0aW1hcCkge1xuXHRcdG11bHRpbWFwLm5hbWVzKCkuZm9yRWFjaCgobmFtZSkgPT4ge1xuXHRcdFx0bXVsdGltYXAuZ2V0QWxsKG5hbWUpLmZvckVhY2goKHZhbHVlKSA9PiB7XG5cdFx0XHRcdHRoaXMuYWRkUGFyYW1ldGVyVmFsdWUobmFtZSwgdmFsdWUpO1xuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyB0aGUgdmFsdWUgb2YgdGhlIG5hbWVkIHF1ZXJ5IHBhcmFtZXRlcnMuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHBhcmFtZXRlciB0byBzZXQuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIG5ldyB2YWx1ZS4gV2lsbCBiZSBleHBsaWNpdGx5IGNhc3RlZCB0byBTdHJpbmcuXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdGFkZFBhcmFtZXRlclZhbHVlKG5hbWUsIHZhbHVlKSB7XG5cdFx0dGhpcy5lbnN1cmVRdWVyeUluaXRpYWxpemVkXygpO1xuXHRcdGlmIChjb3JlLmlzRGVmKHZhbHVlKSkge1xuXHRcdFx0dmFsdWUgPSBTdHJpbmcodmFsdWUpO1xuXHRcdH1cblx0XHR0aGlzLnF1ZXJ5LmFkZChuYW1lLCB2YWx1ZSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyB0aGUgdmFsdWVzIG9mIHRoZSBuYW1lZCBxdWVyeSBwYXJhbWV0ZXIuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHBhcmFtZXRlciB0byBzZXQuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIG5ldyB2YWx1ZS5cblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0YWRkUGFyYW1ldGVyVmFsdWVzKG5hbWUsIHZhbHVlcykge1xuXHRcdHZhbHVlcy5mb3JFYWNoKCh2YWx1ZSkgPT4gdGhpcy5hZGRQYXJhbWV0ZXJWYWx1ZShuYW1lLCB2YWx1ZSkpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEVuc3VyZXMgcXVlcnkgaW50ZXJuYWwgbWFwIGlzIGluaXRpYWxpemVkIGFuZCBzeW5jZWQgd2l0aCBpbml0aWFsIHZhbHVlXG5cdCAqIGV4dHJhY3RlZCBmcm9tIFVSSSBzZWFyY2ggcGFydC5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0ZW5zdXJlUXVlcnlJbml0aWFsaXplZF8oKSB7XG5cdFx0aWYgKHRoaXMucXVlcnkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5xdWVyeSA9IG5ldyBNdWx0aU1hcCgpO1xuXHRcdHZhciBzZWFyY2ggPSB0aGlzLnVybC5zZWFyY2g7XG5cdFx0aWYgKHNlYXJjaCkge1xuXHRcdFx0c2VhcmNoLnN1YnN0cmluZygxKS5zcGxpdCgnJicpLmZvckVhY2goKHBhcmFtKSA9PiB7XG5cdFx0XHRcdHZhciBba2V5LCB2YWx1ZV0gPSBwYXJhbS5zcGxpdCgnPScpO1xuXHRcdFx0XHRpZiAoY29yZS5pc0RlZih2YWx1ZSkpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IFVyaS51cmxEZWNvZGUodmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuYWRkUGFyYW1ldGVyVmFsdWUoa2V5LCB2YWx1ZSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgaGFzaCBwYXJ0IG9mIHVyaS5cblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cblx0Z2V0SGFzaCgpIHtcblx0XHRyZXR1cm4gdGhpcy51cmwuaGFzaCB8fCAnJztcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBob3N0IHBhcnQgb2YgdXJpLiBFLmcuIDxjb2RlPltob3N0bmFtZV06W3BvcnRdPC9jb2RlPi5cblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cblx0Z2V0SG9zdCgpIHtcblx0XHR2YXIgaG9zdCA9IHRoaXMuZ2V0SG9zdG5hbWUoKTtcblx0XHRpZiAoaG9zdCkge1xuXHRcdFx0dmFyIHBvcnQgPSB0aGlzLmdldFBvcnQoKTtcblx0XHRcdGlmIChwb3J0ICYmIHBvcnQgIT09ICc4MCcpIHtcblx0XHRcdFx0aG9zdCArPSAnOicgKyBwb3J0O1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gaG9zdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBob3N0bmFtZSBwYXJ0IG9mIHVyaSB3aXRob3V0IHByb3RvY29sIGFuZCBwb3J0LlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuXHRnZXRIb3N0bmFtZSgpIHtcblx0XHR2YXIgaG9zdG5hbWUgPSB0aGlzLnVybC5ob3N0bmFtZTtcblx0XHRpZiAoaG9zdG5hbWUgPT09IFVyaS5IT1NUTkFNRV9QTEFDRUhPTERFUikge1xuXHRcdFx0cmV0dXJuICcnO1xuXHRcdH1cblx0XHRyZXR1cm4gaG9zdG5hbWU7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgb3JpZ2luIHBhcnQgb2YgdXJpLiBFLmcuIDxjb2RlPmh0dHA6Ly9baG9zdG5hbWVdOltwb3J0XTwvY29kZT4uXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdGdldE9yaWdpbigpIHtcblx0XHR2YXIgaG9zdCA9IHRoaXMuZ2V0SG9zdCgpO1xuXHRcdGlmIChob3N0KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRQcm90b2NvbCgpICsgJy8vJyArIGhvc3Q7XG5cdFx0fVxuXHRcdHJldHVybiAnJztcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBmaXJzdCB2YWx1ZSBmb3IgYSBnaXZlbiBwYXJhbWV0ZXIgb3IgdW5kZWZpbmVkIGlmIHRoZSBnaXZlblxuXHQgKiBwYXJhbWV0ZXIgbmFtZSBkb2VzIG5vdCBhcHBlYXIgaW4gdGhlIHF1ZXJ5IHN0cmluZy5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtTmFtZSBVbmVzY2FwZWQgcGFyYW1ldGVyIG5hbWUuXG5cdCAqIEByZXR1cm4ge3N0cmluZ3x1bmRlZmluZWR9IFRoZSBmaXJzdCB2YWx1ZSBmb3IgYSBnaXZlbiBwYXJhbWV0ZXIgb3Jcblx0ICogICB1bmRlZmluZWQgaWYgdGhlIGdpdmVuIHBhcmFtZXRlciBuYW1lIGRvZXMgbm90IGFwcGVhciBpbiB0aGUgcXVlcnlcblx0ICogICBzdHJpbmcuXG5cdCAqL1xuXHRnZXRQYXJhbWV0ZXJWYWx1ZShuYW1lKSB7XG5cdFx0dGhpcy5lbnN1cmVRdWVyeUluaXRpYWxpemVkXygpO1xuXHRcdHJldHVybiB0aGlzLnF1ZXJ5LmdldChuYW1lKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSB2YWx1ZTxiPnM8L2I+IGZvciBhIGdpdmVuIHBhcmFtZXRlciBhcyBhIGxpc3Qgb2YgZGVjb2RlZFxuXHQgKiBxdWVyeSBwYXJhbWV0ZXIgdmFsdWVzLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgcGFyYW1ldGVyIHRvIGdldCB2YWx1ZXMgZm9yLlxuXHQgKiBAcmV0dXJuIHshQXJyYXk8Pz59IFRoZSB2YWx1ZXMgZm9yIGEgZ2l2ZW4gcGFyYW1ldGVyIGFzIGEgbGlzdCBvZiBkZWNvZGVkXG5cdCAqICAgcXVlcnkgcGFyYW1ldGVyIHZhbHVlcy5cblx0ICovXG5cdGdldFBhcmFtZXRlclZhbHVlcyhuYW1lKSB7XG5cdFx0dGhpcy5lbnN1cmVRdWVyeUluaXRpYWxpemVkXygpO1xuXHRcdHJldHVybiB0aGlzLnF1ZXJ5LmdldEFsbChuYW1lKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBuYW1lPGI+czwvYj4gb2YgdGhlIHBhcmFtZXRlcnMuXG5cdCAqIEByZXR1cm4geyFBcnJheTxzdHJpbmc+fSBUaGUgbmFtZXMgZm9yIHRoZSBwYXJhbWV0ZXJzIGFzIGEgbGlzdCBvZlxuXHQgKiAgIHN0cmluZ3MuXG5cdCAqL1xuXHRnZXRQYXJhbWV0ZXJOYW1lcygpIHtcblx0XHR0aGlzLmVuc3VyZVF1ZXJ5SW5pdGlhbGl6ZWRfKCk7XG5cdFx0cmV0dXJuIHRoaXMucXVlcnkubmFtZXMoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBmdW5jdGlvbiBjdXJyZW50bHkgYmVpbmcgdXNlZCB0byBwYXJzZSBVUklzLlxuXHQgKiBAcmV0dXJuIHshZnVuY3Rpb24oKX1cblx0ICovXG5cdHN0YXRpYyBnZXRQYXJzZUZuKCkge1xuXHRcdHJldHVybiBwYXJzZUZuXztcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBwYXRobmFtZSBwYXJ0IG9mIHVyaS5cblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cblx0Z2V0UGF0aG5hbWUoKSB7XG5cdFx0cmV0dXJuIHRoaXMudXJsLnBhdGhuYW1lO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIHBvcnQgbnVtYmVyIHBhcnQgb2YgdXJpIGFzIHN0cmluZy5cblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cblx0Z2V0UG9ydCgpIHtcblx0XHRyZXR1cm4gdGhpcy51cmwucG9ydDtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBwcm90b2NvbCBwYXJ0IG9mIHVyaS4gRS5nLiA8Y29kZT5odHRwOjwvY29kZT4uXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdGdldFByb3RvY29sKCkge1xuXHRcdHJldHVybiB0aGlzLnVybC5wcm90b2NvbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBzZWFyY2ggcGFydCBvZiB1cmkuIFNlYXJjaCB2YWx1ZSBpcyByZXRyaWV2ZWQgZnJvbSBxdWVyeVxuXHQgKiBwYXJhbWV0ZXJzLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuXHRnZXRTZWFyY2goKSB7XG5cdFx0dmFyIHNlYXJjaCA9ICcnO1xuXHRcdHZhciBxdWVyeXN0cmluZyA9ICcnO1xuXHRcdHRoaXMuZ2V0UGFyYW1ldGVyTmFtZXMoKS5mb3JFYWNoKChuYW1lKSA9PiB7XG5cdFx0XHR0aGlzLmdldFBhcmFtZXRlclZhbHVlcyhuYW1lKS5mb3JFYWNoKCh2YWx1ZSkgPT4ge1xuXHRcdFx0XHRxdWVyeXN0cmluZyArPSBuYW1lO1xuXHRcdFx0XHRpZiAoY29yZS5pc0RlZih2YWx1ZSkpIHtcblx0XHRcdFx0XHRxdWVyeXN0cmluZyArPSAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHF1ZXJ5c3RyaW5nICs9ICcmJztcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHRcdHF1ZXJ5c3RyaW5nID0gcXVlcnlzdHJpbmcuc2xpY2UoMCwgLTEpO1xuXHRcdGlmIChxdWVyeXN0cmluZykge1xuXHRcdFx0c2VhcmNoICs9ICc/JyArIHF1ZXJ5c3RyaW5nO1xuXHRcdH1cblx0XHRyZXR1cm4gc2VhcmNoO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiB1cmkgY29udGFpbnMgdGhlIHBhcmFtZXRlci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICovXG5cdGhhc1BhcmFtZXRlcihuYW1lKSB7XG5cdFx0dGhpcy5lbnN1cmVRdWVyeUluaXRpYWxpemVkXygpO1xuXHRcdHJldHVybiB0aGlzLnF1ZXJ5LmNvbnRhaW5zKG5hbWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIE1ha2VzIHRoaXMgVVJMIHVuaXF1ZSBieSBhZGRpbmcgYSByYW5kb20gcGFyYW0gdG8gaXQuIFVzZWZ1bCBmb3IgYXZvaWRpbmdcblx0ICogY2FjaGUuXG5cdCAqL1xuXHRtYWtlVW5pcXVlKCkge1xuXHRcdHRoaXMuc2V0UGFyYW1ldGVyVmFsdWUoVXJpLlJBTkRPTV9QQVJBTSwgc3RyaW5nLmdldFJhbmRvbVN0cmluZygpKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBNYXliZSBhZGRzIHByb3RvY29sIGFuZCBhIGhvc3RuYW1lIHBsYWNlaG9sZGVyIG9uIGEgcGFyaWFsIFVSSSBpZiBuZWVkZWQuXG5cdCAqIFJlbGV2ZW50IGZvciBjb21wYXRpYmlsaXR5IHdpdGggPGNvZGU+VVJMPC9jb2RlPiBuYXRpdmUgb2JqZWN0LlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF91cmlcblx0ICogQHJldHVybiB7c3RyaW5nfSBVUkkgd2l0aCBwcm90b2NvbCBhbmQgaG9zdG5hbWUgcGxhY2Vob2xkZXIuXG5cdCAqL1xuXHRtYXliZUFkZFByb3RvY29sQW5kSG9zdG5hbWVfKG9wdF91cmkpIHtcblx0XHR2YXIgdXJsID0gb3B0X3VyaTtcblx0XHRpZiAob3B0X3VyaS5pbmRleE9mKCc6Ly8nKSA9PT0gLTEgJiZcblx0XHRcdG9wdF91cmkuaW5kZXhPZignamF2YXNjcmlwdDonKSAhPT0gMCkgeyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcblxuXHRcdFx0dXJsID0gVXJpLkRFRkFVTFRfUFJPVE9DT0w7XG5cdFx0XHRpZiAob3B0X3VyaVswXSAhPT0gJy8nIHx8IG9wdF91cmlbMV0gIT09ICcvJykge1xuXHRcdFx0XHR1cmwgKz0gJy8vJztcblx0XHRcdH1cblxuXHRcdFx0c3dpdGNoIChvcHRfdXJpLmNoYXJBdCgwKSkge1xuXHRcdFx0XHRjYXNlICcuJzpcblx0XHRcdFx0Y2FzZSAnPyc6XG5cdFx0XHRcdGNhc2UgJyMnOlxuXHRcdFx0XHRcdHVybCArPSBVcmkuSE9TVE5BTUVfUExBQ0VIT0xERVI7XG5cdFx0XHRcdFx0dXJsICs9ICcvJztcblx0XHRcdFx0XHR1cmwgKz0gb3B0X3VyaTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnJzpcblx0XHRcdFx0Y2FzZSAnLyc6XG5cdFx0XHRcdFx0aWYgKG9wdF91cmlbMV0gIT09ICcvJykge1xuXHRcdFx0XHRcdFx0dXJsICs9IFVyaS5IT1NUTkFNRV9QTEFDRUhPTERFUjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dXJsICs9IG9wdF91cmk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0dXJsICs9IG9wdF91cmk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB1cmw7XG5cdH1cblxuXHQvKipcblx0ICogTm9ybWFsaXplcyB0aGUgcGFyc2VkIG9iamVjdCB0byBiZSBpbiB0aGUgZXhwZWN0ZWQgc3RhbmRhcmQuXG5cdCAqIEBwYXJhbSB7IU9iamVjdH1cblx0ICovXG5cdHN0YXRpYyBub3JtYWxpemVPYmplY3QocGFyc2VkKSB7XG5cdFx0dmFyIGxlbmd0aCA9IHBhcnNlZC5wYXRobmFtZSA/IHBhcnNlZC5wYXRobmFtZS5sZW5ndGggOiAwO1xuXHRcdGlmIChsZW5ndGggPiAxICYmIHBhcnNlZC5wYXRobmFtZVtsZW5ndGggLSAxXSA9PT0gJy8nKSB7XG5cdFx0XHRwYXJzZWQucGF0aG5hbWUgPSBwYXJzZWQucGF0aG5hbWUuc3Vic3RyKDAsIGxlbmd0aCAtIDEpO1xuXHRcdH1cblx0XHRyZXR1cm4gcGFyc2VkO1xuXHR9XG5cblx0LyoqXG5cdCAqIFBhcnNlcyB0aGUgZ2l2ZW4gdXJpIHN0cmluZyBpbnRvIGFuIG9iamVjdC5cblx0ICogQHBhcmFtIHsqPX0gb3B0X3VyaSBPcHRpb25hbCBzdHJpbmcgVVJJIHRvIHBhcnNlXG5cdCAqL1xuXHRzdGF0aWMgcGFyc2Uob3B0X3VyaSkge1xuXHRcdHJldHVybiBVcmkubm9ybWFsaXplT2JqZWN0KHBhcnNlRm5fKG9wdF91cmkpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIHRoZSBuYW1lZCBxdWVyeSBwYXJhbWV0ZXIuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBwYXJhbWV0ZXIgdG8gcmVtb3ZlLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRyZW1vdmVQYXJhbWV0ZXIobmFtZSkge1xuXHRcdHRoaXMuZW5zdXJlUXVlcnlJbml0aWFsaXplZF8oKTtcblx0XHR0aGlzLnF1ZXJ5LnJlbW92ZShuYW1lKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIHVuaXF1ZW5lc3MgcGFyYW1ldGVyIG9mIHRoZSB1cmkuXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdHJlbW92ZVVuaXF1ZSgpIHtcblx0XHR0aGlzLnJlbW92ZVBhcmFtZXRlcihVcmkuUkFORE9NX1BBUkFNKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBoYXNoLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaGFzaFxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRzZXRIYXNoKGhhc2gpIHtcblx0XHR0aGlzLnVybC5oYXNoID0gaGFzaDtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBob3N0bmFtZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGhvc3RuYW1lXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdHNldEhvc3RuYW1lKGhvc3RuYW1lKSB7XG5cdFx0dGhpcy51cmwuaG9zdG5hbWUgPSBob3N0bmFtZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSB2YWx1ZSBvZiB0aGUgbmFtZWQgcXVlcnkgcGFyYW1ldGVycywgY2xlYXJpbmcgcHJldmlvdXMgdmFsdWVzXG5cdCAqIGZvciB0aGF0IGtleS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcGFyYW1ldGVyIHRvIHNldC5cblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgbmV3IHZhbHVlLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRzZXRQYXJhbWV0ZXJWYWx1ZShuYW1lLCB2YWx1ZSkge1xuXHRcdHRoaXMucmVtb3ZlUGFyYW1ldGVyKG5hbWUpO1xuXHRcdHRoaXMuYWRkUGFyYW1ldGVyVmFsdWUobmFtZSwgdmFsdWUpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHZhbHVlcyBvZiB0aGUgbmFtZWQgcXVlcnkgcGFyYW1ldGVycywgY2xlYXJpbmcgcHJldmlvdXMgdmFsdWVzXG5cdCAqIGZvciB0aGF0IGtleS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcGFyYW1ldGVyIHRvIHNldC5cblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgbmV3IHZhbHVlLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRzZXRQYXJhbWV0ZXJWYWx1ZXMobmFtZSwgdmFsdWVzKSB7XG5cdFx0dGhpcy5yZW1vdmVQYXJhbWV0ZXIobmFtZSk7XG5cdFx0dmFsdWVzLmZvckVhY2goKHZhbHVlKSA9PiB0aGlzLmFkZFBhcmFtZXRlclZhbHVlKG5hbWUsIHZhbHVlKSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgcGF0aG5hbWUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBwYXRobmFtZVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRzZXRQYXRobmFtZShwYXRobmFtZSkge1xuXHRcdHRoaXMudXJsLnBhdGhuYW1lID0gcGF0aG5hbWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgcG9ydCBudW1iZXIuXG5cdCAqIEBwYXJhbSB7Kn0gcG9ydCBQb3J0IG51bWJlci5cblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0c2V0UG9ydChwb3J0KSB7XG5cdFx0dGhpcy51cmwucG9ydCA9IHBvcnQ7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIHVzZWQgZm9yIHBhcnNpbmcgdGhlIG9yaWdpbmFsIHN0cmluZyB1cmlcblx0ICogaW50byBhbiBvYmplY3QuXG5cdCAqIEBwYXJhbSB7IWZ1bmN0aW9uKCl9IHBhcnNlRm5cblx0ICovXG5cdHN0YXRpYyBzZXRQYXJzZUZuKHBhcnNlRm4pIHtcblx0XHRwYXJzZUZuXyA9IHBhcnNlRm47XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgcHJvdG9jb2wuIElmIG1pc3NpbmcgPGNvZGU+aHR0cDo8L2NvZGU+IGlzIHVzZWQgYXMgZGVmYXVsdC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHByb3RvY29sXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdHNldFByb3RvY29sKHByb3RvY29sKSB7XG5cdFx0dGhpcy51cmwucHJvdG9jb2wgPSBwcm90b2NvbDtcblx0XHRpZiAodGhpcy51cmwucHJvdG9jb2xbdGhpcy51cmwucHJvdG9jb2wubGVuZ3RoIC0gMV0gIT09ICc6Jykge1xuXHRcdFx0dGhpcy51cmwucHJvdG9jb2wgKz0gJzonO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBzdHJpbmcgZm9ybSBvZiB0aGUgdXJsLlxuXHQgKiBAb3ZlcnJpZGVcblx0ICovXG5cdHRvU3RyaW5nKCkge1xuXHRcdHZhciBocmVmID0gJyc7XG5cdFx0dmFyIGhvc3QgPSB0aGlzLmdldEhvc3QoKTtcblx0XHRpZiAoaG9zdCkge1xuXHRcdFx0aHJlZiArPSB0aGlzLmdldFByb3RvY29sKCkgKyAnLy8nO1xuXHRcdH1cblx0XHRocmVmICs9IGhvc3QgKyB0aGlzLmdldFBhdGhuYW1lKCkgKyB0aGlzLmdldFNlYXJjaCgpICsgdGhpcy5nZXRIYXNoKCk7XG5cdFx0cmV0dXJuIGhyZWY7XG5cdH1cblxuXHQvKipcblx0ICogSm9pbnMgdGhlIGdpdmVuIHBhdGhzLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gYmFzZVBhdGhcblx0ICogQHBhcmFtIHsuLi5zdHJpbmd9IC4uLnBhdGhzIEFueSBudW1iZXIgb2YgcGF0aHMgdG8gYmUgam9pbmVkIHdpdGggdGhlIGJhc2UgdXJsLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgam9pblBhdGhzKGJhc2VQYXRoLCAuLi5wYXRocykge1xuXHRcdGlmIChiYXNlUGF0aC5jaGFyQXQoYmFzZVBhdGgubGVuZ3RoIC0gMSkgPT09ICcvJykge1xuXHRcdFx0YmFzZVBhdGggPSBiYXNlUGF0aC5zdWJzdHJpbmcoMCwgYmFzZVBhdGgubGVuZ3RoIC0gMSk7XG5cdFx0fVxuXHRcdHBhdGhzID0gcGF0aHMubWFwKHBhdGggPT4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJyA/IHBhdGguc3Vic3RyaW5nKDEpIDogcGF0aCk7XG5cdFx0cmV0dXJuIFtiYXNlUGF0aF0uY29uY2F0KHBhdGhzKS5qb2luKCcvJykucmVwbGFjZSgvXFwvJC8sICcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBVUkwtZGVjb2RlcyB0aGUgc3RyaW5nLiBXZSBuZWVkIHRvIHNwZWNpYWxseSBoYW5kbGUgJysncyBiZWNhdXNlXG5cdCAqIHRoZSBqYXZhc2NyaXB0IGxpYnJhcnkgZG9lc24ndCBjb252ZXJ0IHRoZW0gdG8gc3BhY2VzLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gdXJsIGRlY29kZS5cblx0ICogQHJldHVybiB7c3RyaW5nfSBUaGUgZGVjb2RlZCB7QGNvZGUgc3RyfS5cblx0ICovXG5cdHN0YXRpYyB1cmxEZWNvZGUoc3RyKSB7XG5cdFx0cmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzdHIucmVwbGFjZSgvXFwrL2csICcgJykpO1xuXHR9XG5cbn1cblxuLyoqXG4gKiBEZWZhdWx0IHByb3RvY29sIHZhbHVlLlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBkZWZhdWx0IGh0dHA6XG4gKiBAc3RhdGljXG4gKi9cblVyaS5ERUZBVUxUX1BST1RPQ09MID0gJ2h0dHA6JztcblxuLyoqXG4gKiBIb3N0bmFtZSBwbGFjZWhvbGRlci4gUmVsZXZhbnQgdG8gaW50ZXJuYWwgdXNhZ2Ugb25seS5cbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAc3RhdGljXG4gKi9cblVyaS5IT1NUTkFNRV9QTEFDRUhPTERFUiA9ICdob3N0bmFtZScgKyBEYXRlLm5vdygpO1xuXG4vKipcbiAqIE5hbWUgdXNlZCBieSB0aGUgcGFyYW0gZ2VuZXJhdGVkIGJ5IGBtYWtlVW5pcXVlYC5cbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAc3RhdGljXG4gKi9cblVyaS5SQU5ET01fUEFSQU0gPSAnengnO1xuXG5leHBvcnQgZGVmYXVsdCBVcmk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7IGNvcmUgfSBmcm9tICdtZXRhbCc7XG5pbXBvcnQgZ2xvYmFscyBmcm9tICcuLi9nbG9iYWxzL2dsb2JhbHMnO1xuaW1wb3J0IFVyaSBmcm9tICdtZXRhbC11cmknO1xuXG5mdW5jdGlvbiBhc3NlcnRCcm93c2VyRW52aXJvbm1lbnQoKSB7XG5cdGlmICghZ2xvYmFscy53aW5kb3cpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ1NpZ24taW4gdHlwZSBub3Qgc3VwcG9ydGVkIGluIHRoaXMgZW52aXJvbm1lbnQnKTtcblx0fVxufVxuXG5mdW5jdGlvbiBhc3NlcnREZWZBbmROb3ROdWxsKHZhbHVlLCBlcnJvck1lc3NhZ2UpIHtcblx0aWYgKCFjb3JlLmlzRGVmQW5kTm90TnVsbCh2YWx1ZSkpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcblx0fVxufVxuXG5mdW5jdGlvbiBhc3NlcnROb3ROdWxsKHZhbHVlLCBlcnJvck1lc3NhZ2UpIHtcblx0aWYgKGNvcmUuaXNOdWxsKHZhbHVlKSkge1xuXHRcdHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGFzc2VydEZ1bmN0aW9uKHZhbHVlLCBlcnJvck1lc3NhZ2UpIHtcblx0aWYgKCFjb3JlLmlzRnVuY3Rpb24odmFsdWUpKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0T2JqZWN0KHZhbHVlLCBlcnJvck1lc3NhZ2UpIHtcblx0aWYgKCFjb3JlLmlzT2JqZWN0KHZhbHVlKSkge1xuXHRcdHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFJlc3BvbnNlU3VjY2VlZGVkKHJlc3BvbnNlKSB7XG5cdGlmICghcmVzcG9uc2Uuc3VjY2VlZGVkKCkpIHtcblx0XHR0aHJvdyByZXNwb25zZS5ib2R5KCk7XG5cdH1cblx0cmV0dXJuIHJlc3BvbnNlO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRVc2VyU2lnbmVkSW4odXNlcikge1xuXHRpZiAoIWNvcmUuaXNEZWZBbmROb3ROdWxsKHVzZXIpKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBiZSBzaWduZWQtaW4gdG8gcGVyZm9ybSB0aGlzIG9wZXJhdGlvbicpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFVyaVdpdGhOb1BhdGgodXJsLCBtZXNzYWdlKSB7XG5cdHZhciB1cmkgPSBuZXcgVXJpKHVybCk7XG5cdGlmICh1cmkuZ2V0UGF0aG5hbWUoKS5sZW5ndGggPiAxKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuXHR9XG59XG5cbmV4cG9ydCB7IGFzc2VydEJyb3dzZXJFbnZpcm9ubWVudCwgYXNzZXJ0RGVmQW5kTm90TnVsbCwgYXNzZXJ0Tm90TnVsbCwgYXNzZXJ0RnVuY3Rpb24sIGFzc2VydE9iamVjdCwgYXNzZXJ0UmVzcG9uc2VTdWNjZWVkZWQsIGFzc2VydFVzZXJTaWduZWRJbiwgYXNzZXJ0VXJpV2l0aE5vUGF0aCB9O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgeyBjb3JlIH0gZnJvbSAnbWV0YWwnO1xuXG5pbXBvcnQgeyBhc3NlcnREZWZBbmROb3ROdWxsLCBhc3NlcnRPYmplY3QsIGFzc2VydFJlc3BvbnNlU3VjY2VlZGVkIH0gZnJvbSAnLi4vYXNzZXJ0aW9ucyc7XG5cbi8qKlxuICogQ2xhc3MgcmVzcG9uc2libGUgZm9yIHN0b3JpbmcgYXV0aG9yaXphdGlvbiBpbmZvcm1hdGlvbi5cbiAqL1xuY2xhc3MgQXV0aCB7XG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGFuIHtAbGluayBBdXRofSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHRva2VuT3JFbWFpbCBFaXRoZXIgdGhlIGF1dGhvcml6YXRpb24gdG9rZW4sIG9yXG5cdCAqICAgdGhlIHVzZXJuYW1lLlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9wYXNzd29yZCBJZiBhIHVzZXJuYW1lIGlzIGdpdmVuIGFzIHRoZSBmaXJzdCBwYXJhbSxcblx0ICogICB0aGlzIHNob3VsZCBiZSB0aGUgcGFzc3dvcmQuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0Y29uc3RydWN0b3IodG9rZW5PckVtYWlsLCBvcHRfcGFzc3dvcmQgPSBudWxsKSB7XG5cdFx0dGhpcy50b2tlbiA9IGNvcmUuaXNTdHJpbmcob3B0X3Bhc3N3b3JkKSA/IG51bGwgOiB0b2tlbk9yRW1haWw7XG5cdFx0dGhpcy5lbWFpbCA9IGNvcmUuaXNTdHJpbmcob3B0X3Bhc3N3b3JkKSA/IHRva2VuT3JFbWFpbCA6IG51bGw7XG5cdFx0dGhpcy5wYXNzd29yZCA9IG9wdF9wYXNzd29yZDtcblxuXHRcdHRoaXMuY3JlYXRlZEF0ID0gbnVsbDtcblx0XHR0aGlzLmlkID0gbnVsbDtcblx0XHR0aGlzLm5hbWUgPSBudWxsO1xuXHRcdHRoaXMucGhvdG9VcmwgPSBudWxsO1xuXHRcdHRoaXMud2VkZXBsb3lDbGllbnQgPSBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYW4ge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW5PclVzZXJuYW1lIEVpdGhlciB0aGUgYXV0aG9yaXphdGlvbiB0b2tlbiwgb3Jcblx0ICogICB0aGUgdXNlcm5hbWUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X3Bhc3N3b3JkIElmIGEgdXNlcm5hbWUgaXMgZ2l2ZW4gYXMgdGhlIGZpcnN0IHBhcmFtLFxuXHQgKiAgIHRoaXMgc2hvdWxkIGJlIHRoZSBwYXNzd29yZC5cblx0ICogQHJldHVybiB7IUF1dGh9XG5cdCAqL1xuXHRzdGF0aWMgY3JlYXRlKHRva2VuT3JVc2VybmFtZSwgb3B0X3Bhc3N3b3JkKSB7XG5cdFx0cmV0dXJuIG5ldyBBdXRoKHRva2VuT3JVc2VybmFtZSwgb3B0X3Bhc3N3b3JkKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBjcmVhdGVkIGF0IGRhdGUuXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdGdldENyZWF0ZWRBdCgpIHtcblx0XHRyZXR1cm4gdGhpcy5jcmVhdGVkQXQ7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgZW1haWwuXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdGdldEVtYWlsKCkge1xuXHRcdHJldHVybiB0aGlzLmVtYWlsO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGlkLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuXHRnZXRJZCgpIHtcblx0XHRyZXR1cm4gdGhpcy5pZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBuYW1lLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuXHRnZXROYW1lKCkge1xuXHRcdHJldHVybiB0aGlzLm5hbWU7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgcGFzc3dvcmQuXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdGdldFBhc3N3b3JkKCkge1xuXHRcdHJldHVybiB0aGlzLnBhc3N3b3JkO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIHBob3RvIHVybC5cblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cblx0Z2V0UGhvdG9VcmwoKSB7XG5cdFx0cmV0dXJuIHRoaXMucGhvdG9Vcmw7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgdG9rZW4uXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdGdldFRva2VuKCkge1xuXHRcdHJldHVybiB0aGlzLnRva2VuO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiBjcmVhdGVkIGF0IGlzIHNldC5cblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICovXG5cdGhhc0NyZWF0ZWRBdCgpIHtcblx0XHRyZXR1cm4gY29yZS5pc0RlZkFuZE5vdE51bGwodGhpcy5jcmVhdGVkQXQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiB0aGUgZW1haWwgaXMgc2V0LlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cblx0aGFzRW1haWwoKSB7XG5cdFx0cmV0dXJuIGNvcmUuaXNEZWZBbmROb3ROdWxsKHRoaXMuZW1haWwpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiB0aGUgaWQgaXMgc2V0LlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cblx0aGFzSWQoKSB7XG5cdFx0cmV0dXJuIGNvcmUuaXNEZWZBbmROb3ROdWxsKHRoaXMuaWQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiB0aGUgbmFtZSBpcyBzZXQuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqL1xuXHRoYXNOYW1lKCkge1xuXHRcdHJldHVybiBjb3JlLmlzRGVmQW5kTm90TnVsbCh0aGlzLm5hbWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiB0aGUgcGFzc3dvcmQgaXMgc2V0LlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cblx0aGFzUGFzc3dvcmQoKSB7XG5cdFx0cmV0dXJuIGNvcmUuaXNEZWZBbmROb3ROdWxsKHRoaXMucGFzc3dvcmQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiB0aGUgcGhvdG8gdXJsIGlzIHNldC5cblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICovXG5cdGhhc1Bob3RvVXJsKCkge1xuXHRcdHJldHVybiBjb3JlLmlzRGVmQW5kTm90TnVsbCh0aGlzLnBob3RvVXJsKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgdGhlIHRva2VuIGlzIHNldC5cblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICovXG5cdGhhc1Rva2VuKCkge1xuXHRcdHJldHVybiBjb3JlLmlzRGVmQW5kTm90TnVsbCh0aGlzLnRva2VuKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIGNyZWF0ZWQgYXQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBjcmVhdGVkQXRcblx0ICovXG5cdHNldENyZWF0ZWRBdChjcmVhdGVkQXQpIHtcblx0XHR0aGlzLmNyZWF0ZWRBdCA9IGNyZWF0ZWRBdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBlbWFpbC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGVtYWlsXG5cdCAqL1xuXHRzZXRFbWFpbChlbWFpbCkge1xuXHRcdHRoaXMuZW1haWwgPSBlbWFpbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBpZC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGlkXG5cdCAqL1xuXHRzZXRJZChpZCkge1xuXHRcdHRoaXMuaWQgPSBpZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBuYW1lLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuXHQgKi9cblx0c2V0TmFtZShuYW1lKSB7XG5cdFx0dGhpcy5uYW1lID0gbmFtZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBwYXNzd29yZC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkXG5cdCAqL1xuXHRzZXRQYXNzd29yZChwYXNzd29yZCkge1xuXHRcdHRoaXMucGFzc3dvcmQgPSBwYXNzd29yZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBwaG90byB1cmwuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBwaG90b1VybFxuXHQgKi9cblx0c2V0UGhvdG9VcmwocGhvdG9VcmwpIHtcblx0XHR0aGlzLnBob3RvVXJsID0gcGhvdG9Vcmw7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgdG9rZW4uXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlblxuXHQgKi9cblx0c2V0VG9rZW4odG9rZW4pIHtcblx0XHR0aGlzLnRva2VuID0gdG9rZW47XG5cdH1cblxuXHRzZXRXZWRlcGxveUNsaWVudCh3ZWRlcGxveUNsaWVudCkge1xuXHRcdHRoaXMud2VkZXBsb3lDbGllbnQgPSB3ZWRlcGxveUNsaWVudDtcblx0fVxuXG5cdC8qKlxuXHQgKiBVcGRhdGVzIHRoZSB1c2VyLlxuXHQgKiBAcGFyYW0geyFvYmplY3R9IGRhdGFcblx0ICogQHJldHVybiB7Q29tcGxldGFibGVGdXR1cmV9XG5cdCAqL1xuXHR1cGRhdGVVc2VyKGRhdGEpIHtcblx0XHRhc3NlcnRPYmplY3QoZGF0YSwgJ1VzZXIgZGF0YSBtdXN0IGJlIHNwZWNpZmllZCBhcyBvYmplY3QnKTtcblx0XHRyZXR1cm4gdGhpcy53ZWRlcGxveUNsaWVudFxuXHRcdFx0LnVybCh0aGlzLndlZGVwbG95Q2xpZW50LmF1dGhVcmxfKVxuXHRcdFx0LnBhdGgoJy91c2VycycpXG5cdFx0XHQuYXV0aCh0aGlzKVxuXHRcdFx0LnBhdGNoKGRhdGEpXG5cdFx0XHQudGhlbihyZXNwb25zZSA9PiBhc3NlcnRSZXNwb25zZVN1Y2NlZWRlZChyZXNwb25zZSkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIERlbGV0ZXMgdGhlIGN1cnJlbnQgdXNlci5cblx0ICogQHJldHVybiB7Q29tcGxldGFibGVGdXR1cmV9XG5cdCAqL1xuXHRkZWxldGVVc2VyKCkge1xuXHRcdGFzc2VydERlZkFuZE5vdE51bGwodGhpcy5pZCwgJ0Nhbm5vdCBkZWxldGUgdXNlciB3aXRob3V0IGlkJyk7XG5cdFx0cmV0dXJuIHRoaXMud2VkZXBsb3lDbGllbnRcblx0XHRcdC51cmwodGhpcy53ZWRlcGxveUNsaWVudC5hdXRoVXJsXylcblx0XHRcdC5wYXRoKCcvdXNlcnMnLCB0aGlzLmlkKVxuXHRcdFx0LmF1dGgodGhpcylcblx0XHRcdC5kZWxldGUoKVxuXHRcdFx0LnRoZW4ocmVzcG9uc2UgPT4gYXNzZXJ0UmVzcG9uc2VTdWNjZWVkZWQocmVzcG9uc2UpKTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBBdXRoO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgQXV0aCBmcm9tICcuL2F1dGgvQXV0aCc7XG5pbXBvcnQgeyBhc3NlcnREZWZBbmROb3ROdWxsIH0gZnJvbSAnLi9hc3NlcnRpb25zJztcblxuY2xhc3MgQXBpSGVscGVyIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhbiB7QGxpbmsgQXBpSGVscGVyfSBpbnN0YW5jZS5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcih3ZWRlcGxveUNsaWVudCkge1xuXHRcdGFzc2VydERlZkFuZE5vdE51bGwod2VkZXBsb3lDbGllbnQsICdXZURlcGxveSBjbGllbnQgcmVmZXJlbmNlIG11c3QgYmUgc3BlY2lmaWVkJyk7XG5cdFx0dGhpcy53ZWRlcGxveUNsaWVudCA9IHdlZGVwbG95Q2xpZW50O1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYXV0aG9yaXphdGlvbiBpbmZvcm1hdGlvbiB0byB0aGlzIHJlcXVlc3QuXG5cdCAqIEBwYXJhbSB7IUF1dGh8c3RyaW5nfSBhdXRoT3JUb2tlbk9yRW1haWwgRWl0aGVyIGFuIHtAbGluayBBdXRofSBpbnN0YW5jZSxcblx0ICogYW4gYXV0aG9yaXphdGlvbiB0b2tlbiwgb3IgdGhlIGVtYWlsLlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9wYXNzd29yZCBJZiBhIGVtYWlsIGlzIGdpdmVuIGFzIHRoZSBmaXJzdCBwYXJhbSxcblx0ICogdGhpcyBzaG91bGQgYmUgdGhlIHBhc3N3b3JkLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRhdXRoKGF1dGhPclRva2VuT3JFbWFpbCwgb3B0X3Bhc3N3b3JkKSB7XG5cdFx0dGhpcy5oZWxwZXJBdXRoU2NvcGUgPSBhdXRoT3JUb2tlbk9yRW1haWw7XG5cdFx0aWYgKCEodGhpcy5oZWxwZXJBdXRoU2NvcGUgaW5zdGFuY2VvZiBBdXRoKSkge1xuXHRcdFx0dGhpcy5oZWxwZXJBdXRoU2NvcGUgPSBBdXRoLmNyZWF0ZShhdXRoT3JUb2tlbk9yRW1haWwsIG9wdF9wYXNzd29yZCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgQXBpSGVscGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgeyBjb3JlIH0gZnJvbSAnbWV0YWwnO1xuaW1wb3J0IFVyaSBmcm9tICdtZXRhbC11cmknO1xuXG4vKipcbiAqIENsYXNzIHJlc3BvbnNpYmxlIGZvciBlbmNhcHN1bGF0ZSBwcm92aWRlciBpbmZvcm1hdGlvbi5cbiAqL1xuY2xhc3MgQXV0aFByb3ZpZGVyIHtcblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYW4ge0BsaW5rIEF1dGhQcm92aWRlcn0gaW5zdGFuY2UuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0dGhpcy5wcm92aWRlciA9IG51bGw7XG5cdFx0dGhpcy5wcm92aWRlclNjb3BlID0gbnVsbDtcblx0XHR0aGlzLnJlZGlyZWN0VXJpID0gbnVsbDtcblx0XHR0aGlzLnNjb3BlID0gbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgcHJvdmlkZXIgaXMgZGVmaW5lZCBhbmQgbm90IG51bGwuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqL1xuXHRoYXNQcm92aWRlcigpIHtcblx0XHRyZXR1cm4gY29yZS5pc0RlZkFuZE5vdE51bGwodGhpcy5wcm92aWRlcik7XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIHNjb3BlIGlzIGRlZmluZWQgYW5kIG5vdCBudWxsLlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cblx0aGFzUHJvdmlkZXJTY29wZSgpIHtcblx0XHRyZXR1cm4gY29yZS5pc0RlZkFuZE5vdE51bGwodGhpcy5wcm92aWRlclNjb3BlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgcmVkaXJlY3QgdXJpIGlzIGRlZmluZWQgYW5kIG5vdCBudWxsLlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cblx0aGFzUmVkaXJlY3RVcmkoKSB7XG5cdFx0cmV0dXJuIGNvcmUuaXNEZWZBbmROb3ROdWxsKHRoaXMucmVkaXJlY3RVcmkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiBzY29wZSBpcyBkZWZpbmVkIGFuZCBub3QgbnVsbC5cblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICovXG5cdGhhc1Njb3BlKCkge1xuXHRcdHJldHVybiBjb3JlLmlzRGVmQW5kTm90TnVsbCh0aGlzLnNjb3BlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBNYWtlcyBhdXRob3JpemF0aW9uIHVybC5cblx0ICogQHJldHVybiB7c3RyaW5nPX0gQXV0aG9yaXphdGlvbiB1cmwuXG5cdCAqL1xuXHRtYWtlQXV0aG9yaXphdGlvblVybChvcHRfYXV0aFVybCkge1xuXHRcdHZhciB1cmkgPSBuZXcgVXJpKG9wdF9hdXRoVXJsKTtcblxuXHRcdHVyaS5zZXRQYXRobmFtZSgnL29hdXRoL2F1dGhvcml6ZScpO1xuXG5cdFx0aWYgKHRoaXMuaGFzUHJvdmlkZXIoKSkge1xuXHRcdFx0dXJpLnNldFBhcmFtZXRlclZhbHVlKCdwcm92aWRlcicsIHRoaXMuZ2V0UHJvdmlkZXIoKSk7XG5cdFx0fVxuXHRcdGlmICh0aGlzLmhhc1Byb3ZpZGVyU2NvcGUoKSkge1xuXHRcdFx0dXJpLnNldFBhcmFtZXRlclZhbHVlKCdwcm92aWRlcl9zY29wZScsIHRoaXMuZ2V0UHJvdmlkZXJTY29wZSgpKTtcblx0XHR9XG5cdFx0aWYgKHRoaXMuaGFzUmVkaXJlY3RVcmkoKSkge1xuXHRcdFx0dXJpLnNldFBhcmFtZXRlclZhbHVlKCdyZWRpcmVjdF91cmknLCB0aGlzLmdldFJlZGlyZWN0VXJpKCkpO1xuXHRcdH1cblx0XHRpZiAodGhpcy5oYXNTY29wZSgpKSB7XG5cdFx0XHR1cmkuc2V0UGFyYW1ldGVyVmFsdWUoJ3Njb3BlJywgdGhpcy5nZXRTY29wZSgpKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdXJpLnRvU3RyaW5nKCk7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyBwcm92aWRlciBuYW1lLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmc9fSBQcm92aWRlciBuYW1lLlxuXHQgKi9cblx0Z2V0UHJvdmlkZXIoKSB7XG5cdFx0cmV0dXJuIHRoaXMucHJvdmlkZXI7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyBwcm92aWRlciBzY29wZS5cblx0ICogQHJldHVybiB7c3RyaW5nPX0gU3RyaW5nIHdpdGggc2NvcGVzLlxuXHQgKi9cblx0Z2V0UHJvdmlkZXJTY29wZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5wcm92aWRlclNjb3BlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgcmVkaXJlY3QgdXJpLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmc9fS5cblx0ICovXG5cdGdldFJlZGlyZWN0VXJpKCkge1xuXHRcdHJldHVybiB0aGlzLnJlZGlyZWN0VXJpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgc2NvcGUuXG5cdCAqIEByZXR1cm4ge3N0cmluZz19IFN0cmluZyB3aXRoIHNjb3Blcy5cblx0ICovXG5cdGdldFNjb3BlKCkge1xuXHRcdHJldHVybiB0aGlzLnNjb3BlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgcHJvdmlkZXIgc2NvcGUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gc2NvcGUgU2NvcGUgc3RyaW5nLiBTZXBhcmF0ZSBieSBzcGFjZSBmb3IgbXVsdGlwbGVcblx0ICogICBzY29wZXMsIGUuZy4gXCJzY29wZTEgc2NvcGUyXCIuXG5cdCAqL1xuXHRzZXRQcm92aWRlclNjb3BlKHByb3ZpZGVyU2NvcGUpIHtcblx0XHRhc3NlcnRTdHJpbmdJZkRlZkFuZE5vdE51bGwocHJvdmlkZXJTY29wZSwgJ1Byb3ZpZGVyIHNjb3BlIG11c3QgYmUgYSBzdHJpbmcnKTtcblx0XHR0aGlzLnByb3ZpZGVyU2NvcGUgPSBwcm92aWRlclNjb3BlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgcmVkaXJlY3QgdXJpLlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IHJlZGlyZWN0VXJpLlxuXHQgKi9cblx0c2V0UmVkaXJlY3RVcmkocmVkaXJlY3RVcmkpIHtcblx0XHRhc3NlcnRTdHJpbmdJZkRlZkFuZE5vdE51bGwocmVkaXJlY3RVcmksICdSZWRpcmVjdCB1cmkgbXVzdCBiZSBhIHN0cmluZycpO1xuXHRcdHRoaXMucmVkaXJlY3RVcmkgPSByZWRpcmVjdFVyaTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHNjb3BlLlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IHNjb3BlIFNjb3BlIHN0cmluZy4gU2VwYXJhdGUgYnkgc3BhY2UgZm9yIG11bHRpcGxlXG5cdCAqICAgc2NvcGVzLCBlLmcuIFwic2NvcGUxIHNjb3BlMlwiLlxuXHQgKi9cblx0c2V0U2NvcGUoc2NvcGUpIHtcblx0XHRhc3NlcnRTdHJpbmdJZkRlZkFuZE5vdE51bGwoc2NvcGUsICdTY29wZSBtdXN0IGJlIGEgc3RyaW5nJyk7XG5cdFx0dGhpcy5zY29wZSA9IHNjb3BlO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFN0cmluZ0lmRGVmQW5kTm90TnVsbCh2YWx1ZSwgZXJyb3JNZXNzYWdlKSB7XG5cdGlmIChjb3JlLmlzRGVmQW5kTm90TnVsbCh2YWx1ZSkgJiYgIWNvcmUuaXNTdHJpbmcodmFsdWUpKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQXV0aFByb3ZpZGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgQXV0aFByb3ZpZGVyIGZyb20gJy4vQXV0aFByb3ZpZGVyJztcblxuLyoqXG4gKiBGYWNlYm9vayBhdXRoIHByb3ZpZGVyIGltcGxlbWVudGF0aW9uLlxuICovXG5jbGFzcyBGYWNlYm9va0F1dGhQcm92aWRlciBleHRlbmRzIEF1dGhQcm92aWRlciB7XG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGFuIHtAbGluayBGYWNlYm9va0F1dGhQcm92aWRlcn0gaW5zdGFuY2UuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLnByb3ZpZGVyID0gRmFjZWJvb2tBdXRoUHJvdmlkZXIuUFJPVklERVI7XG5cdH1cbn1cblxuRmFjZWJvb2tBdXRoUHJvdmlkZXIuUFJPVklERVIgPSAnZmFjZWJvb2snO1xuXG5leHBvcnQgZGVmYXVsdCBGYWNlYm9va0F1dGhQcm92aWRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEF1dGhQcm92aWRlciBmcm9tICcuL0F1dGhQcm92aWRlcic7XG5cbi8qKlxuICogR2l0aHViIGF1dGggcHJvdmlkZXIgaW1wbGVtZW50YXRpb24uXG4gKi9cbmNsYXNzIEdpdGh1YkF1dGhQcm92aWRlciBleHRlbmRzIEF1dGhQcm92aWRlciB7XG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGFuIHtAbGluayBHaXRodWJBdXRoUHJvdmlkZXJ9IGluc3RhbmNlLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy5wcm92aWRlciA9IEdpdGh1YkF1dGhQcm92aWRlci5QUk9WSURFUjtcblx0fVxufVxuXG5HaXRodWJBdXRoUHJvdmlkZXIuUFJPVklERVIgPSAnZ2l0aHViJztcblxuZXhwb3J0IGRlZmF1bHQgR2l0aHViQXV0aFByb3ZpZGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgQXV0aFByb3ZpZGVyIGZyb20gJy4vQXV0aFByb3ZpZGVyJztcblxuLyoqXG4gKiBHb29nbGUgYXV0aCBwcm92aWRlciBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuY2xhc3MgR29vZ2xlQXV0aFByb3ZpZGVyIGV4dGVuZHMgQXV0aFByb3ZpZGVyIHtcblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYW4ge0BsaW5rIEdvb2dsZUF1dGhQcm92aWRlcn0gaW5zdGFuY2UuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLnByb3ZpZGVyID0gR29vZ2xlQXV0aFByb3ZpZGVyLlBST1ZJREVSO1xuXHR9XG59XG5cbkdvb2dsZUF1dGhQcm92aWRlci5QUk9WSURFUiA9ICdnb29nbGUnO1xuXG5leHBvcnQgZGVmYXVsdCBHb29nbGVBdXRoUHJvdmlkZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cblxuLyoqXG4gKiBBYnN0cmFjdCBpbnRlcmZhY2UgZm9yIHN0b3JpbmcgYW5kIHJldHJpZXZpbmcgZGF0YSB1c2luZyBzb21lIHBlcnNpc3RlbmNlXG4gKiBtZWNoYW5pc20uXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgU3RvcmFnZU1lY2hhbmlzbSB7XG5cdC8qKlxuXHQgKiBDbGVhciBhbGwgaXRlbXMgZnJvbSB0aGUgZGF0YSBzdG9yYWdlLlxuXHQgKi9cblx0Y2xlYXIoKSB7XG5cdFx0dGhyb3cgRXJyb3IoJ1VuaW1wbGVtZW50ZWQgYWJzdHJhY3QgbWV0aG9kJyk7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyBhbiBpdGVtIGluIHRoZSBkYXRhIHN0b3JhZ2UuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSB0byBzZXQuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlcmlhbGl6ZSB0byBhIHN0cmluZyBhbmQgc2F2ZS5cblx0ICovXG5cdHNldChrZXksIHZhbHVlKSB7XG5cdFx0dGhyb3cgRXJyb3IoJ1VuaW1wbGVtZW50ZWQgYWJzdHJhY3QgbWV0aG9kJyk7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyBhbiBpdGVtIGZyb20gdGhlIGRhdGEgc3RvcmFnZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IHRvIGdldC5cblx0ICogQHJldHVybiB7Kn0gRGVzZXJpYWxpemVkIHZhbHVlIG9yIHVuZGVmaW5lZCBpZiBub3QgZm91bmQuXG5cdCAqL1xuXHRnZXQoa2V5KSB7XG5cdFx0dGhyb3cgRXJyb3IoJ1VuaW1wbGVtZW50ZWQgYWJzdHJhY3QgbWV0aG9kJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIHRoaXMgbWVjaGFuaXNtIGlzIHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudC5cblx0ICogU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdGhpcyB3aGVuIG5lY2Vzc2FyeS5cblx0ICovXG5cdHN0YXRpYyBpc1N1cHBvcnRlZCgpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIGtleXMgc3RvcmVkIGluIHRoZSBTdG9yYWdlIG9iamVjdC5cblx0ICogQHBhcmFtIHshQXJyYXk8c3RyaW5nPn0ga2V5c1xuXHQgKi9cblx0a2V5cygpIHtcblx0XHR0aHJvdyBFcnJvcignVW5pbXBsZW1lbnRlZCBhYnN0cmFjdCBtZXRob2QnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIGFuIGl0ZW0gZnJvbSB0aGUgZGF0YSBzdG9yYWdlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgdG8gcmVtb3ZlLlxuXHQgKi9cblx0cmVtb3ZlKGtleSkge1xuXHRcdHRocm93IEVycm9yKCdVbmltcGxlbWVudGVkIGFic3RyYWN0IG1ldGhvZCcpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIG51bWJlciBvZiBkYXRhIGl0ZW1zIHN0b3JlZCBpbiB0aGUgU3RvcmFnZSBvYmplY3QuXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG5cdHNpemUoKSB7XG5cdFx0dGhyb3cgRXJyb3IoJ1VuaW1wbGVtZW50ZWQgYWJzdHJhY3QgbWV0aG9kJyk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU3RvcmFnZU1lY2hhbmlzbTtcblxuLyoganNoaW50IGlnbm9yZTplbmQgKi9cbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IGNvcmUgZnJvbSAnbWV0YWwnO1xuaW1wb3J0IFN0b3JhZ2VNZWNoYW5pc20gZnJvbSAnLi9tZWNoYW5pc20vU3RvcmFnZU1lY2hhbmlzbSc7XG5cbmNsYXNzIFN0b3JhZ2Uge1xuXG5cdC8qKlxuXHQgKiBQcm92aWRlcyBhIGNvbnZlbmllbnQgQVBJIGZvciBkYXRhIHBlcnNpc3RlbmNlIHVzaW5nIGEgc2VsZWN0ZWQgZGF0YVxuXHQgKiBzdG9yYWdlIG1lY2hhbmlzbS5cblx0ICogQHBhcmFtIHshU3RvcmFnZU1lY2hhbmlzbX0gbWVjaGFuaXNtIFRoZSB1bmRlcmx5aW5nIHN0b3JhZ2UgbWVjaGFuaXNtLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGNvbnN0cnVjdG9yKG1lY2hhbmlzbSkge1xuXHRcdGFzc2VydE1lY2hhbmlzbURlZkFuZE5vdE51bGwobWVjaGFuaXNtKTtcblx0XHRhc3NlcnRNZWNoYW5pc21JbnRhbmNlT2YobWVjaGFuaXNtKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBtZWNoYW5pc20gdXNlZCB0byBwZXJzaXN0IGtleS12YWx1ZSBwYWlycy5cblx0XHQgKiBAdHlwZSB7U3RvcmFnZU1lY2hhbmlzbX1cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5tZWNoYW5pc20gPSBtZWNoYW5pc207XG5cdH1cblxuXHQvKipcblx0ICogQ2xlYXIgYWxsIGl0ZW1zIGZyb20gdGhlIGRhdGEgc3RvcmFnZS5cblx0ICovXG5cdGNsZWFyKCkge1xuXHRcdHRoaXMubWVjaGFuaXNtLmNsZWFyKCk7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyBhbiBpdGVtIGluIHRoZSBkYXRhIHN0b3JhZ2UuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSB0byBzZXQuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlcmlhbGl6ZSB0byBhIHN0cmluZyBhbmQgc2F2ZS5cblx0ICovXG5cdHNldChrZXksIHZhbHVlKSB7XG5cdFx0aWYgKCFjb3JlLmlzRGVmKHZhbHVlKSkge1xuXHRcdFx0dGhpcy5tZWNoYW5pc20ucmVtb3ZlKGtleSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRoaXMubWVjaGFuaXNtLnNldChrZXksIEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyBhbiBpdGVtIGZyb20gdGhlIGRhdGEgc3RvcmFnZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IHRvIGdldC5cblx0ICogQHJldHVybiB7Kn0gRGVzZXJpYWxpemVkIHZhbHVlIG9yIHVuZGVmaW5lZCBpZiBub3QgZm91bmQuXG5cdCAqL1xuXHRnZXQoa2V5KSB7XG5cdFx0dmFyIGpzb247XG5cdFx0dHJ5IHtcblx0XHRcdGpzb24gPSB0aGlzLm1lY2hhbmlzbS5nZXQoa2V5KTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoY29yZS5pc051bGwoanNvbikpIHtcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4gSlNPTi5wYXJzZShqc29uKTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHR0aHJvdyBTdG9yYWdlLkVycm9yQ29kZS5JTlZBTElEX1ZBTFVFO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIGtleXMgc3RvcmVkIGluIHRoZSBTdG9yYWdlIG9iamVjdC5cblx0ICogQHBhcmFtIHshQXJyYXk8c3RyaW5nPn0ga2V5c1xuXHQgKi9cblx0a2V5cygpIHtcblx0XHRyZXR1cm4gdGhpcy5tZWNoYW5pc20ua2V5cygpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgYW4gaXRlbSBmcm9tIHRoZSBkYXRhIHN0b3JhZ2UuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSB0byByZW1vdmUuXG5cdCAqL1xuXHRyZW1vdmUoa2V5KSB7XG5cdFx0dGhpcy5tZWNoYW5pc20ucmVtb3ZlKGtleSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGRhdGEgaXRlbXMgc3RvcmVkIGluIHRoZSBTdG9yYWdlIG9iamVjdC5cblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cblx0c2l6ZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5tZWNoYW5pc20uc2l6ZSgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGxpc3Qgb2YgdmFsdWVzIHN0b3JlZCBpbiB0aGUgU3RvcmFnZSBvYmplY3QuXG5cdCAqIEBwYXJhbSB7IUFycmF5PHN0cmluZz59IHZhbHVlc1xuXHQgKi9cblx0dmFsdWVzKCkge1xuXHRcdHJldHVybiB0aGlzLmtleXMoKS5tYXAoKGtleSkgPT4gdGhpcy5nZXQoa2V5KSk7XG5cdH1cbn1cblxuLyoqXG4gKiBFcnJvcnMgdGhyb3duIGJ5IHRoZSBzdG9yYWdlLlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuU3RvcmFnZS5FcnJvckNvZGUgPSB7XG5cdElOVkFMSURfVkFMVUU6ICdTdG9yYWdlOiBJbnZhbGlkIHZhbHVlIHdhcyBlbmNvdW50ZXJlZCdcbn07XG5cbmZ1bmN0aW9uIGFzc2VydE1lY2hhbmlzbURlZkFuZE5vdE51bGwobWVjaGFuaXNtKSB7XG5cdGlmICghY29yZS5pc0RlZkFuZE5vdE51bGwobWVjaGFuaXNtKSkge1xuXHRcdHRocm93IEVycm9yKCdTdG9yYWdlIG1lY2hhbmlzbSBpcyByZXF1aXJlZCcpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGFzc2VydE1lY2hhbmlzbUludGFuY2VPZihtZWNoYW5pc20pIHtcblx0aWYgKCEobWVjaGFuaXNtIGluc3RhbmNlb2YgU3RvcmFnZU1lY2hhbmlzbSkpIHtcblx0XHR0aHJvdyBFcnJvcignU3RvcmFnZSBtZWNoYW5pc20gbXVzdCBtZSBhbiBpbXBsZW1lbnRhdGlvbiBvZiBTdG9yYWdlTWVjaGFuaXNtJyk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU3RvcmFnZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IFN0b3JhZ2VNZWNoYW5pc20gZnJvbSAnLi9TdG9yYWdlTWVjaGFuaXNtJztcblxuLyoqXG4gKiBBYnN0cmFjdCBpbnRlcmZhY2UgZm9yIHN0b3JpbmcgYW5kIHJldHJpZXZpbmcgZGF0YSB1c2luZyBzb21lIHBlcnNpc3RlbmNlXG4gKiBtZWNoYW5pc20uXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgTG9jYWxTdG9yYWdlTWVjaGFuaXNtIGV4dGVuZHMgU3RvcmFnZU1lY2hhbmlzbSB7XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHJlZmVyZW5jZSBmb3IgZ2xvYmFsIGxvY2FsIHN0b3JhZ2UuIGJ5IGRlZmF1bHRcblx0ICovXG5cdHN0b3JhZ2UoKSB7XG5cdFx0cmV0dXJuIExvY2FsU3RvcmFnZU1lY2hhbmlzbS5nbG9iYWxzLmxvY2FsU3RvcmFnZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAaW5oZXJpdERvY1xuXHQgKi9cblx0Y2xlYXIoKSB7XG5cdFx0dGhpcy5zdG9yYWdlKCkuY2xlYXIoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAaW5oZXJpdERvY1xuXHQgKi9cblx0a2V5cygpIHtcblx0XHRyZXR1cm4gT2JqZWN0LmtleXModGhpcy5zdG9yYWdlKCkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBpbmhlcml0RG9jXG5cdCAqL1xuXHRnZXQoa2V5KSB7XG5cdFx0cmV0dXJuIHRoaXMuc3RvcmFnZSgpLmdldEl0ZW0oa2V5KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAaW5oZXJpdERvY1xuXHQgKi9cblx0c3RhdGljIGlzU3VwcG9ydGVkKCkge1xuXHRcdHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcblx0fVxuXG5cdC8qKlxuXHQgKiBAaW5oZXJpdERvY1xuXHQgKi9cblx0cmVtb3ZlKGtleSkge1xuXHRcdHRoaXMuc3RvcmFnZSgpLnJlbW92ZUl0ZW0oa2V5KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAaW5oZXJpdERvY1xuXHQgKi9cblx0c2V0KGtleSwgdmFsdWUpIHtcblx0XHR0aGlzLnN0b3JhZ2UoKS5zZXRJdGVtKGtleSwgdmFsdWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBpbmhlcml0RG9jXG5cdCAqL1xuXHRzaXplKCkge1xuXHRcdHJldHVybiB0aGlzLnN0b3JhZ2UoKS5sZW5ndGg7XG5cdH1cbn1cblxuaWYgKExvY2FsU3RvcmFnZU1lY2hhbmlzbS5pc1N1cHBvcnRlZCgpKSB7XG5cdExvY2FsU3RvcmFnZU1lY2hhbmlzbS5nbG9iYWxzID0ge1xuXHRcdGxvY2FsU3RvcmFnZTogd2luZG93LmxvY2FsU3RvcmFnZVxuXHR9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBMb2NhbFN0b3JhZ2VNZWNoYW5pc207XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBBdXRoIGZyb20gJy4vQXV0aCc7XG5pbXBvcnQgQXBpSGVscGVyIGZyb20gJy4uL0FwaUhlbHBlcic7XG5pbXBvcnQgRmFjZWJvb2tBdXRoUHJvdmlkZXIgZnJvbSAnLi9GYWNlYm9va0F1dGhQcm92aWRlcic7XG5pbXBvcnQgR2l0aHViQXV0aFByb3ZpZGVyIGZyb20gJy4vR2l0aHViQXV0aFByb3ZpZGVyJztcbmltcG9ydCBnbG9iYWxzIGZyb20gJy4uLy4uL2dsb2JhbHMvZ2xvYmFscyc7XG5pbXBvcnQgR29vZ2xlQXV0aFByb3ZpZGVyIGZyb20gJy4vR29vZ2xlQXV0aFByb3ZpZGVyJztcbmltcG9ydCB7IFN0b3JhZ2UsIExvY2FsU3RvcmFnZU1lY2hhbmlzbSB9IGZyb20gJ21ldGFsLXN0b3JhZ2UnO1xuXG5pbXBvcnQgeyBhc3NlcnREZWZBbmROb3ROdWxsLCBhc3NlcnRGdW5jdGlvbiwgYXNzZXJ0T2JqZWN0LCBhc3NlcnRVc2VyU2lnbmVkSW4sIGFzc2VydEJyb3dzZXJFbnZpcm9ubWVudCwgYXNzZXJ0UmVzcG9uc2VTdWNjZWVkZWQgfSBmcm9tICcuLi9hc3NlcnRpb25zJztcblxuLyoqXG4gKiBDbGFzcyByZXNwb25zaWJsZSBmb3IgZW5jYXBzdWxhdGUgYXV0aCBhcGkgY2FsbHMuXG4gKi9cbmNsYXNzIEF1dGhBcGlIZWxwZXIgZXh0ZW5kcyBBcGlIZWxwZXIge1xuXHQvKipcblx0ICogQ29uc3RydWN0cyBhbiB7QGxpbmsgQXV0aEFwaUhlbHBlcn0gaW5zdGFuY2UuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0Y29uc3RydWN0b3Iod2VkZXBsb3lDbGllbnQpIHtcblx0XHRzdXBlcih3ZWRlcGxveUNsaWVudCk7XG5cblx0XHR0aGlzLmN1cnJlbnRVc2VyID0gbnVsbDtcblx0XHR0aGlzLm9uU2lnbkluQ2FsbGJhY2sgPSBudWxsO1xuXHRcdHRoaXMub25TaWduT3V0Q2FsbGJhY2sgPSBudWxsO1xuXHRcdGlmIChMb2NhbFN0b3JhZ2VNZWNoYW5pc20uaXNTdXBwb3J0ZWQoKSkge1xuXHRcdFx0dGhpcy5zdG9yYWdlID0gbmV3IFN0b3JhZ2UobmV3IExvY2FsU3RvcmFnZU1lY2hhbmlzbSgpKTtcblx0XHR9XG5cblx0XHR0aGlzLnByb2Nlc3NTaWduSW5fKCk7XG5cblx0XHR0aGlzLnByb3ZpZGVyID0ge1xuXHRcdFx0RmFjZWJvb2s6IEZhY2Vib29rQXV0aFByb3ZpZGVyLFxuXHRcdFx0R29vZ2xlOiBHb29nbGVBdXRoUHJvdmlkZXIsXG5cdFx0XHRHaXRodWI6IEdpdGh1YkF1dGhQcm92aWRlclxuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyB1c2VyLlxuXHQgKiBAcGFyYW0geyFvYmplY3R9IGRhdGEgVGhlIGRhdGEgdG8gYmUgdXNlZCB0byBjcmVhdGUgdGhlIHVzZXIuXG5cdCAqIEByZXR1cm4ge0NhbmNlbGxhYmxlUHJvbWlzZX1cblx0ICovXG5cdGNyZWF0ZVVzZXIoZGF0YSkge1xuXHRcdGFzc2VydE9iamVjdChkYXRhLCAnVXNlciBkYXRhIG11c3QgYmUgc3BlY2lmaWVkIGFzIG9iamVjdCcpO1xuXHRcdHJldHVybiB0aGlzLndlZGVwbG95Q2xpZW50XG5cdFx0XHQudXJsKHRoaXMud2VkZXBsb3lDbGllbnQuYXV0aFVybF8pXG5cdFx0XHQucGF0aCgnL3VzZXJzJylcblx0XHRcdC5wb3N0KGRhdGEpXG5cdFx0XHQudGhlbihyZXNwb25zZSA9PiBhc3NlcnRSZXNwb25zZVN1Y2NlZWRlZChyZXNwb25zZSkpXG5cdFx0XHQudGhlbihyZXNwb25zZSA9PiB0aGlzLm1ha2VVc2VyQXV0aEZyb21EYXRhKHJlc3BvbnNlLmJvZHkoKSkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGN1cnJlbnQgYnJvd3NlciB1cmwgd2l0aG91dCB0aGUgZnJhZ21lbnQgcGFydC5cblx0ICogQHJldHVybiB7IXN0cmluZ31cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0Z2V0SHJlZldpdGhvdXRGcmFnbWVudF8oKSB7XG5cdFx0dmFyIGxvY2F0aW9uID0gZ2xvYmFscy53aW5kb3cubG9jYXRpb247XG5cdFx0cmV0dXJuIGxvY2F0aW9uLnByb3RvY29sICsgJy8vJyArIGxvY2F0aW9uLmhvc3QgKyBsb2NhdGlvbi5wYXRobmFtZSArIChsb2NhdGlvbi5zZWFyY2ggPyBsb2NhdGlvbi5zZWFyY2ggOiAnJyk7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgYWNjZXNzIHRva2VuIGZyb20gdGhlIHVybCBmcmFnbWVudCBhbmQgcmVtb3ZlcyBpdC5cblx0ICogQHJldHVybiB7P3N0cmluZ31cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0Z2V0UmVkaXJlY3RBY2Nlc3NUb2tlbl8oKSB7XG5cdFx0aWYgKGdsb2JhbHMud2luZG93KSB7XG5cdFx0XHR2YXIgZnJhZ21lbnQgPSBnbG9iYWxzLndpbmRvdy5sb2NhdGlvbi5oYXNoO1xuXHRcdFx0aWYgKGZyYWdtZW50LmluZGV4T2YoJyNhY2Nlc3NfdG9rZW49JykgPT09IDApIHtcblx0XHRcdFx0cmV0dXJuIGZyYWdtZW50LnN1YnN0cmluZygxNCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdXNlciBieSBpZC5cblx0ICogQHBhcmFtIHshc3RyaW5nfSB1c2VySWRcblx0ICogQHJldHVybiB7Q2FuY2VsbGFibGVQcm9taXNlfVxuXHQgKi9cblx0Z2V0VXNlcih1c2VySWQpIHtcblx0XHRhc3NlcnREZWZBbmROb3ROdWxsKHVzZXJJZCwgJ1VzZXIgdXNlcklkIG11c3QgYmUgc3BlY2lmaWVkJyk7XG5cdFx0YXNzZXJ0VXNlclNpZ25lZEluKHRoaXMuY3VycmVudFVzZXIpO1xuXHRcdHJldHVybiB0aGlzLndlZGVwbG95Q2xpZW50XG5cdFx0XHQudXJsKHRoaXMud2VkZXBsb3lDbGllbnQuYXV0aFVybF8pXG5cdFx0XHQucGF0aCgnL3VzZXJzJywgdXNlcklkKVxuXHRcdFx0LmF1dGgodGhpcy5yZXNvbHZlQXV0aFNjb3BlKCkudG9rZW4pXG5cdFx0XHQuZ2V0KClcblx0XHRcdC50aGVuKHJlc3BvbnNlID0+IGFzc2VydFJlc3BvbnNlU3VjY2VlZGVkKHJlc3BvbnNlKSlcblx0XHRcdC50aGVuKHJlc3BvbnNlID0+IHRoaXMubWFrZVVzZXJBdXRoRnJvbURhdGEocmVzcG9uc2UuYm9keSgpKSk7XG5cdH1cblxuXHQvKipcblx0ICogTG9hZHMgY3VycmVudCB1c2VyLiBSZXF1aXJlcyBhIHVzZXIgdG9rZW4gYXMgYXJndW1lbnQuXG5cdCAqIEBwYXJhbSB7IXN0cmluZ30gdG9rZW5cblx0ICogQHJldHVybiB7Q2FuY2VsbGFibGVQcm9taXNlfVxuXHQgKi9cblx0bG9hZEN1cnJlbnRVc2VyKHRva2VuKSB7XG5cdFx0YXNzZXJ0RGVmQW5kTm90TnVsbCh0b2tlbiwgJ1VzZXIgdG9rZW4gbXVzdCBiZSBzcGVjaWZpZWQnKTtcblx0XHRyZXR1cm4gdGhpcy53ZWRlcGxveUNsaWVudFxuXHRcdFx0LnVybCh0aGlzLndlZGVwbG95Q2xpZW50LmF1dGhVcmxfKVxuXHRcdFx0LnBhdGgoJy91c2VyJylcblx0XHRcdC5hdXRoKHRva2VuKVxuXHRcdFx0LmdldCgpXG5cdFx0XHQudGhlbihyZXNwb25zZSA9PiB7XG5cdFx0XHRcdHZhciBkYXRhID0gcmVzcG9uc2UuYm9keSgpO1xuXHRcdFx0XHRkYXRhLnRva2VuID0gdG9rZW47XG5cdFx0XHRcdHRoaXMuY3VycmVudFVzZXIgPSB0aGlzLm1ha2VVc2VyQXV0aEZyb21EYXRhKGRhdGEpO1xuXHRcdFx0XHRpZiAodGhpcy5zdG9yYWdlKSB7XG5cdFx0XHRcdFx0dGhpcy5zdG9yYWdlLnNldCgnY3VycmVudFVzZXInLCBkYXRhKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5jdXJyZW50VXNlcjtcblx0XHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIE1ha2VzIHVzZXIgQXV0aCBmcm9tIGRhdGEgb2JqZWN0LlxuXHQgKiBAcGFyYW0ge29iamVjdH0gZGF0YVxuXHQgKiBAcmV0dXJuIHtBdXRofVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRtYWtlVXNlckF1dGhGcm9tRGF0YShkYXRhKSB7XG5cdFx0dmFyIGF1dGggPSBuZXcgQXV0aCgpO1xuXHRcdGF1dGguc2V0V2VkZXBsb3lDbGllbnQodGhpcy53ZWRlcGxveUNsaWVudCk7XG5cdFx0YXV0aC5zZXRDcmVhdGVkQXQoZGF0YS5jcmVhdGVkQXQpO1xuXHRcdGF1dGguc2V0RW1haWwoZGF0YS5lbWFpbCk7XG5cdFx0YXV0aC5zZXRJZChkYXRhLmlkKTtcblx0XHRhdXRoLnNldE5hbWUoZGF0YS5uYW1lKTtcblx0XHRhdXRoLnNldFBob3RvVXJsKGRhdGEucGhvdG9VcmwpO1xuXHRcdGF1dGguc2V0VG9rZW4oZGF0YS50b2tlbik7XG5cdFx0cmV0dXJuIGF1dGg7XG5cdH1cblxuXHQvKipcblx0ICogQ2FsbHMgdGhlIG9uIHNpZ24gaW4gY2FsbGJhY2sgaWYgc2V0LlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRtYXliZUNhbGxPblNpZ25JbkNhbGxiYWNrXygpIHtcblx0XHRpZiAodGhpcy5vblNpZ25JbkNhbGxiYWNrKSB7XG5cdFx0XHR0aGlzLm9uU2lnbkluQ2FsbGJhY2suY2FsbCh0aGlzLCB0aGlzLmN1cnJlbnRVc2VyKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQ2FsbHMgdGhlIG9uIHNpZ24gb3V0IGNhbGxiYWNrIGlmIHNldC5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0bWF5YmVDYWxsT25TaWduT3V0Q2FsbGJhY2tfKCkge1xuXHRcdGlmICh0aGlzLm9uU2lnbk91dENhbGxiYWNrKSB7XG5cdFx0XHR0aGlzLm9uU2lnbk91dENhbGxiYWNrLmNhbGwodGhpcywgdGhpcy5jdXJyZW50VXNlcik7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEZpcmVzIHBhc3NlZCBjYWxsYmFjayB3aGVuIGEgdXNlciBzaWduLWluLiBOb3RlIHRoYXQgaXQga2VlcHMgb25seSB0aGVcblx0ICogbGFzdCBjYWxsYmFjayBwYXNzZWQuXG5cdCAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBjYWxsYmFja1xuXHQgKi9cblx0b25TaWduSW4oY2FsbGJhY2spIHtcblx0XHRhc3NlcnRGdW5jdGlvbihjYWxsYmFjaywgJ1NpZ24taW4gY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cdFx0dGhpcy5vblNpZ25JbkNhbGxiYWNrID0gY2FsbGJhY2s7XG5cdH1cblxuXHQvKipcblx0ICogRmlyZXMgcGFzc2VkIGNhbGxiYWNrIHdoZW4gYSB1c2VyIHNpZ24tb3V0LiBOb3RlIHRoYXQgaXQga2VlcHMgb25seSB0aGVcblx0ICogbGFzdCBjYWxsYmFjayBwYXNzZWQuXG5cdCAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBjYWxsYmFja1xuXHQgKi9cblx0b25TaWduT3V0KGNhbGxiYWNrKSB7XG5cdFx0YXNzZXJ0RnVuY3Rpb24oY2FsbGJhY2ssICdTaWduLW91dCBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblx0XHR0aGlzLm9uU2lnbk91dENhbGxiYWNrID0gY2FsbGJhY2s7XG5cdH1cblxuXHQvKipcblx0ICogUHJvY2Vzc2VzIHNpZ24taW4gYnkgZGV0ZWN0aW5nIGEgcHJlc2VuY2Ugb2YgYSBmcmFnbWVudFxuXHQgKiA8Y29kZT4jYWNjZXNzX3Rva2VuPTwvY29kZT4gaW4gdGhlIHVybCBvciwgYWx0ZXJuYXRpdmVseSwgYnkgbG9jYWxcblx0ICogc3RvcmFnZSBjdXJyZW50IHVzZXIuXG5cdCAqL1xuXHRwcm9jZXNzU2lnbkluXygpIHtcblx0XHR2YXIgcmVkaXJlY3RBY2Nlc3NUb2tlbiA9IHRoaXMuZ2V0UmVkaXJlY3RBY2Nlc3NUb2tlbl8oKTtcblx0XHRpZiAocmVkaXJlY3RBY2Nlc3NUb2tlbikge1xuXHRcdFx0dGhpcy5yZW1vdmVVcmxGcmFnbWVudENvbXBsZXRlbHlfKCk7XG5cdFx0XHR0aGlzLmxvYWRDdXJyZW50VXNlcihyZWRpcmVjdEFjY2Vzc1Rva2VuKVxuXHRcdFx0XHQudGhlbigoKSA9PiB0aGlzLm1heWJlQ2FsbE9uU2lnbkluQ2FsbGJhY2tfKCkpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR2YXIgY3VycmVudFVzZXIgPSB0aGlzLnN0b3JhZ2UgJiYgdGhpcy5zdG9yYWdlLmdldCgnY3VycmVudFVzZXInKTtcblx0XHRpZiAoY3VycmVudFVzZXIpIHtcblx0XHRcdHRoaXMuY3VycmVudFVzZXIgPSB0aGlzLm1ha2VVc2VyQXV0aEZyb21EYXRhKGN1cnJlbnRVc2VyKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlcyBmcmFnbWVudCBmcm9tIHVybCBieSBwZXJmb3JtaW5nIGEgcHVzaCBzdGF0ZSB0byB0aGUgY3VycmVudCBwYXRoLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRyZW1vdmVVcmxGcmFnbWVudENvbXBsZXRlbHlfKCkge1xuXHRcdGdsb2JhbHMud2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKHt9LCBkb2N1bWVudC50aXRsZSwgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lICsgd2luZG93LmxvY2F0aW9uLnNlYXJjaCk7XG5cdH1cblxuXHQvKipcblx0ICogUmVzb2x2ZXMgYXV0aCBzY29wZSBmcm9tIGxhc3QgbG9naW4gb3IgYXBpIGhlbHBlci5cblx0ICogQHJldHVybiB7QXV0aH1cblx0ICovXG5cdHJlc29sdmVBdXRoU2NvcGUoKSB7XG5cdFx0aWYgKHRoaXMuaGVscGVyQXV0aFNjb3BlKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5oZWxwZXJBdXRoU2NvcGU7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmN1cnJlbnRVc2VyO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNlbmRzIHBhc3N3b3JkIHJlc2V0IGVtYWlsIHRvIHRoZSBzcGVjaWZpZWQgZW1haWwgaWYgZm91bmQgaW4gZGF0YWJhc2UuXG5cdCAqIEZvciBzZWN1cml0eSByZWFzb25zIGNhbGwgZG8gbm90IGZhaWwgaWYgZW1haWwgbm90IGZvdW5kLlxuXHQgKiBAcGFyYW0geyFzdHJpbmd9IGVtYWlsXG5cdCAqIEByZXR1cm4ge0NhbmNlbGxhYmxlUHJvbWlzZX1cblx0ICovXG5cdHNlbmRQYXNzd29yZFJlc2V0RW1haWwoZW1haWwpIHtcblx0XHRhc3NlcnREZWZBbmROb3ROdWxsKGVtYWlsLCAnU2VuZCBwYXNzd29yZCByZXNldCBlbWFpbCBtdXN0IGJlIHNwZWNpZmllZCcpO1xuXHRcdHJldHVybiB0aGlzLndlZGVwbG95Q2xpZW50XG5cdFx0XHQudXJsKHRoaXMud2VkZXBsb3lDbGllbnQuYXV0aFVybF8pXG5cdFx0XHQucGF0aCgnL3VzZXIvcmVjb3ZlcicpXG5cdFx0XHQucGFyYW0oJ2VtYWlsJywgZW1haWwpXG5cdFx0XHQucG9zdCgpXG5cdFx0XHQudGhlbihyZXNwb25zZSA9PiBhc3NlcnRSZXNwb25zZVN1Y2NlZWRlZChyZXNwb25zZSkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNpZ25zIGluIHVzaW5nIGVtYWlsIGFuZCBwYXNzd29yZC5cblx0ICogQHBhcmFtIHshc3RyaW5nfSBlbWFpbFxuXHQgKiBAcGFyYW0geyFzdHJpbmd9IHBhc3N3b3JkXG5cdCAqIEByZXR1cm4ge0NhbmNlbGxhYmxlUHJvbWlzZX1cblx0ICovXG5cdHNpZ25JbldpdGhFbWFpbEFuZFBhc3N3b3JkKGVtYWlsLCBwYXNzd29yZCkge1xuXHRcdGFzc2VydERlZkFuZE5vdE51bGwoZW1haWwsICdTaWduLWluIGVtYWlsIG11c3QgYmUgc3BlY2lmaWVkJyk7XG5cdFx0YXNzZXJ0RGVmQW5kTm90TnVsbChwYXNzd29yZCwgJ1NpZ24taW4gcGFzc3dvcmQgbXVzdCBiZSBzcGVjaWZpZWQnKTtcblxuXHRcdHJldHVybiB0aGlzLndlZGVwbG95Q2xpZW50XG5cdFx0XHQudXJsKHRoaXMud2VkZXBsb3lDbGllbnQuYXV0aFVybF8pXG5cdFx0XHQucGF0aCgnL29hdXRoL3Rva2VuJylcblx0XHRcdC5wYXJhbSgnZ3JhbnRfdHlwZScsICdwYXNzd29yZCcpXG5cdFx0XHQucGFyYW0oJ3VzZXJuYW1lJywgZW1haWwpXG5cdFx0XHQucGFyYW0oJ3Bhc3N3b3JkJywgcGFzc3dvcmQpXG5cdFx0XHQuZ2V0KClcblx0XHRcdC50aGVuKHJlc3BvbnNlID0+IGFzc2VydFJlc3BvbnNlU3VjY2VlZGVkKHJlc3BvbnNlKSlcblx0XHRcdC50aGVuKHJlc3BvbnNlID0+IHRoaXMubG9hZEN1cnJlbnRVc2VyKHJlc3BvbnNlLmJvZHkoKS5hY2Nlc3NfdG9rZW4pKVxuXHRcdFx0LnRoZW4oKHVzZXIpID0+IHtcblx0XHRcdFx0dGhpcy5tYXliZUNhbGxPblNpZ25JbkNhbGxiYWNrXygpO1xuXHRcdFx0XHRyZXR1cm4gdXNlcjtcblx0XHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNpZ25zIGluIHdpdGggcmVkaXJlY3QuIFNvbWUgcHJvdmlkZXJzIGFuZCBlbnZpcm9ubWVudCBtYXkgbm90IHN1cHBvcnRcblx0ICogdGhpcyBmbG93LlxuXHQgKiBAcGFyYW0ge0F1dGhQcm92aWRlcn0gcHJvdmlkZXJcblx0ICovXG5cdHNpZ25JbldpdGhSZWRpcmVjdChwcm92aWRlcikge1xuXHRcdGFzc2VydEJyb3dzZXJFbnZpcm9ubWVudCgpO1xuXHRcdGFzc2VydERlZkFuZE5vdE51bGwocHJvdmlkZXIsICdTaWduLWluIHByb3ZpZGVyIG11c3QgYmUgZGVmaW5lZCcpO1xuXHRcdGFzc2VydFN1cHBvcnRlZFByb3ZpZGVyKHByb3ZpZGVyKTtcblxuXHRcdGlmICghcHJvdmlkZXIuaGFzUmVkaXJlY3RVcmkoKSkge1xuXHRcdFx0cHJvdmlkZXIuc2V0UmVkaXJlY3RVcmkodGhpcy5nZXRIcmVmV2l0aG91dEZyYWdtZW50XygpKTtcblx0XHR9XG5cdFx0Z2xvYmFscy53aW5kb3cubG9jYXRpb24uaHJlZiA9IHByb3ZpZGVyLm1ha2VBdXRob3JpemF0aW9uVXJsKHRoaXMud2VkZXBsb3lDbGllbnQuYXV0aFVybF8pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNpZ25zIG91dCA8Y29kZT5jdXJyZW50VXNlcjwvY29kZT4gYW5kIHJlbW92ZXMgZnJvbSA8Y29kZT5sb2NhbFN0b3JhZ2U8L2NvZGU+LlxuXHQgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cblx0ICovXG5cdHNpZ25PdXQoKSB7XG5cdFx0YXNzZXJ0VXNlclNpZ25lZEluKHRoaXMuY3VycmVudFVzZXIpO1xuXHRcdHJldHVybiB0aGlzLndlZGVwbG95Q2xpZW50XG5cdFx0XHQudXJsKHRoaXMud2VkZXBsb3lDbGllbnQuYXV0aFVybF8pXG5cdFx0XHQucGF0aCgnL29hdXRoL3Jldm9rZScpXG5cdFx0XHQucGFyYW0oJ3Rva2VuJywgdGhpcy5jdXJyZW50VXNlci50b2tlbilcblx0XHRcdC5nZXQoKVxuXHRcdFx0LnRoZW4ocmVzcG9uc2UgPT4gYXNzZXJ0UmVzcG9uc2VTdWNjZWVkZWQocmVzcG9uc2UpKVxuXHRcdFx0LnRoZW4ocmVzcG9uc2UgPT4ge1xuXHRcdFx0XHR0aGlzLm1heWJlQ2FsbE9uU2lnbk91dENhbGxiYWNrXygpO1xuXHRcdFx0XHR0aGlzLnVubG9hZEN1cnJlbnRVc2VyXygpO1xuXHRcdFx0XHRyZXR1cm4gcmVzcG9uc2U7XG5cdFx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBVbmxvYWRzIGFsbCBpbmZvcm1hdGlvbiBmb3IgPGNvZGU+Y3VycmVudFVzZXI8L2NvZGU+IGFuZCByZW1vdmVzIGZyb21cblx0ICogPGNvZGU+bG9jYWxTdG9yYWdlPC9jb2RlPiBpZiBwcmVzZW50LlxuXHQgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cblx0ICovXG5cdHVubG9hZEN1cnJlbnRVc2VyXygpIHtcblx0XHR0aGlzLmN1cnJlbnRVc2VyID0gbnVsbDtcblx0XHRpZiAodGhpcy5zdG9yYWdlKSB7XG5cdFx0XHR0aGlzLnN0b3JhZ2UucmVtb3ZlKCdjdXJyZW50VXNlcicpO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBhc3NlcnRTdXBwb3J0ZWRQcm92aWRlcihwcm92aWRlcikge1xuXHRzd2l0Y2ggKHByb3ZpZGVyLmNvbnN0cnVjdG9yLlBST1ZJREVSKSB7XG5cdFx0Y2FzZSBGYWNlYm9va0F1dGhQcm92aWRlci5QUk9WSURFUjpcblx0XHRjYXNlIEdpdGh1YkF1dGhQcm92aWRlci5QUk9WSURFUjpcblx0XHRjYXNlIEdvb2dsZUF1dGhQcm92aWRlci5QUk9WSURFUjpcblx0XHRcdGJyZWFrO1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1NpZ24taW4gcHJvdmlkZXIgbm90IHN1cHBvcnRlZCcpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEF1dGhBcGlIZWxwZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBFbWJvZGllZCBmcm9tICcuL0VtYm9kaWVkJztcbmltcG9ydCBSYW5nZSBmcm9tICcuL1JhbmdlJztcblxuLyoqXG4gKiBDbGFzcyB0aGF0IHJlcHJlc2VudHMgYSBzZWFyY2ggYWdncmVnYXRpb24uXG4gKi9cbmNsYXNzIEFnZ3JlZ2F0aW9uIHtcblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYW4ge0BsaW5rIEFnZ3JlZ2F0aW9ufSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBhZ2dyZWdhdGlvbiBmaWVsZC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhdG9yIFRoZSBhZ2dyZWdhdGlvbiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHsqPX0gb3B0X3ZhbHVlIFRoZSBhZ2dyZWdhdGlvbiB2YWx1ZS5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihmaWVsZCwgb3BlcmF0b3IsIG9wdF92YWx1ZSkge1xuXHRcdHRoaXMuZmllbGRfID0gZmllbGQ7XG5cdFx0dGhpcy5vcGVyYXRvcl8gPSBvcGVyYXRvcjtcblx0XHR0aGlzLnZhbHVlXyA9IG9wdF92YWx1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIHtAbGluayBBZ2dyZWdhdGlvbn0gaW5zdGFuY2Ugd2l0aCB0aGUgXCJhdmdcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBhZ2dyZWdhdGlvbiBmaWVsZC5cblx0ICogQHJldHVybiB7IUFnZ3JlZ2F0aW9ufVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgYXZnKGZpZWxkKSB7XG5cdFx0cmV0dXJuIEFnZ3JlZ2F0aW9uLmZpZWxkKGZpZWxkLCAnYXZnJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiB7QGxpbmsgQWdncmVnYXRpb259IGluc3RhbmNlIHdpdGggdGhlIFwiY291bnRcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBhZ2dyZWdhdGlvbiBmaWVsZC5cblx0ICogQHJldHVybiB7IUFnZ3JlZ2F0aW9ufVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgY291bnQoZmllbGQpIHtcblx0XHRyZXR1cm4gQWdncmVnYXRpb24uZmllbGQoZmllbGQsICdjb3VudCcpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4ge0BsaW5rIERpc3RhbmNlQWdncmVnYXRpb259IGluc3RhbmNlIHdpdGggdGhlIFwiZ2VvRGlzdGFuY2VcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBhZ2dyZWdhdGlvbiBmaWVsZC5cblx0ICogQHBhcmFtIHsqfSBsb2NhdGlvbiBUaGUgYWdncmVnYXRpb24gbG9jYXRpb24uXG5cdCAqIEBwYXJhbSB7Li4uIVJhbmdlfSByYW5nZXMgVGhlIGFnZ3JlZ2F0aW9uIHJhbmdlcy5cblx0ICogQHJldHVybiB7IURpc3RhbmNlQWdncmVnYXRpb259XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBkaXN0YW5jZShmaWVsZCwgbG9jYXRpb24sIC4uLnJhbmdlcykge1xuXHRcdHJldHVybiBuZXcgQWdncmVnYXRpb24uRGlzdGFuY2VBZ2dyZWdhdGlvbihmaWVsZCwgbG9jYXRpb24sIC4uLnJhbmdlcyk7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiB7QGxpbmsgQWdncmVnYXRpb259IGluc3RhbmNlIHdpdGggdGhlIFwiZXh0ZW5kZWRTdGF0c1wiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGFnZ3JlZ2F0aW9uIGZpZWxkLlxuXHQgKiBAcmV0dXJuIHshQWdncmVnYXRpb259XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBleHRlbmRlZFN0YXRzKGZpZWxkKSB7XG5cdFx0cmV0dXJuIEFnZ3JlZ2F0aW9uLmZpZWxkKGZpZWxkLCAnZXh0ZW5kZWRTdGF0cycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhpcyBhZ2dyZWdhdGlvbidzIGZpZWxkLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuXHRnZXRGaWVsZCgpIHtcblx0XHRyZXR1cm4gdGhpcy5maWVsZF87XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGlzIGFnZ3JlZ2F0aW9uJ3Mgb3BlcmF0b3IuXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdGdldE9wZXJhdG9yKCkge1xuXHRcdHJldHVybiB0aGlzLm9wZXJhdG9yXztcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoaXMgYWdncmVnYXRpb24ncyB2YWx1ZS5cblx0ICogQHJldHVybiB7Kn1cblx0ICovXG5cdGdldFZhbHVlKCkge1xuXHRcdHJldHVybiB0aGlzLnZhbHVlXztcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIHtAbGluayBBZ2dyZWdhdGlvbn0gaW5zdGFuY2Ugd2l0aCB0aGUgXCJoaXN0b2dyYW1cIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBhZ2dyZWdhdGlvbiBmaWVsZC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGludGVydmFsIFRoZSBoaXN0b2dyYW0ncyBpbnRlcnZhbC5cblx0ICogQHJldHVybiB7IUFnZ3JlZ2F0aW9ufVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgaGlzdG9ncmFtKGZpZWxkLCBpbnRlcnZhbCkge1xuXHRcdHJldHVybiBuZXcgQWdncmVnYXRpb24oZmllbGQsICdoaXN0b2dyYW0nLCBpbnRlcnZhbCk7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiB7QGxpbmsgQWdncmVnYXRpb259IGluc3RhbmNlIHdpdGggdGhlIFwibWF4XCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgYWdncmVnYXRpb24gZmllbGQuXG5cdCAqIEByZXR1cm4geyFBZ2dyZWdhdGlvbn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIG1heChmaWVsZCkge1xuXHRcdHJldHVybiBBZ2dyZWdhdGlvbi5maWVsZChmaWVsZCwgJ21heCcpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4ge0BsaW5rIEFnZ3JlZ2F0aW9ufSBpbnN0YW5jZSB3aXRoIHRoZSBcIm1pblwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGFnZ3JlZ2F0aW9uIGZpZWxkLlxuXHQgKiBAcmV0dXJuIHshQWdncmVnYXRpb259XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBtaW4oZmllbGQpIHtcblx0XHRyZXR1cm4gQWdncmVnYXRpb24uZmllbGQoZmllbGQsICdtaW4nKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIHtAbGluayBBZ2dyZWdhdGlvbn0gaW5zdGFuY2Ugd2l0aCB0aGUgXCJtaXNzaW5nXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgYWdncmVnYXRpb24gZmllbGQuXG5cdCAqIEByZXR1cm4geyFBZ2dyZWdhdGlvbn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIG1pc3NpbmcoZmllbGQpIHtcblx0XHRyZXR1cm4gQWdncmVnYXRpb24uZmllbGQoZmllbGQsICdtaXNzaW5nJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgQWdncmVnYXRpb259IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGFnZ3JlZ2F0aW9uIGZpZWxkLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3IgVGhlIGFnZ3JlZ2F0aW9uIG9wZXJhdG9yLlxuXHQgKiBAcmV0dXJuIHshQWdncmVnYXRpb259XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBmaWVsZChmaWVsZCwgb3BlcmF0b3IpIHtcblx0XHRyZXR1cm4gbmV3IEFnZ3JlZ2F0aW9uKGZpZWxkLCBvcGVyYXRvcik7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiB7QGxpbmsgUmFuZ2VBZ2dyZWdhdGlvbn0gaW5zdGFuY2Ugd2l0aCB0aGUgXCJyYW5nZVwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGFnZ3JlZ2F0aW9uIGZpZWxkLlxuXHQgKiBAcGFyYW0gey4uLiFSYW5nZX0gcmFuZ2VzIFRoZSBhZ2dyZWdhdGlvbiByYW5nZXMuXG5cdCAqIEByZXR1cm4geyFSYW5nZUFnZ3JlZ2F0aW9ufVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgcmFuZ2UoZmllbGQsIC4uLnJhbmdlcykge1xuXHRcdHJldHVybiBuZXcgQWdncmVnYXRpb24uUmFuZ2VBZ2dyZWdhdGlvbihmaWVsZCwgLi4ucmFuZ2VzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIHtAbGluayBBZ2dyZWdhdGlvbn0gaW5zdGFuY2Ugd2l0aCB0aGUgXCJzdGF0c1wiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGFnZ3JlZ2F0aW9uIGZpZWxkLlxuXHQgKiBAcmV0dXJuIHshQWdncmVnYXRpb259XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBzdGF0cyhmaWVsZCkge1xuXHRcdHJldHVybiBBZ2dyZWdhdGlvbi5maWVsZChmaWVsZCwgJ3N0YXRzJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiB7QGxpbmsgQWdncmVnYXRpb259IGluc3RhbmNlIHdpdGggdGhlIFwic3VtXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgYWdncmVnYXRpb24gZmllbGQuXG5cdCAqIEByZXR1cm4geyFBZ2dyZWdhdGlvbn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIHN1bShmaWVsZCkge1xuXHRcdHJldHVybiBBZ2dyZWdhdGlvbi5maWVsZChmaWVsZCwgJ3N1bScpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4ge0BsaW5rIEFnZ3JlZ2F0aW9ufSBpbnN0YW5jZSB3aXRoIHRoZSBcInRlcm1zXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgYWdncmVnYXRpb24gZmllbGQuXG5cdCAqIEByZXR1cm4geyFBZ2dyZWdhdGlvbn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIHRlcm1zKGZpZWxkKSB7XG5cdFx0cmV0dXJuIEFnZ3JlZ2F0aW9uLmZpZWxkKGZpZWxkLCAndGVybXMnKTtcblx0fVxufVxuXG4vKipcbiAqIENsYXNzIHRoYXQgcmVwcmVzZW50cyBhIGRpc3RhbmNlIGFnZ3JlZ2F0aW9uLlxuICogQGV4dGVuZHMge0FnZ3JlZ2F0aW9ufVxuICovXG5jbGFzcyBEaXN0YW5jZUFnZ3JlZ2F0aW9uIGV4dGVuZHMgQWdncmVnYXRpb24ge1xuXHQvKipcblx0ICogQ29uc3RydWN0cyBhbiB7QGxpbmsgRGlzdGFuY2VBZ2dyZWdhdGlvbn0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgYWdncmVnYXRpb24gZmllbGQuXG5cdCAqIEBwYXJhbSB7Kn0gbG9jYXRpb24gVGhlIGFnZ3JlZ2F0aW9uIGxvY2F0aW9uLlxuXHQgKiBAcGFyYW0gey4uLiFSYW5nZX0gcmFuZ2VzIFRoZSBhZ2dyZWdhdGlvbiByYW5nZXMuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0Y29uc3RydWN0b3IoZmllbGQsIGxvY2F0aW9uLCAuLi5yYW5nZXMpIHtcblx0XHRzdXBlcihmaWVsZCwgJ2dlb0Rpc3RhbmNlJywge30pO1xuXHRcdHRoaXMudmFsdWVfLmxvY2F0aW9uID0gRW1ib2RpZWQudG9Cb2R5KGxvY2F0aW9uKTtcblx0XHR0aGlzLnZhbHVlXy5yYW5nZXMgPSByYW5nZXMubWFwKHJhbmdlID0+IHJhbmdlLmJvZHkoKSk7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIHJhbmdlIHRvIHRoaXMgYWdncmVnYXRpb24uXG5cdCAqIEBwYXJhbSB7Kn0gcmFuZ2VPckZyb21cblx0ICogQHBhcmFtIHsqPX0gb3B0X3RvXG5cdCAqIEBjaGFpbm5hYmxlXG5cdCAqL1xuXHRyYW5nZShyYW5nZU9yRnJvbSwgb3B0X3RvKSB7XG5cdFx0dmFyIHJhbmdlID0gcmFuZ2VPckZyb207XG5cdFx0aWYgKCEocmFuZ2UgaW5zdGFuY2VvZiBSYW5nZSkpIHtcblx0XHRcdHJhbmdlID0gUmFuZ2UucmFuZ2UocmFuZ2VPckZyb20sIG9wdF90byk7XG5cdFx0fVxuXHRcdHRoaXMudmFsdWVfLnJhbmdlcy5wdXNoKHJhbmdlLmJvZHkoKSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGlzIGFnZ3JlZ2F0aW9uJ3MgdW5pdC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHVuaXRcblx0ICogQGNoYWlubmFibGVcblx0ICovXG5cdHVuaXQodW5pdCkge1xuXHRcdHRoaXMudmFsdWVfLnVuaXQgPSB1bml0O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59XG5BZ2dyZWdhdGlvbi5EaXN0YW5jZUFnZ3JlZ2F0aW9uID0gRGlzdGFuY2VBZ2dyZWdhdGlvbjtcblxuLyoqXG4gKiBDbGFzcyB0aGF0IHJlcHJlc2VudHMgYSByYW5nZSBhZ2dyZWdhdGlvbi5cbiAqIEBleHRlbmRzIHtBZ2dyZWdhdGlvbn1cbiAqL1xuY2xhc3MgUmFuZ2VBZ2dyZWdhdGlvbiBleHRlbmRzIEFnZ3JlZ2F0aW9uIHtcblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYW4ge0BsaW5rIFJhbmdlQWdncmVnYXRpb259IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGFnZ3JlZ2F0aW9uIGZpZWxkLlxuXHQgKiBAcGFyYW0gey4uLiFSYW5nZX0gcmFuZ2VzIFRoZSBhZ2dyZWdhdGlvbiByYW5nZXMuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0Y29uc3RydWN0b3IoZmllbGQsIC4uLnJhbmdlcykge1xuXHRcdHN1cGVyKGZpZWxkLCAncmFuZ2UnKTtcblx0XHR0aGlzLnZhbHVlXyA9IHJhbmdlcy5tYXAocmFuZ2UgPT4gcmFuZ2UuYm9keSgpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgcmFuZ2UgdG8gdGhpcyBhZ2dyZWdhdGlvbi5cblx0ICogQHBhcmFtIHsqfSByYW5nZU9yRnJvbVxuXHQgKiBAcGFyYW0geyo9fSBvcHRfdG9cblx0ICogQGNoYWlubmFibGVcblx0ICovXG5cdHJhbmdlKHJhbmdlT3JGcm9tLCBvcHRfdG8pIHtcblx0XHR2YXIgcmFuZ2UgPSByYW5nZU9yRnJvbTtcblx0XHRpZiAoIShyYW5nZSBpbnN0YW5jZW9mIFJhbmdlKSkge1xuXHRcdFx0cmFuZ2UgPSBSYW5nZS5yYW5nZShyYW5nZU9yRnJvbSwgb3B0X3RvKTtcblx0XHR9XG5cdFx0dGhpcy52YWx1ZV8ucHVzaChyYW5nZS5ib2R5KCkpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59XG5BZ2dyZWdhdGlvbi5SYW5nZUFnZ3JlZ2F0aW9uID0gUmFuZ2VBZ2dyZWdhdGlvbjtcblxuZXhwb3J0IGRlZmF1bHQgQWdncmVnYXRpb247XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7IGNvcmUgfSBmcm9tICdtZXRhbCc7XG5pbXBvcnQgRW1ib2RpZWQgZnJvbSAnLi9FbWJvZGllZCc7XG5pbXBvcnQgRmlsdGVyIGZyb20gJy4vRmlsdGVyJztcbmltcG9ydCBBZ2dyZWdhdGlvbiBmcm9tICcuL0FnZ3JlZ2F0aW9uJztcblxuLyoqXG4gKiBDbGFzcyByZXNwb25zaWJsZSBmb3IgYnVpbGRpbmcgcXVlcmllcy5cbiAqIEBleHRlbmRzIHtFbWJvZGllZH1cbiAqL1xuY2xhc3MgUXVlcnkgZXh0ZW5kcyBFbWJvZGllZCB7XG5cdC8qKlxuXHQgKiBBZGRzIGFuIGFnZ3JlZ2F0aW9uIHRvIHRoaXMge0BsaW5rIFF1ZXJ5fSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIGFnZ3JlZ2F0aW9uIG5hbWUuXG5cdCAqIEBwYXJhbSB7IUFnZ3JlZ2F0aW9ufHN0cmluZ30gYWdncmVnYXRpb25PckZpZWxkIEVpdGhlciBhblxuXHQgKiAgIHtAbGluayBBZ2dyZWdhdGlvbn0gaW5zdGFuY2Ugb3IgdGhlIG5hbWUgb2YgdGhlIGFnZ3JlZ2F0aW9uIGZpZWxkLlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9vcGVyYXRvciBUaGUgYWdncmVnYXRpb24gb3BlcmF0b3IuXG5cdCAqIEByZXR1cm4geyFRdWVyeX1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGFnZ3JlZ2F0ZShuYW1lLCBhZ2dyZWdhdGlvbk9yRmllbGQsIG9wdF9vcGVyYXRvcikge1xuXHRcdHJldHVybiBuZXcgUXVlcnkoKS5hZ2dyZWdhdGUobmFtZSwgYWdncmVnYXRpb25PckZpZWxkLCBvcHRfb3BlcmF0b3IpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhpcyBxdWVyeSdzIHR5cGUgdG8gXCJjb3VudFwiLlxuXHQgKiBAcmV0dXJuIHshUXVlcnl9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBjb3VudCgpIHtcblx0XHRyZXR1cm4gbmV3IFF1ZXJ5KCkudHlwZSgnY291bnQnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoaXMgcXVlcnkncyB0eXBlIHRvIFwiZmV0Y2hcIi5cblx0ICogQHJldHVybiB7IVF1ZXJ5fVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgZmV0Y2goKSB7XG5cdFx0cmV0dXJuIG5ldyBRdWVyeSgpLnR5cGUoJ2ZldGNoJyk7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIGZpbHRlciB0byB0aGlzIFF1ZXJ5LlxuXHQgKiBAcGFyYW0geyFGaWx0ZXJ8c3RyaW5nfSBmaWVsZE9yRmlsdGVyIEVpdGhlciBhIHtAbGluayBGaWx0ZXJ9IG9yIHRoZVxuXHQgKiAgIG5hbWUgb2YgdGhlIGZpZWxkIHRvIGZpbHRlciBieS5cblx0ICogQHBhcmFtIHsqPX0gb3B0X29wZXJhdG9yT3JWYWx1ZSBFaXRoZXIgdGhlIGZpZWxkJ3Mgb3BlcmF0b3Igb3IgaXRzIHZhbHVlLlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfdmFsdWUgVGhlIGZpbHRlcidzIHZhbHVlLlxuXHQgKiBAcmV0dXJuIHshUXVlcnl9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBmaWx0ZXIoZmllbGRPckZpbHRlciwgb3B0X29wZXJhdG9yT3JWYWx1ZSwgb3B0X3ZhbHVlKSB7XG5cdFx0cmV0dXJuIG5ldyBRdWVyeSgpLmZpbHRlcihmaWVsZE9yRmlsdGVyLCBvcHRfb3BlcmF0b3JPclZhbHVlLCBvcHRfdmFsdWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHF1ZXJ5IG9mZnNldC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBUaGUgaW5kZXggb2YgdGhlIGZpcnN0IGVudHJ5IHRoYXQgc2hvdWxkIGJlIHJldHVybmVkXG5cdCAqICAgYnkgdGhpcyBxdWVyeS5cblx0ICogQHJldHVybiB7IVF1ZXJ5fVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgb2Zmc2V0KG9mZnNldCkge1xuXHRcdHJldHVybiBuZXcgUXVlcnkoKS5vZmZzZXQob2Zmc2V0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgaGlnaGxpZ2h0IGVudHJ5IHRvIHRoaXMge0BsaW5rIFF1ZXJ5fSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBmaWVsZCdzIG5hbWUuXG5cdCAqIEByZXR1cm4geyFRdWVyeX1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGhpZ2hsaWdodChmaWVsZCkge1xuXHRcdHJldHVybiBuZXcgUXVlcnkoKS5oaWdobGlnaHQoZmllbGQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHF1ZXJ5IGxpbWl0LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gbGltaXQgVGhlIG1heCBhbW91bnQgb2YgZW50cmllcyB0aGF0IHRoaXMgcXVlcnkgc2hvdWxkIHJldHVybi5cblx0ICogQHJldHVybiB7IVF1ZXJ5fVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgbGltaXQobGltaXQpIHtcblx0XHRyZXR1cm4gbmV3IFF1ZXJ5KCkubGltaXQobGltaXQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBzZWFyY2ggdG8gdGhpcyB7QGxpbmsgUXVlcnl9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0geyFGaWx0ZXJ8c3RyaW5nfSBmaWx0ZXJPclRleHRPckZpZWxkIElmIG5vIG90aGVyIGFyZ3VtZW50c1xuXHQgKiAgIGFyZSBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbiwgdGhpcyBzaG91bGQgYmUgZWl0aGVyIGEge0BsaW5rIEZpbHRlcn1cblx0ICogICBpbnN0YW5jZSBvciBhIHRleHQgdG8gYmUgdXNlZCBpbiBhIG1hdGNoIGZpbHRlci4gSW4gYm90aCBjYXNlc1xuXHQgKiAgIHRoZSBmaWx0ZXIgd2lsbCBiZSBhcHBsaWVkIHRvIGFsbCBmaWVsZHMuIEFub3RoZXIgb3B0aW9uIGlzIHRvXG5cdCAqICAgcGFzcyB0aGlzIGFzIGEgZmllbGQgbmFtZSBpbnN0ZWFkLCB0b2dldGhlciB3aXRoIG90aGVyIGFyZ3VtZW50c1xuXHQgKiAgIHNvIHRoZSBmaWx0ZXIgY2FuIGJlIGNyZWF0ZWQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X3RleHRPck9wZXJhdG9yIEVpdGhlciBhIHRleHQgdG8gYmUgdXNlZCBpbiBhXG5cdCAqICAgbWF0Y2ggZmlsdGVyLCBvciB0aGUgb3BlcmF0b3IgdGhhdCBzaG91bGQgYmUgdXNlZC5cblx0ICogQHBhcmFtIHsqPX0gb3B0X3ZhbHVlIFRoZSB2YWx1ZSB0byBiZSB1c2VkIGJ5IHRoZSBmaWx0ZXIuIFNob3VsZFxuXHQgKiAgIG9ubHkgYmUgcGFzc2VkIGlmIGFuIG9wZXJhdG9yIHdhcyBwYXNzZWQgYXMgdGhlIHNlY29uZCBhcmd1bWVudC5cblx0ICogQHJldHVybiB7IVF1ZXJ5fVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgc2VhcmNoKGZpbHRlck9yVGV4dE9yRmllbGQsIG9wdF90ZXh0T3JPcGVyYXRvciwgb3B0X3ZhbHVlKSB7XG5cdFx0cmV0dXJuIG5ldyBRdWVyeSgpLnNlYXJjaChmaWx0ZXJPclRleHRPckZpZWxkLCBvcHRfdGV4dE9yT3BlcmF0b3IsIG9wdF92YWx1ZSk7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIHNvcnQgZW50cnkgdG8gdGhpcyBxdWVyeSwgc3BlY2lmeWluZyB0aGUgZmllbGQgdGhpcyBxdWVyeSBzaG91bGQgYmVcblx0ICogc29ydGVkIGJ5IGFuZCwgb3B0aW9uYWxseSwgdGhlIHNvcnQgZGlyZWN0aW9uLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGZpZWxkIHRoYXQgdGhlIHF1ZXJ5IHNob3VsZCBiZSBzb3J0ZWQgYnkuXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X2RpcmVjdGlvbiBUaGUgZGlyZWN0aW9uIHRoZSBzb3J0IG9wZXJhdGlvbiBzaG91bGQgdXNlLlxuXHQgKiAgIElmIG5vbmUgaXMgZ2l2ZW4sIFwiYXNjXCIgaXMgdXNlZCBieSBkZWZhdWx0LlxuXHQgKiBAcmV0dXJuIHshUXVlcnl9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBzb3J0KGZpZWxkLCBvcHRfZGlyZWN0aW9uKSB7XG5cdFx0cmV0dXJuIG5ldyBRdWVyeSgpLnNvcnQoZmllbGQsIG9wdF9kaXJlY3Rpb24pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHF1ZXJ5IHR5cGUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFRoZSBxdWVyeSdzIHR5cGUuIEZvciBleGFtcGxlOiBcImNvdW50XCIsIFwiZmV0Y2hcIi5cblx0ICogQHJldHVybiB7IVF1ZXJ5fVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgdHlwZSh0eXBlKSB7XG5cdFx0cmV0dXJuIG5ldyBRdWVyeSgpLnR5cGUodHlwZSk7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhbiBhZ2dyZWdhdGlvbiB0byB0aGlzIHtAbGluayBRdWVyeX0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBhZ2dyZWdhdGlvbiBuYW1lLlxuXHQgKiBAcGFyYW0geyFBZ2dyZWdhdGlvbnxzdHJpbmd9IGFnZ3JlZ2F0aW9uT3JGaWVsZCBFaXRoZXIgYW5cblx0ICogICB7QGxpbmsgQWdncmVnYXRpb259IGluc3RhbmNlIG9yIHRoZSBuYW1lIG9mIHRoZSBhZ2dyZWdhdGlvbiBmaWVsZC5cblx0ICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfb3BlcmF0b3IgVGhlIGFnZ3JlZ2F0aW9uIG9wZXJhdG9yLlxuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cblx0YWdncmVnYXRlKG5hbWUsIGFnZ3JlZ2F0aW9uT3JGaWVsZCwgb3B0X29wZXJhdG9yKSB7XG5cdFx0dmFyIGFnZ3JlZ2F0aW9uID0gYWdncmVnYXRpb25PckZpZWxkO1xuXHRcdGlmICghKGFnZ3JlZ2F0aW9uIGluc3RhbmNlb2YgQWdncmVnYXRpb24pKSB7XG5cdFx0XHRhZ2dyZWdhdGlvbiA9IEFnZ3JlZ2F0aW9uLmZpZWxkKGFnZ3JlZ2F0aW9uT3JGaWVsZCwgb3B0X29wZXJhdG9yKTtcblx0XHR9XG5cblx0XHR2YXIgZmllbGQgPSBhZ2dyZWdhdGlvbi5nZXRGaWVsZCgpO1xuXHRcdHZhciB2YWx1ZSA9IHt9O1xuXHRcdHZhbHVlW2ZpZWxkXSA9IHtcblx0XHRcdG5hbWU6IG5hbWUsXG5cdFx0XHRvcGVyYXRvcjogYWdncmVnYXRpb24uZ2V0T3BlcmF0b3IoKVxuXHRcdH07XG5cdFx0aWYgKGNvcmUuaXNEZWZBbmROb3ROdWxsKGFnZ3JlZ2F0aW9uLmdldFZhbHVlKCkpKSB7XG5cdFx0XHR2YWx1ZVtmaWVsZF0udmFsdWUgPSBhZ2dyZWdhdGlvbi5nZXRWYWx1ZSgpO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5ib2R5Xy5hZ2dyZWdhdGlvbikge1xuXHRcdFx0dGhpcy5ib2R5Xy5hZ2dyZWdhdGlvbiA9IFtdO1xuXHRcdH1cblx0XHR0aGlzLmJvZHlfLmFnZ3JlZ2F0aW9uLnB1c2godmFsdWUpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhpcyBxdWVyeSdzIHR5cGUgdG8gXCJjb3VudFwiLlxuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cblx0Y291bnQoKSB7XG5cdFx0cmV0dXJuIHRoaXMudHlwZSgnY291bnQnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoaXMgcXVlcnkncyB0eXBlIHRvIFwiZmV0Y2hcIi5cblx0ICogQGNoYWlubmFibGVcblx0ICovXG5cdGZldGNoKCkge1xuXHRcdHJldHVybiB0aGlzLnR5cGUoJ2ZldGNoJyk7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIGZpbHRlciB0byB0aGlzIFF1ZXJ5LlxuXHQgKiBAcGFyYW0geyFGaWx0ZXJ8c3RyaW5nfSBmaWVsZE9yRmlsdGVyIEVpdGhlciBhIHtAbGluayBGaWx0ZXJ9IG9yIHRoZVxuXHQgKiAgIG5hbWUgb2YgdGhlIGZpZWxkIHRvIGZpbHRlciBieS5cblx0ICogQHBhcmFtIHsqPX0gb3B0X29wZXJhdG9yT3JWYWx1ZSBFaXRoZXIgdGhlIGZpZWxkJ3Mgb3BlcmF0b3Igb3IgaXRzIHZhbHVlLlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfdmFsdWUgVGhlIGZpbHRlcidzIHZhbHVlLlxuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cblx0ZmlsdGVyKGZpZWxkT3JGaWx0ZXIsIG9wdF9vcGVyYXRvck9yVmFsdWUsIG9wdF92YWx1ZSkge1xuXHRcdGxldCBmaWx0ZXIgPSBGaWx0ZXIudG9GaWx0ZXIoZmllbGRPckZpbHRlciwgb3B0X29wZXJhdG9yT3JWYWx1ZSwgb3B0X3ZhbHVlKTtcblx0XHRpZiAoIXRoaXMuYm9keV8uZmlsdGVyKSB7XG5cdFx0XHR0aGlzLmJvZHlfLmZpbHRlciA9IFtdO1xuXHRcdH1cblx0XHR0aGlzLmJvZHlfLmZpbHRlci5wdXNoKGZpbHRlci5ib2R5KCkpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHF1ZXJ5IG9mZnNldC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBUaGUgaW5kZXggb2YgdGhlIGZpcnN0IGVudHJ5IHRoYXQgc2hvdWxkIGJlIHJldHVybmVkXG5cdCAqICAgYnkgdGhpcyBxdWVyeS5cblx0ICogQGNoYWlubmFibGVcblx0ICovXG5cdG9mZnNldChvZmZzZXQpIHtcblx0XHR0aGlzLmJvZHlfLm9mZnNldCA9IG9mZnNldDtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgaGlnaGxpZ2h0IGVudHJ5IHRvIHRoaXMge0BsaW5rIFF1ZXJ5fSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBmaWVsZCdzIG5hbWUuXG5cdCAqIEBjaGFpbm5hYmxlXG5cdCAqL1xuXHRoaWdobGlnaHQoZmllbGQpIHtcblx0XHRpZiAoIXRoaXMuYm9keV8uaGlnaGxpZ2h0KSB7XG5cdFx0XHR0aGlzLmJvZHlfLmhpZ2hsaWdodCA9IFtdO1xuXHRcdH1cblxuXHRcdHRoaXMuYm9keV8uaGlnaGxpZ2h0LnB1c2goZmllbGQpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHF1ZXJ5IGxpbWl0LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gbGltaXQgVGhlIG1heCBhbW91bnQgb2YgZW50cmllcyB0aGF0IHRoaXMgcXVlcnkgc2hvdWxkIHJldHVybi5cblx0ICogQGNoYWlubmFibGVcblx0ICovXG5cdGxpbWl0KGxpbWl0KSB7XG5cdFx0dGhpcy5ib2R5Xy5saW1pdCA9IGxpbWl0O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBzZWFyY2ggdG8gdGhpcyB7QGxpbmsgUXVlcnl9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0geyFGaWx0ZXJ8c3RyaW5nfSBmaWx0ZXJPclRleHRPckZpZWxkIElmIG5vIG90aGVyIGFyZ3VtZW50c1xuXHQgKiAgIGFyZSBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbiwgdGhpcyBzaG91bGQgYmUgZWl0aGVyIGEge0BsaW5rIEZpbHRlcn1cblx0ICogICBpbnN0YW5jZSBvciBhIHRleHQgdG8gYmUgdXNlZCBpbiBhIG1hdGNoIGZpbHRlci4gSW4gYm90aCBjYXNlc1xuXHQgKiAgIHRoZSBmaWx0ZXIgd2lsbCBiZSBhcHBsaWVkIHRvIGFsbCBmaWVsZHMuIEFub3RoZXIgb3B0aW9uIGlzIHRvXG5cdCAqICAgcGFzcyB0aGlzIGFzIGEgZmllbGQgbmFtZSBpbnN0ZWFkLCB0b2dldGhlciB3aXRoIG90aGVyIGFyZ3VtZW50c1xuXHQgKiAgIHNvIHRoZSBmaWx0ZXIgY2FuIGJlIGNyZWF0ZWQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X3RleHRPck9wZXJhdG9yIEVpdGhlciBhIHRleHQgdG8gYmUgdXNlZCBpbiBhXG5cdCAqICAgbWF0Y2ggZmlsdGVyLCBvciB0aGUgb3BlcmF0b3IgdGhhdCBzaG91bGQgYmUgdXNlZC5cblx0ICogQHBhcmFtIHsqPX0gb3B0X3ZhbHVlIFRoZSB2YWx1ZSB0byBiZSB1c2VkIGJ5IHRoZSBmaWx0ZXIuIFNob3VsZFxuXHQgKiAgIG9ubHkgYmUgcGFzc2VkIGlmIGFuIG9wZXJhdG9yIHdhcyBwYXNzZWQgYXMgdGhlIHNlY29uZCBhcmd1bWVudC5cblx0ICogQGNoYWlubmFibGVcblx0ICovXG5cdHNlYXJjaChmaWx0ZXJPclRleHRPckZpZWxkLCBvcHRfdGV4dE9yT3BlcmF0b3IsIG9wdF92YWx1ZSkge1xuXHRcdHZhciBmaWx0ZXIgPSBmaWx0ZXJPclRleHRPckZpZWxkO1xuXG5cdFx0aWYgKG9wdF92YWx1ZSkge1xuXHRcdFx0ZmlsdGVyID0gRmlsdGVyLmZpZWxkKGZpbHRlck9yVGV4dE9yRmllbGQsIG9wdF90ZXh0T3JPcGVyYXRvciwgb3B0X3ZhbHVlKTtcblx0XHR9IGVsc2UgaWYgKG9wdF90ZXh0T3JPcGVyYXRvcikge1xuXHRcdFx0ZmlsdGVyID0gRmlsdGVyLm1hdGNoKGZpbHRlck9yVGV4dE9yRmllbGQsIG9wdF90ZXh0T3JPcGVyYXRvcik7XG5cdFx0fSBlbHNlIGlmICghKGZpbHRlciBpbnN0YW5jZW9mIEZpbHRlcikpIHtcblx0XHRcdGZpbHRlciA9IEZpbHRlci5tYXRjaChmaWx0ZXJPclRleHRPckZpZWxkKTtcblx0XHR9XG5cblx0XHRpZiAoIXRoaXMuYm9keV8uc2VhcmNoKSB7XG5cdFx0XHR0aGlzLmJvZHlfLnNlYXJjaCA9IFtdO1xuXHRcdH1cblxuXHRcdGlmIChjb3JlLmlzRGVmQW5kTm90TnVsbChmaWx0ZXJPclRleHRPckZpZWxkKSkge1xuXHRcdFx0dGhpcy5ib2R5Xy5zZWFyY2gucHVzaChmaWx0ZXIuYm9keSgpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5ib2R5Xy5zZWFyY2gucHVzaCh7fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIHNvcnQgZW50cnkgdG8gdGhpcyBxdWVyeSwgc3BlY2lmeWluZyB0aGUgZmllbGQgdGhpcyBxdWVyeSBzaG91bGQgYmVcblx0ICogc29ydGVkIGJ5IGFuZCwgb3B0aW9uYWxseSwgdGhlIHNvcnQgZGlyZWN0aW9uLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGZpZWxkIHRoYXQgdGhlIHF1ZXJ5IHNob3VsZCBiZSBzb3J0ZWQgYnkuXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X2RpcmVjdGlvbiBUaGUgZGlyZWN0aW9uIHRoZSBzb3J0IG9wZXJhdGlvbiBzaG91bGQgdXNlLlxuXHQgKiAgIElmIG5vbmUgaXMgZ2l2ZW4sIFwiYXNjXCIgaXMgdXNlZCBieSBkZWZhdWx0LlxuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cblx0c29ydChmaWVsZCwgb3B0X2RpcmVjdGlvbikge1xuXHRcdGlmICghdGhpcy5ib2R5Xy5zb3J0KSB7XG5cdFx0XHR0aGlzLmJvZHlfLnNvcnQgPSBbXTtcblx0XHR9XG5cdFx0dmFyIHNvcnRFbnRyeSA9IHt9O1xuXHRcdHNvcnRFbnRyeVtmaWVsZF0gPSBvcHRfZGlyZWN0aW9uIHx8ICdhc2MnO1xuXHRcdHRoaXMuYm9keV8uc29ydC5wdXNoKHNvcnRFbnRyeSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgcXVlcnkgdHlwZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVGhlIHF1ZXJ5J3MgdHlwZS4gRm9yIGV4YW1wbGU6IFwiY291bnRcIiwgXCJmZXRjaFwiLlxuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cblx0dHlwZSh0eXBlKSB7XG5cdFx0dGhpcy5ib2R5Xy50eXBlID0gdHlwZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBRdWVyeTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEFwaUhlbHBlciBmcm9tICcuLi9BcGlIZWxwZXInO1xuaW1wb3J0IFF1ZXJ5IGZyb20gJy4uLy4uL2FwaS1xdWVyeS9RdWVyeSc7XG5pbXBvcnQgRmlsdGVyIGZyb20gJy4uLy4uL2FwaS1xdWVyeS9GaWx0ZXInO1xuaW1wb3J0IHsgYXNzZXJ0RGVmQW5kTm90TnVsbCwgYXNzZXJ0T2JqZWN0LCBhc3NlcnRSZXNwb25zZVN1Y2NlZWRlZCB9IGZyb20gJy4uL2Fzc2VydGlvbnMnO1xuaW1wb3J0IHsgY29yZSB9IGZyb20gJ21ldGFsJztcblxuLyoqXG4gKiBDbGFzcyByZXNwb25zaWJsZSBmb3IgZW5jYXBzdWxhdGUgZGF0YSBhcGkgY2FsbHMuXG4gKi9cbmNsYXNzIERhdGFBcGlIZWxwZXIgZXh0ZW5kcyBBcGlIZWxwZXIge1xuXHQvKipcblx0ICogQ29uc3RydWN0cyBhbiB7QGxpbmsgRGF0YUFwaUhlbHBlcn0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7QGxpbmsgV2VEZXBsb3l9IGluc3RhbmNlLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGNvbnN0cnVjdG9yKHdlZGVwbG95Q2xpZW50KSB7XG5cdFx0c3VwZXIod2VkZXBsb3lDbGllbnQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBmaWx0ZXIgdG8gdGhpcyByZXF1ZXN0J3Mge0BsaW5rIFF1ZXJ5fS5cblx0ICogQHBhcmFtIHshRmlsdGVyfHN0cmluZ30gZmllbGRPckZpbHRlciBFaXRoZXIgYSBGaWx0ZXIgaW5zdGFuY2Ugb3IgdGhlXG5cdCAqICAgbmFtZSBvZiB0aGUgZmllbGQgdG8gZmlsdGVyIGJ5LlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfb3BlcmF0b3JPclZhbHVlIEVpdGhlciB0aGUgZmllbGQncyBvcGVyYXRvciBvciBpdHMgdmFsdWUuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF92YWx1ZSBUaGUgZmlsdGVyJ3MgdmFsdWUuXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdHdoZXJlKGZpZWxkT3JGaWx0ZXIsIG9wdF9vcGVyYXRvck9yVmFsdWUsIG9wdF92YWx1ZSkge1xuXHRcdHRoaXMuZ2V0T3JDcmVhdGVGaWx0ZXJfKCkuYW5kKGZpZWxkT3JGaWx0ZXIsIG9wdF9vcGVyYXRvck9yVmFsdWUsIG9wdF92YWx1ZSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIGZpbHRlciB0byBiZSBjb21wb3NlZCB3aXRoIHRoaXMgZmlsdGVyIHVzaW5nIHRoZSBcIm9yXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7IUZpbHRlcnxzdHJpbmd9IGZpZWxkT3JGaWx0ZXIgRWl0aGVyIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2Ugb3Jcblx0ICogICB0aGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gZmlsdGVyIGJ5LlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfb3BlcmF0b3JPclZhbHVlIEVpdGhlciB0aGUgZmllbGQncyBvcGVyYXRvciBvciBpdHMgdmFsdWUuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF92YWx1ZSBUaGUgZmlsdGVyJ3MgdmFsdWUuXG5cdCAqIEBjaGFpbm5hYmxlXG5cdCAqL1xuXHRvcihmaWVsZE9yRmlsdGVyLCBvcHRfb3BlcmF0b3JPclZhbHVlLCBvcHRfdmFsdWUpIHtcblx0XHRpZiAodGhpcy5nZXRPckNyZWF0ZUZpbHRlcl8oKS5ib2R5KCkuYW5kLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0dGhyb3cgRXJyb3IoJ0l0XFwncyByZXF1aXJlZCB0byBoYXZlIGEgY29uZGl0aW9uIGJlZm9yZSB1c2luZyBhbiBcXCdvcigpXFwnIGZvciB0aGUgZmlyc3QgdGltZS4nKTtcblx0XHR9XG5cdFx0dGhpcy5nZXRPckNyZWF0ZUZpbHRlcl8oKS5vcihmaWVsZE9yRmlsdGVyLCBvcHRfb3BlcmF0b3JPclZhbHVlLCBvcHRfdmFsdWUpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBmaWx0ZXIgdG8gYmUgY29tcG9zZSB3aXRoIHRoaXMgZmlsdGVyIHVzaW5nIFwibm9uZVwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIGZpbHRlciBieS5cblx0ICogQHBhcmFtIHshKEFycmF5fC4uLiopfSBhcmdzIEEgdmFyaWFibGUgYW1vdW50IG9mIHZhbHVlcyB0byBiZSB1c2VkIHdpdGhcblx0ICogdGhlIFwibm9uZVwiIG9wZXJhdG9yLiBDYW4gYmUgcGFzc2VkIGVpdGhlciBhcyBhIHNpbmdsZSBhcnJheSBvciBhc1xuXHQgKiBzZXBhcmF0ZSBwYXJhbXMuXG5cdCAqIEBjaGFpbm5hYmxlXG5cdCAqL1xuXHRub25lKGZpZWxkLCAuLi5hcmdzKSB7XG5cdFx0cmV0dXJuIHRoaXMud2hlcmUoRmlsdGVyLm5vbmUoZmllbGQsIGFyZ3MpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgZmlsdGVyIHRvIGJlIGNvbXBvc2Ugd2l0aCB0aGlzIGZpbHRlciB1c2luZyBcIm1hdGNoXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZE9yUXVlcnkgSWYgbm8gc2Vjb25kIHN0cmluZyBhcmd1bWVudCBpcyBnaXZlbiwgdGhpc1xuXHQgKiBzaG91bGQgYmUgdGhlIHF1ZXJ5IHN0cmluZywgaW4gd2hpY2ggY2FzZSBhbGwgZmllbGRzIHdpbGwgYmUgbWF0Y2hlZC5cblx0ICogT3RoZXJ3aXNlLCB0aGlzIHNob3VsZCBiZSB0aGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gbWF0Y2guXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X3F1ZXJ5IFRoZSBxdWVyeSBzdHJpbmcuXG5cdCAqIEBjaGFpbm5hYmxlXG5cdCAqL1xuXHRtYXRjaChmaWVsZCwgdmFsdWUpIHtcblx0XHRyZXR1cm4gdGhpcy53aGVyZShGaWx0ZXIubWF0Y2goZmllbGQsIHZhbHVlKSk7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIGZpbHRlciB0byBiZSBjb21wb3NlIHdpdGggdGhpcyBmaWx0ZXIgdXNpbmcgXCJzaW1pbGFyXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZE9yUXVlcnkgSWYgbm8gc2Vjb25kIHN0cmluZyBhcmd1bWVudCBpcyBnaXZlbiwgdGhpc1xuXHQgKiBzaG91bGQgYmUgdGhlIHF1ZXJ5IHN0cmluZywgaW4gd2hpY2ggY2FzZSBhbGwgZmllbGRzIHdpbGwgYmUgbWF0Y2hlZC5cblx0ICogT3RoZXJ3aXNlLCB0aGlzIHNob3VsZCBiZSB0aGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gbWF0Y2guXG5cdCAqIEBwYXJhbSB7P3N0cmluZ30gcXVlcnkgVGhlIHF1ZXJ5IHN0cmluZy5cblx0ICogQGNoYWlubmFibGVcblx0ICovXG5cdHNpbWlsYXIoZmllbGRPclF1ZXJ5LCBxdWVyeSkge1xuXHRcdHJldHVybiB0aGlzLndoZXJlKEZpbHRlci5zaW1pbGFyKGZpZWxkT3JRdWVyeSwgcXVlcnkpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcIjxcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIGZpbHRlcidzIHZhbHVlLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuICAgKiBAc3RhdGljXG5cdCAqL1xuXHRsdChmaWVsZCwgdmFsdWUpIHtcblx0XHRyZXR1cm4gdGhpcy53aGVyZShGaWx0ZXIubHQoZmllbGQsIHZhbHVlKSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIHRoYXQgdXNlcyB0aGUgXCI8PVwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIGZpbHRlciBieS5cblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgZmlsdGVyJ3MgdmFsdWUuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG4gICAqIEBzdGF0aWNcblx0ICovXG5cdGx0ZShmaWVsZCwgdmFsdWUpIHtcblx0XHRyZXR1cm4gdGhpcy53aGVyZShGaWx0ZXIubHRlKGZpZWxkLCB2YWx1ZSkpO1xuXHR9XG5cblxuXHQvKipcblx0ICogQWRkcyBhIGZpbHRlciB0byBiZSBjb21wb3NlIHdpdGggdGhpcyBmaWx0ZXIgdXNpbmcgXCJhbnlcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7IShBcnJheXwuLi4qKX0gYXJncyBBIHZhcmlhYmxlIGFtb3VudCBvZiB2YWx1ZXMgdG8gYmUgdXNlZCB3aXRoXG5cdCAqIHRoZSBcIm5vbmVcIiBvcGVyYXRvci4gQ2FuIGJlIHBhc3NlZCBlaXRoZXIgYXMgYSBzaW5nbGUgYXJyYXkgb3IgYXNcblx0ICogc2VwYXJhdGUgcGFyYW1zLlxuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cblx0YW55KGZpZWxkLCAuLi5hcmdzKSB7XG5cdFx0cmV0dXJuIHRoaXMud2hlcmUoRmlsdGVyLmFueShmaWVsZCwgYXJncykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBmaWx0ZXIgdG8gYmUgY29tcG9zZSB3aXRoIHRoaXMgZmlsdGVyIHVzaW5nIFwiZ3BcIiBvcGVyYXRvci4gVGhpcyBpcyBhXG5cdCAqIHNwZWNpYWwgdXNlIGNhc2Ugb2YgYEZpbHRlci5wb2x5Z29uYCBmb3IgYm91bmRpbmcgYm94ZXMuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQncyBuYW1lLlxuXHQgKiBAcGFyYW0geyp9IGJveE9yVXBwZXJMZWZ0IEVpdGhlciBhIGBHZW8uQm91bmRpbmdCb3hgIGluc3RhbmNlLCBvciBhXG5cdCAqIGJvdW5kaW5nIGJveCdzIHVwcGVyIGxlZnQgY29vcmRpbmF0ZS5cblx0ICogQHBhcmFtIHsqPX0gb3B0X2xvd2VyUmlnaHQgQSBib3VuZGluZyBib3gncyBsb3dlciByaWdodCBjb29yZGluYXRlLlxuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cblx0Ym91bmRpbmdCb3goZmllbGQsIGJveE9yVXBwZXJMZWZ0LCBvcHRfbG93ZXJSaWdodCkge1xuXHRcdHJldHVybiB0aGlzLndoZXJlKEZpbHRlci5ib3VuZGluZ0JveChmaWVsZCwgYm94T3JVcHBlckxlZnQsIG9wdF9sb3dlclJpZ2h0KSk7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIGZpbHRlciB0byBiZSBjb21wb3NlIHdpdGggdGhpcyBmaWx0ZXIgdXNpbmcgXCJnZFwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGZpZWxkJ3MgbmFtZS5cblx0ICogQHBhcmFtIHsqfSBsb2NhdGlvbk9yQ2lyY2xlIEVpdGhlciBhIGBHZW8uQ2lyY2xlYCBpbnN0YW5jZSBvciBhXG5cdCAqIGNvb3JkaW5hdGUuXG5cdCAqIEBwYXJhbSB7UmFuZ2V8c3RyaW5nPX0gb3B0X3JhbmdlT3JEaXN0YW5jZSBFaXRoZXIgYSBgUmFuZ2VgIGluc3RhbmNlIG9yXG5cdCAqIHRoZSBkaXN0YW5jZSB2YWx1ZS5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cblx0ICogQGNoYWlubmFibGVcblx0ICovXG5cdGRpc3RhbmNlKGZpZWxkLCBsb2NhdGlvbk9yQ2lyY2xlLCBvcHRfcmFuZ2VPckRpc3RhbmNlKSB7XG5cdFx0cmV0dXJuIHRoaXMud2hlcmUoRmlsdGVyLmRpc3RhbmNlKGZpZWxkLCBsb2NhdGlvbk9yQ2lyY2xlLCBvcHRfcmFuZ2VPckRpc3RhbmNlKSk7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIGZpbHRlciB0byBiZSBjb21wb3NlIHdpdGggdGhpcyBmaWx0ZXIgdXNpbmcgXCJyYW5nZVwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGZpZWxkJ3MgbmFtZS5cblx0ICogQHBhcmFtIHsqfSByYW5nZU9yTWluIEVpdGhlciBhIGBSYW5nZWAgaW5zdGFuY2Ugb3IgYSB0aGUgcmFuZ2UncyBtaW5cblx0ICogdmFsdWUuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF9tYXggVGhlIHJhbmdlJ3MgbWF4IHZhbHVlLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cblx0cmFuZ2UoZmllbGQsIHJhbmdlT3JNaW4sIG9wdF9tYXgpIHtcblx0XHRyZXR1cm4gdGhpcy53aGVyZShGaWx0ZXIucmFuZ2UoZmllbGQsIHJhbmdlT3JNaW4sIG9wdF9tYXgpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBsaW1pdCBmb3IgdGhpcyByZXF1ZXN0J3Mge0BsaW5rIFF1ZXJ5fS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IFRoZSBtYXggYW1vdW50IG9mIGVudHJpZXMgdGhhdCB0aGlzIHJlcXVlc3Qgc2hvdWxkIHJldHVybi5cblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0bGltaXQobGltaXQpIHtcblx0XHR0aGlzLmdldE9yQ3JlYXRlUXVlcnlfKCkubGltaXQobGltaXQpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIG9mZnNldCBmb3IgdGhpcyByZXF1ZXN0J3Mge0BsaW5rIFF1ZXJ5fS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBUaGUgaW5kZXggb2YgdGhlIGZpcnN0IGVudHJ5IHRoYXQgc2hvdWxkIGJlXG5cdCAqIHJldHVybmVkIGJ5IHRoaXMgcXVlcnkuXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdG9mZnNldChvZmZzZXQpIHtcblx0XHR0aGlzLmdldE9yQ3JlYXRlUXVlcnlfKCkub2Zmc2V0KG9mZnNldCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIGhpZ2hsaWdodCBlbnRyeSB0byB0aGlzIHJlcXVlc3QncyB7QGxpbmsgUXVlcnl9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGZpZWxkJ3MgbmFtZS5cblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0aGlnaGxpZ2h0KGZpZWxkKSB7XG5cdFx0dGhpcy5nZXRPckNyZWF0ZVF1ZXJ5XygpLmhpZ2hsaWdodChmaWVsZCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhbiBhZ2dyZWdhdGlvbiB0byB0aGlzIHtAbGluayBRdWVyeX0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBhZ2dyZWdhdGlvbiBuYW1lLlxuXHQgKiBAcGFyYW0geyFBZ2dyZWdhdGlvbnxzdHJpbmd9IGFnZ3JlZ2F0aW9uT3JGaWVsZCBFaXRoZXIgYW4ge0BsaW5rXG5cdCAqIEFnZ3JlZ2F0aW9ufSBpbnN0YW5jZSBvciB0aGUgbmFtZSBvZiB0aGUgYWdncmVnYXRpb24gZmllbGQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X29wZXJhdG9yIFRoZSBhZ2dyZWdhdGlvbiBvcGVyYXRvci5cblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0YWdncmVnYXRlKG5hbWUsIGFnZ3JlZ2F0aW9uT3JGaWVsZCwgb3B0X29wZXJhdG9yKSB7XG5cdFx0dGhpcy5nZXRPckNyZWF0ZVF1ZXJ5XygpLmFnZ3JlZ2F0ZShuYW1lLCBhZ2dyZWdhdGlvbk9yRmllbGQsIG9wdF9vcGVyYXRvcik7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGlzIHJlcXVlc3QncyBxdWVyeSB0eXBlIHRvICdjb3VudCcuXG5cdCAqIEBjaGFpbm5hYmxlXG5cdCAqL1xuXHRjb3VudCgpIHtcblx0XHR0aGlzLmdldE9yQ3JlYXRlUXVlcnlfKCkudHlwZSgnY291bnQnKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgc29ydCBxdWVyeSB0byB0aGlzIHJlcXVlc3QncyBib2R5LlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGZpZWxkIHRoYXQgdGhlIHF1ZXJ5IHNob3VsZCBiZSBzb3J0ZWQgYnkuXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X2RpcmVjdGlvbiBUaGUgZGlyZWN0aW9uIHRoZSBzb3J0IG9wZXJhdGlvbiBzaG91bGRcblx0ICogdXNlLiBJZiBub25lIGlzIGdpdmVuLCAnYXNjJyBpcyB1c2VkIGJ5IGRlZmF1bHQuXG5cdCAqIEBjaGFpbm5hYmxlXG5cdCAqL1xuXHRvcmRlckJ5KGZpZWxkLCBvcHRfZGlyZWN0aW9uKSB7XG5cdFx0dGhpcy5nZXRPckNyZWF0ZVF1ZXJ5XygpLnNvcnQoZmllbGQsIG9wdF9kaXJlY3Rpb24pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gb2JqZWN0IChvciBtdWx0aXBsZSBvYmplY3RzKSBhbmQgc2F2ZXMgaXQgdG8gV2VEZXBsb3kgZGF0YS4gSWZcblx0ICogdGhlcmUncyBhIHZhbGlkYXRpb24gcmVnaXN0ZXJlZCBpbiB0aGUgY29sbGVjdGlvbiBhbmQgdGhlIHJlcXVlc3QgaXNcblx0ICogc3VjY2Vzc2Z1bCwgdGhlIHJlc3VsdGluZyBvYmplY3QgKG9yIGFycmF5IG9mIG9iamVjdHMpIGlzIHJldHVybmVkLiBUaGVcblx0ICogZGF0YSBwYXJhbWV0ZXIgY2FuIGJlIGVpdGhlciBhbiBPYmplY3Qgb3IgYW4gQXJyYXkgb2YgT2JqZWN0cy5cblx0ICogVGhlc2UgT2JqZWN0cyBkZXNjcmliZSB0aGUgYXR0cmlidXRlcyBvbiB0aGUgb2JqZWN0cyB0aGF0IGFyZSB0byBiZSBjcmVhdGVkLlxuXHQgKiBgYGBqYXZhc2NyaXB0XG5cdCAqIHZhciBkYXRhID0gV2VEZXBsb3kuZGF0YSgnaHR0cDovL2RlbW9kYXRhLndlZGVwbG95LmlvJyk7XG5cdCAqXG5cdCAqIGRhdGEuY3JlYXRlKCdtb3ZpZXMnLCB7J3RpdGxlJz0+ICdTdGFyIFdhcnM6IEVwaXNvZGUgSSDigJMgVGhlIFBoYW50b20gTWVuYWNlJ30pXG5cdCAqIFx0XHQgLnRoZW4oZnVuY3Rpb24obW92aWUpe1xuXHQgKiBcdFx0XHQgY29uc29sZS5sb2cobW92aWUpXG5cdCAqICAgICB9KTtcblx0ICpcblx0ICogZGF0YS5jcmVhdGUoJ21vdmllcycsIFt7J3RpdGxlJz0+ICdTdGFyIFdhcnM6IEVwaXNvZGUgSUkg4oCTIEF0dGFjayBvZiB0aGUgQ2xvbmVzJ30sXG5cdCAqIFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHsndGl0bGUnPT4gJ1N0YXIgV2FyczogRXBpc29kZSBJSUkg4oCTIFJldmVuZ2Ugb2YgdGhlIFNpdGgnfSlcblx0ICogXHRcdCAudGhlbihmdW5jdGlvbihtb3ZpZXMpe1xuXHQgKiBcdFx0XHQgY29uc29sZS5sb2cobW92aWVzKVxuXHQgKiAgICAgfSk7XG5cdCAqIGBgYFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gY29sbGVjdGlvbiBDb2xsZWN0aW9uIChrZXkpIHVzZWQgdG8gY3JlYXRlIHRoZSBuZXcgZGF0YS5cblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGEgQXR0cmlidXRlcyBvbiB0aGUgb2JqZWN0IHRoYXQgaXMgdG8gYmUgY3JlYXRlZC5cblx0ICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZX1cblx0ICovXG5cdGNyZWF0ZShjb2xsZWN0aW9uLCBkYXRhKSB7XG5cdFx0YXNzZXJ0RGVmQW5kTm90TnVsbChjb2xsZWN0aW9uLCAnQ29sbGVjdGlvbiBrZXkgbXVzdCBiZSBzcGVjaWZpZWQuJyk7XG5cdFx0YXNzZXJ0T2JqZWN0KGRhdGEsICdEYXRhIGNhblxcJ3QgYmUgZW1wdHkuJyk7XG5cblx0XHRyZXR1cm4gdGhpcy53ZWRlcGxveUNsaWVudFxuXHRcdFx0LnVybCh0aGlzLndlZGVwbG95Q2xpZW50LmRhdGFVcmxfKVxuXHRcdFx0LmF1dGgodGhpcy5oZWxwZXJBdXRoU2NvcGUpXG5cdFx0XHQucGF0aChjb2xsZWN0aW9uKVxuXHRcdFx0LnBvc3QoZGF0YSlcblx0XHRcdC50aGVuKHJlc3BvbnNlID0+IGFzc2VydFJlc3BvbnNlU3VjY2VlZGVkKHJlc3BvbnNlKSlcblx0XHRcdC50aGVuKHJlc3BvbnNlID0+IHJlc3BvbnNlLmJvZHkoKSk7XG5cdH1cblxuXHQvKipcblx0ICogVXBkYXRlIHRoZSBhdHRyaWJ1dGVzIG9mIGEgZG9jdW1lbnQgZm9ybSB0aGUgcGFzc2VkLWluIG9iamVjdCBhbmQgc2F2ZXNcblx0ICogdGhlIHJlY29yZC4gSWYgdGhlIG9iamVjdCBpcyBpbnZhbGlkLCB0aGUgc2F2aW5nIHdpbGwgZmFpbCBhbmQgYW4gZXJyb3Jcblx0ICogb2JqZWN0IHdpbGwgYmUgcmV0dXJuZWQuXG5cdCAqXG5cdCAqIGBgYGphdmFzY3JpcHRcblx0ICogdmFyIGRhdGEgPSBXZURlcGxveS5kYXRhKCdodHRwOi8vZGVtb2RhdGEud2VkZXBsb3kuaW8nKTtcblx0ICpcblx0ICogZGF0YS51cGRhdGUoJ21vdmllcy8xMDE5MTEyMzUzJywgeyd0aXRsZSc9PiAnU3RhciBXYXJzOiBFcGlzb2RlIEknfSlcblx0ICogXHRcdCAudGhlbihmdW5jdGlvbihtb3ZpZSl7XG5cdCAqIFx0XHRcdCBjb25zb2xlLmxvZyhtb3ZpZSlcblx0ICogICAgIH0pO1xuXHQgKiBgYGBcblx0ICogQHBhcmFtIHtzdHJpbmd9IGRvY3VtZW50IEtleSB1c2VkIHRvIHVwZGF0ZSB0aGUgZG9jdW1lbnQuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIEF0dHJpYnV0ZXMgb24gdGhlIG9iamVjdCB0aGF0IGlzIHRvIGJlIHVwZGF0ZWQuXG5cdCAqIEByZXR1cm4geyFDYW5jZWxsYWJsZVByb21pc2V9XG5cdCAqL1xuXHR1cGRhdGUoZG9jdW1lbnQsIGRhdGEpIHtcblx0XHRhc3NlcnREZWZBbmROb3ROdWxsKGRvY3VtZW50LCAnRG9jdW1lbnQga2V5IG11c3QgYmUgc3BlY2lmaWVkLicpO1xuXHRcdGFzc2VydE9iamVjdChkYXRhLCAnRGF0YSBtdXN0IGJlIHNwZWNpZmllZC4nKTtcblxuXHRcdHJldHVybiB0aGlzLndlZGVwbG95Q2xpZW50XG5cdFx0XHQudXJsKHRoaXMud2VkZXBsb3lDbGllbnQuZGF0YVVybF8pXG5cdFx0XHQuYXV0aCh0aGlzLmhlbHBlckF1dGhTY29wZSlcblx0XHRcdC5wYXRoKGRvY3VtZW50KVxuXHRcdFx0LnB1dChkYXRhKVxuXHRcdFx0LnRoZW4ocmVzcG9uc2UgPT4gYXNzZXJ0UmVzcG9uc2VTdWNjZWVkZWQocmVzcG9uc2UpKVxuXHRcdFx0LnRoZW4ocmVzcG9uc2UgPT4gcmVzcG9uc2UuYm9keSgpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEZWxldGVzIGEgW2RvY3VtZW50L2ZpZWxkL2NvbGxlY3Rpb25dLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleSB1c2VkIHRvIGRlbGV0ZSB0aGVcblx0ICogZG9jdW1lbnQvZmllbGQvY29sbGVjdGlvbi5cblx0ICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZX1cblx0ICovXG5cdGRlbGV0ZShrZXkpIHtcblx0XHRhc3NlcnREZWZBbmROb3ROdWxsKGtleSwgJ0RvY3VtZW50L0ZpZWxkL0NvbGxlY3Rpb24ga2V5IG11c3QgYmUgc3BlY2lmaWVkJyk7XG5cblx0XHRyZXR1cm4gdGhpcy53ZWRlcGxveUNsaWVudFxuXHRcdFx0LnVybCh0aGlzLndlZGVwbG95Q2xpZW50LmRhdGFVcmxfKVxuXHRcdFx0LmF1dGgodGhpcy5oZWxwZXJBdXRoU2NvcGUpXG5cdFx0XHQucGF0aChrZXkpXG5cdFx0XHQuZGVsZXRlKClcblx0XHRcdC50aGVuKHJlc3BvbnNlID0+IGFzc2VydFJlc3BvbnNlU3VjY2VlZGVkKHJlc3BvbnNlKSlcblx0XHRcdC50aGVuKCgpID0+IHVuZGVmaW5lZCk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0cmlldmUgZGF0YSBmcm9tIGEgW2RvY3VtZW50L2ZpZWxkL2NvbGxlY3Rpb25dLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleSB1c2VkIHRvIGRlbGV0ZSB0aGUgZG9jdW1lbnQvZmllbGQvY29sbGVjdGlvbi5cblx0ICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZX1cblx0ICovXG5cdGdldChrZXkpIHtcblx0XHRhc3NlcnREZWZBbmROb3ROdWxsKGtleSwgJ0RvY3VtZW50L0ZpZWxkL0NvbGxlY3Rpb24ga2V5IG11c3QgYmUgc3BlY2lmaWVkJyk7XG5cblx0XHR0aGlzLmFkZEZpbHRlcnNUb1F1ZXJ5XygpO1xuXG5cdFx0cmV0dXJuIHRoaXMud2VkZXBsb3lDbGllbnRcblx0XHRcdC51cmwodGhpcy53ZWRlcGxveUNsaWVudC5kYXRhVXJsXylcblx0XHRcdC5hdXRoKHRoaXMuaGVscGVyQXV0aFNjb3BlKVxuXHRcdFx0LnBhdGgoa2V5KVxuXHRcdFx0LmdldCh0aGlzLnF1ZXJ5Xylcblx0XHRcdC50aGVuKHJlc3BvbnNlID0+IGFzc2VydFJlc3BvbnNlU3VjY2VlZGVkKHJlc3BvbnNlKSlcblx0XHRcdC50aGVuKHJlc3BvbnNlID0+IHJlc3BvbnNlLmJvZHkoKSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0cmlldmUgZGF0YSBmcm9tIGEgW2RvY3VtZW50L2ZpZWxkL2NvbGxlY3Rpb25dIGFuZCBwdXQgaXQgaW4gYSBzZWFyY2hcblx0ICogZm9ybWF0LlxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleSB1c2VkIHRvIGRlbGV0ZSB0aGUgZG9jdW1lbnQvZmllbGQvY29sbGVjdGlvbi5cblx0ICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZX1cblx0ICovXG5cdHNlYXJjaChrZXkpIHtcblx0XHRhc3NlcnREZWZBbmROb3ROdWxsKGtleSwgJ0RvY3VtZW50L0ZpZWxkL0NvbGxlY3Rpb24ga2V5IG11c3QgYmUgc3BlY2lmaWVkJyk7XG5cblx0XHR0aGlzLm9uU2VhcmNoXygpO1xuXG5cdFx0dGhpcy5hZGRGaWx0ZXJzVG9RdWVyeV8oKTtcblxuXHRcdHJldHVybiB0aGlzLndlZGVwbG95Q2xpZW50XG5cdFx0XHQudXJsKHRoaXMud2VkZXBsb3lDbGllbnQuZGF0YVVybF8pXG5cdFx0XHQuYXV0aCh0aGlzLmhlbHBlckF1dGhTY29wZSlcblx0XHRcdC5wYXRoKGtleSlcblx0XHRcdC5nZXQodGhpcy5xdWVyeV8pXG5cdFx0XHQudGhlbihyZXNwb25zZSA9PiBhc3NlcnRSZXNwb25zZVN1Y2NlZWRlZChyZXNwb25zZSkpXG5cdFx0XHQudGhlbihyZXNwb25zZSA9PiByZXNwb25zZS5ib2R5KCkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgbmV3IHNvY2tldC5pbyBpbnN0YW5jZS4gTW9uaXRvciB0aGUgYXJyaXZhbCBvZiBuZXcgYnJvYWRjYXN0ZWRcblx0ICogZGF0YS5cblx0ICogQHBhcmFtICB7c3RyaW5nfSBjb2xsZWN0aW9uIGtleS9jb2xsZWN0aW9uIHVzZWQgdG8gZmluZCBvcmdhbml6ZWQgZGF0YS5cblx0ICogQHBhcmFtICB7T2JqZWN0PX0gb3B0X29wdGlvbnMgT2JqZWN0IHdpdGggU29ja2V0IElPIG9wdGlvbnMuXG5cdCAqIEByZXR1cm4geyFpb30gU29ja2V0IElPIHJlZmVyZW5jZS4gU2VydmVyIGV2ZW50cyBjYW4gYmUgbGlzdGVuZWQgb24gaXQuXG5cdCAqL1xuXHR3YXRjaChjb2xsZWN0aW9uLCBvcHRfb3B0aW9ucykge1xuXHRcdGFzc2VydERlZkFuZE5vdE51bGwoY29sbGVjdGlvbiwgJ0NvbGxlY3Rpb24ga2V5IG11c3QgYmUgc3BlY2lmaWVkJyk7XG5cblx0XHR0aGlzLmFkZEZpbHRlcnNUb1F1ZXJ5XygpO1xuXG5cdFx0cmV0dXJuIHRoaXMud2VkZXBsb3lDbGllbnRcblx0XHRcdC51cmwodGhpcy53ZWRlcGxveUNsaWVudC5kYXRhVXJsXylcblx0XHRcdC5hdXRoKHRoaXMuaGVscGVyQXV0aFNjb3BlKVxuXHRcdFx0LnBhdGgoY29sbGVjdGlvbilcblx0XHRcdC53YXRjaCh0aGlzLnF1ZXJ5Xywgb3B0X29wdGlvbnMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGN1cnJlbnRsIHVzZWQgbWFpbiB7QGxpbmsgRmlsdGVyfSBvYmplY3QuIElmIG5vbmUgZXhpc3RzIHlldCwgYVxuXHQgKiBuZXcgb25lIGlzIGNyZWF0ZWQuXG5cdCAqIEByZXR1cm4geyFRdWVyeX1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0Z2V0T3JDcmVhdGVGaWx0ZXJfKCkge1xuXHRcdGlmICghdGhpcy5maWx0ZXJfKSB7XG5cdFx0XHR0aGlzLmZpbHRlcl8gPSBuZXcgRmlsdGVyKCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmZpbHRlcl87XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgY3VycmVudGx5IHVzZWQge0BsaW5rIFF1ZXJ5fSBvYmplY3QuIElmIG5vbmUgZXhpc3RzIHlldCxcblx0ICogYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG5cdCAqIEByZXR1cm4geyFRdWVyeX1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0Z2V0T3JDcmVhdGVRdWVyeV8oKSB7XG5cdFx0aWYgKCF0aGlzLnF1ZXJ5Xykge1xuXHRcdFx0dGhpcy5xdWVyeV8gPSBuZXcgUXVlcnkoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMucXVlcnlfO1xuXHR9XG5cblx0LyoqXG5cdCAqIExvYWQgdGhlIGN1cnJlbnRseSB1c2VkIG1haW4ge0BsaW5rIEZpbHRlcn0gb2JqZWN0IGludG8gdGhlIGN1cnJlbnRseVxuXHQgKiB1c2VkIHtAbGluayBRdWVyeX0uXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0YWRkRmlsdGVyc1RvUXVlcnlfKCkge1xuXHRcdGlmIChjb3JlLmlzRGVmKHRoaXMuZmlsdGVyXykgJiYgdGhpcy50b1NlYXJjaF8gIT09IHRydWUpIHtcblx0XHRcdHRoaXMuZ2V0T3JDcmVhdGVRdWVyeV8oKS5maWx0ZXIodGhpcy5maWx0ZXJfKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIHNlYXJjaCB0byB0aGlzIHJlcXVlc3QncyB7QGxpbmsgUXVlcnl9IGluc3RhbmNlLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdG9uU2VhcmNoXygpIHtcblx0XHRpZiAoY29yZS5pc0RlZih0aGlzLmZpbHRlcl8pKSB7XG5cdFx0XHR0aGlzLmdldE9yQ3JlYXRlUXVlcnlfKCkuc2VhcmNoKHRoaXMuZ2V0T3JDcmVhdGVGaWx0ZXJfKCkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyBFcnJvcignSXRcXCdzIHJlcXVpcmVkIHRvIGhhdmUgYSBjb25kaXRpb24gYmVmb3JlIHVzaW5nIGFuIFxcJ3NlYXJjaCgpXFwnIGZvciB0aGUgZmlyc3QgdGltZS4nKTtcblx0XHR9XG5cdFx0dGhpcy50b1NlYXJjaF8gPSB0cnVlO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgRGF0YUFwaUhlbHBlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBBYnN0cmFjdGlvbiBsYXllciBmb3Igc3RyaW5nIHRvIGJhc2U2NCBjb252ZXJzaW9uXG4gKiByZWZlcmVuY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvMzQ2MlxuICovXG5jbGFzcyBCYXNlNjQge1xuXHQvKipcblx0ICogQ3JlYXRlcyBhIGJhc2UtNjQgZW5jb2RlZCBBU0NJSSBzdHJpbmcgZnJvbSBhIFwic3RyaW5nXCIgb2YgYmluYXJ5IGRhdGEuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgdG8gYmUgZW5jb2RlZC5cblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgZW5jb2RlU3RyaW5nKHN0cmluZykge1xuXHRcdGlmICh0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0cmV0dXJuIGJ0b2Eoc3RyaW5nKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbmV3IEJ1ZmZlcihzdHJpbmcudG9TdHJpbmcoKSwgJ2JpbmFyeScpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2U2NDtcbiIsIi8qIVxuICogUHJvbWlzZXMgcG9seWZpbGwgZnJvbSBHb29nbGUncyBDbG9zdXJlIExpYnJhcnkuXG4gKlxuICogICAgICBDb3B5cmlnaHQgMjAxMyBUaGUgQ2xvc3VyZSBMaWJyYXJ5IEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTk9URShlZHVhcmRvKTogUHJvbWlzZSBzdXBwb3J0IGlzIG5vdCByZWFkeSBvbiBhbGwgc3VwcG9ydGVkIGJyb3dzZXJzLFxuICogdGhlcmVmb3JlIGNvcmUuanMgaXMgdGVtcG9yYXJpbHkgdXNpbmcgR29vZ2xlJ3MgcHJvbWlzZXMgYXMgcG9seWZpbGwuIEl0XG4gKiBzdXBwb3J0cyBjYW5jZWxsYWJsZSBwcm9taXNlcyBhbmQgaGFzIGNsZWFuIGFuZCBmYXN0IGltcGxlbWVudGF0aW9uLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHsgY29yZSB9IGZyb20gJ21ldGFsJztcbmltcG9ydCB7IGFzeW5jIH0gZnJvbSAnbWV0YWwnO1xuXG4vKipcbiAqIFByb3ZpZGVzIGEgbW9yZSBzdHJpY3QgaW50ZXJmYWNlIGZvciBUaGVuYWJsZXMgaW4gdGVybXMgb2ZcbiAqIGh0dHA6Ly9wcm9taXNlc2FwbHVzLmNvbSBmb3IgaW50ZXJvcCB3aXRoIHtAc2VlIENhbmNlbGxhYmxlUHJvbWlzZX0uXG4gKlxuICogQGludGVyZmFjZVxuICogQGV4dGVuZHMge0lUaGVuYWJsZS48VFlQRT59XG4gKiBAdGVtcGxhdGUgVFlQRVxuICovXG52YXIgVGhlbmFibGUgPSBmdW5jdGlvbigpIHt9O1xuXG4vKipcbiAqIEFkZHMgY2FsbGJhY2tzIHRoYXQgd2lsbCBvcGVyYXRlIG9uIHRoZSByZXN1bHQgb2YgdGhlIFRoZW5hYmxlLCByZXR1cm5pbmcgYVxuICogbmV3IGNoaWxkIFByb21pc2UuXG4gKlxuICogSWYgdGhlIFRoZW5hYmxlIGlzIGZ1bGZpbGxlZCwgdGhlIHtAY29kZSBvbkZ1bGZpbGxlZH0gY2FsbGJhY2sgd2lsbCBiZVxuICogaW52b2tlZCB3aXRoIHRoZSBmdWxmaWxsbWVudCB2YWx1ZSBhcyBhcmd1bWVudCwgYW5kIHRoZSBjaGlsZCBQcm9taXNlIHdpbGxcbiAqIGJlIGZ1bGZpbGxlZCB3aXRoIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGNhbGxiYWNrLiBJZiB0aGUgY2FsbGJhY2sgdGhyb3dzXG4gKiBhbiBleGNlcHRpb24sIHRoZSBjaGlsZCBQcm9taXNlIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCB0aGUgdGhyb3duIHZhbHVlXG4gKiBpbnN0ZWFkLlxuICpcbiAqIElmIHRoZSBUaGVuYWJsZSBpcyByZWplY3RlZCwgdGhlIHtAY29kZSBvblJlamVjdGVkfSBjYWxsYmFjayB3aWxsIGJlIGludm9rZWRcbiAqIHdpdGggdGhlIHJlamVjdGlvbiByZWFzb24gYXMgYXJndW1lbnQsIGFuZCB0aGUgY2hpbGQgUHJvbWlzZSB3aWxsIGJlIHJlamVjdGVkXG4gKiB3aXRoIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGNhbGxiYWNrIG9yIHRocm93biB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0gez8oZnVuY3Rpb24odGhpczpUSElTLCBUWVBFKTpcbiAqICAgICAgICAgICAgIChSRVNVTFR8SVRoZW5hYmxlLjxSRVNVTFQ+fFRoZW5hYmxlKSk9fSBvcHRfb25GdWxmaWxsZWQgQVxuICogICAgIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBpbnZva2VkIHdpdGggdGhlIGZ1bGZpbGxtZW50IHZhbHVlIGlmIHRoZSBQcm9taXNlXG4gKiAgICAgaXMgZnVsbGZpbGxlZC5cbiAqIEBwYXJhbSB7PyhmdW5jdGlvbigqKTogKik9fSBvcHRfb25SZWplY3RlZCBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBpbnZva2VkXG4gKiAgICAgd2l0aCB0aGUgcmVqZWN0aW9uIHJlYXNvbiBpZiB0aGUgUHJvbWlzZSBpcyByZWplY3RlZC5cbiAqIEBwYXJhbSB7VEhJUz19IG9wdF9jb250ZXh0IEFuIG9wdGlvbmFsIGNvbnRleHQgb2JqZWN0IHRoYXQgd2lsbCBiZSB0aGVcbiAqICAgICBleGVjdXRpb24gY29udGV4dCBmb3IgdGhlIGNhbGxiYWNrcy4gQnkgZGVmYXVsdCwgZnVuY3Rpb25zIGFyZSBleGVjdXRlZFxuICogICAgIHdpdGggdGhlIGRlZmF1bHQgdGhpcy5cbiAqIEByZXR1cm4geyFDYW5jZWxsYWJsZVByb21pc2UuPFJFU1VMVD59IEEgbmV3IFByb21pc2UgdGhhdCB3aWxsIHJlY2VpdmUgdGhlXG4gKiAgICAgcmVzdWx0IG9mIHRoZSBmdWxmaWxsbWVudCBvciByZWplY3Rpb24gY2FsbGJhY2suXG4gKiBAdGVtcGxhdGUgUkVTVUxULFRISVNcbiAqL1xuVGhlbmFibGUucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbigpIHt9O1xuXG5cbi8qKlxuICogQW4gZXhwYW5kbyBwcm9wZXJ0eSB0byBpbmRpY2F0ZSB0aGF0IGFuIG9iamVjdCBpbXBsZW1lbnRzXG4gKiB7QGNvZGUgVGhlbmFibGV9LlxuICpcbiAqIHtAc2VlIGFkZEltcGxlbWVudGF0aW9ufS5cbiAqXG4gKiBAY29uc3RcbiAqL1xuVGhlbmFibGUuSU1QTEVNRU5URURfQllfUFJPUCA9ICckZ29vZ19UaGVuYWJsZSc7XG5cblxuLyoqXG4gKiBNYXJrcyBhIGdpdmVuIGNsYXNzIChjb25zdHJ1Y3RvcikgYXMgYW4gaW1wbGVtZW50YXRpb24gb2YgVGhlbmFibGUsIHNvXG4gKiB0aGF0IHdlIGNhbiBxdWVyeSB0aGF0IGZhY3QgYXQgcnVudGltZS4gVGhlIGNsYXNzIG11c3QgaGF2ZSBhbHJlYWR5XG4gKiBpbXBsZW1lbnRlZCB0aGUgaW50ZXJmYWNlLlxuICogRXhwb3J0cyBhICd0aGVuJyBtZXRob2Qgb24gdGhlIGNvbnN0cnVjdG9yIHByb3RvdHlwZSwgc28gdGhhdCB0aGUgb2JqZWN0c1xuICogYWxzbyBpbXBsZW1lbnQgdGhlIGV4dGVybiB7QHNlZSBUaGVuYWJsZX0gaW50ZXJmYWNlIGZvciBpbnRlcm9wIHdpdGhcbiAqIG90aGVyIFByb21pc2UgaW1wbGVtZW50YXRpb25zLlxuICogQHBhcmFtIHtmdW5jdGlvbihuZXc6VGhlbmFibGUsLi4uWz9dKX0gY3RvciBUaGUgY2xhc3MgY29uc3RydWN0b3IuIFRoZVxuICogICAgIGNvcnJlc3BvbmRpbmcgY2xhc3MgbXVzdCBoYXZlIGFscmVhZHkgaW1wbGVtZW50ZWQgdGhlIGludGVyZmFjZS5cbiAqL1xuVGhlbmFibGUuYWRkSW1wbGVtZW50YXRpb24gPSBmdW5jdGlvbihjdG9yKSB7XG4gIGN0b3IucHJvdG90eXBlLnRoZW4gPSBjdG9yLnByb3RvdHlwZS50aGVuO1xuICBjdG9yLnByb3RvdHlwZS4kZ29vZ19UaGVuYWJsZSA9IHRydWU7XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHsqfSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgYSBnaXZlbiBpbnN0YW5jZSBpbXBsZW1lbnRzIHtAY29kZSBUaGVuYWJsZX0uXG4gKiAgICAgVGhlIGNsYXNzL3N1cGVyY2xhc3Mgb2YgdGhlIGluc3RhbmNlIG11c3QgY2FsbCB7QGNvZGUgYWRkSW1wbGVtZW50YXRpb259LlxuICovXG5UaGVuYWJsZS5pc0ltcGxlbWVudGVkQnkgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgaWYgKCFvYmplY3QpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdHJ5IHtcbiAgICByZXR1cm4gISFvYmplY3QuJGdvb2dfVGhlbmFibGU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBQcm9wZXJ0eSBhY2Nlc3Mgc2VlbXMgdG8gYmUgZm9yYmlkZGVuLlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuXG4vKipcbiAqIExpa2UgYmluZCgpLCBleGNlcHQgdGhhdCBhICd0aGlzIG9iamVjdCcgaXMgbm90IHJlcXVpcmVkLiBVc2VmdWwgd2hlbiB0aGVcbiAqIHRhcmdldCBmdW5jdGlvbiBpcyBhbHJlYWR5IGJvdW5kLlxuICpcbiAqIFVzYWdlOlxuICogdmFyIGcgPSBwYXJ0aWFsKGYsIGFyZzEsIGFyZzIpO1xuICogZyhhcmczLCBhcmc0KTtcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBBIGZ1bmN0aW9uIHRvIHBhcnRpYWxseSBhcHBseS5cbiAqIEBwYXJhbSB7Li4uKn0gdmFyX2FyZ3MgQWRkaXRpb25hbCBhcmd1bWVudHMgdGhhdCBhcmUgcGFydGlhbGx5IGFwcGxpZWQgdG8gZm4uXG4gKiBAcmV0dXJuIHshRnVuY3Rpb259IEEgcGFydGlhbGx5LWFwcGxpZWQgZm9ybSBvZiB0aGUgZnVuY3Rpb24gYmluZCgpIHdhc1xuICogICAgIGludm9rZWQgYXMgYSBtZXRob2Qgb2YuXG4gKi9cbnZhciBwYXJ0aWFsID0gZnVuY3Rpb24oZm4pIHtcbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgLy8gQ2xvbmUgdGhlIGFycmF5ICh3aXRoIHNsaWNlKCkpIGFuZCBhcHBlbmQgYWRkaXRpb25hbCBhcmd1bWVudHNcbiAgICAvLyB0byB0aGUgZXhpc3RpbmcgYXJndW1lbnRzLlxuICAgIHZhciBuZXdBcmdzID0gYXJncy5zbGljZSgpO1xuICAgIG5ld0FyZ3MucHVzaC5hcHBseShuZXdBcmdzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBuZXdBcmdzKTtcbiAgfTtcbn07XG5cbi8qKlxuICogUHJvbWlzZXMgcHJvdmlkZSBhIHJlc3VsdCB0aGF0IG1heSBiZSByZXNvbHZlZCBhc3luY2hyb25vdXNseS4gQSBQcm9taXNlIG1heVxuICogYmUgcmVzb2x2ZWQgYnkgYmVpbmcgZnVsZmlsbGVkIG9yIHJlamVjdGVkIHdpdGggYSB2YWx1ZSwgd2hpY2ggd2lsbCBiZSBrbm93blxuICogYXMgdGhlIGZ1bGZpbGxtZW50IHZhbHVlIG9yIHRoZSByZWplY3Rpb24gcmVhc29uLiBXaGV0aGVyIGZ1bGZpbGxlZCBvclxuICogcmVqZWN0ZWQsIHRoZSBQcm9taXNlIHJlc3VsdCBpcyBpbW11dGFibGUgb25jZSBpdCBpcyBzZXQuXG4gKlxuICogUHJvbWlzZXMgbWF5IHJlcHJlc2VudCByZXN1bHRzIG9mIGFueSB0eXBlLCBpbmNsdWRpbmcgdW5kZWZpbmVkLiBSZWplY3Rpb25cbiAqIHJlYXNvbnMgYXJlIHR5cGljYWxseSBFcnJvcnMsIGJ1dCBtYXkgYWxzbyBiZSBvZiBhbnkgdHlwZS4gQ2xvc3VyZSBQcm9taXNlc1xuICogYWxsb3cgZm9yIG9wdGlvbmFsIHR5cGUgYW5ub3RhdGlvbnMgdGhhdCBlbmZvcmNlIHRoYXQgZnVsZmlsbG1lbnQgdmFsdWVzIGFyZVxuICogb2YgdGhlIGFwcHJvcHJpYXRlIHR5cGVzIGF0IGNvbXBpbGUgdGltZS5cbiAqXG4gKiBUaGUgcmVzdWx0IG9mIGEgUHJvbWlzZSBpcyBhY2Nlc3NpYmxlIGJ5IGNhbGxpbmcge0Bjb2RlIHRoZW59IGFuZCByZWdpc3RlcmluZ1xuICoge0Bjb2RlIG9uRnVsZmlsbGVkfSBhbmQge0Bjb2RlIG9uUmVqZWN0ZWR9IGNhbGxiYWNrcy4gT25jZSB0aGUgUHJvbWlzZVxuICogcmVzb2x2ZXMsIHRoZSByZWxldmFudCBjYWxsYmFja3MgYXJlIGludm9rZWQgd2l0aCB0aGUgZnVsZmlsbG1lbnQgdmFsdWUgb3JcbiAqIHJlamVjdGlvbiByZWFzb24gYXMgYXJndW1lbnQuIENhbGxiYWNrcyBhcmUgYWx3YXlzIGludm9rZWQgaW4gdGhlIG9yZGVyIHRoZXlcbiAqIHdlcmUgcmVnaXN0ZXJlZCwgZXZlbiB3aGVuIGFkZGl0aW9uYWwge0Bjb2RlIHRoZW59IGNhbGxzIGFyZSBtYWRlIGZyb20gaW5zaWRlXG4gKiBhbm90aGVyIGNhbGxiYWNrLiBBIGNhbGxiYWNrIGlzIGFsd2F5cyBydW4gYXN5bmNocm9ub3VzbHkgc29tZXRpbWUgYWZ0ZXIgdGhlXG4gKiBzY29wZSBjb250YWluaW5nIHRoZSByZWdpc3RlcmluZyB7QGNvZGUgdGhlbn0gaW52b2NhdGlvbiBoYXMgcmV0dXJuZWQuXG4gKlxuICogSWYgYSBQcm9taXNlIGlzIHJlc29sdmVkIHdpdGggYW5vdGhlciBQcm9taXNlLCB0aGUgZmlyc3QgUHJvbWlzZSB3aWxsIGJsb2NrXG4gKiB1bnRpbCB0aGUgc2Vjb25kIGlzIHJlc29sdmVkLCBhbmQgdGhlbiBhc3N1bWVzIHRoZSBzYW1lIHJlc3VsdCBhcyB0aGUgc2Vjb25kXG4gKiBQcm9taXNlLiBUaGlzIGFsbG93cyBQcm9taXNlcyB0byBkZXBlbmQgb24gdGhlIHJlc3VsdHMgb2Ygb3RoZXIgUHJvbWlzZXMsXG4gKiBsaW5raW5nIHRvZ2V0aGVyIG11bHRpcGxlIGFzeW5jaHJvbm91cyBvcGVyYXRpb25zLlxuICpcbiAqIFRoaXMgaW1wbGVtZW50YXRpb24gaXMgY29tcGF0aWJsZSB3aXRoIHRoZSBQcm9taXNlcy9BKyBzcGVjaWZpY2F0aW9uIGFuZFxuICogcGFzc2VzIHRoYXQgc3BlY2lmaWNhdGlvbidzIGNvbmZvcm1hbmNlIHRlc3Qgc3VpdGUuIEEgQ2xvc3VyZSBQcm9taXNlIG1heSBiZVxuICogcmVzb2x2ZWQgd2l0aCBhIFByb21pc2UgaW5zdGFuY2UgKG9yIHN1ZmZpY2llbnRseSBjb21wYXRpYmxlIFByb21pc2UtbGlrZVxuICogb2JqZWN0KSBjcmVhdGVkIGJ5IG90aGVyIFByb21pc2UgaW1wbGVtZW50YXRpb25zLiBGcm9tIHRoZSBzcGVjaWZpY2F0aW9uLFxuICogUHJvbWlzZS1saWtlIG9iamVjdHMgYXJlIGtub3duIGFzIFwiVGhlbmFibGVzXCIuXG4gKlxuICogQHNlZSBodHRwOi8vcHJvbWlzZXNhcGx1cy5jb20vXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbihcbiAqICAgICAgICAgICAgIHRoaXM6UkVTT0xWRVJfQ09OVEVYVCxcbiAqICAgICAgICAgICAgIGZ1bmN0aW9uKChUWVBFfElUaGVuYWJsZS48VFlQRT58VGhlbmFibGUpKSxcbiAqICAgICAgICAgICAgIGZ1bmN0aW9uKCopKTogdm9pZH0gcmVzb2x2ZXJcbiAqICAgICBJbml0aWFsaXphdGlvbiBmdW5jdGlvbiB0aGF0IGlzIGludm9rZWQgaW1tZWRpYXRlbHkgd2l0aCB7QGNvZGUgcmVzb2x2ZX1cbiAqICAgICBhbmQge0Bjb2RlIHJlamVjdH0gZnVuY3Rpb25zIGFzIGFyZ3VtZW50cy4gVGhlIFByb21pc2UgaXMgcmVzb2x2ZWQgb3JcbiAqICAgICByZWplY3RlZCB3aXRoIHRoZSBmaXJzdCBhcmd1bWVudCBwYXNzZWQgdG8gZWl0aGVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtSRVNPTFZFUl9DT05URVhUPX0gb3B0X2NvbnRleHQgQW4gb3B0aW9uYWwgY29udGV4dCBmb3IgZXhlY3V0aW5nIHRoZVxuICogICAgIHJlc29sdmVyIGZ1bmN0aW9uLiBJZiB1bnNwZWNpZmllZCwgdGhlIHJlc29sdmVyIGZ1bmN0aW9uIHdpbGwgYmUgZXhlY3V0ZWRcbiAqICAgICBpbiB0aGUgZGVmYXVsdCBzY29wZS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHN0cnVjdFxuICogQGZpbmFsXG4gKiBAaW1wbGVtZW50cyB7VGhlbmFibGUuPFRZUEU+fVxuICogQHRlbXBsYXRlIFRZUEUsUkVTT0xWRVJfQ09OVEVYVFxuICovXG52YXIgQ2FuY2VsbGFibGVQcm9taXNlID0gZnVuY3Rpb24ocmVzb2x2ZXIsIG9wdF9jb250ZXh0KSB7XG4gIC8qKlxuICAgKiBUaGUgaW50ZXJuYWwgc3RhdGUgb2YgdGhpcyBQcm9taXNlLiBFaXRoZXIgUEVORElORywgRlVMRklMTEVELCBSRUpFQ1RFRCwgb3JcbiAgICogQkxPQ0tFRC5cbiAgICogQHByaXZhdGUge0NhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV99XG4gICAqL1xuICB0aGlzLnN0YXRlXyA9IENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uUEVORElORztcblxuICAvKipcbiAgICogVGhlIHJlc29sdmVkIHJlc3VsdCBvZiB0aGUgUHJvbWlzZS4gSW1tdXRhYmxlIG9uY2Ugc2V0IHdpdGggZWl0aGVyIGFcbiAgICogZnVsZmlsbG1lbnQgdmFsdWUgb3IgcmVqZWN0aW9uIHJlYXNvbi5cbiAgICogQHByaXZhdGUgeyp9XG4gICAqL1xuICB0aGlzLnJlc3VsdF8gPSB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIEZvciBQcm9taXNlcyBjcmVhdGVkIGJ5IGNhbGxpbmcge0Bjb2RlIHRoZW4oKX0sIHRoZSBvcmlnaW5hdGluZyBwYXJlbnQuXG4gICAqIEBwcml2YXRlIHtDYW5jZWxsYWJsZVByb21pc2V9XG4gICAqL1xuICB0aGlzLnBhcmVudF8gPSBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgbGlzdCBvZiB7QGNvZGUgb25GdWxmaWxsZWR9IGFuZCB7QGNvZGUgb25SZWplY3RlZH0gY2FsbGJhY2tzIGFkZGVkIHRvXG4gICAqIHRoaXMgUHJvbWlzZSBieSBjYWxscyB0byB7QGNvZGUgdGhlbigpfS5cbiAgICogQHByaXZhdGUge0FycmF5LjxDYW5jZWxsYWJsZVByb21pc2UuQ2FsbGJhY2tFbnRyeV8+fVxuICAgKi9cbiAgdGhpcy5jYWxsYmFja0VudHJpZXNfID0gbnVsbDtcblxuICAvKipcbiAgICogV2hldGhlciB0aGUgUHJvbWlzZSBpcyBpbiB0aGUgcXVldWUgb2YgUHJvbWlzZXMgdG8gZXhlY3V0ZS5cbiAgICogQHByaXZhdGUge2Jvb2xlYW59XG4gICAqL1xuICB0aGlzLmV4ZWN1dGluZ18gPSBmYWxzZTtcblxuICBpZiAoQ2FuY2VsbGFibGVQcm9taXNlLlVOSEFORExFRF9SRUpFQ1RJT05fREVMQVkgPiAwKSB7XG4gICAgLyoqXG4gICAgICogQSB0aW1lb3V0IElEIHVzZWQgd2hlbiB0aGUge0Bjb2RlIFVOSEFORExFRF9SRUpFQ1RJT05fREVMQVl9IGlzIGdyZWF0ZXJcbiAgICAgKiB0aGFuIDAgbWlsbGlzZWNvbmRzLiBUaGUgSUQgaXMgc2V0IHdoZW4gdGhlIFByb21pc2UgaXMgcmVqZWN0ZWQsIGFuZFxuICAgICAqIGNsZWFyZWQgb25seSBpZiBhbiB7QGNvZGUgb25SZWplY3RlZH0gY2FsbGJhY2sgaXMgaW52b2tlZCBmb3IgdGhlXG4gICAgICogUHJvbWlzZSAob3Igb25lIG9mIGl0cyBkZXNjZW5kYW50cykgYmVmb3JlIHRoZSBkZWxheSBpcyBleGNlZWRlZC5cbiAgICAgKlxuICAgICAqIElmIHRoZSByZWplY3Rpb24gaXMgbm90IGhhbmRsZWQgYmVmb3JlIHRoZSB0aW1lb3V0IGNvbXBsZXRlcywgdGhlXG4gICAgICogcmVqZWN0aW9uIHJlYXNvbiBpcyBwYXNzZWQgdG8gdGhlIHVuaGFuZGxlZCByZWplY3Rpb24gaGFuZGxlci5cbiAgICAgKiBAcHJpdmF0ZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudW5oYW5kbGVkUmVqZWN0aW9uSWRfID0gMDtcbiAgfSBlbHNlIGlmIChDYW5jZWxsYWJsZVByb21pc2UuVU5IQU5ETEVEX1JFSkVDVElPTl9ERUxBWSA9PT0gMCkge1xuICAgIC8qKlxuICAgICAqIFdoZW4gdGhlIHtAY29kZSBVTkhBTkRMRURfUkVKRUNUSU9OX0RFTEFZfSBpcyBzZXQgdG8gMCBtaWxsaXNlY29uZHMsIGFcbiAgICAgKiBib29sZWFuIHRoYXQgaXMgc2V0IGlmIHRoZSBQcm9taXNlIGlzIHJlamVjdGVkLCBhbmQgcmVzZXQgdG8gZmFsc2UgaWYgYW5cbiAgICAgKiB7QGNvZGUgb25SZWplY3RlZH0gY2FsbGJhY2sgaXMgaW52b2tlZCBmb3IgdGhlIFByb21pc2UgKG9yIG9uZSBvZiBpdHNcbiAgICAgKiBkZXNjZW5kYW50cykuIElmIHRoZSByZWplY3Rpb24gaXMgbm90IGhhbmRsZWQgYmVmb3JlIHRoZSBuZXh0IHRpbWVzdGVwLFxuICAgICAqIHRoZSByZWplY3Rpb24gcmVhc29uIGlzIHBhc3NlZCB0byB0aGUgdW5oYW5kbGVkIHJlamVjdGlvbiBoYW5kbGVyLlxuICAgICAqIEBwcml2YXRlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuaGFkVW5oYW5kbGVkUmVqZWN0aW9uXyA9IGZhbHNlO1xuICB9XG5cbiAgdHJ5IHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgcmVzb2x2ZXIuY2FsbChcbiAgICAgIG9wdF9jb250ZXh0LCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBzZWxmLnJlc29sdmVfKENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uRlVMRklMTEVELCB2YWx1ZSk7XG4gICAgICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgICAgc2VsZi5yZXNvbHZlXyhDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLlJFSkVDVEVELCByZWFzb24pO1xuICAgICAgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aGlzLnJlc29sdmVfKENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uUkVKRUNURUQsIGUpO1xuICB9XG59O1xuXG4vKipcbiAqIFRoZSBkZWxheSBpbiBtaWxsaXNlY29uZHMgYmVmb3JlIGEgcmVqZWN0ZWQgUHJvbWlzZSdzIHJlYXNvbiBpcyBwYXNzZWQgdG9cbiAqIHRoZSByZWplY3Rpb24gaGFuZGxlci4gQnkgZGVmYXVsdCwgdGhlIHJlamVjdGlvbiBoYW5kbGVyIHJldGhyb3dzIHRoZVxuICogcmVqZWN0aW9uIHJlYXNvbiBzbyB0aGF0IGl0IGFwcGVhcnMgaW4gdGhlIGRldmVsb3BlciBjb25zb2xlIG9yXG4gKiB7QGNvZGUgd2luZG93Lm9uZXJyb3J9IGhhbmRsZXIuXG4gKiBSZWplY3Rpb25zIGFyZSByZXRocm93biBhcyBxdWlja2x5IGFzIHBvc3NpYmxlIGJ5IGRlZmF1bHQuIEEgbmVnYXRpdmUgdmFsdWVcbiAqIGRpc2FibGVzIHJlamVjdGlvbiBoYW5kbGluZyBlbnRpcmVseS5cbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5VTkhBTkRMRURfUkVKRUNUSU9OX0RFTEFZID0gMDtcblxuXG4vKipcbiAqIFRoZSBwb3NzaWJsZSBpbnRlcm5hbCBzdGF0ZXMgZm9yIGEgUHJvbWlzZS4gVGhlc2Ugc3RhdGVzIGFyZSBub3QgZGlyZWN0bHlcbiAqIG9ic2VydmFibGUgdG8gZXh0ZXJuYWwgY2FsbGVycy5cbiAqIEBlbnVtIHtudW1iZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfID0ge1xuICAvKiogVGhlIFByb21pc2UgaXMgd2FpdGluZyBmb3IgcmVzb2x1dGlvbi4gKi9cbiAgUEVORElORzogMCxcblxuICAvKiogVGhlIFByb21pc2UgaXMgYmxvY2tlZCB3YWl0aW5nIGZvciB0aGUgcmVzdWx0IG9mIGFub3RoZXIgVGhlbmFibGUuICovXG4gIEJMT0NLRUQ6IDEsXG5cbiAgLyoqIFRoZSBQcm9taXNlIGhhcyBiZWVuIHJlc29sdmVkIHdpdGggYSBmdWxmaWxsbWVudCB2YWx1ZS4gKi9cbiAgRlVMRklMTEVEOiAyLFxuXG4gIC8qKiBUaGUgUHJvbWlzZSBoYXMgYmVlbiByZXNvbHZlZCB3aXRoIGEgcmVqZWN0aW9uIHJlYXNvbi4gKi9cbiAgUkVKRUNURUQ6IDNcbn07XG5cblxuLyoqXG4gKiBUeXBlZGVmIGZvciBlbnRyaWVzIGluIHRoZSBjYWxsYmFjayBjaGFpbi4gRWFjaCBjYWxsIHRvIHtAY29kZSB0aGVufSxcbiAqIHtAY29kZSB0aGVuQ2F0Y2h9LCBvciB7QGNvZGUgdGhlbkFsd2F5c30gY3JlYXRlcyBhbiBlbnRyeSBjb250YWluaW5nIHRoZVxuICogZnVuY3Rpb25zIHRoYXQgbWF5IGJlIGludm9rZWQgb25jZSB0aGUgUHJvbWlzZSBpcyByZXNvbHZlZC5cbiAqXG4gKiBAdHlwZWRlZiB7e1xuICogICBjaGlsZDogQ2FuY2VsbGFibGVQcm9taXNlLFxuICogICBvbkZ1bGZpbGxlZDogZnVuY3Rpb24oKiksXG4gKiAgIG9uUmVqZWN0ZWQ6IGZ1bmN0aW9uKCopXG4gKiB9fVxuICogQHByaXZhdGVcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLkNhbGxiYWNrRW50cnlfID0gbnVsbDtcblxuXG4vKipcbiAqIEBwYXJhbSB7KFRZUEV8VGhlbmFibGUuPFRZUEU+fFRoZW5hYmxlKT19IG9wdF92YWx1ZVxuICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZS48VFlQRT59IEEgbmV3IFByb21pc2UgdGhhdCBpcyBpbW1lZGlhdGVseSByZXNvbHZlZFxuICogICAgIHdpdGggdGhlIGdpdmVuIHZhbHVlLlxuICogQHRlbXBsYXRlIFRZUEVcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLnJlc29sdmUgPSBmdW5jdGlvbihvcHRfdmFsdWUpIHtcbiAgcmV0dXJuIG5ldyBDYW5jZWxsYWJsZVByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgcmVzb2x2ZShvcHRfdmFsdWUpO1xuICAgIH0pO1xufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7Kj19IG9wdF9yZWFzb25cbiAqIEByZXR1cm4geyFDYW5jZWxsYWJsZVByb21pc2V9IEEgbmV3IFByb21pc2UgdGhhdCBpcyBpbW1lZGlhdGVseSByZWplY3RlZCB3aXRoIHRoZVxuICogICAgIGdpdmVuIHJlYXNvbi5cbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLnJlamVjdCA9IGZ1bmN0aW9uKG9wdF9yZWFzb24pIHtcbiAgcmV0dXJuIG5ldyBDYW5jZWxsYWJsZVByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICByZWplY3Qob3B0X3JlYXNvbik7XG4gICAgfSk7XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHshQXJyYXkuPCEoVGhlbmFibGUuPFRZUEU+fFRoZW5hYmxlKT59IHByb21pc2VzXG4gKiBAcmV0dXJuIHshQ2FuY2VsbGFibGVQcm9taXNlLjxUWVBFPn0gQSBQcm9taXNlIHRoYXQgcmVjZWl2ZXMgdGhlIHJlc3VsdCBvZiB0aGVcbiAqICAgICBmaXJzdCBQcm9taXNlIChvciBQcm9taXNlLWxpa2UpIGlucHV0IHRvIGNvbXBsZXRlLlxuICogQHRlbXBsYXRlIFRZUEVcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLnJhY2UgPSBmdW5jdGlvbihwcm9taXNlcykge1xuICByZXR1cm4gbmV3IENhbmNlbGxhYmxlUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGlmICghcHJvbWlzZXMubGVuZ3RoKSB7XG4gICAgICAgIHJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwLCBwcm9taXNlOyAocHJvbWlzZSA9IHByb21pc2VzW2ldKTsgaSsrKSB7XG4gICAgICAgIHByb21pc2UudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgfVxuICAgIH0pO1xufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7IUFycmF5LjwhKFRoZW5hYmxlLjxUWVBFPnxUaGVuYWJsZSk+fSBwcm9taXNlc1xuICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZS48IUFycmF5LjxUWVBFPj59IEEgUHJvbWlzZSB0aGF0IHJlY2VpdmVzIGEgbGlzdCBvZlxuICogICAgIGV2ZXJ5IGZ1bGZpbGxlZCB2YWx1ZSBvbmNlIGV2ZXJ5IGlucHV0IFByb21pc2UgKG9yIFByb21pc2UtbGlrZSkgaXNcbiAqICAgICBzdWNjZXNzZnVsbHkgZnVsZmlsbGVkLCBvciBpcyByZWplY3RlZCBieSB0aGUgZmlyc3QgcmVqZWN0aW9uIHJlc3VsdC5cbiAqIEB0ZW1wbGF0ZSBUWVBFXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5hbGwgPSBmdW5jdGlvbihwcm9taXNlcykge1xuICByZXR1cm4gbmV3IENhbmNlbGxhYmxlUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciB0b0Z1bGZpbGwgPSBwcm9taXNlcy5sZW5ndGg7XG4gICAgICB2YXIgdmFsdWVzID0gW107XG5cbiAgICAgIGlmICghdG9GdWxmaWxsKSB7XG4gICAgICAgIHJlc29sdmUodmFsdWVzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgb25GdWxmaWxsID0gZnVuY3Rpb24oaW5kZXgsIHZhbHVlKSB7XG4gICAgICAgIHRvRnVsZmlsbC0tO1xuICAgICAgICB2YWx1ZXNbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgIGlmICh0b0Z1bGZpbGwgPT09IDApIHtcbiAgICAgICAgICByZXNvbHZlKHZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBvblJlamVjdCA9IGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICByZWplY3QocmVhc29uKTtcbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBwcm9taXNlOyAocHJvbWlzZSA9IHByb21pc2VzW2ldKTsgaSsrKSB7XG4gICAgICAgIHByb21pc2UudGhlbihwYXJ0aWFsKG9uRnVsZmlsbCwgaSksIG9uUmVqZWN0KTtcbiAgICAgIH1cbiAgICB9KTtcbn07XG5cblxuLyoqXG4gKiBAcGFyYW0geyFBcnJheS48IShUaGVuYWJsZS48VFlQRT58VGhlbmFibGUpPn0gcHJvbWlzZXNcbiAqIEByZXR1cm4geyFDYW5jZWxsYWJsZVByb21pc2UuPFRZUEU+fSBBIFByb21pc2UgdGhhdCByZWNlaXZlcyB0aGUgdmFsdWUgb2ZcbiAqICAgICB0aGUgZmlyc3QgaW5wdXQgdG8gYmUgZnVsZmlsbGVkLCBvciBpcyByZWplY3RlZCB3aXRoIGEgbGlzdCBvZiBldmVyeVxuICogICAgIHJlamVjdGlvbiByZWFzb24gaWYgYWxsIGlucHV0cyBhcmUgcmVqZWN0ZWQuXG4gKiBAdGVtcGxhdGUgVFlQRVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UuZmlyc3RGdWxmaWxsZWQgPSBmdW5jdGlvbihwcm9taXNlcykge1xuICByZXR1cm4gbmV3IENhbmNlbGxhYmxlUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciB0b1JlamVjdCA9IHByb21pc2VzLmxlbmd0aDtcbiAgICAgIHZhciByZWFzb25zID0gW107XG5cbiAgICAgIGlmICghdG9SZWplY3QpIHtcbiAgICAgICAgcmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBvbkZ1bGZpbGwgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBvblJlamVjdCA9IGZ1bmN0aW9uKGluZGV4LCByZWFzb24pIHtcbiAgICAgICAgdG9SZWplY3QtLTtcbiAgICAgICAgcmVhc29uc1tpbmRleF0gPSByZWFzb247XG4gICAgICAgIGlmICh0b1JlamVjdCA9PT0gMCkge1xuICAgICAgICAgIHJlamVjdChyZWFzb25zKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIHByb21pc2U7IChwcm9taXNlID0gcHJvbWlzZXNbaV0pOyBpKyspIHtcbiAgICAgICAgcHJvbWlzZS50aGVuKG9uRnVsZmlsbCwgcGFydGlhbChvblJlamVjdCwgaSkpO1xuICAgICAgfVxuICAgIH0pO1xufTtcblxuXG4vKipcbiAqIEFkZHMgY2FsbGJhY2tzIHRoYXQgd2lsbCBvcGVyYXRlIG9uIHRoZSByZXN1bHQgb2YgdGhlIFByb21pc2UsIHJldHVybmluZyBhXG4gKiBuZXcgY2hpbGQgUHJvbWlzZS5cbiAqXG4gKiBJZiB0aGUgUHJvbWlzZSBpcyBmdWxmaWxsZWQsIHRoZSB7QGNvZGUgb25GdWxmaWxsZWR9IGNhbGxiYWNrIHdpbGwgYmUgaW52b2tlZFxuICogd2l0aCB0aGUgZnVsZmlsbG1lbnQgdmFsdWUgYXMgYXJndW1lbnQsIGFuZCB0aGUgY2hpbGQgUHJvbWlzZSB3aWxsIGJlXG4gKiBmdWxmaWxsZWQgd2l0aCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBjYWxsYmFjay4gSWYgdGhlIGNhbGxiYWNrIHRocm93cyBhblxuICogZXhjZXB0aW9uLCB0aGUgY2hpbGQgUHJvbWlzZSB3aWxsIGJlIHJlamVjdGVkIHdpdGggdGhlIHRocm93biB2YWx1ZSBpbnN0ZWFkLlxuICpcbiAqIElmIHRoZSBQcm9taXNlIGlzIHJlamVjdGVkLCB0aGUge0Bjb2RlIG9uUmVqZWN0ZWR9IGNhbGxiYWNrIHdpbGwgYmUgaW52b2tlZFxuICogd2l0aCB0aGUgcmVqZWN0aW9uIHJlYXNvbiBhcyBhcmd1bWVudCwgYW5kIHRoZSBjaGlsZCBQcm9taXNlIHdpbGwgYmUgcmVqZWN0ZWRcbiAqIHdpdGggdGhlIHJldHVybiB2YWx1ZSAob3IgdGhyb3duIHZhbHVlKSBvZiB0aGUgY2FsbGJhY2suXG4gKlxuICogQG92ZXJyaWRlXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uKG9wdF9vbkZ1bGZpbGxlZCwgb3B0X29uUmVqZWN0ZWQsIG9wdF9jb250ZXh0KSB7XG4gIHJldHVybiB0aGlzLmFkZENoaWxkUHJvbWlzZV8oXG4gICAgY29yZS5pc0Z1bmN0aW9uKG9wdF9vbkZ1bGZpbGxlZCkgPyBvcHRfb25GdWxmaWxsZWQgOiBudWxsLFxuICAgIGNvcmUuaXNGdW5jdGlvbihvcHRfb25SZWplY3RlZCkgPyBvcHRfb25SZWplY3RlZCA6IG51bGwsXG4gICAgb3B0X2NvbnRleHQpO1xufTtcblRoZW5hYmxlLmFkZEltcGxlbWVudGF0aW9uKENhbmNlbGxhYmxlUHJvbWlzZSk7XG5cblxuLyoqXG4gKiBBZGRzIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGludm9rZWQgd2hldGhlciB0aGUgUHJvbWlzZSBpcyBmdWxmaWxsZWQgb3JcbiAqIHJlamVjdGVkLiBUaGUgY2FsbGJhY2sgcmVjZWl2ZXMgbm8gYXJndW1lbnQsIGFuZCBubyBuZXcgY2hpbGQgUHJvbWlzZSBpc1xuICogY3JlYXRlZC4gVGhpcyBpcyB1c2VmdWwgZm9yIGVuc3VyaW5nIHRoYXQgY2xlYW51cCB0YWtlcyBwbGFjZSBhZnRlciBjZXJ0YWluXG4gKiBhc3luY2hyb25vdXMgb3BlcmF0aW9ucy4gQ2FsbGJhY2tzIGFkZGVkIHdpdGgge0Bjb2RlIHRoZW5BbHdheXN9IHdpbGwgYmVcbiAqIGV4ZWN1dGVkIGluIHRoZSBzYW1lIG9yZGVyIHdpdGggb3RoZXIgY2FsbHMgdG8ge0Bjb2RlIHRoZW59LFxuICoge0Bjb2RlIHRoZW5BbHdheXN9LCBvciB7QGNvZGUgdGhlbkNhdGNofS5cbiAqXG4gKiBTaW5jZSBpdCBkb2VzIG5vdCBwcm9kdWNlIGEgbmV3IGNoaWxkIFByb21pc2UsIGNhbmNlbGxhdGlvbiBwcm9wYWdhdGlvbiBpc1xuICogbm90IHByZXZlbnRlZCBieSBhZGRpbmcgY2FsbGJhY2tzIHdpdGgge0Bjb2RlIHRoZW5BbHdheXN9LiBBIFByb21pc2UgdGhhdCBoYXNcbiAqIGEgY2xlYW51cCBoYW5kbGVyIGFkZGVkIHdpdGgge0Bjb2RlIHRoZW5BbHdheXN9IHdpbGwgYmUgY2FuY2VsZWQgaWYgYWxsIG9mXG4gKiBpdHMgY2hpbGRyZW4gY3JlYXRlZCBieSB7QGNvZGUgdGhlbn0gKG9yIHtAY29kZSB0aGVuQ2F0Y2h9KSBhcmUgY2FuY2VsZWQuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOlRISVMpOiB2b2lkfSBvblJlc29sdmVkIEEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGludm9rZWRcbiAqICAgICB3aGVuIHRoZSBQcm9taXNlIGlzIHJlc29sdmVkLlxuICogQHBhcmFtIHtUSElTPX0gb3B0X2NvbnRleHQgQW4gb3B0aW9uYWwgY29udGV4dCBvYmplY3QgdGhhdCB3aWxsIGJlIHRoZVxuICogICAgIGV4ZWN1dGlvbiBjb250ZXh0IGZvciB0aGUgY2FsbGJhY2tzLiBCeSBkZWZhdWx0LCBmdW5jdGlvbnMgYXJlIGV4ZWN1dGVkXG4gKiAgICAgaW4gdGhlIGdsb2JhbCBzY29wZS5cbiAqIEByZXR1cm4geyFDYW5jZWxsYWJsZVByb21pc2UuPFRZUEU+fSBUaGlzIFByb21pc2UsIGZvciBjaGFpbmluZyBhZGRpdGlvbmFsIGNhbGxzLlxuICogQHRlbXBsYXRlIFRISVNcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLnByb3RvdHlwZS50aGVuQWx3YXlzID0gZnVuY3Rpb24ob25SZXNvbHZlZCwgb3B0X2NvbnRleHQpIHtcbiAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEVuc3VyZSB0aGF0IG5vIGFyZ3VtZW50cyBhcmUgcGFzc2VkIHRvIG9uUmVzb2x2ZWQuXG4gICAgICBvblJlc29sdmVkLmNhbGwob3B0X2NvbnRleHQpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgQ2FuY2VsbGFibGVQcm9taXNlLmhhbmRsZVJlamVjdGlvbl8uY2FsbChudWxsLCBlcnIpO1xuICAgIH1cbiAgfTtcblxuICB0aGlzLmFkZENhbGxiYWNrRW50cnlfKHtcbiAgICBjaGlsZDogbnVsbCxcbiAgICBvblJlamVjdGVkOiBjYWxsYmFjayxcbiAgICBvbkZ1bGZpbGxlZDogY2FsbGJhY2tcbiAgfSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vKipcbiAqIEFkZHMgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgaW52b2tlZCBvbmx5IGlmIHRoZSBQcm9taXNlIGlzIHJlamVjdGVkLiBUaGlzXG4gKiBpcyBlcXVpdmFsZW50IHRvIHtAY29kZSB0aGVuKG51bGwsIG9uUmVqZWN0ZWQpfS5cbiAqXG4gKiBAcGFyYW0geyFmdW5jdGlvbih0aGlzOlRISVMsICopOiAqfSBvblJlamVjdGVkIEEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlXG4gKiAgICAgaW52b2tlZCB3aXRoIHRoZSByZWplY3Rpb24gcmVhc29uIGlmIHRoZSBQcm9taXNlIGlzIHJlamVjdGVkLlxuICogQHBhcmFtIHtUSElTPX0gb3B0X2NvbnRleHQgQW4gb3B0aW9uYWwgY29udGV4dCBvYmplY3QgdGhhdCB3aWxsIGJlIHRoZVxuICogICAgIGV4ZWN1dGlvbiBjb250ZXh0IGZvciB0aGUgY2FsbGJhY2tzLiBCeSBkZWZhdWx0LCBmdW5jdGlvbnMgYXJlIGV4ZWN1dGVkXG4gKiAgICAgaW4gdGhlIGdsb2JhbCBzY29wZS5cbiAqIEByZXR1cm4geyFDYW5jZWxsYWJsZVByb21pc2V9IEEgbmV3IFByb21pc2UgdGhhdCB3aWxsIHJlY2VpdmUgdGhlIHJlc3VsdCBvZiB0aGVcbiAqICAgICBjYWxsYmFjay5cbiAqIEB0ZW1wbGF0ZSBUSElTXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5wcm90b3R5cGUudGhlbkNhdGNoID0gZnVuY3Rpb24ob25SZWplY3RlZCwgb3B0X2NvbnRleHQpIHtcbiAgcmV0dXJuIHRoaXMuYWRkQ2hpbGRQcm9taXNlXyhudWxsLCBvblJlamVjdGVkLCBvcHRfY29udGV4dCk7XG59O1xuXG4vKipcbiAqIEFsaWFzIG9mIHtAbGluayBDYW5jZWxsYWJsZVByb21pc2UucHJvdG90eXBlLnRoZW5DYXRjaH1cbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLnByb3RvdHlwZS5jYXRjaCA9IENhbmNlbGxhYmxlUHJvbWlzZS5wcm90b3R5cGUudGhlbkNhdGNoO1xuXG5cbi8qKlxuICogQ2FuY2VscyB0aGUgUHJvbWlzZSBpZiBpdCBpcyBzdGlsbCBwZW5kaW5nIGJ5IHJlamVjdGluZyBpdCB3aXRoIGEgY2FuY2VsXG4gKiBFcnJvci4gTm8gYWN0aW9uIGlzIHBlcmZvcm1lZCBpZiB0aGUgUHJvbWlzZSBpcyBhbHJlYWR5IHJlc29sdmVkLlxuICpcbiAqIEFsbCBjaGlsZCBQcm9taXNlcyBvZiB0aGUgY2FuY2VsZWQgUHJvbWlzZSB3aWxsIGJlIHJlamVjdGVkIHdpdGggdGhlIHNhbWVcbiAqIGNhbmNlbCBlcnJvciwgYXMgd2l0aCBub3JtYWwgUHJvbWlzZSByZWplY3Rpb24uIElmIHRoZSBQcm9taXNlIHRvIGJlIGNhbmNlbGVkXG4gKiBpcyB0aGUgb25seSBjaGlsZCBvZiBhIHBlbmRpbmcgUHJvbWlzZSwgdGhlIHBhcmVudCBQcm9taXNlIHdpbGwgYWxzbyBiZVxuICogY2FuY2VsZWQuIENhbmNlbGxhdGlvbiBtYXkgcHJvcGFnYXRlIHVwd2FyZCB0aHJvdWdoIG11bHRpcGxlIGdlbmVyYXRpb25zLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X21lc3NhZ2UgQW4gb3B0aW9uYWwgZGVidWdnaW5nIG1lc3NhZ2UgZm9yIGRlc2NyaWJpbmcgdGhlXG4gKiAgICAgY2FuY2VsbGF0aW9uIHJlYXNvbi5cbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbihvcHRfbWVzc2FnZSkge1xuICBpZiAodGhpcy5zdGF0ZV8gPT09IENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uUEVORElORykge1xuICAgIGFzeW5jLnJ1bihmdW5jdGlvbigpIHtcbiAgICAgIHZhciBlcnIgPSBuZXcgQ2FuY2VsbGFibGVQcm9taXNlLkNhbmNlbGxhdGlvbkVycm9yKG9wdF9tZXNzYWdlKTtcbiAgICAgIGVyci5JU19DQU5DRUxMQVRJT05fRVJST1IgPSB0cnVlO1xuICAgICAgdGhpcy5jYW5jZWxJbnRlcm5hbF8oZXJyKTtcbiAgICB9LCB0aGlzKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIENhbmNlbHMgdGhpcyBQcm9taXNlIHdpdGggdGhlIGdpdmVuIGVycm9yLlxuICpcbiAqIEBwYXJhbSB7IUVycm9yfSBlcnIgVGhlIGNhbmNlbGxhdGlvbiBlcnJvci5cbiAqIEBwcml2YXRlXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5wcm90b3R5cGUuY2FuY2VsSW50ZXJuYWxfID0gZnVuY3Rpb24oZXJyKSB7XG4gIGlmICh0aGlzLnN0YXRlXyA9PT0gQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5QRU5ESU5HKSB7XG4gICAgaWYgKHRoaXMucGFyZW50Xykge1xuICAgICAgLy8gQ2FuY2VsIHRoZSBQcm9taXNlIGFuZCByZW1vdmUgaXQgZnJvbSB0aGUgcGFyZW50J3MgY2hpbGQgbGlzdC5cbiAgICAgIHRoaXMucGFyZW50Xy5jYW5jZWxDaGlsZF8odGhpcywgZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZXNvbHZlXyhDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLlJFSkVDVEVELCBlcnIpO1xuICAgIH1cbiAgfVxufTtcblxuXG4vKipcbiAqIENhbmNlbHMgYSBjaGlsZCBQcm9taXNlIGZyb20gdGhlIGxpc3Qgb2YgY2FsbGJhY2sgZW50cmllcy4gSWYgdGhlIFByb21pc2UgaGFzXG4gKiBub3QgYWxyZWFkeSBiZWVuIHJlc29sdmVkLCByZWplY3QgaXQgd2l0aCBhIGNhbmNlbCBlcnJvci4gSWYgdGhlcmUgYXJlIG5vXG4gKiBvdGhlciBjaGlsZHJlbiBpbiB0aGUgbGlzdCBvZiBjYWxsYmFjayBlbnRyaWVzLCBwcm9wYWdhdGUgdGhlIGNhbmNlbGxhdGlvblxuICogYnkgY2FuY2VsaW5nIHRoaXMgUHJvbWlzZSBhcyB3ZWxsLlxuICpcbiAqIEBwYXJhbSB7IUNhbmNlbGxhYmxlUHJvbWlzZX0gY2hpbGRQcm9taXNlIFRoZSBQcm9taXNlIHRvIGNhbmNlbC5cbiAqIEBwYXJhbSB7IUVycm9yfSBlcnIgVGhlIGNhbmNlbCBlcnJvciB0byB1c2UgZm9yIHJlamVjdGluZyB0aGUgUHJvbWlzZS5cbiAqIEBwcml2YXRlXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5wcm90b3R5cGUuY2FuY2VsQ2hpbGRfID0gZnVuY3Rpb24oY2hpbGRQcm9taXNlLCBlcnIpIHtcbiAgaWYgKCF0aGlzLmNhbGxiYWNrRW50cmllc18pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGNoaWxkQ291bnQgPSAwO1xuICB2YXIgY2hpbGRJbmRleCA9IC0xO1xuXG4gIC8vIEZpbmQgdGhlIGNhbGxiYWNrIGVudHJ5IGZvciB0aGUgY2hpbGRQcm9taXNlLCBhbmQgY291bnQgd2hldGhlciB0aGVyZSBhcmVcbiAgLy8gYWRkaXRpb25hbCBjaGlsZCBQcm9taXNlcy5cbiAgZm9yICh2YXIgaSA9IDAsIGVudHJ5OyAoZW50cnkgPSB0aGlzLmNhbGxiYWNrRW50cmllc19baV0pOyBpKyspIHtcbiAgICB2YXIgY2hpbGQgPSBlbnRyeS5jaGlsZDtcbiAgICBpZiAoY2hpbGQpIHtcbiAgICAgIGNoaWxkQ291bnQrKztcbiAgICAgIGlmIChjaGlsZCA9PT0gY2hpbGRQcm9taXNlKSB7XG4gICAgICAgIGNoaWxkSW5kZXggPSBpO1xuICAgICAgfVxuICAgICAgaWYgKGNoaWxkSW5kZXggPj0gMCAmJiBjaGlsZENvdW50ID4gMSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBJZiB0aGUgY2hpbGQgUHJvbWlzZSB3YXMgdGhlIG9ubHkgY2hpbGQsIGNhbmNlbCB0aGlzIFByb21pc2UgYXMgd2VsbC5cbiAgLy8gT3RoZXJ3aXNlLCByZWplY3Qgb25seSB0aGUgY2hpbGQgUHJvbWlzZSB3aXRoIHRoZSBjYW5jZWwgZXJyb3IuXG4gIGlmIChjaGlsZEluZGV4ID49IDApIHtcbiAgICBpZiAodGhpcy5zdGF0ZV8gPT09IENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uUEVORElORyAmJiBjaGlsZENvdW50ID09PSAxKSB7XG4gICAgICB0aGlzLmNhbmNlbEludGVybmFsXyhlcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY2FsbGJhY2tFbnRyeSA9IHRoaXMuY2FsbGJhY2tFbnRyaWVzXy5zcGxpY2UoY2hpbGRJbmRleCwgMSlbMF07XG4gICAgICB0aGlzLmV4ZWN1dGVDYWxsYmFja18oXG4gICAgICAgIGNhbGxiYWNrRW50cnksIENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uUkVKRUNURUQsIGVycik7XG4gICAgfVxuICB9XG59O1xuXG5cbi8qKlxuICogQWRkcyBhIGNhbGxiYWNrIGVudHJ5IHRvIHRoZSBjdXJyZW50IFByb21pc2UsIGFuZCBzY2hlZHVsZXMgY2FsbGJhY2tcbiAqIGV4ZWN1dGlvbiBpZiB0aGUgUHJvbWlzZSBoYXMgYWxyZWFkeSBiZWVuIHJlc29sdmVkLlxuICpcbiAqIEBwYXJhbSB7Q2FuY2VsbGFibGVQcm9taXNlLkNhbGxiYWNrRW50cnlffSBjYWxsYmFja0VudHJ5IFJlY29yZCBjb250YWluaW5nXG4gKiAgICAge0Bjb2RlIG9uRnVsZmlsbGVkfSBhbmQge0Bjb2RlIG9uUmVqZWN0ZWR9IGNhbGxiYWNrcyB0byBleGVjdXRlIGFmdGVyXG4gKiAgICAgdGhlIFByb21pc2UgaXMgcmVzb2x2ZWQuXG4gKiBAcHJpdmF0ZVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UucHJvdG90eXBlLmFkZENhbGxiYWNrRW50cnlfID0gZnVuY3Rpb24oY2FsbGJhY2tFbnRyeSkge1xuICBpZiAoKCF0aGlzLmNhbGxiYWNrRW50cmllc18gfHwgIXRoaXMuY2FsbGJhY2tFbnRyaWVzXy5sZW5ndGgpICYmXG4gICAgKHRoaXMuc3RhdGVfID09PSBDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLkZVTEZJTExFRCB8fFxuICAgIHRoaXMuc3RhdGVfID09PSBDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLlJFSkVDVEVEKSkge1xuICAgIHRoaXMuc2NoZWR1bGVDYWxsYmFja3NfKCk7XG4gIH1cbiAgaWYgKCF0aGlzLmNhbGxiYWNrRW50cmllc18pIHtcbiAgICB0aGlzLmNhbGxiYWNrRW50cmllc18gPSBbXTtcbiAgfVxuICB0aGlzLmNhbGxiYWNrRW50cmllc18ucHVzaChjYWxsYmFja0VudHJ5KTtcbn07XG5cblxuLyoqXG4gKiBDcmVhdGVzIGEgY2hpbGQgUHJvbWlzZSBhbmQgYWRkcyBpdCB0byB0aGUgY2FsbGJhY2sgZW50cnkgbGlzdC4gVGhlIHJlc3VsdCBvZlxuICogdGhlIGNoaWxkIFByb21pc2UgaXMgZGV0ZXJtaW5lZCBieSB0aGUgc3RhdGUgb2YgdGhlIHBhcmVudCBQcm9taXNlIGFuZCB0aGVcbiAqIHJlc3VsdCBvZiB0aGUge0Bjb2RlIG9uRnVsZmlsbGVkfSBvciB7QGNvZGUgb25SZWplY3RlZH0gY2FsbGJhY2tzIGFzXG4gKiBzcGVjaWZpZWQgaW4gdGhlIFByb21pc2UgcmVzb2x1dGlvbiBwcm9jZWR1cmUuXG4gKlxuICogQHNlZSBodHRwOi8vcHJvbWlzZXNhcGx1cy5jb20vI3RoZV9fbWV0aG9kXG4gKlxuICogQHBhcmFtIHs/ZnVuY3Rpb24odGhpczpUSElTLCBUWVBFKTpcbiAqICAgICAgICAgIChSRVNVTFR8Q2FuY2VsbGFibGVQcm9taXNlLjxSRVNVTFQ+fFRoZW5hYmxlKX0gb25GdWxmaWxsZWQgQSBjYWxsYmFjayB0aGF0XG4gKiAgICAgd2lsbCBiZSBpbnZva2VkIGlmIHRoZSBQcm9taXNlIGlzIGZ1bGxmaWxsZWQsIG9yIG51bGwuXG4gKiBAcGFyYW0gez9mdW5jdGlvbih0aGlzOlRISVMsICopOiAqfSBvblJlamVjdGVkIEEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlXG4gKiAgICAgaW52b2tlZCBpZiB0aGUgUHJvbWlzZSBpcyByZWplY3RlZCwgb3IgbnVsbC5cbiAqIEBwYXJhbSB7VEhJUz19IG9wdF9jb250ZXh0IEFuIG9wdGlvbmFsIGV4ZWN1dGlvbiBjb250ZXh0IGZvciB0aGUgY2FsbGJhY2tzLlxuICogICAgIGluIHRoZSBkZWZhdWx0IGNhbGxpbmcgY29udGV4dC5cbiAqIEByZXR1cm4geyFDYW5jZWxsYWJsZVByb21pc2V9IFRoZSBjaGlsZCBQcm9taXNlLlxuICogQHRlbXBsYXRlIFJFU1VMVCxUSElTXG4gKiBAcHJpdmF0ZVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UucHJvdG90eXBlLmFkZENoaWxkUHJvbWlzZV8gPSBmdW5jdGlvbihcbm9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBvcHRfY29udGV4dCkge1xuXG4gIHZhciBjYWxsYmFja0VudHJ5ID0ge1xuICAgIGNoaWxkOiBudWxsLFxuICAgIG9uRnVsZmlsbGVkOiBudWxsLFxuICAgIG9uUmVqZWN0ZWQ6IG51bGxcbiAgfTtcblxuICBjYWxsYmFja0VudHJ5LmNoaWxkID0gbmV3IENhbmNlbGxhYmxlUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAvLyBJbnZva2Ugb25GdWxmaWxsZWQsIG9yIHJlc29sdmUgd2l0aCB0aGUgcGFyZW50J3MgdmFsdWUgaWYgYWJzZW50LlxuICAgIGNhbGxiYWNrRW50cnkub25GdWxmaWxsZWQgPSBvbkZ1bGZpbGxlZCA/IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gb25GdWxmaWxsZWQuY2FsbChvcHRfY29udGV4dCwgdmFsdWUpO1xuICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgfSA6IHJlc29sdmU7XG5cbiAgICAvLyBJbnZva2Ugb25SZWplY3RlZCwgb3IgcmVqZWN0IHdpdGggdGhlIHBhcmVudCdzIHJlYXNvbiBpZiBhYnNlbnQuXG4gICAgY2FsbGJhY2tFbnRyeS5vblJlamVjdGVkID0gb25SZWplY3RlZCA/IGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG9uUmVqZWN0ZWQuY2FsbChvcHRfY29udGV4dCwgcmVhc29uKTtcbiAgICAgICAgaWYgKCFjb3JlLmlzRGVmKHJlc3VsdCkgJiYgcmVhc29uLklTX0NBTkNFTExBVElPTl9FUlJPUikge1xuICAgICAgICAgIC8vIFByb3BhZ2F0ZSBjYW5jZWxsYXRpb24gdG8gY2hpbGRyZW4gaWYgbm8gb3RoZXIgcmVzdWx0IGlzIHJldHVybmVkLlxuICAgICAgICAgIHJlamVjdChyZWFzb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfVxuICAgIH0gOiByZWplY3Q7XG4gIH0pO1xuXG4gIGNhbGxiYWNrRW50cnkuY2hpbGQucGFyZW50XyA9IHRoaXM7XG4gIHRoaXMuYWRkQ2FsbGJhY2tFbnRyeV8oXG4gICAgLyoqIEB0eXBlIHtDYW5jZWxsYWJsZVByb21pc2UuQ2FsbGJhY2tFbnRyeV99ICovIChjYWxsYmFja0VudHJ5KSk7XG4gIHJldHVybiBjYWxsYmFja0VudHJ5LmNoaWxkO1xufTtcblxuXG4vKipcbiAqIFVuYmxvY2tzIHRoZSBQcm9taXNlIGFuZCBmdWxmaWxscyBpdCB3aXRoIHRoZSBnaXZlbiB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge1RZUEV9IHZhbHVlXG4gKiBAcHJpdmF0ZVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UucHJvdG90eXBlLnVuYmxvY2tBbmRGdWxmaWxsXyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICh0aGlzLnN0YXRlXyAhPT0gQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5CTE9DS0VEKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5jZWxsYWJsZVByb21pc2UgaXMgbm90IGJsb2NrZWQuJyk7XG4gIH1cbiAgdGhpcy5zdGF0ZV8gPSBDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLlBFTkRJTkc7XG4gIHRoaXMucmVzb2x2ZV8oQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5GVUxGSUxMRUQsIHZhbHVlKTtcbn07XG5cblxuLyoqXG4gKiBVbmJsb2NrcyB0aGUgUHJvbWlzZSBhbmQgcmVqZWN0cyBpdCB3aXRoIHRoZSBnaXZlbiByZWplY3Rpb24gcmVhc29uLlxuICpcbiAqIEBwYXJhbSB7Kn0gcmVhc29uXG4gKiBAcHJpdmF0ZVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UucHJvdG90eXBlLnVuYmxvY2tBbmRSZWplY3RfID0gZnVuY3Rpb24ocmVhc29uKSB7XG4gIGlmICh0aGlzLnN0YXRlXyAhPT0gQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5CTE9DS0VEKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5jZWxsYWJsZVByb21pc2UgaXMgbm90IGJsb2NrZWQuJyk7XG4gIH1cbiAgdGhpcy5zdGF0ZV8gPSBDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLlBFTkRJTkc7XG4gIHRoaXMucmVzb2x2ZV8oQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5SRUpFQ1RFRCwgcmVhc29uKTtcbn07XG5cblxuLyoqXG4gKiBBdHRlbXB0cyB0byByZXNvbHZlIGEgUHJvbWlzZSB3aXRoIGEgZ2l2ZW4gcmVzb2x1dGlvbiBzdGF0ZSBhbmQgdmFsdWUuIFRoaXNcbiAqIGlzIGEgbm8tb3AgaWYgdGhlIGdpdmVuIFByb21pc2UgaGFzIGFscmVhZHkgYmVlbiByZXNvbHZlZC5cbiAqXG4gKiBJZiB0aGUgZ2l2ZW4gcmVzdWx0IGlzIGEgVGhlbmFibGUgKHN1Y2ggYXMgYW5vdGhlciBQcm9taXNlKSwgdGhlIFByb21pc2Ugd2lsbFxuICogYmUgcmVzb2x2ZWQgd2l0aCB0aGUgc2FtZSBzdGF0ZSBhbmQgcmVzdWx0IGFzIHRoZSBUaGVuYWJsZSBvbmNlIGl0IGlzIGl0c2VsZlxuICogcmVzb2x2ZWQuXG4gKlxuICogSWYgdGhlIGdpdmVuIHJlc3VsdCBpcyBub3QgYSBUaGVuYWJsZSwgdGhlIFByb21pc2Ugd2lsbCBiZSBmdWxmaWxsZWQgb3JcbiAqIHJlamVjdGVkIHdpdGggdGhhdCByZXN1bHQgYmFzZWQgb24gdGhlIGdpdmVuIHN0YXRlLlxuICpcbiAqIEBzZWUgaHR0cDovL3Byb21pc2VzYXBsdXMuY29tLyN0aGVfcHJvbWlzZV9yZXNvbHV0aW9uX3Byb2NlZHVyZVxuICpcbiAqIEBwYXJhbSB7Q2FuY2VsbGFibGVQcm9taXNlLlN0YXRlX30gc3RhdGVcbiAqIEBwYXJhbSB7Kn0geCBUaGUgcmVzdWx0IHRvIGFwcGx5IHRvIHRoZSBQcm9taXNlLlxuICogQHByaXZhdGVcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLnByb3RvdHlwZS5yZXNvbHZlXyA9IGZ1bmN0aW9uKHN0YXRlLCB4KSB7XG4gIGlmICh0aGlzLnN0YXRlXyAhPT0gQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5QRU5ESU5HKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHRoaXMgPT09IHgpIHtcbiAgICBzdGF0ZSA9IENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uUkVKRUNURUQ7XG4gICAgeCA9IG5ldyBUeXBlRXJyb3IoJ0NhbmNlbGxhYmxlUHJvbWlzZSBjYW5ub3QgcmVzb2x2ZSB0byBpdHNlbGYnKTtcblxuICB9IGVsc2UgaWYgKFRoZW5hYmxlLmlzSW1wbGVtZW50ZWRCeSh4KSkge1xuICAgIHggPSAvKiogQHR5cGUgeyFUaGVuYWJsZX0gKi8gKHgpO1xuICAgIHRoaXMuc3RhdGVfID0gQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5CTE9DS0VEO1xuICAgIHgudGhlbih0aGlzLnVuYmxvY2tBbmRGdWxmaWxsXywgdGhpcy51bmJsb2NrQW5kUmVqZWN0XywgdGhpcyk7XG4gICAgcmV0dXJuO1xuXG4gIH0gZWxzZSBpZiAoY29yZS5pc09iamVjdCh4KSkge1xuICAgIHRyeSB7XG4gICAgICB2YXIgdGhlbiA9IHgudGhlbjtcbiAgICAgIGlmIChjb3JlLmlzRnVuY3Rpb24odGhlbikpIHtcbiAgICAgICAgdGhpcy50cnlUaGVuXyh4LCB0aGVuKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHN0YXRlID0gQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5SRUpFQ1RFRDtcbiAgICAgIHggPSBlO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMucmVzdWx0XyA9IHg7XG4gIHRoaXMuc3RhdGVfID0gc3RhdGU7XG4gIHRoaXMuc2NoZWR1bGVDYWxsYmFja3NfKCk7XG5cbiAgaWYgKHN0YXRlID09PSBDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLlJFSkVDVEVEICYmICF4LklTX0NBTkNFTExBVElPTl9FUlJPUikge1xuICAgIENhbmNlbGxhYmxlUHJvbWlzZS5hZGRVbmhhbmRsZWRSZWplY3Rpb25fKHRoaXMsIHgpO1xuICB9XG59O1xuXG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gY2FsbCB0aGUge0Bjb2RlIHRoZW59IG1ldGhvZCBvbiBhbiBvYmplY3QgaW4gdGhlIGhvcGVzIHRoYXQgaXQgaXNcbiAqIGEgUHJvbWlzZS1jb21wYXRpYmxlIGluc3RhbmNlLiBUaGlzIGFsbG93cyBpbnRlcm9wZXJhdGlvbiBiZXR3ZWVuIGRpZmZlcmVudFxuICogUHJvbWlzZSBpbXBsZW1lbnRhdGlvbnMsIGhvd2V2ZXIgYSBub24tY29tcGxpYW50IG9iamVjdCBtYXkgY2F1c2UgYSBQcm9taXNlXG4gKiB0byBoYW5nIGluZGVmaW5pdGVseS4gSWYgdGhlIHtAY29kZSB0aGVufSBtZXRob2QgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgdGhlXG4gKiBkZXBlbmRlbnQgUHJvbWlzZSB3aWxsIGJlIHJlamVjdGVkIHdpdGggdGhlIHRocm93biB2YWx1ZS5cbiAqXG4gKiBAc2VlIGh0dHA6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNzBcbiAqXG4gKiBAcGFyYW0ge1RoZW5hYmxlfSB0aGVuYWJsZSBBbiBvYmplY3Qgd2l0aCBhIHtAY29kZSB0aGVufSBtZXRob2QgdGhhdCBtYXkgYmVcbiAqICAgICBjb21wYXRpYmxlIHdpdGggdGhlIFByb21pc2UvQSsgc3BlY2lmaWNhdGlvbi5cbiAqIEBwYXJhbSB7IUZ1bmN0aW9ufSB0aGVuIFRoZSB7QGNvZGUgdGhlbn0gbWV0aG9kIG9mIHRoZSBUaGVuYWJsZSBvYmplY3QuXG4gKiBAcHJpdmF0ZVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UucHJvdG90eXBlLnRyeVRoZW5fID0gZnVuY3Rpb24odGhlbmFibGUsIHRoZW4pIHtcbiAgdGhpcy5zdGF0ZV8gPSBDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLkJMT0NLRUQ7XG4gIHZhciBwcm9taXNlID0gdGhpcztcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuXG4gIHZhciByZXNvbHZlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgIHByb21pc2UudW5ibG9ja0FuZEZ1bGZpbGxfKHZhbHVlKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHJlamVjdCA9IGZ1bmN0aW9uKHJlYXNvbikge1xuICAgIGlmICghY2FsbGVkKSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgcHJvbWlzZS51bmJsb2NrQW5kUmVqZWN0XyhyZWFzb24pO1xuICAgIH1cbiAgfTtcblxuICB0cnkge1xuICAgIHRoZW4uY2FsbCh0aGVuYWJsZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJlamVjdChlKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIEV4ZWN1dGVzIHRoZSBwZW5kaW5nIGNhbGxiYWNrcyBvZiBhIHJlc29sdmVkIFByb21pc2UgYWZ0ZXIgYSB0aW1lb3V0LlxuICpcbiAqIFNlY3Rpb24gMi4yLjQgb2YgdGhlIFByb21pc2VzL0ErIHNwZWNpZmljYXRpb24gcmVxdWlyZXMgdGhhdCBQcm9taXNlXG4gKiBjYWxsYmFja3MgbXVzdCBvbmx5IGJlIGludm9rZWQgZnJvbSBhIGNhbGwgc3RhY2sgdGhhdCBvbmx5IGNvbnRhaW5zIFByb21pc2VcbiAqIGltcGxlbWVudGF0aW9uIGNvZGUsIHdoaWNoIHdlIGFjY29tcGxpc2ggYnkgaW52b2tpbmcgY2FsbGJhY2sgZXhlY3V0aW9uIGFmdGVyXG4gKiBhIHRpbWVvdXQuIElmIHtAY29kZSBzdGFydEV4ZWN1dGlvbl99IGlzIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyBmb3IgdGhlIHNhbWVcbiAqIFByb21pc2UsIHRoZSBjYWxsYmFjayBjaGFpbiB3aWxsIGJlIGV2YWx1YXRlZCBvbmx5IG9uY2UuIEFkZGl0aW9uYWwgY2FsbGJhY2tzXG4gKiBtYXkgYmUgYWRkZWQgZHVyaW5nIHRoZSBldmFsdWF0aW9uIHBoYXNlLCBhbmQgd2lsbCBiZSBleGVjdXRlZCBpbiB0aGUgc2FtZVxuICogZXZlbnQgbG9vcC5cbiAqXG4gKiBBbGwgUHJvbWlzZXMgYWRkZWQgdG8gdGhlIHdhaXRpbmcgbGlzdCBkdXJpbmcgdGhlIHNhbWUgYnJvd3NlciBldmVudCBsb29wXG4gKiB3aWxsIGJlIGV4ZWN1dGVkIGluIG9uZSBiYXRjaCB0byBhdm9pZCB1c2luZyBhIHNlcGFyYXRlIHRpbWVvdXQgcGVyIFByb21pc2UuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLnByb3RvdHlwZS5zY2hlZHVsZUNhbGxiYWNrc18gPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLmV4ZWN1dGluZ18pIHtcbiAgICB0aGlzLmV4ZWN1dGluZ18gPSB0cnVlO1xuICAgIGFzeW5jLnJ1bih0aGlzLmV4ZWN1dGVDYWxsYmFja3NfLCB0aGlzKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIEV4ZWN1dGVzIGFsbCBwZW5kaW5nIGNhbGxiYWNrcyBmb3IgdGhpcyBQcm9taXNlLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5wcm90b3R5cGUuZXhlY3V0ZUNhbGxiYWNrc18gPSBmdW5jdGlvbigpIHtcbiAgd2hpbGUgKHRoaXMuY2FsbGJhY2tFbnRyaWVzXyAmJiB0aGlzLmNhbGxiYWNrRW50cmllc18ubGVuZ3RoKSB7XG4gICAgdmFyIGVudHJpZXMgPSB0aGlzLmNhbGxiYWNrRW50cmllc187XG4gICAgdGhpcy5jYWxsYmFja0VudHJpZXNfID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVudHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuZXhlY3V0ZUNhbGxiYWNrXyhlbnRyaWVzW2ldLCB0aGlzLnN0YXRlXywgdGhpcy5yZXN1bHRfKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5leGVjdXRpbmdfID0gZmFsc2U7XG59O1xuXG5cbi8qKlxuICogRXhlY3V0ZXMgYSBwZW5kaW5nIGNhbGxiYWNrIGZvciB0aGlzIFByb21pc2UuIEludm9rZXMgYW4ge0Bjb2RlIG9uRnVsZmlsbGVkfVxuICogb3Ige0Bjb2RlIG9uUmVqZWN0ZWR9IGNhbGxiYWNrIGJhc2VkIG9uIHRoZSByZXNvbHZlZCBzdGF0ZSBvZiB0aGUgUHJvbWlzZS5cbiAqXG4gKiBAcGFyYW0geyFDYW5jZWxsYWJsZVByb21pc2UuQ2FsbGJhY2tFbnRyeV99IGNhbGxiYWNrRW50cnkgQW4gZW50cnkgY29udGFpbmluZyB0aGVcbiAqICAgICBvbkZ1bGZpbGxlZCBhbmQvb3Igb25SZWplY3RlZCBjYWxsYmFja3MgZm9yIHRoaXMgc3RlcC5cbiAqIEBwYXJhbSB7Q2FuY2VsbGFibGVQcm9taXNlLlN0YXRlX30gc3RhdGUgVGhlIHJlc29sdXRpb24gc3RhdHVzIG9mIHRoZSBQcm9taXNlLFxuICogICAgIGVpdGhlciBGVUxGSUxMRUQgb3IgUkVKRUNURUQuXG4gKiBAcGFyYW0geyp9IHJlc3VsdCBUaGUgcmVzb2x2ZWQgcmVzdWx0IG9mIHRoZSBQcm9taXNlLlxuICogQHByaXZhdGVcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLnByb3RvdHlwZS5leGVjdXRlQ2FsbGJhY2tfID0gZnVuY3Rpb24oXG5jYWxsYmFja0VudHJ5LCBzdGF0ZSwgcmVzdWx0KSB7XG4gIGlmIChzdGF0ZSA9PT0gQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5GVUxGSUxMRUQpIHtcbiAgICBjYWxsYmFja0VudHJ5Lm9uRnVsZmlsbGVkKHJlc3VsdCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5yZW1vdmVVbmhhbmRsZWRSZWplY3Rpb25fKCk7XG4gICAgY2FsbGJhY2tFbnRyeS5vblJlamVjdGVkKHJlc3VsdCk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBNYXJrcyB0aGlzIHJlamVjdGVkIFByb21pc2UgYXMgaGF2aW5nIGJlaW5nIGhhbmRsZWQuIEFsc28gbWFya3MgYW55IHBhcmVudFxuICogUHJvbWlzZXMgaW4gdGhlIHJlamVjdGVkIHN0YXRlIGFzIGhhbmRsZWQuIFRoZSByZWplY3Rpb24gaGFuZGxlciB3aWxsIG5vXG4gKiBsb25nZXIgYmUgaW52b2tlZCBmb3IgdGhpcyBQcm9taXNlIChpZiBpdCBoYXMgbm90IGJlZW4gY2FsbGVkIGFscmVhZHkpLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5wcm90b3R5cGUucmVtb3ZlVW5oYW5kbGVkUmVqZWN0aW9uXyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcDtcbiAgaWYgKENhbmNlbGxhYmxlUHJvbWlzZS5VTkhBTkRMRURfUkVKRUNUSU9OX0RFTEFZID4gMCkge1xuICAgIGZvciAocCA9IHRoaXM7IHAgJiYgcC51bmhhbmRsZWRSZWplY3Rpb25JZF87IHAgPSBwLnBhcmVudF8pIHtcbiAgICAgIGNsZWFyVGltZW91dChwLnVuaGFuZGxlZFJlamVjdGlvbklkXyk7XG4gICAgICBwLnVuaGFuZGxlZFJlamVjdGlvbklkXyA9IDA7XG4gICAgfVxuICB9IGVsc2UgaWYgKENhbmNlbGxhYmxlUHJvbWlzZS5VTkhBTkRMRURfUkVKRUNUSU9OX0RFTEFZID09PSAwKSB7XG4gICAgZm9yIChwID0gdGhpczsgcCAmJiBwLmhhZFVuaGFuZGxlZFJlamVjdGlvbl87IHAgPSBwLnBhcmVudF8pIHtcbiAgICAgIHAuaGFkVW5oYW5kbGVkUmVqZWN0aW9uXyA9IGZhbHNlO1xuICAgIH1cbiAgfVxufTtcblxuXG4vKipcbiAqIE1hcmtzIHRoaXMgcmVqZWN0ZWQgUHJvbWlzZSBhcyB1bmhhbmRsZWQuIElmIG5vIHtAY29kZSBvblJlamVjdGVkfSBjYWxsYmFja1xuICogaXMgY2FsbGVkIGZvciB0aGlzIFByb21pc2UgYmVmb3JlIHRoZSB7QGNvZGUgVU5IQU5ETEVEX1JFSkVDVElPTl9ERUxBWX1cbiAqIGV4cGlyZXMsIHRoZSByZWFzb24gd2lsbCBiZSBwYXNzZWQgdG8gdGhlIHVuaGFuZGxlZCByZWplY3Rpb24gaGFuZGxlci4gVGhlXG4gKiBoYW5kbGVyIHR5cGljYWxseSByZXRocm93cyB0aGUgcmVqZWN0aW9uIHJlYXNvbiBzbyB0aGF0IGl0IGJlY29tZXMgdmlzaWJsZSBpblxuICogdGhlIGRldmVsb3BlciBjb25zb2xlLlxuICpcbiAqIEBwYXJhbSB7IUNhbmNlbGxhYmxlUHJvbWlzZX0gcHJvbWlzZSBUaGUgcmVqZWN0ZWQgUHJvbWlzZS5cbiAqIEBwYXJhbSB7Kn0gcmVhc29uIFRoZSBQcm9taXNlIHJlamVjdGlvbiByZWFzb24uXG4gKiBAcHJpdmF0ZVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UuYWRkVW5oYW5kbGVkUmVqZWN0aW9uXyA9IGZ1bmN0aW9uKHByb21pc2UsIHJlYXNvbikge1xuICBpZiAoQ2FuY2VsbGFibGVQcm9taXNlLlVOSEFORExFRF9SRUpFQ1RJT05fREVMQVkgPiAwKSB7XG4gICAgcHJvbWlzZS51bmhhbmRsZWRSZWplY3Rpb25JZF8gPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgQ2FuY2VsbGFibGVQcm9taXNlLmhhbmRsZVJlamVjdGlvbl8uY2FsbChudWxsLCByZWFzb24pO1xuICAgIH0sIENhbmNlbGxhYmxlUHJvbWlzZS5VTkhBTkRMRURfUkVKRUNUSU9OX0RFTEFZKTtcblxuICB9IGVsc2UgaWYgKENhbmNlbGxhYmxlUHJvbWlzZS5VTkhBTkRMRURfUkVKRUNUSU9OX0RFTEFZID09PSAwKSB7XG4gICAgcHJvbWlzZS5oYWRVbmhhbmRsZWRSZWplY3Rpb25fID0gdHJ1ZTtcbiAgICBhc3luYy5ydW4oZnVuY3Rpb24oKSB7XG4gICAgICBpZiAocHJvbWlzZS5oYWRVbmhhbmRsZWRSZWplY3Rpb25fKSB7XG4gICAgICAgIENhbmNlbGxhYmxlUHJvbWlzZS5oYW5kbGVSZWplY3Rpb25fLmNhbGwobnVsbCwgcmVhc29uKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcblxuXG4vKipcbiAqIEEgbWV0aG9kIHRoYXQgaXMgaW52b2tlZCB3aXRoIHRoZSByZWplY3Rpb24gcmVhc29ucyBmb3IgUHJvbWlzZXMgdGhhdCBhcmVcbiAqIHJlamVjdGVkIGJ1dCBoYXZlIG5vIHtAY29kZSBvblJlamVjdGVkfSBjYWxsYmFja3MgcmVnaXN0ZXJlZCB5ZXQuXG4gKiBAdHlwZSB7ZnVuY3Rpb24oKil9XG4gKiBAcHJpdmF0ZVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UuaGFuZGxlUmVqZWN0aW9uXyA9IGFzeW5jLnRocm93RXhjZXB0aW9uO1xuXG5cbi8qKlxuICogU2V0cyBhIGhhbmRsZXIgdGhhdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHJlYXNvbnMgZnJvbSB1bmhhbmRsZWQgcmVqZWN0ZWRcbiAqIFByb21pc2VzLiBJZiB0aGUgcmVqZWN0ZWQgUHJvbWlzZSAob3Igb25lIG9mIGl0cyBkZXNjZW5kYW50cykgaGFzIGFuXG4gKiB7QGNvZGUgb25SZWplY3RlZH0gY2FsbGJhY2sgcmVnaXN0ZXJlZCwgdGhlIHJlamVjdGlvbiB3aWxsIGJlIGNvbnNpZGVyZWRcbiAqIGhhbmRsZWQsIGFuZCB0aGUgcmVqZWN0aW9uIGhhbmRsZXIgd2lsbCBub3QgYmUgY2FsbGVkLlxuICpcbiAqIEJ5IGRlZmF1bHQsIHVuaGFuZGxlZCByZWplY3Rpb25zIGFyZSByZXRocm93biBzbyB0aGF0IHRoZSBlcnJvciBtYXkgYmVcbiAqIGNhcHR1cmVkIGJ5IHRoZSBkZXZlbG9wZXIgY29uc29sZSBvciBhIHtAY29kZSB3aW5kb3cub25lcnJvcn0gaGFuZGxlci5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCopfSBoYW5kbGVyIEEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHJlYXNvbnMgZnJvbVxuICogICAgIHJlamVjdGVkIFByb21pc2VzLiBEZWZhdWx0cyB0byB7QGNvZGUgYXN5bmMudGhyb3dFeGNlcHRpb259LlxuICovXG5DYW5jZWxsYWJsZVByb21pc2Uuc2V0VW5oYW5kbGVkUmVqZWN0aW9uSGFuZGxlciA9IGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgQ2FuY2VsbGFibGVQcm9taXNlLmhhbmRsZVJlamVjdGlvbl8gPSBoYW5kbGVyO1xufTtcblxuXG5cbi8qKlxuICogRXJyb3IgdXNlZCBhcyBhIHJlamVjdGlvbiByZWFzb24gZm9yIGNhbmNlbGVkIFByb21pc2VzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X21lc3NhZ2VcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge0Vycm9yfVxuICogQGZpbmFsXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5DYW5jZWxsYXRpb25FcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihvcHRfbWVzc2FnZSkge1xuICAgICBzdXBlcihvcHRfbWVzc2FnZSk7XG5cbiAgICAgaWYgKG9wdF9tZXNzYWdlKSB7XG4gICAgICAgdGhpcy5tZXNzYWdlID0gb3B0X21lc3NhZ2U7XG4gICAgIH1cbiAgIH1cbn07XG5cbi8qKiBAb3ZlcnJpZGUgKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5DYW5jZWxsYXRpb25FcnJvci5wcm90b3R5cGUubmFtZSA9ICdjYW5jZWwnO1xuXG5leHBvcnQge0NhbmNlbGxhYmxlUHJvbWlzZX07XG5leHBvcnQgZGVmYXVsdCBDYW5jZWxsYWJsZVByb21pc2U7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7IGNvcmUgfSBmcm9tICdtZXRhbCc7XG5pbXBvcnQgVXJpIGZyb20gJ21ldGFsLXVyaSc7XG5pbXBvcnQgeyBDYW5jZWxsYWJsZVByb21pc2UgYXMgUHJvbWlzZSB9IGZyb20gJ21ldGFsLXByb21pc2UnO1xuXG5jbGFzcyBBamF4IHtcblxuXHQvKipcblx0ICogWG1sSHR0cFJlcXVlc3QncyBnZXRBbGxSZXNwb25zZUhlYWRlcnMoKSBtZXRob2QgcmV0dXJucyBhIHN0cmluZyBvZlxuXHQgKiByZXNwb25zZSBoZWFkZXJzIGFjY29yZGluZyB0byB0aGUgZm9ybWF0IGRlc2NyaWJlZCBvbiB0aGUgc3BlYzpcblx0ICoge0BsaW5rIGh0dHA6Ly93d3cudzMub3JnL1RSL1hNTEh0dHBSZXF1ZXN0LyN0aGUtZ2V0YWxscmVzcG9uc2VoZWFkZXJzLW1ldGhvZH0uXG5cdCAqIFRoaXMgbWV0aG9kIHBhcnNlcyB0aGF0IHN0cmluZyBpbnRvIGEgdXNlci1mcmllbmRseSBuYW1lL3ZhbHVlIHBhaXJcblx0ICogb2JqZWN0LlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gYWxsSGVhZGVycyBBbGwgaGVhZGVycyBhcyBzdHJpbmcuXG5cdCAqIEByZXR1cm4geyFBcnJheS48T2JqZWN0PHN0cmluZywgc3RyaW5nPj59XG5cdCAqL1xuXHRzdGF0aWMgcGFyc2VSZXNwb25zZUhlYWRlcnMoYWxsSGVhZGVycykge1xuXHRcdHZhciBoZWFkZXJzID0gW107XG5cdFx0aWYgKCFhbGxIZWFkZXJzKSB7XG5cdFx0XHRyZXR1cm4gaGVhZGVycztcblx0XHR9XG5cdFx0dmFyIHBhaXJzID0gYWxsSGVhZGVycy5zcGxpdCgnXFx1MDAwZFxcdTAwMGEnKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHBhaXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaW5kZXggPSBwYWlyc1tpXS5pbmRleE9mKCdcXHUwMDNhXFx1MDAyMCcpO1xuXHRcdFx0aWYgKGluZGV4ID4gMCkge1xuXHRcdFx0XHR2YXIgbmFtZSA9IHBhaXJzW2ldLnN1YnN0cmluZygwLCBpbmRleCk7XG5cdFx0XHRcdHZhciB2YWx1ZSA9IHBhaXJzW2ldLnN1YnN0cmluZyhpbmRleCArIDIpO1xuXHRcdFx0XHRoZWFkZXJzLnB1c2goe1xuXHRcdFx0XHRcdG5hbWU6IG5hbWUsXG5cdFx0XHRcdFx0dmFsdWU6IHZhbHVlXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gaGVhZGVycztcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXF1ZXN0cyB0aGUgdXJsIHVzaW5nIFhNTEh0dHBSZXF1ZXN0LlxuXHQgKiBAcGFyYW0geyFzdHJpbmd9IHVybFxuXHQgKiBAcGFyYW0geyFzdHJpbmd9IG1ldGhvZFxuXHQgKiBAcGFyYW0gez9zdHJpbmd9IGJvZHlcblx0ICogQHBhcmFtIHtNdWx0aU1hcD19IG9wdF9oZWFkZXJzXG5cdCAqIEBwYXJhbSB7TXVsdGlNYXA9fSBvcHRfcGFyYW1zXG5cdCAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X3RpbWVvdXRcblx0ICogQHBhcmFtIHtib29sZWFuPX0gb3B0X3N5bmNcblx0ICogQHBhcmFtIHtib29sZWFuPX0gb3B0X3dpdGhDcmVkZW50aWFsc1xuXHQgKiBAcmV0dXJuIHtQcm9taXNlfSBEZWZlcnJlZCBhamF4IHJlcXVlc3QuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHN0YXRpYyByZXF1ZXN0KHVybCwgbWV0aG9kLCBib2R5LCBvcHRfaGVhZGVycywgb3B0X3BhcmFtcywgb3B0X3RpbWVvdXQsIG9wdF9zeW5jLCBvcHRfd2l0aENyZWRlbnRpYWxzKSB7XG5cdFx0dXJsID0gdXJsIHx8ICcnO1xuXHRcdG1ldGhvZCA9IG1ldGhvZCB8fCAnR0VUJztcblxuXHRcdHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cblx0XHR2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuXHRcdFx0cmVxdWVzdC5vbmxvYWQgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKHJlcXVlc3QuYWJvcnRlZCkge1xuXHRcdFx0XHRcdHJlcXVlc3Qub25lcnJvcigpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXNvbHZlKHJlcXVlc3QpO1xuXHRcdFx0fTtcblx0XHRcdHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ1JlcXVlc3QgZXJyb3InKTtcblx0XHRcdFx0ZXJyb3IucmVxdWVzdCA9IHJlcXVlc3Q7XG5cdFx0XHRcdHJlamVjdChlcnJvcik7XG5cdFx0XHR9O1xuXHRcdH0pLnRoZW5DYXRjaChmdW5jdGlvbihyZWFzb24pIHtcblx0XHRcdHJlcXVlc3QuYWJvcnQoKTtcblx0XHRcdHRocm93IHJlYXNvbjtcblx0XHR9KS50aGVuQWx3YXlzKGZ1bmN0aW9uKCkge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuXHRcdH0pO1xuXG5cdFx0aWYgKG9wdF9wYXJhbXMpIHtcblx0XHRcdHVybCA9IG5ldyBVcmkodXJsKS5hZGRQYXJhbWV0ZXJzRnJvbU11bHRpTWFwKG9wdF9wYXJhbXMpLnRvU3RyaW5nKCk7XG5cdFx0fVxuXG5cdFx0cmVxdWVzdC5vcGVuKG1ldGhvZCwgdXJsLCAhb3B0X3N5bmMpO1xuXG5cdFx0aWYgKG9wdF93aXRoQ3JlZGVudGlhbHMpIHtcblx0XHRcdHJlcXVlc3Qud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAob3B0X2hlYWRlcnMpIHtcblx0XHRcdG9wdF9oZWFkZXJzLm5hbWVzKCkuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG5cdFx0XHRcdHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcihuYW1lLCBvcHRfaGVhZGVycy5nZXRBbGwobmFtZSkuam9pbignLCAnKSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXF1ZXN0LnNlbmQoY29yZS5pc0RlZihib2R5KSA/IGJvZHkgOiBudWxsKTtcblxuXHRcdGlmIChjb3JlLmlzRGVmQW5kTm90TnVsbChvcHRfdGltZW91dCkpIHtcblx0XHRcdHZhciB0aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0cHJvbWlzZS5jYW5jZWwoJ1JlcXVlc3QgdGltZW91dCcpO1xuXHRcdFx0fSwgb3B0X3RpbWVvdXQpO1xuXHRcdH1cblxuXHRcdHJldHVybiBwcm9taXNlO1xuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgQWpheDtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBQcm92aWRlcyBhIGNvbnZlbmllbnQgaW50ZXJmYWNlIGZvciBkYXRhIHRyYW5zcG9ydC5cbiAqIEBpbnRlcmZhY2VcbiAqL1xuY2xhc3MgVHJhbnNwb3J0IHtcblxuXHQvKipcblx0ICogU2VuZHMgYSBtZXNzYWdlIGZvciB0aGUgc3BlY2lmaWVkIGNsaWVudC5cblx0ICogQHBhcmFtIHshQ2xpZW50UmVxdWVzdH0gY2xpZW50UmVxdWVzdFxuXHQgKiBAcmV0dXJuIHshUHJvbWlzZX0gRGVmZXJyZWQgcmVxdWVzdC5cblx0ICovXG5cdHNlbmQoKSB7fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFRyYW5zcG9ydDtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHsgY29yZSB9IGZyb20gJ21ldGFsJztcbmltcG9ydCB7IE11bHRpTWFwIH0gZnJvbSAnbWV0YWwtc3RydWN0cyc7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGNsaWVudCBtZXNzYWdlIChlLmcuIGEgcmVxdWVzdCBvciBhIHJlc3BvbnNlKS5cbiAqL1xuY2xhc3MgQ2xpZW50TWVzc2FnZSB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHRoaXMuaGVhZGVyc18gPSBuZXcgTXVsdGlNYXAoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBGbHVlbnQgZ2V0dGVyIGFuZCBzZXR0ZXIgZm9yIHJlcXVlc3QgYm9keS5cblx0ICogQHBhcmFtIHsqPX0gb3B0X2JvZHkgUmVxdWVzdCBib2R5IHRvIGJlIHNldC4gSWYgbm9uZSBpcyBnaXZlbixcblx0ICogICB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgYm9keSB3aWxsIGJlIHJldHVybmVkLlxuXHQgKiBAcmV0dXJuIHsqfSBSZXR1cm5zIHJlcXVlc3QgYm9keSBpZiBubyBib2R5IHZhbHVlIHdhcyBnaXZlbi4gT3RoZXJ3aXNlXG5cdCAqICAgcmV0dXJucyB0aGUge0BsaW5rIENsaWVudE1lc3NhZ2V9IG9iamVjdCBpdHNlbGYsIHNvIGNhbGxzIGNhbiBiZSBjaGFpbmVkLlxuXHQgKiBAY2hhaW5hYmxlIENoYWluYWJsZSB3aGVuIHVzZWQgYXMgc2V0dGVyLlxuXHQgKi9cblx0Ym9keShvcHRfYm9keSkge1xuXHRcdGlmIChjb3JlLmlzRGVmKG9wdF9ib2R5KSkge1xuXHRcdFx0dGhpcy5ib2R5XyA9IG9wdF9ib2R5O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmJvZHlfO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBoZWFkZXIuIElmIGEgaGVhZGVyIHdpdGggdGhlIHNhbWUgbmFtZSBhbHJlYWR5IGV4aXN0cywgaXQgd2lsbCBub3QgYmVcblx0ICogb3ZlcndyaXR0ZW4sIGJ1dCB0aGUgbmV3IHZhbHVlIHdpbGwgYmUgc3RvcmVkIGFzIHdlbGwuIFRoZSBvcmRlciBpcyBwcmVzZXJ2ZWQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRoZWFkZXIobmFtZSwgdmFsdWUpIHtcblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMikge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cycpO1xuXHRcdH1cblx0XHR0aGlzLmhlYWRlcnNfLnNldChuYW1lLCB2YWx1ZSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogRmx1ZW50IGdldHRlciBhbmQgc2V0dGVyIGZvciByZXF1ZXN0IGhlYWRlcnMuXG5cdCAqIEBwYXJhbSB7TXVsdGlNYXB8T2JqZWN0PX0gb3B0X2hlYWRlcnMgUmVxdWVzdCBoZWFkZXJzIGxpc3QgdG9cblx0ICogICBiZSBzZXQuIElmIG5vbmUgaXMgZ2l2ZW4gdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGhlYWRlcnMgd2lsbFxuXHQgKiAgIGJlIHJldHVybmVkLlxuXHQgKiBAcmV0dXJuIHshTXVsdGlNYXB8Q2xpZW50TWVzc2FnZX0gUmV0dXJucyBtYXAgb2YgcmVxdWVzdCBoZWFkZXJzXG5cdCAqICAgaWYgbm8gbmV3IHZhbHVlIHdhcyBnaXZlbi4gT3RoZXJ3aXNlIHJldHVybnMgdGhlIHtAbGluayBDbGllbnRNZXNzYWdlfVxuXHQgKiAgIG9iamVjdCBpdHNlbGYsIHNvIGNhbGxzIGNhbiBiZSBjaGFpbmVkLlxuXHQgKiBAY2hhaW5hYmxlIENoYWluYWJsZSB3aGVuIHVzZWQgYXMgc2V0dGVyLlxuXHQgKi9cblx0aGVhZGVycyhvcHRfaGVhZGVycykge1xuXHRcdGlmIChjb3JlLmlzRGVmKG9wdF9oZWFkZXJzKSkge1xuXHRcdFx0aWYgKG9wdF9oZWFkZXJzIGluc3RhbmNlb2YgTXVsdGlNYXApIHtcblx0XHRcdFx0dGhpcy5oZWFkZXJzXyA9IG9wdF9oZWFkZXJzO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5oZWFkZXJzXy52YWx1ZXMgPSBvcHRfaGVhZGVycztcblx0XHRcdH1cblx0XHRcdHJldHVybiBvcHRfaGVhZGVycztcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuaGVhZGVyc187XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlcyB0aGUgYm9keS5cblx0ICovXG5cdHJlbW92ZUJvZHkoKSB7XG5cdFx0dGhpcy5ib2R5XyA9IHVuZGVmaW5lZDtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBDbGllbnRNZXNzYWdlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgeyBjb3JlIH0gZnJvbSAnbWV0YWwnO1xuaW1wb3J0IENsaWVudE1lc3NhZ2UgZnJvbSAnLi9DbGllbnRNZXNzYWdlJztcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgY2xpZW50IHJlc3BvbnNlIG9iamVjdC5cbiAqIEBleHRlbmRzIHtDbGllbnRNZXNzYWdlfVxuICovXG5jbGFzcyBDbGllbnRSZXNwb25zZSBleHRlbmRzIENsaWVudE1lc3NhZ2Uge1xuXHRjb25zdHJ1Y3RvcihjbGllbnRSZXF1ZXN0KSB7XG5cdFx0c3VwZXIoKTtcblx0XHRpZiAoIWNsaWVudFJlcXVlc3QpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignQ2FuXFwndCBjcmVhdGUgcmVzcG9uc2Ugd2l0aG91dCByZXF1ZXN0Jyk7XG5cdFx0fVxuXHRcdHRoaXMuY2xpZW50UmVxdWVzdF8gPSBjbGllbnRSZXF1ZXN0O1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgcmVxdWVzdCB0aGF0IGNyZWF0ZWQgdGhpcyByZXNwb25zZS5cblx0ICogQHJldHVybiB7IUNsaWVudFJlcXVlc3R9XG5cdCAqL1xuXHRyZXF1ZXN0KCkge1xuXHRcdHJldHVybiB0aGlzLmNsaWVudFJlcXVlc3RfO1xuXHR9XG5cblx0LyoqXG5cdCAqIEZsdWVudCBnZXR0ZXIgYW5kIHNldHRlciBmb3IgcmVzcG9uc2Ugc3RhdHVzIGNvZGUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X3N0YXR1c0NvZGUgUmVxdWVzdCBzdGF0dXMgY29kZSB0byBiZSBzZXQuIElmIG5vbmUgaXMgZ2l2ZW4sXG5cdCAqICAgdGhlIGN1cnJlbnQgc3RhdHVzIGNvZGUgdmFsdWUgd2lsbCBiZSByZXR1cm5lZC5cblx0ICogQHJldHVybiB7IUNsaWVudE1lc3NhZ2V8bnVtYmVyfSBSZXR1cm5zIHJlc3BvbnNlIHN0YXR1cyBjb2RlIGlmIG5vIG5ldyB2YWx1ZSB3YXNcblx0ICogICBnaXZlbi4gT3RoZXJ3aXNlIHJldHVybnMgdGhlIHtAbGluayBDbGllbnRNZXNzYWdlfSBvYmplY3QgaXRzZWxmLCBzbyBjYWxscyBjYW5cblx0ICogICBiZSBjaGFpbmVkLlxuXHQgKiBAY2hhaW5hYmxlIENoYWluYWJsZSB3aGVuIHVzZWQgYXMgc2V0dGVyLlxuXHQgKi9cblx0c3RhdHVzQ29kZShvcHRfc3RhdHVzQ29kZSkge1xuXHRcdGlmIChjb3JlLmlzRGVmKG9wdF9zdGF0dXNDb2RlKSkge1xuXHRcdFx0dGhpcy5zdGF0dXNDb2RlXyA9IG9wdF9zdGF0dXNDb2RlO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLnN0YXR1c0NvZGVfO1xuXHR9XG5cblx0LyoqXG5cdCAqIEZsdWVudCBnZXR0ZXIgYW5kIHNldHRlciBmb3IgcmVzcG9uc2Ugc3RhdHVzIHRleHQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X3N0YXR1c1RleHQgUmVxdWVzdCBzdGF0dXMgdGV4dCB0byBiZSBzZXQuIElmIG5vbmUgaXMgZ2l2ZW4sXG5cdCAqICAgdGhlIGN1cnJlbnQgc3RhdHVzIHRleHQgdmFsdWUgd2lsbCBiZSByZXR1cm5lZC5cblx0ICogQHJldHVybiB7IUNsaWVudE1lc3NhZ2V8bnVtYmVyfSBSZXR1cm5zIHJlc3BvbnNlIHN0YXR1cyB0ZXh0IGlmIG5vIG5ldyB2YWx1ZSB3YXNcblx0ICogICBnaXZlbi4gT3RoZXJ3aXNlIHJldHVybnMgdGhlIHtAbGluayBDbGllbnRNZXNzYWdlfSBvYmplY3QgaXRzZWxmLCBzbyBjYWxscyBjYW5cblx0ICogICBiZSBjaGFpbmVkLlxuXHQgKiBAY2hhaW5hYmxlIENoYWluYWJsZSB3aGVuIHVzZWQgYXMgc2V0dGVyLlxuXHQgKi9cblx0c3RhdHVzVGV4dChvcHRfc3RhdHVzVGV4dCkge1xuXHRcdGlmIChjb3JlLmlzRGVmKG9wdF9zdGF0dXNUZXh0KSkge1xuXHRcdFx0dGhpcy5zdGF0dXNUZXh0XyA9IG9wdF9zdGF0dXNUZXh0O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLnN0YXR1c1RleHRfO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiByZXNwb25zZSBzdWNjZWVkZWQuIEFueSBzdGF0dXMgY29kZSAyeHggb3IgM3h4IGlzIGNvbnNpZGVyZWQgdmFsaWQuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqL1xuXHRzdWNjZWVkZWQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc3RhdHVzQ29kZSgpID49IDIwMCAmJiB0aGlzLnN0YXR1c0NvZGUoKSA8PSAzOTk7XG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBDbGllbnRSZXNwb25zZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEFqYXggZnJvbSAnbWV0YWwtYWpheCc7XG5pbXBvcnQgVHJhbnNwb3J0IGZyb20gJy4uL1RyYW5zcG9ydCc7XG5pbXBvcnQgQ2xpZW50UmVzcG9uc2UgZnJvbSAnLi4vQ2xpZW50UmVzcG9uc2UnO1xuXG4vKipcbiAqIFRoZSBpbXBsZW1lbnRhdGlvbiBvZiBhbiBhamF4IHRyYW5zcG9ydCB0byBiZSB1c2VkIHdpdGgge0BsaW5rIFdlRGVwbG95fS5cbiAqIEBleHRlbmRzIHtUcmFuc3BvcnR9XG4gKi9cbmNsYXNzIEFqYXhUcmFuc3BvcnQgZXh0ZW5kcyBUcmFuc3BvcnQge1xuXHQvKipcblx0ICogQGluaGVyaXREb2Ncblx0ICovXG5cdHNlbmQoY2xpZW50UmVxdWVzdCkge1xuXHRcdHZhciBkZWZlcnJlZCA9IEFqYXgucmVxdWVzdChcblx0XHRcdGNsaWVudFJlcXVlc3QudXJsKCksIGNsaWVudFJlcXVlc3QubWV0aG9kKCksIGNsaWVudFJlcXVlc3QuYm9keSgpLFxuXHRcdFx0Y2xpZW50UmVxdWVzdC5oZWFkZXJzKCksIGNsaWVudFJlcXVlc3QucGFyYW1zKCksIG51bGwsIGZhbHNlLCBjbGllbnRSZXF1ZXN0LndpdGhDcmVkZW50aWFscygpKTtcblxuXHRcdHJldHVybiBkZWZlcnJlZC50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG5cdFx0XHR2YXIgY2xpZW50UmVzcG9uc2UgPSBuZXcgQ2xpZW50UmVzcG9uc2UoY2xpZW50UmVxdWVzdCk7XG5cdFx0XHRjbGllbnRSZXNwb25zZS5ib2R5KHJlc3BvbnNlLnJlc3BvbnNlVGV4dCk7XG5cdFx0XHRjbGllbnRSZXNwb25zZS5zdGF0dXNDb2RlKHJlc3BvbnNlLnN0YXR1cyk7XG5cdFx0XHRjbGllbnRSZXNwb25zZS5zdGF0dXNUZXh0KHJlc3BvbnNlLnN0YXR1c1RleHQpO1xuXHRcdFx0QWpheC5wYXJzZVJlc3BvbnNlSGVhZGVycyhyZXNwb25zZS5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkuZm9yRWFjaChmdW5jdGlvbihoZWFkZXIpIHtcblx0XHRcdFx0Y2xpZW50UmVzcG9uc2UuaGVhZGVyKGhlYWRlci5uYW1lLCBoZWFkZXIudmFsdWUpO1xuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gY2xpZW50UmVzcG9uc2U7XG5cdFx0fSk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQWpheFRyYW5zcG9ydDtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEFqYXhUcmFuc3BvcnQgZnJvbSAnLi9icm93c2VyL0FqYXhUcmFuc3BvcnQnO1xuXG4vKipcbiAqIFByb3ZpZGVzIGEgZmFjdG9yeSBmb3IgZGF0YSB0cmFuc3BvcnQuXG4gKi9cbmNsYXNzIFRyYW5zcG9ydEZhY3Rvcnkge1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHR0aGlzLnRyYW5zcG9ydHMgPSB7fTtcblx0XHR0aGlzLnRyYW5zcG9ydHNbVHJhbnNwb3J0RmFjdG9yeS5ERUZBVUxUX1RSQU5TUE9SVF9OQU1FXSA9IFRyYW5zcG9ydEZhY3RvcnlbVHJhbnNwb3J0RmFjdG9yeS5ERUZBVUxUX1RSQU5TUE9SVF9OQU1FXTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHtAbGluayBUcmFuc3BvcnRGYWN0b3J5fSBpbnN0YW5jZS5cblx0ICovXG5cdHN0YXRpYyBpbnN0YW5jZSgpIHtcblx0XHRpZiAoIVRyYW5zcG9ydEZhY3RvcnkuaW5zdGFuY2VfKSB7XG5cdFx0XHRUcmFuc3BvcnRGYWN0b3J5Lmluc3RhbmNlXyA9IG5ldyBUcmFuc3BvcnRGYWN0b3J5KCk7XG5cdFx0fVxuXHRcdHJldHVybiBUcmFuc3BvcnRGYWN0b3J5Lmluc3RhbmNlXztcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIGFuIGluc3RhbmNlIG9mIHRoZSB0cmFuc3BvcnQgaW1wbGVtZW50YXRpb24gd2l0aCB0aGUgZ2l2ZW4gbmFtZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGltcGxlbWVudGF0aW9uTmFtZVxuXHQgKiBAcmV0dXJuIHshVHJhbnNwb3J0fVxuXHQgKi9cblx0Z2V0KGltcGxlbWVudGF0aW9uTmFtZSkge1xuXHRcdHZhciBUcmFuc3BvcnRDbGFzcyA9IHRoaXMudHJhbnNwb3J0c1tpbXBsZW1lbnRhdGlvbk5hbWVdO1xuXG5cdFx0aWYgKCFUcmFuc3BvcnRDbGFzcykge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRyYW5zcG9ydCBuYW1lOiAnICsgaW1wbGVtZW50YXRpb25OYW1lKTtcblx0XHR9XG5cblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIG5ldyAoVHJhbnNwb3J0Q2xhc3MpKCk7XG5cdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgY3JlYXRlIHRyYW5zcG9ydCcsIGVycik7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGRlZmF1bHQgdHJhbnNwb3J0IGltcGxlbWVudGF0aW9uLlxuXHQgKiBAcmV0dXJuIHshVHJhbnNwb3J0fVxuXHQgKi9cblx0Z2V0RGVmYXVsdCgpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXQoVHJhbnNwb3J0RmFjdG9yeS5ERUZBVUxUX1RSQU5TUE9SVF9OQU1FKTtcblx0fVxufVxuXG5UcmFuc3BvcnRGYWN0b3J5LkRFRkFVTFRfVFJBTlNQT1JUX05BTUUgPSAnZGVmYXVsdCc7XG5cblRyYW5zcG9ydEZhY3RvcnlbVHJhbnNwb3J0RmFjdG9yeS5ERUZBVUxUX1RSQU5TUE9SVF9OQU1FXSA9IEFqYXhUcmFuc3BvcnQ7XG5cbmV4cG9ydCBkZWZhdWx0IFRyYW5zcG9ydEZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7IGNvcmUgfSBmcm9tICdtZXRhbCc7XG5pbXBvcnQgQ2xpZW50TWVzc2FnZSBmcm9tICcuL0NsaWVudE1lc3NhZ2UnO1xuaW1wb3J0IHsgTXVsdGlNYXAgfSBmcm9tICdtZXRhbC1zdHJ1Y3RzJztcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgY2xpZW50IHJlcXVlc3Qgb2JqZWN0LlxuICogQGV4dGVuZHMge0NsaWVudE1lc3NhZ2V9XG4gKi9cbmNsYXNzIENsaWVudFJlcXVlc3QgZXh0ZW5kcyBDbGllbnRNZXNzYWdlIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLnBhcmFtc18gPSBuZXcgTXVsdGlNYXAoKTtcblx0XHR0aGlzLndpdGhDcmVkZW50aWFsc18gPSB0cnVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEZsdWVudCBnZXR0ZXIgYW5kIHNldHRlciBmb3Igd2l0aCBjcmVkZW50aWFscyBvcHRpb24uXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF93aXRoQ3JlZGVudGlhbHNcblx0ICogQGNoYWluYWJsZSBDaGFpbmFibGUgd2hlbiB1c2VkIGFzIHNldHRlci5cblx0ICovXG5cdHdpdGhDcmVkZW50aWFscyhvcHRfd2l0aENyZWRlbnRpYWxzKSB7XG5cdFx0aWYgKGNvcmUuaXNEZWYob3B0X3dpdGhDcmVkZW50aWFscykpIHtcblx0XHRcdHRoaXMud2l0aENyZWRlbnRpYWxzXyA9ICEhb3B0X3dpdGhDcmVkZW50aWFscztcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy53aXRoQ3JlZGVudGlhbHNfO1xuXHR9XG5cblx0LyoqXG5cdCAqIEZsdWVudCBnZXR0ZXIgYW5kIHNldHRlciBmb3IgcmVxdWVzdCBtZXRob2QuXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X21ldGhvZCBSZXF1ZXN0IG1ldGhvZCB0byBiZSBzZXQuIElmIG5vbmUgaXMgZ2l2ZW4sXG5cdCAqICAgdGhlIGN1cnJlbnQgbWV0aG9kIHZhbHVlIHdpbGwgYmUgcmV0dXJuZWQuXG5cdCAqIEByZXR1cm4geyFDbGllbnRNZXNzYWdlfHN0cmluZ30gUmV0dXJucyByZXF1ZXN0IG1ldGhvZCBpZiBubyBuZXcgdmFsdWUgd2FzXG5cdCAqICAgZ2l2ZW4uIE90aGVyd2lzZSByZXR1cm5zIHRoZSB7QGxpbmsgQ2xpZW50TWVzc2FnZX0gb2JqZWN0IGl0c2VsZiwgc29cblx0ICogICBjYWxscyBjYW4gYmUgY2hhaW5lZC5cblx0ICogQGNoYWluYWJsZSBDaGFpbmFibGUgd2hlbiB1c2VkIGFzIHNldHRlci5cblx0ICovXG5cdG1ldGhvZChvcHRfbWV0aG9kKSB7XG5cdFx0aWYgKGNvcmUuaXNEZWYob3B0X21ldGhvZCkpIHtcblx0XHRcdHRoaXMubWV0aG9kXyA9IG9wdF9tZXRob2Q7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMubWV0aG9kXyB8fCBDbGllbnRSZXF1ZXN0LkRFRkFVTFRfTUVUSE9EO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBxdWVyeS4gSWYgYSBxdWVyeSB3aXRoIHRoZSBzYW1lIG5hbWUgYWxyZWFkeSBleGlzdHMsIGl0IHdpbGwgbm90XG5cdCAqIGJlIG92ZXJ3cml0dGVuLCBidXQgbmV3IHZhbHVlIHdpbGwgYmUgc3RvcmVkIGFzIHdlbGwuIFRoZSBvcmRlciBpcyBwcmVzZXJ2ZWQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRwYXJhbShuYW1lLCB2YWx1ZSkge1xuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAyKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzJyk7XG5cdFx0fVxuXHRcdHRoaXMucGFyYW1zXy5zZXQobmFtZSwgdmFsdWUpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEZsdWVudCBnZXR0ZXIgYW5kIHNldHRlciBmb3IgcmVxdWVzdCBxdWVyeXN0cmluZy5cblx0ICogQHBhcmFtIHtNdWx0aU1hcHxPYmplY3Q9fSBvcHRfcGFyYW1zIFJlcXVlc3QgcXVlcnlzdHJpbmcgbWFwIHRvIGJlIHNldC5cblx0ICogICBJZiBub25lIGlzIGdpdmVuIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBwYXJhbXMgd2lsbCBiZSByZXR1cm5lZC5cblx0ICogQHJldHVybiB7IU11bHRpTWFwfENsaWVudE1lc3NhZ2V9IFJldHVybnMgbWFwIG9mIHJlcXVlc3QgcXVlcnlzdHJpbmcgaWZcblx0ICogICBubyBuZXcgdmFsdWUgd2FzIGdpdmVuLiBPdGhlcndpc2UgcmV0dXJucyB0aGUge0BsaW5rIENsaWVudE1lc3NhZ2V9XG5cdCAqICAgb2JqZWN0IGl0c2VsZiwgc28gY2FsbHMgY2FuIGJlIGNoYWluZWQuXG5cdCAqL1xuXHRwYXJhbXMob3B0X3BhcmFtcykge1xuXHRcdGlmIChjb3JlLmlzRGVmKG9wdF9wYXJhbXMpKSB7XG5cdFx0XHRpZiAob3B0X3BhcmFtcyBpbnN0YW5jZW9mIE11bHRpTWFwKSB7XG5cdFx0XHRcdHRoaXMucGFyYW1zXyA9IG9wdF9wYXJhbXM7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnBhcmFtc18udmFsdWVzID0gb3B0X3BhcmFtcztcblx0XHRcdH1cblx0XHRcdHJldHVybiBvcHRfcGFyYW1zO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5wYXJhbXNfO1xuXHR9XG5cblx0LyoqXG5cdCAqIEZsdWVudCBnZXR0ZXIgYW5kIHNldHRlciBmb3IgcmVxdWVzdCB1cmwuXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X3VybCBSZXF1ZXN0IHVybCB0byBiZSBzZXQuIElmIG5vbmUgaXMgZ2l2ZW4sXG5cdCAqICAgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIHVybCB3aWxsIGJlIHJldHVybmVkLlxuXHQgKiBAcmV0dXJuIHshQ2xpZW50TWVzc2FnZXxzdHJpbmd9IFJldHVybnMgcmVxdWVzdCB1cmwgaWYgbm8gbmV3IHZhbHVlIHdhcyBnaXZlbi5cblx0ICogICBPdGhlcndpc2UgcmV0dXJucyB0aGUge0BsaW5rIENsaWVudE1lc3NhZ2V9IG9iamVjdCBpdHNlbGYsIHNvIGNhbGxzIGNhbiBiZVxuXHQgKiAgIGNoYWluZWQuXG5cdCAqIEBjaGFpbmFibGUgQ2hhaW5hYmxlIHdoZW4gdXNlZCBhcyBzZXR0ZXIuXG5cdCAqL1xuXHR1cmwob3B0X3VybCkge1xuXHRcdGlmIChjb3JlLmlzRGVmKG9wdF91cmwpKSB7XG5cdFx0XHR0aGlzLnVybF8gPSBvcHRfdXJsO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLnVybF87XG5cdH1cblxufVxuXG5DbGllbnRSZXF1ZXN0LkRFRkFVTFRfTUVUSE9EID0gJ0dFVCc7XG5cbmV4cG9ydCBkZWZhdWx0IENsaWVudFJlcXVlc3Q7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBnbG9iYWxzIGZyb20gJy4uL2dsb2JhbHMvZ2xvYmFscyc7XG5pbXBvcnQgeyBjb3JlIH0gZnJvbSAnbWV0YWwnO1xuaW1wb3J0IEF1dGggZnJvbSAnLi9hdXRoL0F1dGgnO1xuaW1wb3J0IEF1dGhBcGlIZWxwZXIgZnJvbSAnLi9hdXRoL0F1dGhBcGlIZWxwZXInO1xuaW1wb3J0IERhdGFBcGlIZWxwZXIgZnJvbSAnLi9kYXRhL0RhdGFBcGlIZWxwZXInO1xuaW1wb3J0IEJhc2U2NCBmcm9tICcuLi9jcnlwdC9CYXNlNjQnO1xuaW1wb3J0IEVtYm9kaWVkIGZyb20gJy4uL2FwaS1xdWVyeS9FbWJvZGllZCc7XG5pbXBvcnQgUXVlcnkgZnJvbSAnLi4vYXBpLXF1ZXJ5L1F1ZXJ5JztcbmltcG9ydCBGaWx0ZXIgZnJvbSAnLi4vYXBpLXF1ZXJ5L0ZpbHRlcic7XG5pbXBvcnQgVHJhbnNwb3J0RmFjdG9yeSBmcm9tICcuL1RyYW5zcG9ydEZhY3RvcnknO1xuaW1wb3J0IENsaWVudFJlcXVlc3QgZnJvbSAnLi9DbGllbnRSZXF1ZXN0JztcbmltcG9ydCB7IE11bHRpTWFwIH0gZnJvbSAnbWV0YWwtc3RydWN0cyc7XG5pbXBvcnQgVXJpIGZyb20gJ21ldGFsLXVyaSc7XG5pbXBvcnQgeyBhc3NlcnRVcmlXaXRoTm9QYXRoIH0gZnJvbSAnLi9hc3NlcnRpb25zJztcblxuXG52YXIgaW87XG5cbi8vIE9wdGltaXN0aWMgaW5pdGlhbGl6YXRpb24gb2YgYGlvYCByZWZlcmVuY2UgZnJvbSBnbG9iYWwgYGdsb2JhbHMud2luZG93LmlvYC5cbmlmICh0eXBlb2YgZ2xvYmFscy53aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG5cdGlvID0gZ2xvYmFscy53aW5kb3cuaW87XG59XG5cbi8qKlxuICogVGhlIG1haW4gY2xhc3MgZm9yIG1ha2luZyBhcGkgcmVxdWVzdHMuIFNlbmRpbmcgcmVxdWVzdHMgcmV0dXJucyBhIHByb21pc2VcbiAqIHRoYXQgaXMgcmVzb2x2ZWQgd2hlbiB0aGUgcmVzcG9uc2UgYXJyaXZlcy4gVXNhZ2UgZXhhbXBsZTpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIFdlRGVwbG95XG4gKiAgIC51cmwoJy9kYXRhL3Rhc2tzJylcbiAqICAgLnBvc3Qoe2Rlc2M6ICdCdXkgbWlsa2wnfSlcbiAqICAgLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAqICAgICAvLyBIYW5kbGUgcmVzcG9uc2UgaGVyZS5cbiAqICAgICBjb25zb2xlLmxvZyhyZXNwb25zZS5ib2R5KCkpXG4gKiAgIH0pO1xuICogYGBgXG4gKi9cbmNsYXNzIFdlRGVwbG95IHtcblx0LyoqXG5cdCAqIFdlRGVwbG95IGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBiYXNlIHVybC5cblx0ICogQHBhcmFtIHsuLi5zdHJpbmd9IHBhdGhzIEFueSBhbW91bnQgb2YgcGF0aHMgdG8gYmUgYXBwZW5kZWQgdG8gdGhlIGJhc2Vcblx0ICogdXJsLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGNvbnN0cnVjdG9yKHVybCwgLi4ucGF0aHMpIHtcblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cywgdHJ5IGBuZXcgV2VEZXBsb3koYmFzZVVybCwgdXJsKWAnKTtcblx0XHR9XG5cblx0XHR0aGlzLmF1dGhfID0gbnVsbDtcblx0XHR0aGlzLmJvZHlfID0gbnVsbDtcblx0XHR0aGlzLnVybF8gPSBVcmkuam9pblBhdGhzKHVybCB8fCAnJywgLi4ucGF0aHMpO1xuXHRcdHRoaXMuaGVhZGVyc18gPSBuZXcgTXVsdGlNYXAoKTtcblx0XHR0aGlzLnBhcmFtc18gPSBuZXcgTXVsdGlNYXAoKTtcblx0XHR0aGlzLndpdGhDcmVkZW50aWFsc18gPSB0cnVlO1xuXG5cdFx0dGhpcy5oZWFkZXIoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi9qc29uJyk7XG5cdFx0dGhpcy5oZWFkZXIoJ1gtUmVxdWVzdGVkLVdpdGgnLCAnWE1MSHR0cFJlcXVlc3QnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTdGF0aWMgZmFjdG9yeSBmb3IgY3JlYXRpbmcgV2VEZXBsb3kgZGF0YSBmb3IgdGhlIGdpdmVuIHVybC5cblx0ICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfZGF0YVVybCBUaGUgdXJsIHRoYXQgcG9pbnRzIHRvIHRoZSBkYXRhIHNlcnZpY2VzLlxuXHQgKiBAcmV0dXJuIEByZXR1cm4ge2RhdGF9IFdlRGVwbG95IGRhdGEgaW5zdGFuY2UuXG5cdCAqL1xuXHRzdGF0aWMgZGF0YShvcHRfZGF0YVVybCkge1xuXHRcdGFzc2VydFVyaVdpdGhOb1BhdGgob3B0X2RhdGFVcmwsICdUaGUgZGF0YSB1cmwgc2hvdWxkIG5vdCBoYXZlIGEgcGF0aCcpO1xuXG5cdFx0aWYgKGNvcmUuaXNTdHJpbmcob3B0X2RhdGFVcmwpKSB7XG5cdFx0XHRXZURlcGxveS5kYXRhVXJsXyA9IG9wdF9kYXRhVXJsO1xuXHRcdH1cblxuXHRcdGxldCBkYXRhID0gbmV3IERhdGFBcGlIZWxwZXIoV2VEZXBsb3kpO1xuXG5cdFx0ZGF0YS5hdXRoKFdlRGVwbG95LmF1dGgoKS5jdXJyZW50VXNlcik7XG5cblx0XHRyZXR1cm4gZGF0YTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGF1dGhvcml6YXRpb24gaW5mb3JtYXRpb24gdG8gdGhpcyByZXF1ZXN0LlxuXHQgKiBAcGFyYW0geyFBdXRofHN0cmluZ30gYXV0aE9yVG9rZW5PckVtYWlsIEVpdGhlciBhbiB7QGxpbmsgQXV0aH0gaW5zdGFuY2UsXG5cdCAqIGFuIGF1dGhvcml6YXRpb24gdG9rZW4sIG9yIHRoZSBlbWFpbC5cblx0ICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfcGFzc3dvcmQgSWYgYSBlbWFpbCBpcyBnaXZlbiBhcyB0aGUgZmlyc3QgcGFyYW0sXG5cdCAqIHRoaXMgc2hvdWxkIGJlIHRoZSBwYXNzd29yZC5cblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0YXV0aChhdXRoT3JUb2tlbk9yRW1haWwsIG9wdF9wYXNzd29yZCkge1xuXHRcdHRoaXMuYXV0aF8gPSBhdXRoT3JUb2tlbk9yRW1haWw7XG5cdFx0aWYgKCEodGhpcy5hdXRoXyBpbnN0YW5jZW9mIEF1dGgpKSB7XG5cdFx0XHR0aGlzLmF1dGhfID0gQXV0aC5jcmVhdGUoYXV0aE9yVG9rZW5PckVtYWlsLCBvcHRfcGFzc3dvcmQpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBTdGF0aWMgZmFjdG9yeSBmb3IgY3JlYXRpbmcgV2VEZXBsb3kgYXV0aCBmb3IgdGhlIGdpdmVuIHVybC5cblx0ICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfYXV0aFVybCBUaGUgdXJsIHRoYXQgcG9pbnRzIHRvIHRoZSBhdXRoIHNlcnZpY2UuXG5cdCAqL1xuXHRzdGF0aWMgYXV0aChvcHRfYXV0aFVybCkge1xuXHRcdGlmIChjb3JlLmlzU3RyaW5nKG9wdF9hdXRoVXJsKSkge1xuXHRcdFx0V2VEZXBsb3kuYXV0aFVybF8gPSBvcHRfYXV0aFVybDtcblx0XHR9XG5cdFx0aWYgKCFXZURlcGxveS5hdXRoXykge1xuXHRcdFx0V2VEZXBsb3kuYXV0aF8gPSBuZXcgQXV0aEFwaUhlbHBlcihXZURlcGxveSk7XG5cdFx0fVxuXHRcdHJldHVybiBXZURlcGxveS5hdXRoXztcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBib2R5IHRoYXQgd2lsbCBiZSBzZW50IHdpdGggdGhpcyByZXF1ZXN0LlxuXHQgKiBAcGFyYW0geyp9IGJvZHlcblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0Ym9keShib2R5KSB7XG5cdFx0dGhpcy5ib2R5XyA9IGJvZHk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgdGhlIGdpdmVuIGJvZHkgb2JqZWN0IHRvIHF1ZXJ5IHBhcmFtcy5cblx0ICogQHBhcmFtIHshQ2xpZW50UmVxdWVzdH0gY2xpZW50UmVxdWVzdCBDbGllbnQgcmVxdWVzdC5cblx0ICogQHBhcmFtIHsqfSBib2R5XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdGNvbnZlcnRCb2R5VG9QYXJhbXNfKGNsaWVudFJlcXVlc3QsIGJvZHkpIHtcblx0XHRpZiAoY29yZS5pc1N0cmluZyhib2R5KSkge1xuXHRcdFx0Ym9keSA9IHtcblx0XHRcdFx0Ym9keTogYm9keVxuXHRcdFx0fTtcblx0XHR9IGVsc2UgaWYgKGJvZHkgaW5zdGFuY2VvZiBFbWJvZGllZCkge1xuXHRcdFx0Ym9keSA9IGJvZHkuYm9keSgpO1xuXHRcdH1cblx0XHRPYmplY3Qua2V5cyhib2R5IHx8IHt9KS5mb3JFYWNoKG5hbWUgPT4gY2xpZW50UmVxdWVzdC5wYXJhbShuYW1lLCBib2R5W25hbWVdKSk7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBjbGllbnQgcmVxdWVzdCBhbmQgZW5jb2RlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kXG5cdCAqIEBwYXJhbSB7Kn0gYm9keVxuXHQgKiBAcmV0dXJuIHshQ2xpZW50UmVxdWVzdH0gQ2xpZW50IHJlcXVlc3QuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdGNyZWF0ZUNsaWVudFJlcXVlc3RfKG1ldGhvZCwgYm9keSkge1xuXHRcdGNvbnN0IGNsaWVudFJlcXVlc3QgPSBuZXcgQ2xpZW50UmVxdWVzdCgpO1xuXG5cdFx0Y2xpZW50UmVxdWVzdC5ib2R5KGJvZHkgfHwgdGhpcy5ib2R5Xyk7XG5cblx0XHRpZiAoIWNvcmUuaXNEZWZBbmROb3ROdWxsKGNsaWVudFJlcXVlc3QuYm9keSgpKSkge1xuXHRcdFx0aWYgKHRoaXMuZm9ybURhdGFfKSB7XG5cdFx0XHRcdGNsaWVudFJlcXVlc3QuYm9keSh0aGlzLmZvcm1EYXRhXyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Y2xpZW50UmVxdWVzdC5tZXRob2QobWV0aG9kKTtcblx0XHRjbGllbnRSZXF1ZXN0LmhlYWRlcnModGhpcy5oZWFkZXJzKCkpO1xuXHRcdGNsaWVudFJlcXVlc3QucGFyYW1zKHRoaXMucGFyYW1zKCkpO1xuXHRcdGNsaWVudFJlcXVlc3QudXJsKHRoaXMudXJsKCkpO1xuXHRcdGNsaWVudFJlcXVlc3Qud2l0aENyZWRlbnRpYWxzKHRoaXMud2l0aENyZWRlbnRpYWxzXyk7XG5cblx0XHR0aGlzLmVuY29kZShjbGllbnRSZXF1ZXN0KTtcblxuXHRcdHJldHVybiBjbGllbnRSZXF1ZXN0O1xuXHR9XG5cblx0LyoqXG5cdCAqIERlY29kZXMgY2xpZW50UmVzcG9uc2UgYm9keSwgcGFyc2luZyB0aGUgYm9keSBmb3IgZXhhbXBsZS5cblx0ICogQHBhcmFtIHshQ2xpZW50UmVzcG9uc2V9IGNsaWVudFJlc3BvbnNlIFRoZSByZXNwb25zZSBvYmplY3QgdG8gYmVcblx0ICogZGVjb2RlZC5cblx0ICogQHJldHVybiB7IUNsaWVudFJlc3BvbnNlfSBUaGUgZGVjb2RlZCByZXNwb25zZS5cblx0ICovXG5cdGRlY29kZShjbGllbnRSZXNwb25zZSkge1xuXHRcdGlmIChXZURlcGxveS5pc0NvbnRlbnRUeXBlSnNvbihjbGllbnRSZXNwb25zZSkpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGNsaWVudFJlc3BvbnNlLmJvZHkoSlNPTi5wYXJzZShjbGllbnRSZXNwb25zZS5ib2R5KCkpKTtcblx0XHRcdH0gY2F0Y2ggKGVycikge31cblx0XHR9XG5cdFx0cmV0dXJuIGNsaWVudFJlc3BvbnNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNlbmRzIG1lc3NhZ2Ugd2l0aCB0aGUgREVMRVRFIGh0dHAgdmVyYi5cblx0ICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfYm9keSBDb250ZW50IHRvIGJlIHNlbnQgYXMgdGhlIHJlcXVlc3QncyBib2R5LlxuXHQgKiBAcmV0dXJuIHshQ2FuY2VsbGFibGVQcm9taXNlfVxuXHQgKi9cblx0ZGVsZXRlKG9wdF9ib2R5KSB7XG5cdFx0cmV0dXJuIHRoaXMuc2VuZEFzeW5jKCdERUxFVEUnLCBvcHRfYm9keSk7XG5cdH1cblxuXHQvKipcblx0ICogRW5jb2RlcyB0aGUgZ2l2ZW4ge0BsaW5rIENsaWVudFJlcXVlc3R9LCBjb252ZXJ0aW5nIGl0cyBib2R5IHRvIGFuXG5cdCAqIGFwcHJvcHJpYXRlIGZvcm1hdCBmb3IgZXhhbXBsZS5cblx0ICogQHBhcmFtIHshQ2xpZW50UmVxdWVzdH0gY2xpZW50UmVxdWVzdCBUaGUgcmVxdWVzdCBvYmplY3QgdG8gZW5jb2RlLlxuXHQgKiBAcmV0dXJuIHshQ2xpZW50UmVxdWVzdH0gVGhlIGVuY29kZWQgcmVxdWVzdC5cblx0ICovXG5cdGVuY29kZShjbGllbnRSZXF1ZXN0KSB7XG5cdFx0bGV0IGJvZHkgPSBjbGllbnRSZXF1ZXN0LmJvZHkoKTtcblxuXHRcdGlmIChjb3JlLmlzRWxlbWVudChib2R5KSkge1xuXHRcdFx0Ym9keSA9IG5ldyBGb3JtRGF0YShib2R5KTtcblx0XHRcdGNsaWVudFJlcXVlc3QuYm9keShib2R5KTtcblx0XHR9XG5cblx0XHRib2R5ID0gdGhpcy5tYXliZVdyYXBXaXRoUXVlcnlfKGJvZHkpO1xuXHRcdGlmIChjbGllbnRSZXF1ZXN0Lm1ldGhvZCgpID09PSAnR0VUJykge1xuXHRcdFx0dGhpcy5jb252ZXJ0Qm9keVRvUGFyYW1zXyhjbGllbnRSZXF1ZXN0LCBib2R5KTtcblx0XHRcdGNsaWVudFJlcXVlc3QucmVtb3ZlQm9keSgpO1xuXHRcdFx0Ym9keSA9IG51bGw7XG5cdFx0fVxuXG5cdFx0aWYgKHR5cGVvZiBGb3JtRGF0YSAhPT0gJ3VuZGVmaW5lZCcgJiYgYm9keSBpbnN0YW5jZW9mIEZvcm1EYXRhKSB7XG5cdFx0XHRjbGllbnRSZXF1ZXN0LmhlYWRlcnMoKS5yZW1vdmUoJ2NvbnRlbnQtdHlwZScpO1xuXHRcdH0gZWxzZSBpZiAoYm9keSBpbnN0YW5jZW9mIEVtYm9kaWVkKSB7XG5cdFx0XHRjbGllbnRSZXF1ZXN0LmJvZHkoYm9keS50b1N0cmluZygpKTtcblx0XHR9IGVsc2UgaWYgKFdlRGVwbG95LmlzQ29udGVudFR5cGVKc29uKGNsaWVudFJlcXVlc3QpKSB7XG5cdFx0XHRjbGllbnRSZXF1ZXN0LmJvZHkoSlNPTi5zdHJpbmdpZnkoY2xpZW50UmVxdWVzdC5ib2R5KCkpKTtcblx0XHR9XG5cblx0XHR0aGlzLmVuY29kZVBhcmFtc18oY2xpZW50UmVxdWVzdCk7XG5cdFx0dGhpcy5yZXNvbHZlQXV0aGVudGljYXRpb25fKGNsaWVudFJlcXVlc3QpO1xuXG5cdFx0cmV0dXJuIGNsaWVudFJlcXVlc3Q7XG5cdH1cblxuXHQvKipcblx0ICogRW5jb2RlcyB0aGUgcGFyYW1zIGZvciB0aGUgZ2l2ZW4gcmVxdWVzdCwgYWNjb3JkaW5nIHRvIHRoZWlyIHR5cGVzLlxuXHQgKiBAcGFyYW0geyFDbGllbnRSZXF1ZXN0fSBjbGllbnRSZXF1ZXN0XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdGVuY29kZVBhcmFtc18oY2xpZW50UmVxdWVzdCkge1xuXHRcdGxldCBwYXJhbXMgPSBjbGllbnRSZXF1ZXN0LnBhcmFtcygpO1xuXHRcdHBhcmFtcy5uYW1lcygpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuXHRcdFx0bGV0IHZhbHVlcyA9IHBhcmFtcy5nZXRBbGwobmFtZSk7XG5cdFx0XHR2YWx1ZXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgaW5kZXgpIHtcblx0XHRcdFx0aWYgKHZhbHVlIGluc3RhbmNlb2YgRW1ib2RpZWQpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoY29yZS5pc09iamVjdCh2YWx1ZSkgfHwgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIGtleS92YWx1ZSBwYWlyIHRvIGJlIHNlbnQgdmlhIHRoZSBib2R5IGluIGEgYG11bHRpcGFydC9mb3JtLWRhdGFgIGZvcm1hdC5cblx0ICogSWYgdGhlIGJvZHkgaXMgc2V0IGJ5IG90aGVyIG1lYW5zIChmb3IgZXhhbXBsZSwgdGhyb3VnaCB0aGUgYGJvZHlgIG1ldGhvZCksIHRoaXNcblx0ICogd2lsbCBiZSBpZ25vcmVkLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuXHQgKiBAcGFyYW0geyp9IHZhbHVlXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdGZvcm0obmFtZSwgdmFsdWUpIHtcblx0XHRpZiAodHlwZW9mIEZvcm1EYXRhID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdmb3JtKCkgaXMgb25seSBhdmFpbGFibGUgd2hlbiBGb3JtRGF0YSBBUEkgaXMgYXZhaWxhYmxlLicpO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5mb3JtRGF0YV8pIHtcblx0XHRcdHRoaXMuZm9ybURhdGFfID0gbmV3IEZvcm1EYXRhKCk7XG5cdFx0fVxuXHRcdHRoaXMuZm9ybURhdGFfLmFwcGVuZChuYW1lLCB2YWx1ZSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogU2VuZHMgbWVzc2FnZSB3aXRoIHRoZSBHRVQgaHR0cCB2ZXJiLlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfcGFyYW1zIFBhcmFtcyB0byBiZSBhZGRlZCB0byB0aGUgcmVxdWVzdCB1cmwuXG5cdCAqIEByZXR1cm4geyFDYW5jZWxsYWJsZVByb21pc2V9XG5cdCAqL1xuXHRnZXQob3B0X3BhcmFtcykge1xuXHRcdHJldHVybiB0aGlzLnNlbmRBc3luYygnR0VUJywgb3B0X3BhcmFtcyk7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIGhlYWRlci4gSWYgdGhlIGhlYWRlciB3aXRoIHRoZSBzYW1lIG5hbWUgYWxyZWFkeSBleGlzdHMsIGl0IHdpbGxcblx0ICogbm90IGJlIG92ZXJ3cml0dGVuLCBidXQgbmV3IHZhbHVlIHdpbGwgYmUgc3RvcmVkLiBUaGUgb3JkZXIgaXMgcHJlc2VydmVkLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBIZWFkZXIga2V5LlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIEhlYWRlciB2YWx1ZS5cblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0aGVhZGVyKG5hbWUsIHZhbHVlKSB7XG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDIpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMnKTtcblx0XHR9XG5cdFx0dGhpcy5oZWFkZXJzXy5zZXQobmFtZSwgdmFsdWUpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGhlYWRlcnMuXG5cdCAqIEByZXR1cm4geyFNdWx0aU1hcH1cblx0ICovXG5cdGhlYWRlcnMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuaGVhZGVyc187XG5cdH1cblxuXHQvKipcblx0ICogV3JhcHMgdGhlIGdpdmVuIGBFbWJvZGllZGAgaW5zdGFuY2Ugd2l0aCBhIHtAbGluayBRdWVyeX0gaW5zdGFuY2UgaWYgbmVlZGVkLlxuXHQgKiBAcGFyYW0ge0VtYm9kaWVkfSBlbWJvZGllZFxuXHQgKiBAcmV0dXJuIHtFbWJvZGllZH1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0bWF5YmVXcmFwV2l0aFF1ZXJ5XyhlbWJvZGllZCkge1xuXHRcdGlmIChlbWJvZGllZCBpbnN0YW5jZW9mIEZpbHRlcikge1xuXHRcdFx0ZW1ib2RpZWQgPSBRdWVyeS5maWx0ZXIoZW1ib2RpZWQpO1xuXHRcdH1cblx0XHRyZXR1cm4gZW1ib2RpZWQ7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIHF1ZXJ5LiBJZiB0aGUgcXVlcnkgd2l0aCB0aGUgc2FtZSBuYW1lIGFscmVhZHkgZXhpc3RzLCBpdCB3aWxsIG5vdFxuXHQgKiBiZSBvdmVyd3JpdHRlbiwgYnV0IG5ldyB2YWx1ZSB3aWxsIGJlIHN0b3JlZC4gVGhlIG9yZGVyIGlzIHByZXNlcnZlZC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgUGFyYW0ga2V5LlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFBhcmFtIHZhbHVlLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRwYXJhbShuYW1lLCB2YWx1ZSkge1xuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAyKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzJyk7XG5cdFx0fVxuXHRcdHRoaXMucGFyYW1zXy5zZXQobmFtZSwgdmFsdWUpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIHF1ZXJ5IHN0cmluZ3MgbWFwLlxuXHQgKiBAcmV0dXJuIHshTXVsdGlNYXB9XG5cdCAqL1xuXHRwYXJhbXMoKSB7XG5cdFx0cmV0dXJuIHRoaXMucGFyYW1zXztcblx0fVxuXG5cdC8qKlxuXHQgKiBTZW5kcyBtZXNzYWdlIHdpdGggdGhlIFBBVENIIGh0dHAgdmVyYi5cblx0ICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfYm9keSBDb250ZW50IHRvIGJlIHNlbnQgYXMgdGhlIHJlcXVlc3QncyBib2R5LlxuXHQgKiBAcmV0dXJuIHshQ2FuY2VsbGFibGVQcm9taXNlfVxuXHQgKi9cblx0cGF0Y2gob3B0X2JvZHkpIHtcblx0XHRyZXR1cm4gdGhpcy5zZW5kQXN5bmMoJ1BBVENIJywgb3B0X2JvZHkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBuZXcge0BsaW5rIFdlRGVwbG95fSBpbnN0YW5jZSBmb3IgaGFuZGxpbmcgdGhlIHVybCByZXN1bHRpbmcgaW4gdGhlXG5cdCAqIHVuaW9uIG9mIHRoZSBjdXJyZW50IHVybCB3aXRoIHRoZSBnaXZlbiBwYXRocy5cblx0ICogQHBhcmFtIHsuLi5zdHJpbmd9IHBhdGhzIEFueSBudW1iZXIgb2YgcGF0aHMuXG5cdCAqIEByZXR1cm4geyFXZURlcGxveX0gQSBuZXcge0BsaW5rIFdlRGVwbG95fSBpbnN0YW5jZSBmb3IgaGFuZGxpbmcgdGhlIGdpdmVuIHBhdGhzLlxuXHQgKi9cblx0cGF0aCguLi5wYXRocykge1xuXHRcdGxldCB3ZWRlcGxveUNsaWVudCA9IG5ldyBXZURlcGxveSh0aGlzLnVybCgpLCAuLi5wYXRocyk7XG5cblx0XHRpZiAoY29yZS5pc0RlZkFuZE5vdE51bGwodGhpcy5hdXRoXykpIHtcblx0XHRcdHdlZGVwbG95Q2xpZW50LmF1dGgodGhpcy5hdXRoXyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHdlZGVwbG95Q2xpZW50LnVzZSh0aGlzLmN1c3RvbVRyYW5zcG9ydF8pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNlbmRzIG1lc3NhZ2Ugd2l0aCB0aGUgUE9TVCBodHRwIHZlcmIuXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X2JvZHkgQ29udGVudCB0byBiZSBzZW50IGFzIHRoZSByZXF1ZXN0J3MgYm9keS5cblx0ICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZX1cblx0ICovXG5cdHBvc3Qob3B0X2JvZHkpIHtcblx0XHRyZXR1cm4gdGhpcy5zZW5kQXN5bmMoJ1BPU1QnLCBvcHRfYm9keSk7XG5cdH1cblxuXHQvKipcblx0ICogU2VuZHMgbWVzc2FnZSB3aXRoIHRoZSBQVVQgaHR0cCB2ZXJiLlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9ib2R5IENvbnRlbnQgdG8gYmUgc2VudCBhcyB0aGUgcmVxdWVzdCdzIGJvZHkuXG5cdCAqIEByZXR1cm4geyFDYW5jZWxsYWJsZVByb21pc2V9XG5cdCAqL1xuXHRwdXQob3B0X2JvZHkpIHtcblx0XHRyZXR1cm4gdGhpcy5zZW5kQXN5bmMoJ1BVVCcsIG9wdF9ib2R5KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIHRoZSBhdXRoZW50aWNhdGlvbiBpbmZvcm1hdGlvbiB0byB0aGUgcmVxdWVzdC5cblx0ICogQHBhcmFtIHshQ2xpZW50UmVxdWVzdH0gY2xpZW50UmVxdWVzdFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRyZXNvbHZlQXV0aGVudGljYXRpb25fKGNsaWVudFJlcXVlc3QpIHtcblx0XHRpZiAoIXRoaXMuYXV0aF8pIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYgKHRoaXMuYXV0aF8uaGFzVG9rZW4oKSkge1xuXHRcdFx0Y2xpZW50UmVxdWVzdC5oZWFkZXIoJ0F1dGhvcml6YXRpb24nLCAnQmVhcmVyICcgKyB0aGlzLmF1dGhfLnRva2VuKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc3QgY3JlZGVudGlhbHMgPSB0aGlzLmF1dGhfLmVtYWlsICsgJzonICsgdGhpcy5hdXRoXy5wYXNzd29yZDtcblx0XHRcdGNsaWVudFJlcXVlc3QuaGVhZGVyKCdBdXRob3JpemF0aW9uJywgJ0Jhc2ljICcgKyBCYXNlNjQuZW5jb2RlU3RyaW5nKGNyZWRlbnRpYWxzKSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFVzZXMgdHJhbnNwb3J0IHRvIHNlbmQgcmVxdWVzdCB3aXRoIGdpdmVuIG1ldGhvZCBuYW1lIGFuZCBib2R5XG5cdCAqIGFzeW5jaHJvbm91c2x5LlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kIFRoZSBIVFRQIG1ldGhvZCB0byBiZSB1c2VkIHdoZW4gc2VuZGluZyBkYXRhLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gYm9keSBDb250ZW50IHRvIGJlIHNlbnQgYXMgdGhlIHJlcXVlc3QncyBib2R5LlxuXHQgKiBAcmV0dXJuIHshQ2FuY2VsbGFibGVQcm9taXNlfSBEZWZlcnJlZCByZXF1ZXN0LlxuXHQgKi9cblx0c2VuZEFzeW5jKG1ldGhvZCwgYm9keSkge1xuXHRcdGNvbnN0IHRyYW5zcG9ydCA9IHRoaXMuY3VzdG9tVHJhbnNwb3J0XyB8fCBUcmFuc3BvcnRGYWN0b3J5Lmluc3RhbmNlKCkuZ2V0RGVmYXVsdCgpO1xuXG5cdFx0Y29uc3QgY2xpZW50UmVxdWVzdCA9IHRoaXMuY3JlYXRlQ2xpZW50UmVxdWVzdF8obWV0aG9kLCBib2R5KTtcblxuXHRcdHJldHVybiB0cmFuc3BvcnQuc2VuZChjbGllbnRSZXF1ZXN0KS50aGVuKHRoaXMuZGVjb2RlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBzb2NrZXQgdHJhbnNwb3J0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzb2NrZXQgaW1wbGVtZW50YXRpb24gb2JqZWN0LlxuXHQgKi9cblx0c3RhdGljIHNvY2tldChzb2NrZXQpIHtcblx0XHRpbyA9IHNvY2tldDtcblx0fVxuXG5cdC8qKlxuXHQgKiBTdGF0aWMgZmFjdG9yeSBmb3IgY3JlYXRpbmcgV2VEZXBsb3kgY2xpZW50IGZvciB0aGUgZ2l2ZW4gdXJsLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSB1cmwgdGhhdCB0aGUgY2xpZW50IHNob3VsZCB1c2UgZm9yIHNlbmRpbmcgcmVxdWVzdHMuXG5cdCAqL1xuXHRzdGF0aWMgdXJsKHVybCkge1xuXHRcdHJldHVybiBuZXcgV2VEZXBsb3kodXJsKS51c2UodGhpcy5jdXN0b21UcmFuc3BvcnRfKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBVUkwgdXNlZCBieSB0aGlzIGNsaWVudC5cblx0ICovXG5cdHVybCgpIHtcblx0XHRyZXR1cm4gdGhpcy51cmxfO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNwZWNpZmllcyB7QGxpbmsgVHJhbnNwb3J0fSBpbXBsZW1lbnRhdGlvbi5cblx0ICogQHBhcmFtIHshVHJhbnNwb3J0fSB0cmFuc3BvcnQgVGhlIHRyYW5zcG9ydCBpbXBsZW1lbnRhdGlvbiB0aGF0IHNob3VsZCBiZVxuXHQgKiB1c2VkLlxuXHQgKi9cblx0dXNlKHRyYW5zcG9ydCkge1xuXHRcdHRoaXMuY3VzdG9tVHJhbnNwb3J0XyA9IHRyYW5zcG9ydDtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIG5ldyBzb2NrZXQuaW8gaW5zdGFuY2UuIFRoZSBwYXJhbWV0ZXJzIHBhc3NlZCB0byBzb2NrZXQuaW9cblx0ICogY29uc3RydWN0b3Igd2lsbCBiZSBwcm92aWRlZDpcblx0ICpcblx0ICogYGBgamF2YXNjcmlwdFxuXHQgKiBXZURlcGxveS51cmwoJ2h0dHA6Ly9kb21haW46ODA4MC9wYXRoL2EnKS53YXRjaCh7aWQ6ICdteUlkJ30sIHtmb286IHRydWV9KTtcblx0ICogLy8gRXF1YWxzOlxuXHQgKiBpbygnZG9tYWluOjgwODAvP3VybD1wYXRoJTJGYSUzRmlkJTNEbXlJZCcsIHtmb286IHRydWV9KTtcblx0ICogYGBgXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0X3BhcmFtcyBQYXJhbXMgdG8gYmUgc2VudCB3aXRoIHRoZSBTb2NrZXQgSU8gcmVxdWVzdC5cblx0ICogQHBhcmFtIHtPYmplY3Q9fSBvcHRfb3B0aW9ucyBPYmplY3Qgd2l0aCBTb2NrZXQgSU8gb3B0aW9ucy5cblx0ICogQHJldHVybiB7IWlvfSBTb2NrZXQgSU8gcmVmZXJlbmNlLiBTZXJ2ZXIgZXZlbnRzIGNhbiBiZSBsaXN0ZW5lZCBvbiBpdC5cblx0ICovXG5cdHdhdGNoKG9wdF9wYXJhbXMsIG9wdF9vcHRpb25zKSB7XG5cdFx0aWYgKHR5cGVvZiBpbyA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignU29ja2V0LmlvIGNsaWVudCBub3QgbG9hZGVkJyk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgY2xpZW50UmVxdWVzdCA9IHRoaXMuY3JlYXRlQ2xpZW50UmVxdWVzdF8oJ0dFVCcsIG9wdF9wYXJhbXMpO1xuXHRcdGNvbnN0IHVyaSA9IG5ldyBVcmkoY2xpZW50UmVxdWVzdC51cmwoKSk7XG5cdFx0dXJpLmFkZFBhcmFtZXRlcnNGcm9tTXVsdGlNYXAoY2xpZW50UmVxdWVzdC5wYXJhbXMoKSk7XG5cblx0XHRvcHRfb3B0aW9ucyA9IG9wdF9vcHRpb25zIHx8IHtcblx0XHRcdGZvcmNlTmV3OiB0cnVlXG5cdFx0fTtcblx0XHRvcHRfb3B0aW9ucy5xdWVyeSA9ICd1cmw9JyArIGVuY29kZVVSSUNvbXBvbmVudCh1cmkuZ2V0UGF0aG5hbWUoKSArIHVyaS5nZXRTZWFyY2goKSk7XG5cdFx0b3B0X29wdGlvbnMucGF0aCA9IG9wdF9vcHRpb25zLnBhdGggfHwgdXJpLmdldFBhdGhuYW1lKCk7XG5cblx0XHRyZXR1cm4gaW8odXJpLmdldEhvc3QoKSwgb3B0X29wdGlvbnMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0X3dpdGhDcmVkZW50aWFsc1xuXHQgKi9cblx0d2l0aENyZWRlbnRpYWxzKHdpdGhDcmVkZW50aWFscykge1xuXHRcdHRoaXMud2l0aENyZWRlbnRpYWxzXyA9ICEhd2l0aENyZWRlbnRpYWxzO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59XG5cbldlRGVwbG95LmlzQ29udGVudFR5cGVKc29uID0gZnVuY3Rpb24oY2xpZW50TWVzc2FnZSkge1xuXHRjb25zdCBjb250ZW50VHlwZSA9IGNsaWVudE1lc3NhZ2UuaGVhZGVycygpLmdldCgnY29udGVudC10eXBlJykgfHwgJyc7XG5cdHJldHVybiBjb250ZW50VHlwZS5pbmRleE9mKCdhcHBsaWNhdGlvbi9qc29uJykgPT09IDA7XG59O1xuXG5XZURlcGxveS5hdXRoXyA9IG51bGw7XG5XZURlcGxveS5hdXRoVXJsXyA9ICcnO1xuV2VEZXBsb3kuZGF0YV8gPSBudWxsO1xuV2VEZXBsb3kuZGF0YVVybF8gPSAnJztcblxuZXhwb3J0IGRlZmF1bHQgV2VEZXBsb3k7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBnbG9iYWxzIGZyb20gJy4uL2dsb2JhbHMvZ2xvYmFscyc7XG5pbXBvcnQgRmlsdGVyIGZyb20gJy4uL2FwaS1xdWVyeS9GaWx0ZXInO1xuaW1wb3J0IEdlbyBmcm9tICcuLi9hcGktcXVlcnkvR2VvJztcbmltcG9ydCBXZURlcGxveSBmcm9tICcuLi9hcGkvV2VEZXBsb3knO1xuaW1wb3J0IFF1ZXJ5IGZyb20gJy4uL2FwaS1xdWVyeS9RdWVyeSc7XG5pbXBvcnQgUmFuZ2UgZnJvbSAnLi4vYXBpLXF1ZXJ5L1JhbmdlJztcblxuZ2xvYmFscy53aW5kb3cuRmlsdGVyID0gRmlsdGVyO1xuZ2xvYmFscy53aW5kb3cuR2VvID0gR2VvO1xuZ2xvYmFscy53aW5kb3cuUXVlcnkgPSBRdWVyeTtcbmdsb2JhbHMud2luZG93LlJhbmdlID0gUmFuZ2U7XG5nbG9iYWxzLndpbmRvdy5XZURlcGxveSA9IFdlRGVwbG95O1xuXG5leHBvcnQgeyBGaWx0ZXIsIEdlbywgUXVlcnksIFJhbmdlLCBXZURlcGxveSB9O1xuZXhwb3J0IGRlZmF1bHQgV2VEZXBsb3k7XG4iXSwic291cmNlUm9vdCI6Ii9zb3VyY2UvIn0=
