(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["io"] = factory();
	else
		root["io"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	/**
	 * Module dependencies.
	 */

	var url = __webpack_require__(1);
	var parser = __webpack_require__(6);
	var Manager = __webpack_require__(14);
	var debug = __webpack_require__(3)('socket.io-client');

	/**
	 * Module exports.
	 */

	module.exports = exports = lookup;

	/**
	 * Managers cache.
	 */

	var cache = exports.managers = {};

	/**
	 * Looks up an existing `Manager` for multiplexing.
	 * If the user summons:
	 *
	 *   `io('http://localhost/a');`
	 *   `io('http://localhost/b');`
	 *
	 * We reuse the existing instance based on same scheme/port/host,
	 * and we initialize sockets for each namespace.
	 *
	 * @api public
	 */

	function lookup(uri, opts) {
	  if ((typeof uri === 'undefined' ? 'undefined' : _typeof(uri)) === 'object') {
	    opts = uri;
	    uri = undefined;
	  }

	  opts = opts || {};

	  var parsed = url(uri);
	  var source = parsed.source;
	  var id = parsed.id;
	  var path = parsed.path;
	  var sameNamespace = cache[id] && path in cache[id].nsps;
	  var newConnection = opts.forceNew || opts['force new connection'] || false === opts.multiplex || sameNamespace;

	  var io;

	  if (newConnection) {
	    debug('ignoring socket cache for %s', source);
	    io = Manager(source, opts);
	  } else {
	    if (!cache[id]) {
	      debug('new io instance for %s', source);
	      cache[id] = Manager(source, opts);
	    }
	    io = cache[id];
	  }
	  if (parsed.query && !opts.query) {
	    opts.query = parsed.query;
	  } else if (opts && 'object' === _typeof(opts.query)) {
	    opts.query = encodeQueryString(opts.query);
	  }
	  return io.socket(parsed.path, opts);
	}
	/**
	 *  Helper method to parse query objects to string.
	 * @param {object} query
	 * @returns {string}
	 */
	function encodeQueryString(obj) {
	  var str = [];
	  for (var p in obj) {
	    if (obj.hasOwnProperty(p)) {
	      str.push(encodeURIComponent(p) + '=' + encodeURIComponent(obj[p]));
	    }
	  }
	  return str.join('&');
	}
	/**
	 * Protocol version.
	 *
	 * @api public
	 */

	exports.protocol = parser.protocol;

	/**
	 * `connect`.
	 *
	 * @param {String} uri
	 * @api public
	 */

	exports.connect = lookup;

	/**
	 * Expose constructors for standalone build.
	 *
	 * @api public
	 */

	exports.Manager = __webpack_require__(14);
	exports.Socket = __webpack_require__(42);

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';

	/**
	 * Module dependencies.
	 */

	var parseuri = __webpack_require__(2);
	var debug = __webpack_require__(3)('socket.io-client:url');

	/**
	 * Module exports.
	 */

	module.exports = url;

	/**
	 * URL parser.
	 *
	 * @param {String} url
	 * @param {Object} An object meant to mimic window.location.
	 *                 Defaults to window.location.
	 * @api public
	 */

	function url(uri, loc) {
	  var obj = uri;

	  // default to window.location
	  loc = loc || global.location;
	  if (null == uri) uri = loc.protocol + '//' + loc.host;

	  // relative path support
	  if ('string' === typeof uri) {
	    if ('/' === uri.charAt(0)) {
	      if ('/' === uri.charAt(1)) {
	        uri = loc.protocol + uri;
	      } else {
	        uri = loc.host + uri;
	      }
	    }

	    if (!/^(https?|wss?):\/\//.test(uri)) {
	      debug('protocol-less url %s', uri);
	      if ('undefined' !== typeof loc) {
	        uri = loc.protocol + '//' + uri;
	      } else {
	        uri = 'https://' + uri;
	      }
	    }

	    // parse
	    debug('parse %s', uri);
	    obj = parseuri(uri);
	  }

	  // make sure we treat `localhost:80` and `localhost` equally
	  if (!obj.port) {
	    if (/^(http|ws)$/.test(obj.protocol)) {
	      obj.port = '80';
	    } else if (/^(http|ws)s$/.test(obj.protocol)) {
	      obj.port = '443';
	    }
	  }

	  obj.path = obj.path || '/';

	  var ipv6 = obj.host.indexOf(':') !== -1;
	  var host = ipv6 ? '[' + obj.host + ']' : obj.host;

	  // define unique id
	  obj.id = obj.protocol + '://' + host + ':' + obj.port;
	  // define href
	  obj.href = obj.protocol + '://' + host + (loc && loc.port === obj.port ? '' : ':' + obj.port);

	  return obj;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 2 */
/***/ function(module, exports) {

	/**
	 * Parses an URI
	 *
	 * @author Steven Levithan <stevenlevithan.com> (MIT license)
	 * @api private
	 */

	var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

	var parts = [
	    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
	];

	module.exports = function parseuri(str) {
	    var src = str,
	        b = str.indexOf('['),
	        e = str.indexOf(']');

	    if (b != -1 && e != -1) {
	        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
	    }

	    var m = re.exec(str || ''),
	        uri = {},
	        i = 14;

	    while (i--) {
	        uri[parts[i]] = m[i] || '';
	    }

	    if (b != -1 && e != -1) {
	        uri.source = src;
	        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
	        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
	        uri.ipv6uri = true;
	    }

	    return uri;
	};


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * This is the web browser implementation of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */

	exports = module.exports = __webpack_require__(4);
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.storage = 'undefined' != typeof chrome
	               && 'undefined' != typeof chrome.storage
	                  ? chrome.storage.local
	                  : localstorage();

	/**
	 * Colors.
	 */

	exports.colors = [
	  'lightseagreen',
	  'forestgreen',
	  'goldenrod',
	  'dodgerblue',
	  'darkorchid',
	  'crimson'
	];

	/**
	 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
	 * and the Firebug extension (any Firefox version) are known
	 * to support "%c" CSS customizations.
	 *
	 * TODO: add a `localStorage` variable to explicitly enable/disable colors
	 */

	function useColors() {
	  // is webkit? http://stackoverflow.com/a/16459606/376773
	  return ('WebkitAppearance' in document.documentElement.style) ||
	    // is firebug? http://stackoverflow.com/a/398120/376773
	    (window.console && (console.firebug || (console.exception && console.table))) ||
	    // is firefox >= v31?
	    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
	    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
	}

	/**
	 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	 */

	exports.formatters.j = function(v) {
	  return JSON.stringify(v);
	};


	/**
	 * Colorize log arguments if enabled.
	 *
	 * @api public
	 */

	function formatArgs() {
	  var args = arguments;
	  var useColors = this.useColors;

	  args[0] = (useColors ? '%c' : '')
	    + this.namespace
	    + (useColors ? ' %c' : ' ')
	    + args[0]
	    + (useColors ? '%c ' : ' ')
	    + '+' + exports.humanize(this.diff);

	  if (!useColors) return args;

	  var c = 'color: ' + this.color;
	  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

	  // the final "%c" is somewhat tricky, because there could be other
	  // arguments passed either before or after the %c, so we need to
	  // figure out the correct index to insert the CSS into
	  var index = 0;
	  var lastC = 0;
	  args[0].replace(/%[a-z%]/g, function(match) {
	    if ('%%' === match) return;
	    index++;
	    if ('%c' === match) {
	      // we only are interested in the *last* %c
	      // (the user may have provided their own)
	      lastC = index;
	    }
	  });

	  args.splice(lastC, 0, c);
	  return args;
	}

	/**
	 * Invokes `console.log()` when available.
	 * No-op when `console.log` is not a "function".
	 *
	 * @api public
	 */

	function log() {
	  // this hackery is required for IE8/9, where
	  // the `console.log` function doesn't have 'apply'
	  return 'object' === typeof console
	    && console.log
	    && Function.prototype.apply.call(console.log, console, arguments);
	}

	/**
	 * Save `namespaces`.
	 *
	 * @param {String} namespaces
	 * @api private
	 */

	function save(namespaces) {
	  try {
	    if (null == namespaces) {
	      exports.storage.removeItem('debug');
	    } else {
	      exports.storage.debug = namespaces;
	    }
	  } catch(e) {}
	}

	/**
	 * Load `namespaces`.
	 *
	 * @return {String} returns the previously persisted debug modes
	 * @api private
	 */

	function load() {
	  var r;
	  try {
	    r = exports.storage.debug;
	  } catch(e) {}
	  return r;
	}

	/**
	 * Enable namespaces listed in `localStorage.debug` initially.
	 */

	exports.enable(load());

	/**
	 * Localstorage attempts to return the localstorage.
	 *
	 * This is necessary because safari throws
	 * when a user disables cookies/localstorage
	 * and you attempt to access it.
	 *
	 * @return {LocalStorage}
	 * @api private
	 */

	function localstorage(){
	  try {
	    return window.localStorage;
	  } catch (e) {}
	}


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */

	exports = module.exports = debug;
	exports.coerce = coerce;
	exports.disable = disable;
	exports.enable = enable;
	exports.enabled = enabled;
	exports.humanize = __webpack_require__(5);

	/**
	 * The currently active debug mode names, and names to skip.
	 */

	exports.names = [];
	exports.skips = [];

	/**
	 * Map of special "%n" handling functions, for the debug "format" argument.
	 *
	 * Valid key names are a single, lowercased letter, i.e. "n".
	 */

	exports.formatters = {};

	/**
	 * Previously assigned color.
	 */

	var prevColor = 0;

	/**
	 * Previous log timestamp.
	 */

	var prevTime;

	/**
	 * Select a color.
	 *
	 * @return {Number}
	 * @api private
	 */

	function selectColor() {
	  return exports.colors[prevColor++ % exports.colors.length];
	}

	/**
	 * Create a debugger with the given `namespace`.
	 *
	 * @param {String} namespace
	 * @return {Function}
	 * @api public
	 */

	function debug(namespace) {

	  // define the `disabled` version
	  function disabled() {
	  }
	  disabled.enabled = false;

	  // define the `enabled` version
	  function enabled() {

	    var self = enabled;

	    // set `diff` timestamp
	    var curr = +new Date();
	    var ms = curr - (prevTime || curr);
	    self.diff = ms;
	    self.prev = prevTime;
	    self.curr = curr;
	    prevTime = curr;

	    // add the `color` if not set
	    if (null == self.useColors) self.useColors = exports.useColors();
	    if (null == self.color && self.useColors) self.color = selectColor();

	    var args = Array.prototype.slice.call(arguments);

	    args[0] = exports.coerce(args[0]);

	    if ('string' !== typeof args[0]) {
	      // anything else let's inspect with %o
	      args = ['%o'].concat(args);
	    }

	    // apply any `formatters` transformations
	    var index = 0;
	    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
	      // if we encounter an escaped % then don't increase the array index
	      if (match === '%%') return match;
	      index++;
	      var formatter = exports.formatters[format];
	      if ('function' === typeof formatter) {
	        var val = args[index];
	        match = formatter.call(self, val);

	        // now we need to remove `args[index]` since it's inlined in the `format`
	        args.splice(index, 1);
	        index--;
	      }
	      return match;
	    });

	    if ('function' === typeof exports.formatArgs) {
	      args = exports.formatArgs.apply(self, args);
	    }
	    var logFn = enabled.log || exports.log || console.log.bind(console);
	    logFn.apply(self, args);
	  }
	  enabled.enabled = true;

	  var fn = exports.enabled(namespace) ? enabled : disabled;

	  fn.namespace = namespace;

	  return fn;
	}

	/**
	 * Enables a debug mode by namespaces. This can include modes
	 * separated by a colon and wildcards.
	 *
	 * @param {String} namespaces
	 * @api public
	 */

	function enable(namespaces) {
	  exports.save(namespaces);

	  var split = (namespaces || '').split(/[\s,]+/);
	  var len = split.length;

	  for (var i = 0; i < len; i++) {
	    if (!split[i]) continue; // ignore empty strings
	    namespaces = split[i].replace(/\*/g, '.*?');
	    if (namespaces[0] === '-') {
	      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
	    } else {
	      exports.names.push(new RegExp('^' + namespaces + '$'));
	    }
	  }
	}

	/**
	 * Disable debug output.
	 *
	 * @api public
	 */

	function disable() {
	  exports.enable('');
	}

	/**
	 * Returns true if the given mode name is enabled, false otherwise.
	 *
	 * @param {String} name
	 * @return {Boolean}
	 * @api public
	 */

	function enabled(name) {
	  var i, len;
	  for (i = 0, len = exports.skips.length; i < len; i++) {
	    if (exports.skips[i].test(name)) {
	      return false;
	    }
	  }
	  for (i = 0, len = exports.names.length; i < len; i++) {
	    if (exports.names[i].test(name)) {
	      return true;
	    }
	  }
	  return false;
	}

	/**
	 * Coerce `val`.
	 *
	 * @param {Mixed} val
	 * @return {Mixed}
	 * @api private
	 */

	function coerce(val) {
	  if (val instanceof Error) return val.stack || val.message;
	  return val;
	}


/***/ },
/* 5 */
/***/ function(module, exports) {

	/**
	 * Helpers.
	 */

	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var y = d * 365.25;

	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} options
	 * @return {String|Number}
	 * @api public
	 */

	module.exports = function(val, options){
	  options = options || {};
	  if ('string' == typeof val) return parse(val);
	  return options.long
	    ? long(val)
	    : short(val);
	};

	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */

	function parse(str) {
	  str = '' + str;
	  if (str.length > 10000) return;
	  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
	  if (!match) return;
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s;
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n;
	  }
	}

	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function short(ms) {
	  if (ms >= d) return Math.round(ms / d) + 'd';
	  if (ms >= h) return Math.round(ms / h) + 'h';
	  if (ms >= m) return Math.round(ms / m) + 'm';
	  if (ms >= s) return Math.round(ms / s) + 's';
	  return ms + 'ms';
	}

	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function long(ms) {
	  return plural(ms, d, 'day')
	    || plural(ms, h, 'hour')
	    || plural(ms, m, 'minute')
	    || plural(ms, s, 'second')
	    || ms + ' ms';
	}

	/**
	 * Pluralization helper.
	 */

	function plural(ms, n, name) {
	  if (ms < n) return;
	  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
	  return Math.ceil(ms / n) + ' ' + name + 's';
	}


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module dependencies.
	 */

	var debug = __webpack_require__(3)('socket.io-parser');
	var json = __webpack_require__(7);
	var isArray = __webpack_require__(10);
	var Emitter = __webpack_require__(11);
	var binary = __webpack_require__(12);
	var isBuf = __webpack_require__(13);

	/**
	 * Protocol version.
	 *
	 * @api public
	 */

	exports.protocol = 4;

	/**
	 * Packet types.
	 *
	 * @api public
	 */

	exports.types = [
	  'CONNECT',
	  'DISCONNECT',
	  'EVENT',
	  'ACK',
	  'ERROR',
	  'BINARY_EVENT',
	  'BINARY_ACK'
	];

	/**
	 * Packet type `connect`.
	 *
	 * @api public
	 */

	exports.CONNECT = 0;

	/**
	 * Packet type `disconnect`.
	 *
	 * @api public
	 */

	exports.DISCONNECT = 1;

	/**
	 * Packet type `event`.
	 *
	 * @api public
	 */

	exports.EVENT = 2;

	/**
	 * Packet type `ack`.
	 *
	 * @api public
	 */

	exports.ACK = 3;

	/**
	 * Packet type `error`.
	 *
	 * @api public
	 */

	exports.ERROR = 4;

	/**
	 * Packet type 'binary event'
	 *
	 * @api public
	 */

	exports.BINARY_EVENT = 5;

	/**
	 * Packet type `binary ack`. For acks with binary arguments.
	 *
	 * @api public
	 */

	exports.BINARY_ACK = 6;

	/**
	 * Encoder constructor.
	 *
	 * @api public
	 */

	exports.Encoder = Encoder;

	/**
	 * Decoder constructor.
	 *
	 * @api public
	 */

	exports.Decoder = Decoder;

	/**
	 * A socket.io Encoder instance
	 *
	 * @api public
	 */

	function Encoder() {}

	/**
	 * Encode a packet as a single string if non-binary, or as a
	 * buffer sequence, depending on packet type.
	 *
	 * @param {Object} obj - packet object
	 * @param {Function} callback - function to handle encodings (likely engine.write)
	 * @return Calls callback with Array of encodings
	 * @api public
	 */

	Encoder.prototype.encode = function(obj, callback){
	  debug('encoding packet %j', obj);

	  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
	    encodeAsBinary(obj, callback);
	  }
	  else {
	    var encoding = encodeAsString(obj);
	    callback([encoding]);
	  }
	};

	/**
	 * Encode packet as string.
	 *
	 * @param {Object} packet
	 * @return {String} encoded
	 * @api private
	 */

	function encodeAsString(obj) {
	  var str = '';
	  var nsp = false;

	  // first is type
	  str += obj.type;

	  // attachments if we have them
	  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
	    str += obj.attachments;
	    str += '-';
	  }

	  // if we have a namespace other than `/`
	  // we append it followed by a comma `,`
	  if (obj.nsp && '/' != obj.nsp) {
	    nsp = true;
	    str += obj.nsp;
	  }

	  // immediately followed by the id
	  if (null != obj.id) {
	    if (nsp) {
	      str += ',';
	      nsp = false;
	    }
	    str += obj.id;
	  }

	  // json data
	  if (null != obj.data) {
	    if (nsp) str += ',';
	    str += json.stringify(obj.data);
	  }

	  debug('encoded %j as %s', obj, str);
	  return str;
	}

	/**
	 * Encode packet as 'buffer sequence' by removing blobs, and
	 * deconstructing packet into object with placeholders and
	 * a list of buffers.
	 *
	 * @param {Object} packet
	 * @return {Buffer} encoded
	 * @api private
	 */

	function encodeAsBinary(obj, callback) {

	  function writeEncoding(bloblessData) {
	    var deconstruction = binary.deconstructPacket(bloblessData);
	    var pack = encodeAsString(deconstruction.packet);
	    var buffers = deconstruction.buffers;

	    buffers.unshift(pack); // add packet info to beginning of data list
	    callback(buffers); // write all the buffers
	  }

	  binary.removeBlobs(obj, writeEncoding);
	}

	/**
	 * A socket.io Decoder instance
	 *
	 * @return {Object} decoder
	 * @api public
	 */

	function Decoder() {
	  this.reconstructor = null;
	}

	/**
	 * Mix in `Emitter` with Decoder.
	 */

	Emitter(Decoder.prototype);

	/**
	 * Decodes an ecoded packet string into packet JSON.
	 *
	 * @param {String} obj - encoded packet
	 * @return {Object} packet
	 * @api public
	 */

	Decoder.prototype.add = function(obj) {
	  var packet;
	  if ('string' == typeof obj) {
	    packet = decodeString(obj);
	    if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) { // binary packet's json
	      this.reconstructor = new BinaryReconstructor(packet);

	      // no attachments, labeled binary but no binary data to follow
	      if (this.reconstructor.reconPack.attachments === 0) {
	        this.emit('decoded', packet);
	      }
	    } else { // non-binary full packet
	      this.emit('decoded', packet);
	    }
	  }
	  else if (isBuf(obj) || obj.base64) { // raw binary data
	    if (!this.reconstructor) {
	      throw new Error('got binary data when not reconstructing a packet');
	    } else {
	      packet = this.reconstructor.takeBinaryData(obj);
	      if (packet) { // received final buffer
	        this.reconstructor = null;
	        this.emit('decoded', packet);
	      }
	    }
	  }
	  else {
	    throw new Error('Unknown type: ' + obj);
	  }
	};

	/**
	 * Decode a packet String (JSON data)
	 *
	 * @param {String} str
	 * @return {Object} packet
	 * @api private
	 */

	function decodeString(str) {
	  var p = {};
	  var i = 0;

	  // look up type
	  p.type = Number(str.charAt(0));
	  if (null == exports.types[p.type]) return error();

	  // look up attachments if type binary
	  if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {
	    var buf = '';
	    while (str.charAt(++i) != '-') {
	      buf += str.charAt(i);
	      if (i == str.length) break;
	    }
	    if (buf != Number(buf) || str.charAt(i) != '-') {
	      throw new Error('Illegal attachments');
	    }
	    p.attachments = Number(buf);
	  }

	  // look up namespace (if any)
	  if ('/' == str.charAt(i + 1)) {
	    p.nsp = '';
	    while (++i) {
	      var c = str.charAt(i);
	      if (',' == c) break;
	      p.nsp += c;
	      if (i == str.length) break;
	    }
	  } else {
	    p.nsp = '/';
	  }

	  // look up id
	  var next = str.charAt(i + 1);
	  if ('' !== next && Number(next) == next) {
	    p.id = '';
	    while (++i) {
	      var c = str.charAt(i);
	      if (null == c || Number(c) != c) {
	        --i;
	        break;
	      }
	      p.id += str.charAt(i);
	      if (i == str.length) break;
	    }
	    p.id = Number(p.id);
	  }

	  // look up json data
	  if (str.charAt(++i)) {
	    try {
	      p.data = json.parse(str.substr(i));
	    } catch(e){
	      return error();
	    }
	  }

	  debug('decoded %s as %j', str, p);
	  return p;
	}

	/**
	 * Deallocates a parser's resources
	 *
	 * @api public
	 */

	Decoder.prototype.destroy = function() {
	  if (this.reconstructor) {
	    this.reconstructor.finishedReconstruction();
	  }
	};

	/**
	 * A manager of a binary event's 'buffer sequence'. Should
	 * be constructed whenever a packet of type BINARY_EVENT is
	 * decoded.
	 *
	 * @param {Object} packet
	 * @return {BinaryReconstructor} initialized reconstructor
	 * @api private
	 */

	function BinaryReconstructor(packet) {
	  this.reconPack = packet;
	  this.buffers = [];
	}

	/**
	 * Method to be called when binary data received from connection
	 * after a BINARY_EVENT packet.
	 *
	 * @param {Buffer | ArrayBuffer} binData - the raw binary data received
	 * @return {null | Object} returns null if more binary data is expected or
	 *   a reconstructed packet object if all buffers have been received.
	 * @api private
	 */

	BinaryReconstructor.prototype.takeBinaryData = function(binData) {
	  this.buffers.push(binData);
	  if (this.buffers.length == this.reconPack.attachments) { // done with buffer list
	    var packet = binary.reconstructPacket(this.reconPack, this.buffers);
	    this.finishedReconstruction();
	    return packet;
	  }
	  return null;
	};

	/**
	 * Cleans up binary packet reconstruction variables.
	 *
	 * @api private
	 */

	BinaryReconstructor.prototype.finishedReconstruction = function() {
	  this.reconPack = null;
	  this.buffers = [];
	};

	function error(data){
	  return {
	    type: exports.ERROR,
	    data: 'parser error'
	  };
	}


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */
	;(function () {
	  // Detect the `define` function exposed by asynchronous module loaders. The
	  // strict `define` check is necessary for compatibility with `r.js`.
	  var isLoader = "function" === "function" && __webpack_require__(9);

	  // A set of types used to distinguish objects from primitives.
	  var objectTypes = {
	    "function": true,
	    "object": true
	  };

	  // Detect the `exports` object exposed by CommonJS implementations.
	  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

	  // Use the `global` object exposed by Node (including Browserify via
	  // `insert-module-globals`), Narwhal, and Ringo as the default context,
	  // and the `window` object in browsers. Rhino exports a `global` function
	  // instead.
	  var root = objectTypes[typeof window] && window || this,
	      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == "object" && global;

	  if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal || freeGlobal["self"] === freeGlobal)) {
	    root = freeGlobal;
	  }

	  // Public: Initializes JSON 3 using the given `context` object, attaching the
	  // `stringify` and `parse` functions to the specified `exports` object.
	  function runInContext(context, exports) {
	    context || (context = root["Object"]());
	    exports || (exports = root["Object"]());

	    // Native constructor aliases.
	    var Number = context["Number"] || root["Number"],
	        String = context["String"] || root["String"],
	        Object = context["Object"] || root["Object"],
	        Date = context["Date"] || root["Date"],
	        SyntaxError = context["SyntaxError"] || root["SyntaxError"],
	        TypeError = context["TypeError"] || root["TypeError"],
	        Math = context["Math"] || root["Math"],
	        nativeJSON = context["JSON"] || root["JSON"];

	    // Delegate to the native `stringify` and `parse` implementations.
	    if (typeof nativeJSON == "object" && nativeJSON) {
	      exports.stringify = nativeJSON.stringify;
	      exports.parse = nativeJSON.parse;
	    }

	    // Convenience aliases.
	    var objectProto = Object.prototype,
	        getClass = objectProto.toString,
	        isProperty, forEach, undef;

	    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
	    var isExtended = new Date(-3509827334573292);
	    try {
	      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
	      // results for certain dates in Opera >= 10.53.
	      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
	        // Safari < 2.0.2 stores the internal millisecond time value correctly,
	        // but clips the values returned by the date methods to the range of
	        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
	        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
	    } catch (exception) {}

	    // Internal: Determines whether the native `JSON.stringify` and `parse`
	    // implementations are spec-compliant. Based on work by Ken Snyder.
	    function has(name) {
	      if (has[name] !== undef) {
	        // Return cached feature test result.
	        return has[name];
	      }
	      var isSupported;
	      if (name == "bug-string-char-index") {
	        // IE <= 7 doesn't support accessing string characters using square
	        // bracket notation. IE 8 only supports this for primitives.
	        isSupported = "a"[0] != "a";
	      } else if (name == "json") {
	        // Indicates whether both `JSON.stringify` and `JSON.parse` are
	        // supported.
	        isSupported = has("json-stringify") && has("json-parse");
	      } else {
	        var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
	        // Test `JSON.stringify`.
	        if (name == "json-stringify") {
	          var stringify = exports.stringify, stringifySupported = typeof stringify == "function" && isExtended;
	          if (stringifySupported) {
	            // A test function object with a custom `toJSON` method.
	            (value = function () {
	              return 1;
	            }).toJSON = value;
	            try {
	              stringifySupported =
	                // Firefox 3.1b1 and b2 serialize string, number, and boolean
	                // primitives as object literals.
	                stringify(0) === "0" &&
	                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
	                // literals.
	                stringify(new Number()) === "0" &&
	                stringify(new String()) == '""' &&
	                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
	                // does not define a canonical JSON representation (this applies to
	                // objects with `toJSON` properties as well, *unless* they are nested
	                // within an object or array).
	                stringify(getClass) === undef &&
	                // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
	                // FF 3.1b3 pass this test.
	                stringify(undef) === undef &&
	                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
	                // respectively, if the value is omitted entirely.
	                stringify() === undef &&
	                // FF 3.1b1, 2 throw an error if the given value is not a number,
	                // string, array, object, Boolean, or `null` literal. This applies to
	                // objects with custom `toJSON` methods as well, unless they are nested
	                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
	                // methods entirely.
	                stringify(value) === "1" &&
	                stringify([value]) == "[1]" &&
	                // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
	                // `"[null]"`.
	                stringify([undef]) == "[null]" &&
	                // YUI 3.0.0b1 fails to serialize `null` literals.
	                stringify(null) == "null" &&
	                // FF 3.1b1, 2 halts serialization if an array contains a function:
	                // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
	                // elides non-JSON values from objects and arrays, unless they
	                // define custom `toJSON` methods.
	                stringify([undef, getClass, null]) == "[null,null,null]" &&
	                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
	                // where character escape codes are expected (e.g., `\b` => `\u0008`).
	                stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
	                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
	                stringify(null, value) === "1" &&
	                stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
	                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
	                // serialize extended years.
	                stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
	                // The milliseconds are optional in ES 5, but required in 5.1.
	                stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
	                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
	                // four-digit years instead of six-digit years. Credits: @Yaffle.
	                stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
	                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
	                // values less than 1000. Credits: @Yaffle.
	                stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
	            } catch (exception) {
	              stringifySupported = false;
	            }
	          }
	          isSupported = stringifySupported;
	        }
	        // Test `JSON.parse`.
	        if (name == "json-parse") {
	          var parse = exports.parse;
	          if (typeof parse == "function") {
	            try {
	              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
	              // Conforming implementations should also coerce the initial argument to
	              // a string prior to parsing.
	              if (parse("0") === 0 && !parse(false)) {
	                // Simple parsing test.
	                value = parse(serialized);
	                var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
	                if (parseSupported) {
	                  try {
	                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
	                    parseSupported = !parse('"\t"');
	                  } catch (exception) {}
	                  if (parseSupported) {
	                    try {
	                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading
	                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
	                      // certain octal literals.
	                      parseSupported = parse("01") !== 1;
	                    } catch (exception) {}
	                  }
	                  if (parseSupported) {
	                    try {
	                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
	                      // points. These environments, along with FF 3.1b1 and 2,
	                      // also allow trailing commas in JSON objects and arrays.
	                      parseSupported = parse("1.") !== 1;
	                    } catch (exception) {}
	                  }
	                }
	              }
	            } catch (exception) {
	              parseSupported = false;
	            }
	          }
	          isSupported = parseSupported;
	        }
	      }
	      return has[name] = !!isSupported;
	    }

	    if (!has("json")) {
	      // Common `[[Class]]` name aliases.
	      var functionClass = "[object Function]",
	          dateClass = "[object Date]",
	          numberClass = "[object Number]",
	          stringClass = "[object String]",
	          arrayClass = "[object Array]",
	          booleanClass = "[object Boolean]";

	      // Detect incomplete support for accessing string characters by index.
	      var charIndexBuggy = has("bug-string-char-index");

	      // Define additional utility methods if the `Date` methods are buggy.
	      if (!isExtended) {
	        var floor = Math.floor;
	        // A mapping between the months of the year and the number of days between
	        // January 1st and the first of the respective month.
	        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
	        // Internal: Calculates the number of days between the Unix epoch and the
	        // first day of the given month.
	        var getDay = function (year, month) {
	          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
	        };
	      }

	      // Internal: Determines if a property is a direct property of the given
	      // object. Delegates to the native `Object#hasOwnProperty` method.
	      if (!(isProperty = objectProto.hasOwnProperty)) {
	        isProperty = function (property) {
	          var members = {}, constructor;
	          if ((members.__proto__ = null, members.__proto__ = {
	            // The *proto* property cannot be set multiple times in recent
	            // versions of Firefox and SeaMonkey.
	            "toString": 1
	          }, members).toString != getClass) {
	            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
	            // supports the mutable *proto* property.
	            isProperty = function (property) {
	              // Capture and break the object's prototype chain (see section 8.6.2
	              // of the ES 5.1 spec). The parenthesized expression prevents an
	              // unsafe transformation by the Closure Compiler.
	              var original = this.__proto__, result = property in (this.__proto__ = null, this);
	              // Restore the original prototype chain.
	              this.__proto__ = original;
	              return result;
	            };
	          } else {
	            // Capture a reference to the top-level `Object` constructor.
	            constructor = members.constructor;
	            // Use the `constructor` property to simulate `Object#hasOwnProperty` in
	            // other environments.
	            isProperty = function (property) {
	              var parent = (this.constructor || constructor).prototype;
	              return property in this && !(property in parent && this[property] === parent[property]);
	            };
	          }
	          members = null;
	          return isProperty.call(this, property);
	        };
	      }

	      // Internal: Normalizes the `for...in` iteration algorithm across
	      // environments. Each enumerated key is yielded to a `callback` function.
	      forEach = function (object, callback) {
	        var size = 0, Properties, members, property;

	        // Tests for bugs in the current environment's `for...in` algorithm. The
	        // `valueOf` property inherits the non-enumerable flag from
	        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
	        (Properties = function () {
	          this.valueOf = 0;
	        }).prototype.valueOf = 0;

	        // Iterate over a new instance of the `Properties` class.
	        members = new Properties();
	        for (property in members) {
	          // Ignore all properties inherited from `Object.prototype`.
	          if (isProperty.call(members, property)) {
	            size++;
	          }
	        }
	        Properties = members = null;

	        // Normalize the iteration algorithm.
	        if (!size) {
	          // A list of non-enumerable properties inherited from `Object.prototype`.
	          members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
	          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
	          // properties.
	          forEach = function (object, callback) {
	            var isFunction = getClass.call(object) == functionClass, property, length;
	            var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;
	            for (property in object) {
	              // Gecko <= 1.0 enumerates the `prototype` property of functions under
	              // certain conditions; IE does not.
	              if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
	                callback(property);
	              }
	            }
	            // Manually invoke the callback for each non-enumerable property.
	            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
	          };
	        } else if (size == 2) {
	          // Safari <= 2.0.4 enumerates shadowed properties twice.
	          forEach = function (object, callback) {
	            // Create a set of iterated properties.
	            var members = {}, isFunction = getClass.call(object) == functionClass, property;
	            for (property in object) {
	              // Store each property name to prevent double enumeration. The
	              // `prototype` property of functions is not enumerated due to cross-
	              // environment inconsistencies.
	              if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
	                callback(property);
	              }
	            }
	          };
	        } else {
	          // No bugs detected; use the standard `for...in` algorithm.
	          forEach = function (object, callback) {
	            var isFunction = getClass.call(object) == functionClass, property, isConstructor;
	            for (property in object) {
	              if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
	                callback(property);
	              }
	            }
	            // Manually invoke the callback for the `constructor` property due to
	            // cross-environment inconsistencies.
	            if (isConstructor || isProperty.call(object, (property = "constructor"))) {
	              callback(property);
	            }
	          };
	        }
	        return forEach(object, callback);
	      };

	      // Public: Serializes a JavaScript `value` as a JSON string. The optional
	      // `filter` argument may specify either a function that alters how object and
	      // array members are serialized, or an array of strings and numbers that
	      // indicates which properties should be serialized. The optional `width`
	      // argument may be either a string or number that specifies the indentation
	      // level of the output.
	      if (!has("json-stringify")) {
	        // Internal: A map of control characters and their escaped equivalents.
	        var Escapes = {
	          92: "\\\\",
	          34: '\\"',
	          8: "\\b",
	          12: "\\f",
	          10: "\\n",
	          13: "\\r",
	          9: "\\t"
	        };

	        // Internal: Converts `value` into a zero-padded string such that its
	        // length is at least equal to `width`. The `width` must be <= 6.
	        var leadingZeroes = "000000";
	        var toPaddedString = function (width, value) {
	          // The `|| 0` expression is necessary to work around a bug in
	          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
	          return (leadingZeroes + (value || 0)).slice(-width);
	        };

	        // Internal: Double-quotes a string `value`, replacing all ASCII control
	        // characters (characters with code unit values between 0 and 31) with
	        // their escaped equivalents. This is an implementation of the
	        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
	        var unicodePrefix = "\\u00";
	        var quote = function (value) {
	          var result = '"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;
	          var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);
	          for (; index < length; index++) {
	            var charCode = value.charCodeAt(index);
	            // If the character is a control character, append its Unicode or
	            // shorthand escape sequence; otherwise, append the character as-is.
	            switch (charCode) {
	              case 8: case 9: case 10: case 12: case 13: case 34: case 92:
	                result += Escapes[charCode];
	                break;
	              default:
	                if (charCode < 32) {
	                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));
	                  break;
	                }
	                result += useCharIndex ? symbols[index] : value.charAt(index);
	            }
	          }
	          return result + '"';
	        };

	        // Internal: Recursively serializes an object. Implements the
	        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
	        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
	          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
	          try {
	            // Necessary for host object support.
	            value = object[property];
	          } catch (exception) {}
	          if (typeof value == "object" && value) {
	            className = getClass.call(value);
	            if (className == dateClass && !isProperty.call(value, "toJSON")) {
	              if (value > -1 / 0 && value < 1 / 0) {
	                // Dates are serialized according to the `Date#toJSON` method
	                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
	                // for the ISO 8601 date time string format.
	                if (getDay) {
	                  // Manually compute the year, month, date, hours, minutes,
	                  // seconds, and milliseconds if the `getUTC*` methods are
	                  // buggy. Adapted from @Yaffle's `date-shim` project.
	                  date = floor(value / 864e5);
	                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
	                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
	                  date = 1 + date - getDay(year, month);
	                  // The `time` value specifies the time within the day (see ES
	                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
	                  // to compute `A modulo B`, as the `%` operator does not
	                  // correspond to the `modulo` operation for negative numbers.
	                  time = (value % 864e5 + 864e5) % 864e5;
	                  // The hours, minutes, seconds, and milliseconds are obtained by
	                  // decomposing the time within the day. See section 15.9.1.10.
	                  hours = floor(time / 36e5) % 24;
	                  minutes = floor(time / 6e4) % 60;
	                  seconds = floor(time / 1e3) % 60;
	                  milliseconds = time % 1e3;
	                } else {
	                  year = value.getUTCFullYear();
	                  month = value.getUTCMonth();
	                  date = value.getUTCDate();
	                  hours = value.getUTCHours();
	                  minutes = value.getUTCMinutes();
	                  seconds = value.getUTCSeconds();
	                  milliseconds = value.getUTCMilliseconds();
	                }
	                // Serialize extended years correctly.
	                value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
	                  "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
	                  // Months, dates, hours, minutes, and seconds should have two
	                  // digits; milliseconds should have three.
	                  "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
	                  // Milliseconds are optional in ES 5.0, but required in 5.1.
	                  "." + toPaddedString(3, milliseconds) + "Z";
	              } else {
	                value = null;
	              }
	            } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
	              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
	              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
	              // ignores all `toJSON` methods on these objects unless they are
	              // defined directly on an instance.
	              value = value.toJSON(property);
	            }
	          }
	          if (callback) {
	            // If a replacement function was provided, call it to obtain the value
	            // for serialization.
	            value = callback.call(object, property, value);
	          }
	          if (value === null) {
	            return "null";
	          }
	          className = getClass.call(value);
	          if (className == booleanClass) {
	            // Booleans are represented literally.
	            return "" + value;
	          } else if (className == numberClass) {
	            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
	            // `"null"`.
	            return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
	          } else if (className == stringClass) {
	            // Strings are double-quoted and escaped.
	            return quote("" + value);
	          }
	          // Recursively serialize objects and arrays.
	          if (typeof value == "object") {
	            // Check for cyclic structures. This is a linear search; performance
	            // is inversely proportional to the number of unique nested objects.
	            for (length = stack.length; length--;) {
	              if (stack[length] === value) {
	                // Cyclic structures cannot be serialized by `JSON.stringify`.
	                throw TypeError();
	              }
	            }
	            // Add the object to the stack of traversed objects.
	            stack.push(value);
	            results = [];
	            // Save the current indentation level and indent one additional level.
	            prefix = indentation;
	            indentation += whitespace;
	            if (className == arrayClass) {
	              // Recursively serialize array elements.
	              for (index = 0, length = value.length; index < length; index++) {
	                element = serialize(index, value, callback, properties, whitespace, indentation, stack);
	                results.push(element === undef ? "null" : element);
	              }
	              result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
	            } else {
	              // Recursively serialize object members. Members are selected from
	              // either a user-specified list of property names, or the object
	              // itself.
	              forEach(properties || value, function (property) {
	                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
	                if (element !== undef) {
	                  // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
	                  // is not the empty string, let `member` {quote(property) + ":"}
	                  // be the concatenation of `member` and the `space` character."
	                  // The "`space` character" refers to the literal space
	                  // character, not the `space` {width} argument provided to
	                  // `JSON.stringify`.
	                  results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
	                }
	              });
	              result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
	            }
	            // Remove the object from the traversed object stack.
	            stack.pop();
	            return result;
	          }
	        };

	        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
	        exports.stringify = function (source, filter, width) {
	          var whitespace, callback, properties, className;
	          if (objectTypes[typeof filter] && filter) {
	            if ((className = getClass.call(filter)) == functionClass) {
	              callback = filter;
	            } else if (className == arrayClass) {
	              // Convert the property names array into a makeshift set.
	              properties = {};
	              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
	            }
	          }
	          if (width) {
	            if ((className = getClass.call(width)) == numberClass) {
	              // Convert the `width` to an integer and create a string containing
	              // `width` number of space characters.
	              if ((width -= width % 1) > 0) {
	                for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
	              }
	            } else if (className == stringClass) {
	              whitespace = width.length <= 10 ? width : width.slice(0, 10);
	            }
	          }
	          // Opera <= 7.54u2 discards the values associated with empty string keys
	          // (`""`) only if they are used directly within an object member list
	          // (e.g., `!("" in { "": 1})`).
	          return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
	        };
	      }

	      // Public: Parses a JSON source string.
	      if (!has("json-parse")) {
	        var fromCharCode = String.fromCharCode;

	        // Internal: A map of escaped control characters and their unescaped
	        // equivalents.
	        var Unescapes = {
	          92: "\\",
	          34: '"',
	          47: "/",
	          98: "\b",
	          116: "\t",
	          110: "\n",
	          102: "\f",
	          114: "\r"
	        };

	        // Internal: Stores the parser state.
	        var Index, Source;

	        // Internal: Resets the parser state and throws a `SyntaxError`.
	        var abort = function () {
	          Index = Source = null;
	          throw SyntaxError();
	        };

	        // Internal: Returns the next token, or `"$"` if the parser has reached
	        // the end of the source string. A token may be a string, number, `null`
	        // literal, or Boolean literal.
	        var lex = function () {
	          var source = Source, length = source.length, value, begin, position, isSigned, charCode;
	          while (Index < length) {
	            charCode = source.charCodeAt(Index);
	            switch (charCode) {
	              case 9: case 10: case 13: case 32:
	                // Skip whitespace tokens, including tabs, carriage returns, line
	                // feeds, and space characters.
	                Index++;
	                break;
	              case 123: case 125: case 91: case 93: case 58: case 44:
	                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
	                // the current position.
	                value = charIndexBuggy ? source.charAt(Index) : source[Index];
	                Index++;
	                return value;
	              case 34:
	                // `"` delimits a JSON string; advance to the next character and
	                // begin parsing the string. String tokens are prefixed with the
	                // sentinel `@` character to distinguish them from punctuators and
	                // end-of-string tokens.
	                for (value = "@", Index++; Index < length;) {
	                  charCode = source.charCodeAt(Index);
	                  if (charCode < 32) {
	                    // Unescaped ASCII control characters (those with a code unit
	                    // less than the space character) are not permitted.
	                    abort();
	                  } else if (charCode == 92) {
	                    // A reverse solidus (`\`) marks the beginning of an escaped
	                    // control character (including `"`, `\`, and `/`) or Unicode
	                    // escape sequence.
	                    charCode = source.charCodeAt(++Index);
	                    switch (charCode) {
	                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
	                        // Revive escaped control characters.
	                        value += Unescapes[charCode];
	                        Index++;
	                        break;
	                      case 117:
	                        // `\u` marks the beginning of a Unicode escape sequence.
	                        // Advance to the first character and validate the
	                        // four-digit code point.
	                        begin = ++Index;
	                        for (position = Index + 4; Index < position; Index++) {
	                          charCode = source.charCodeAt(Index);
	                          // A valid sequence comprises four hexdigits (case-
	                          // insensitive) that form a single hexadecimal value.
	                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
	                            // Invalid Unicode escape sequence.
	                            abort();
	                          }
	                        }
	                        // Revive the escaped character.
	                        value += fromCharCode("0x" + source.slice(begin, Index));
	                        break;
	                      default:
	                        // Invalid escape sequence.
	                        abort();
	                    }
	                  } else {
	                    if (charCode == 34) {
	                      // An unescaped double-quote character marks the end of the
	                      // string.
	                      break;
	                    }
	                    charCode = source.charCodeAt(Index);
	                    begin = Index;
	                    // Optimize for the common case where a string is valid.
	                    while (charCode >= 32 && charCode != 92 && charCode != 34) {
	                      charCode = source.charCodeAt(++Index);
	                    }
	                    // Append the string as-is.
	                    value += source.slice(begin, Index);
	                  }
	                }
	                if (source.charCodeAt(Index) == 34) {
	                  // Advance to the next character and return the revived string.
	                  Index++;
	                  return value;
	                }
	                // Unterminated string.
	                abort();
	              default:
	                // Parse numbers and literals.
	                begin = Index;
	                // Advance past the negative sign, if one is specified.
	                if (charCode == 45) {
	                  isSigned = true;
	                  charCode = source.charCodeAt(++Index);
	                }
	                // Parse an integer or floating-point value.
	                if (charCode >= 48 && charCode <= 57) {
	                  // Leading zeroes are interpreted as octal literals.
	                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
	                    // Illegal octal literal.
	                    abort();
	                  }
	                  isSigned = false;
	                  // Parse the integer component.
	                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
	                  // Floats cannot contain a leading decimal point; however, this
	                  // case is already accounted for by the parser.
	                  if (source.charCodeAt(Index) == 46) {
	                    position = ++Index;
	                    // Parse the decimal component.
	                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
	                    if (position == Index) {
	                      // Illegal trailing decimal.
	                      abort();
	                    }
	                    Index = position;
	                  }
	                  // Parse exponents. The `e` denoting the exponent is
	                  // case-insensitive.
	                  charCode = source.charCodeAt(Index);
	                  if (charCode == 101 || charCode == 69) {
	                    charCode = source.charCodeAt(++Index);
	                    // Skip past the sign following the exponent, if one is
	                    // specified.
	                    if (charCode == 43 || charCode == 45) {
	                      Index++;
	                    }
	                    // Parse the exponential component.
	                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
	                    if (position == Index) {
	                      // Illegal empty exponent.
	                      abort();
	                    }
	                    Index = position;
	                  }
	                  // Coerce the parsed value to a JavaScript number.
	                  return +source.slice(begin, Index);
	                }
	                // A negative sign may only precede numbers.
	                if (isSigned) {
	                  abort();
	                }
	                // `true`, `false`, and `null` literals.
	                if (source.slice(Index, Index + 4) == "true") {
	                  Index += 4;
	                  return true;
	                } else if (source.slice(Index, Index + 5) == "false") {
	                  Index += 5;
	                  return false;
	                } else if (source.slice(Index, Index + 4) == "null") {
	                  Index += 4;
	                  return null;
	                }
	                // Unrecognized token.
	                abort();
	            }
	          }
	          // Return the sentinel `$` character if the parser has reached the end
	          // of the source string.
	          return "$";
	        };

	        // Internal: Parses a JSON `value` token.
	        var get = function (value) {
	          var results, hasMembers;
	          if (value == "$") {
	            // Unexpected end of input.
	            abort();
	          }
	          if (typeof value == "string") {
	            if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
	              // Remove the sentinel `@` character.
	              return value.slice(1);
	            }
	            // Parse object and array literals.
	            if (value == "[") {
	              // Parses a JSON array, returning a new JavaScript array.
	              results = [];
	              for (;; hasMembers || (hasMembers = true)) {
	                value = lex();
	                // A closing square bracket marks the end of the array literal.
	                if (value == "]") {
	                  break;
	                }
	                // If the array literal contains elements, the current token
	                // should be a comma separating the previous element from the
	                // next.
	                if (hasMembers) {
	                  if (value == ",") {
	                    value = lex();
	                    if (value == "]") {
	                      // Unexpected trailing `,` in array literal.
	                      abort();
	                    }
	                  } else {
	                    // A `,` must separate each array element.
	                    abort();
	                  }
	                }
	                // Elisions and leading commas are not permitted.
	                if (value == ",") {
	                  abort();
	                }
	                results.push(get(value));
	              }
	              return results;
	            } else if (value == "{") {
	              // Parses a JSON object, returning a new JavaScript object.
	              results = {};
	              for (;; hasMembers || (hasMembers = true)) {
	                value = lex();
	                // A closing curly brace marks the end of the object literal.
	                if (value == "}") {
	                  break;
	                }
	                // If the object literal contains members, the current token
	                // should be a comma separator.
	                if (hasMembers) {
	                  if (value == ",") {
	                    value = lex();
	                    if (value == "}") {
	                      // Unexpected trailing `,` in object literal.
	                      abort();
	                    }
	                  } else {
	                    // A `,` must separate each object member.
	                    abort();
	                  }
	                }
	                // Leading commas are not permitted, object property names must be
	                // double-quoted strings, and a `:` must separate each property
	                // name and value.
	                if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
	                  abort();
	                }
	                results[value.slice(1)] = get(lex());
	              }
	              return results;
	            }
	            // Unexpected token encountered.
	            abort();
	          }
	          return value;
	        };

	        // Internal: Updates a traversed object member.
	        var update = function (source, property, callback) {
	          var element = walk(source, property, callback);
	          if (element === undef) {
	            delete source[property];
	          } else {
	            source[property] = element;
	          }
	        };

	        // Internal: Recursively traverses a parsed JSON object, invoking the
	        // `callback` function for each value. This is an implementation of the
	        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
	        var walk = function (source, property, callback) {
	          var value = source[property], length;
	          if (typeof value == "object" && value) {
	            // `forEach` can't be used to traverse an array in Opera <= 8.54
	            // because its `Object#hasOwnProperty` implementation returns `false`
	            // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
	            if (getClass.call(value) == arrayClass) {
	              for (length = value.length; length--;) {
	                update(value, length, callback);
	              }
	            } else {
	              forEach(value, function (property) {
	                update(value, property, callback);
	              });
	            }
	          }
	          return callback.call(source, property, value);
	        };

	        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
	        exports.parse = function (source, callback) {
	          var result, value;
	          Index = 0;
	          Source = "" + source;
	          result = get(lex());
	          // If a JSON string contains multiple tokens, it is invalid.
	          if (lex() != "$") {
	            abort();
	          }
	          // Reset the parser state.
	          Index = Source = null;
	          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
	        };
	      }
	    }

	    exports["runInContext"] = runInContext;
	    return exports;
	  }

	  if (freeExports && !isLoader) {
	    // Export for CommonJS environments.
	    runInContext(root, freeExports);
	  } else {
	    // Export for web browsers and JavaScript engines.
	    var nativeJSON = root.JSON,
	        previousJSON = root["JSON3"],
	        isRestored = false;

	    var JSON3 = runInContext(root, (root["JSON3"] = {
	      // Public: Restores the original value of the global `JSON` object and
	      // returns a reference to the `JSON3` object.
	      "noConflict": function () {
	        if (!isRestored) {
	          isRestored = true;
	          root.JSON = nativeJSON;
	          root["JSON3"] = previousJSON;
	          nativeJSON = previousJSON = null;
	        }
	        return JSON3;
	      }
	    }));

	    root.JSON = {
	      "parse": JSON3.parse,
	      "stringify": JSON3.stringify
	    };
	  }

	  // Export for asynchronous module loaders.
	  if (isLoader) {
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	      return JSON3;
	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	}).call(this);

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)(module), (function() { return this; }())))

/***/ },
/* 8 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 9 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {module.exports = __webpack_amd_options__;

	/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ },
/* 10 */
/***/ function(module, exports) {

	module.exports = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};


/***/ },
/* 11 */
/***/ function(module, exports) {

	
	/**
	 * Expose `Emitter`.
	 */

	module.exports = Emitter;

	/**
	 * Initialize a new `Emitter`.
	 *
	 * @api public
	 */

	function Emitter(obj) {
	  if (obj) return mixin(obj);
	};

	/**
	 * Mixin the emitter properties.
	 *
	 * @param {Object} obj
	 * @return {Object}
	 * @api private
	 */

	function mixin(obj) {
	  for (var key in Emitter.prototype) {
	    obj[key] = Emitter.prototype[key];
	  }
	  return obj;
	}

	/**
	 * Listen on the given `event` with `fn`.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */

	Emitter.prototype.on =
	Emitter.prototype.addEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};
	  (this._callbacks[event] = this._callbacks[event] || [])
	    .push(fn);
	  return this;
	};

	/**
	 * Adds an `event` listener that will be invoked a single
	 * time then automatically removed.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */

	Emitter.prototype.once = function(event, fn){
	  var self = this;
	  this._callbacks = this._callbacks || {};

	  function on() {
	    self.off(event, on);
	    fn.apply(this, arguments);
	  }

	  on.fn = fn;
	  this.on(event, on);
	  return this;
	};

	/**
	 * Remove the given callback for `event` or all
	 * registered callbacks.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */

	Emitter.prototype.off =
	Emitter.prototype.removeListener =
	Emitter.prototype.removeAllListeners =
	Emitter.prototype.removeEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};

	  // all
	  if (0 == arguments.length) {
	    this._callbacks = {};
	    return this;
	  }

	  // specific event
	  var callbacks = this._callbacks[event];
	  if (!callbacks) return this;

	  // remove all handlers
	  if (1 == arguments.length) {
	    delete this._callbacks[event];
	    return this;
	  }

	  // remove specific handler
	  var cb;
	  for (var i = 0; i < callbacks.length; i++) {
	    cb = callbacks[i];
	    if (cb === fn || cb.fn === fn) {
	      callbacks.splice(i, 1);
	      break;
	    }
	  }
	  return this;
	};

	/**
	 * Emit `event` with the given args.
	 *
	 * @param {String} event
	 * @param {Mixed} ...
	 * @return {Emitter}
	 */

	Emitter.prototype.emit = function(event){
	  this._callbacks = this._callbacks || {};
	  var args = [].slice.call(arguments, 1)
	    , callbacks = this._callbacks[event];

	  if (callbacks) {
	    callbacks = callbacks.slice(0);
	    for (var i = 0, len = callbacks.length; i < len; ++i) {
	      callbacks[i].apply(this, args);
	    }
	  }

	  return this;
	};

	/**
	 * Return array of callbacks for `event`.
	 *
	 * @param {String} event
	 * @return {Array}
	 * @api public
	 */

	Emitter.prototype.listeners = function(event){
	  this._callbacks = this._callbacks || {};
	  return this._callbacks[event] || [];
	};

	/**
	 * Check if this emitter has `event` handlers.
	 *
	 * @param {String} event
	 * @return {Boolean}
	 * @api public
	 */

	Emitter.prototype.hasListeners = function(event){
	  return !! this.listeners(event).length;
	};


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/*global Blob,File*/

	/**
	 * Module requirements
	 */

	var isArray = __webpack_require__(10);
	var isBuf = __webpack_require__(13);

	/**
	 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
	 * Anything with blobs or files should be fed through removeBlobs before coming
	 * here.
	 *
	 * @param {Object} packet - socket.io event packet
	 * @return {Object} with deconstructed packet and list of buffers
	 * @api public
	 */

	exports.deconstructPacket = function(packet){
	  var buffers = [];
	  var packetData = packet.data;

	  function _deconstructPacket(data) {
	    if (!data) return data;

	    if (isBuf(data)) {
	      var placeholder = { _placeholder: true, num: buffers.length };
	      buffers.push(data);
	      return placeholder;
	    } else if (isArray(data)) {
	      var newData = new Array(data.length);
	      for (var i = 0; i < data.length; i++) {
	        newData[i] = _deconstructPacket(data[i]);
	      }
	      return newData;
	    } else if ('object' == typeof data && !(data instanceof Date)) {
	      var newData = {};
	      for (var key in data) {
	        newData[key] = _deconstructPacket(data[key]);
	      }
	      return newData;
	    }
	    return data;
	  }

	  var pack = packet;
	  pack.data = _deconstructPacket(packetData);
	  pack.attachments = buffers.length; // number of binary 'attachments'
	  return {packet: pack, buffers: buffers};
	};

	/**
	 * Reconstructs a binary packet from its placeholder packet and buffers
	 *
	 * @param {Object} packet - event packet with placeholders
	 * @param {Array} buffers - binary buffers to put in placeholder positions
	 * @return {Object} reconstructed packet
	 * @api public
	 */

	exports.reconstructPacket = function(packet, buffers) {
	  var curPlaceHolder = 0;

	  function _reconstructPacket(data) {
	    if (data && data._placeholder) {
	      var buf = buffers[data.num]; // appropriate buffer (should be natural order anyway)
	      return buf;
	    } else if (isArray(data)) {
	      for (var i = 0; i < data.length; i++) {
	        data[i] = _reconstructPacket(data[i]);
	      }
	      return data;
	    } else if (data && 'object' == typeof data) {
	      for (var key in data) {
	        data[key] = _reconstructPacket(data[key]);
	      }
	      return data;
	    }
	    return data;
	  }

	  packet.data = _reconstructPacket(packet.data);
	  packet.attachments = undefined; // no longer useful
	  return packet;
	};

	/**
	 * Asynchronously removes Blobs or Files from data via
	 * FileReader's readAsArrayBuffer method. Used before encoding
	 * data as msgpack. Calls callback with the blobless data.
	 *
	 * @param {Object} data
	 * @param {Function} callback
	 * @api private
	 */

	exports.removeBlobs = function(data, callback) {
	  function _removeBlobs(obj, curKey, containingObject) {
	    if (!obj) return obj;

	    // convert any blob
	    if ((global.Blob && obj instanceof Blob) ||
	        (global.File && obj instanceof File)) {
	      pendingBlobs++;

	      // async filereader
	      var fileReader = new FileReader();
	      fileReader.onload = function() { // this.result == arraybuffer
	        if (containingObject) {
	          containingObject[curKey] = this.result;
	        }
	        else {
	          bloblessData = this.result;
	        }

	        // if nothing pending its callback time
	        if(! --pendingBlobs) {
	          callback(bloblessData);
	        }
	      };

	      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
	    } else if (isArray(obj)) { // handle array
	      for (var i = 0; i < obj.length; i++) {
	        _removeBlobs(obj[i], i, obj);
	      }
	    } else if (obj && 'object' == typeof obj && !isBuf(obj)) { // and object
	      for (var key in obj) {
	        _removeBlobs(obj[key], key, obj);
	      }
	    }
	  }

	  var pendingBlobs = 0;
	  var bloblessData = data;
	  _removeBlobs(bloblessData);
	  if (!pendingBlobs) {
	    callback(bloblessData);
	  }
	};

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 13 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {
	module.exports = isBuf;

	/**
	 * Returns true if obj is a buffer or an arraybuffer.
	 *
	 * @api private
	 */

	function isBuf(obj) {
	  return (global.Buffer && global.Buffer.isBuffer(obj)) ||
	         (global.ArrayBuffer && obj instanceof ArrayBuffer);
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	/**
	 * Module dependencies.
	 */

	var eio = __webpack_require__(15);
	var Socket = __webpack_require__(42);
	var Emitter = __webpack_require__(43);
	var parser = __webpack_require__(6);
	var on = __webpack_require__(45);
	var bind = __webpack_require__(46);
	var debug = __webpack_require__(3)('socket.io-client:manager');
	var indexOf = __webpack_require__(40);
	var Backoff = __webpack_require__(49);

	/**
	 * IE6+ hasOwnProperty
	 */

	var has = Object.prototype.hasOwnProperty;

	/**
	 * Module exports
	 */

	module.exports = Manager;

	/**
	 * `Manager` constructor.
	 *
	 * @param {String} engine instance or engine uri/opts
	 * @param {Object} options
	 * @api public
	 */

	function Manager(uri, opts) {
	  if (!(this instanceof Manager)) return new Manager(uri, opts);
	  if (uri && 'object' === (typeof uri === 'undefined' ? 'undefined' : _typeof(uri))) {
	    opts = uri;
	    uri = undefined;
	  }
	  opts = opts || {};

	  opts.path = opts.path || '/socket.io';
	  this.nsps = {};
	  this.subs = [];
	  this.opts = opts;
	  this.reconnection(opts.reconnection !== false);
	  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
	  this.reconnectionDelay(opts.reconnectionDelay || 1000);
	  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
	  this.randomizationFactor(opts.randomizationFactor || 0.5);
	  this.backoff = new Backoff({
	    min: this.reconnectionDelay(),
	    max: this.reconnectionDelayMax(),
	    jitter: this.randomizationFactor()
	  });
	  this.timeout(null == opts.timeout ? 20000 : opts.timeout);
	  this.readyState = 'closed';
	  this.uri = uri;
	  this.connecting = [];
	  this.lastPing = null;
	  this.encoding = false;
	  this.packetBuffer = [];
	  this.encoder = new parser.Encoder();
	  this.decoder = new parser.Decoder();
	  this.autoConnect = opts.autoConnect !== false;
	  if (this.autoConnect) this.open();
	}

	/**
	 * Propagate given event to sockets and emit on `this`
	 *
	 * @api private
	 */

	Manager.prototype.emitAll = function () {
	  this.emit.apply(this, arguments);
	  for (var nsp in this.nsps) {
	    if (has.call(this.nsps, nsp)) {
	      this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
	    }
	  }
	};

	/**
	 * Update `socket.id` of all sockets
	 *
	 * @api private
	 */

	Manager.prototype.updateSocketIds = function () {
	  for (var nsp in this.nsps) {
	    if (has.call(this.nsps, nsp)) {
	      this.nsps[nsp].id = this.engine.id;
	    }
	  }
	};

	/**
	 * Mix in `Emitter`.
	 */

	Emitter(Manager.prototype);

	/**
	 * Sets the `reconnection` config.
	 *
	 * @param {Boolean} true/false if it should automatically reconnect
	 * @return {Manager} self or value
	 * @api public
	 */

	Manager.prototype.reconnection = function (v) {
	  if (!arguments.length) return this._reconnection;
	  this._reconnection = !!v;
	  return this;
	};

	/**
	 * Sets the reconnection attempts config.
	 *
	 * @param {Number} max reconnection attempts before giving up
	 * @return {Manager} self or value
	 * @api public
	 */

	Manager.prototype.reconnectionAttempts = function (v) {
	  if (!arguments.length) return this._reconnectionAttempts;
	  this._reconnectionAttempts = v;
	  return this;
	};

	/**
	 * Sets the delay between reconnections.
	 *
	 * @param {Number} delay
	 * @return {Manager} self or value
	 * @api public
	 */

	Manager.prototype.reconnectionDelay = function (v) {
	  if (!arguments.length) return this._reconnectionDelay;
	  this._reconnectionDelay = v;
	  this.backoff && this.backoff.setMin(v);
	  return this;
	};

	Manager.prototype.randomizationFactor = function (v) {
	  if (!arguments.length) return this._randomizationFactor;
	  this._randomizationFactor = v;
	  this.backoff && this.backoff.setJitter(v);
	  return this;
	};

	/**
	 * Sets the maximum delay between reconnections.
	 *
	 * @param {Number} delay
	 * @return {Manager} self or value
	 * @api public
	 */

	Manager.prototype.reconnectionDelayMax = function (v) {
	  if (!arguments.length) return this._reconnectionDelayMax;
	  this._reconnectionDelayMax = v;
	  this.backoff && this.backoff.setMax(v);
	  return this;
	};

	/**
	 * Sets the connection timeout. `false` to disable
	 *
	 * @return {Manager} self or value
	 * @api public
	 */

	Manager.prototype.timeout = function (v) {
	  if (!arguments.length) return this._timeout;
	  this._timeout = v;
	  return this;
	};

	/**
	 * Starts trying to reconnect if reconnection is enabled and we have not
	 * started reconnecting yet
	 *
	 * @api private
	 */

	Manager.prototype.maybeReconnectOnOpen = function () {
	  // Only try to reconnect if it's the first time we're connecting
	  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
	    // keeps reconnection from firing twice for the same reconnection loop
	    this.reconnect();
	  }
	};

	/**
	 * Sets the current transport `socket`.
	 *
	 * @param {Function} optional, callback
	 * @return {Manager} self
	 * @api public
	 */

	Manager.prototype.open = Manager.prototype.connect = function (fn, opts) {
	  debug('readyState %s', this.readyState);
	  if (~this.readyState.indexOf('open')) return this;

	  debug('opening %s', this.uri);
	  this.engine = eio(this.uri, this.opts);
	  var socket = this.engine;
	  var self = this;
	  this.readyState = 'opening';
	  this.skipReconnect = false;

	  // emit `open`
	  var openSub = on(socket, 'open', function () {
	    self.onopen();
	    fn && fn();
	  });

	  // emit `connect_error`
	  var errorSub = on(socket, 'error', function (data) {
	    debug('connect_error');
	    self.cleanup();
	    self.readyState = 'closed';
	    self.emitAll('connect_error', data);
	    if (fn) {
	      var err = new Error('Connection error');
	      err.data = data;
	      fn(err);
	    } else {
	      // Only do this if there is no fn to handle the error
	      self.maybeReconnectOnOpen();
	    }
	  });

	  // emit `connect_timeout`
	  if (false !== this._timeout) {
	    var timeout = this._timeout;
	    debug('connect attempt will timeout after %d', timeout);

	    // set timer
	    var timer = setTimeout(function () {
	      debug('connect attempt timed out after %d', timeout);
	      openSub.destroy();
	      socket.close();
	      socket.emit('error', 'timeout');
	      self.emitAll('connect_timeout', timeout);
	    }, timeout);

	    this.subs.push({
	      destroy: function destroy() {
	        clearTimeout(timer);
	      }
	    });
	  }

	  this.subs.push(openSub);
	  this.subs.push(errorSub);

	  return this;
	};

	/**
	 * Called upon transport open.
	 *
	 * @api private
	 */

	Manager.prototype.onopen = function () {
	  debug('open');

	  // clear old subs
	  this.cleanup();

	  // mark as open
	  this.readyState = 'open';
	  this.emit('open');

	  // add new subs
	  var socket = this.engine;
	  this.subs.push(on(socket, 'data', bind(this, 'ondata')));
	  this.subs.push(on(socket, 'ping', bind(this, 'onping')));
	  this.subs.push(on(socket, 'pong', bind(this, 'onpong')));
	  this.subs.push(on(socket, 'error', bind(this, 'onerror')));
	  this.subs.push(on(socket, 'close', bind(this, 'onclose')));
	  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));
	};

	/**
	 * Called upon a ping.
	 *
	 * @api private
	 */

	Manager.prototype.onping = function () {
	  this.lastPing = new Date();
	  this.emitAll('ping');
	};

	/**
	 * Called upon a packet.
	 *
	 * @api private
	 */

	Manager.prototype.onpong = function () {
	  this.emitAll('pong', new Date() - this.lastPing);
	};

	/**
	 * Called with data.
	 *
	 * @api private
	 */

	Manager.prototype.ondata = function (data) {
	  this.decoder.add(data);
	};

	/**
	 * Called when parser fully decodes a packet.
	 *
	 * @api private
	 */

	Manager.prototype.ondecoded = function (packet) {
	  this.emit('packet', packet);
	};

	/**
	 * Called upon socket error.
	 *
	 * @api private
	 */

	Manager.prototype.onerror = function (err) {
	  debug('error', err);
	  this.emitAll('error', err);
	};

	/**
	 * Creates a new socket for the given `nsp`.
	 *
	 * @return {Socket}
	 * @api public
	 */

	Manager.prototype.socket = function (nsp, opts) {
	  var socket = this.nsps[nsp];
	  if (!socket) {
	    socket = new Socket(this, nsp, opts);
	    this.nsps[nsp] = socket;
	    var self = this;
	    socket.on('connecting', onConnecting);
	    socket.on('connect', function () {
	      socket.id = self.engine.id;
	    });

	    if (this.autoConnect) {
	      // manually call here since connecting evnet is fired before listening
	      onConnecting();
	    }
	  }

	  function onConnecting() {
	    if (!~indexOf(self.connecting, socket)) {
	      self.connecting.push(socket);
	    }
	  }

	  return socket;
	};

	/**
	 * Called upon a socket close.
	 *
	 * @param {Socket} socket
	 */

	Manager.prototype.destroy = function (socket) {
	  var index = indexOf(this.connecting, socket);
	  if (~index) this.connecting.splice(index, 1);
	  if (this.connecting.length) return;

	  this.close();
	};

	/**
	 * Writes a packet.
	 *
	 * @param {Object} packet
	 * @api private
	 */

	Manager.prototype.packet = function (packet) {
	  debug('writing packet %j', packet);
	  var self = this;
	  if (packet.query && packet.type === 0) packet.nsp += '?' + packet.query;

	  if (!self.encoding) {
	    // encode, then write to engine with result
	    self.encoding = true;
	    this.encoder.encode(packet, function (encodedPackets) {
	      for (var i = 0; i < encodedPackets.length; i++) {
	        self.engine.write(encodedPackets[i], packet.options);
	      }
	      self.encoding = false;
	      self.processPacketQueue();
	    });
	  } else {
	    // add packet to the queue
	    self.packetBuffer.push(packet);
	  }
	};

	/**
	 * If packet buffer is non-empty, begins encoding the
	 * next packet in line.
	 *
	 * @api private
	 */

	Manager.prototype.processPacketQueue = function () {
	  if (this.packetBuffer.length > 0 && !this.encoding) {
	    var pack = this.packetBuffer.shift();
	    this.packet(pack);
	  }
	};

	/**
	 * Clean up transport subscriptions and packet buffer.
	 *
	 * @api private
	 */

	Manager.prototype.cleanup = function () {
	  debug('cleanup');

	  var subsLength = this.subs.length;
	  for (var i = 0; i < subsLength; i++) {
	    var sub = this.subs.shift();
	    sub.destroy();
	  }

	  this.packetBuffer = [];
	  this.encoding = false;
	  this.lastPing = null;

	  this.decoder.destroy();
	};

	/**
	 * Close the current socket.
	 *
	 * @api private
	 */

	Manager.prototype.close = Manager.prototype.disconnect = function () {
	  debug('disconnect');
	  this.skipReconnect = true;
	  this.reconnecting = false;
	  if ('opening' === this.readyState) {
	    // `onclose` will not fire because
	    // an open event never happened
	    this.cleanup();
	  }
	  this.backoff.reset();
	  this.readyState = 'closed';
	  if (this.engine) this.engine.close();
	};

	/**
	 * Called upon engine close.
	 *
	 * @api private
	 */

	Manager.prototype.onclose = function (reason) {
	  debug('onclose');

	  this.cleanup();
	  this.backoff.reset();
	  this.readyState = 'closed';
	  this.emit('close', reason);

	  if (this._reconnection && !this.skipReconnect) {
	    this.reconnect();
	  }
	};

	/**
	 * Attempt a reconnection.
	 *
	 * @api private
	 */

	Manager.prototype.reconnect = function () {
	  if (this.reconnecting || this.skipReconnect) return this;

	  var self = this;

	  if (this.backoff.attempts >= this._reconnectionAttempts) {
	    debug('reconnect failed');
	    this.backoff.reset();
	    this.emitAll('reconnect_failed');
	    this.reconnecting = false;
	  } else {
	    var delay = this.backoff.duration();
	    debug('will wait %dms before reconnect attempt', delay);

	    this.reconnecting = true;
	    var timer = setTimeout(function () {
	      if (self.skipReconnect) return;

	      debug('attempting reconnect');
	      self.emitAll('reconnect_attempt', self.backoff.attempts);
	      self.emitAll('reconnecting', self.backoff.attempts);

	      // check again for the case socket closed in above events
	      if (self.skipReconnect) return;

	      self.open(function (err) {
	        if (err) {
	          debug('reconnect attempt error');
	          self.reconnecting = false;
	          self.reconnect();
	          self.emitAll('reconnect_error', err.data);
	        } else {
	          debug('reconnect success');
	          self.onreconnect();
	        }
	      });
	    }, delay);

	    this.subs.push({
	      destroy: function destroy() {
	        clearTimeout(timer);
	      }
	    });
	  }
	};

	/**
	 * Called upon successful reconnect.
	 *
	 * @api private
	 */

	Manager.prototype.onreconnect = function () {
	  var attempt = this.backoff.attempts;
	  this.reconnecting = false;
	  this.backoff.reset();
	  this.updateSocketIds();
	  this.emitAll('reconnect', attempt);
	};

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	
	module.exports =  __webpack_require__(16);


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	
	module.exports = __webpack_require__(17);

	/**
	 * Exports parser
	 *
	 * @api public
	 *
	 */
	module.exports.parser = __webpack_require__(24);


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Module dependencies.
	 */

	var transports = __webpack_require__(18);
	var Emitter = __webpack_require__(33);
	var debug = __webpack_require__(3)('engine.io-client:socket');
	var index = __webpack_require__(40);
	var parser = __webpack_require__(24);
	var parseuri = __webpack_require__(2);
	var parsejson = __webpack_require__(41);
	var parseqs = __webpack_require__(34);

	/**
	 * Module exports.
	 */

	module.exports = Socket;

	/**
	 * Noop function.
	 *
	 * @api private
	 */

	function noop(){}

	/**
	 * Socket constructor.
	 *
	 * @param {String|Object} uri or options
	 * @param {Object} options
	 * @api public
	 */

	function Socket(uri, opts){
	  if (!(this instanceof Socket)) return new Socket(uri, opts);

	  opts = opts || {};

	  if (uri && 'object' == typeof uri) {
	    opts = uri;
	    uri = null;
	  }

	  if (uri) {
	    uri = parseuri(uri);
	    opts.hostname = uri.host;
	    opts.secure = uri.protocol == 'https' || uri.protocol == 'wss';
	    opts.port = uri.port;
	    if (uri.query) opts.query = uri.query;
	  } else if (opts.host) {
	    opts.hostname = parseuri(opts.host).host;
	  }

	  this.secure = null != opts.secure ? opts.secure :
	    (global.location && 'https:' == location.protocol);

	  if (opts.hostname && !opts.port) {
	    // if no port is specified manually, use the protocol default
	    opts.port = this.secure ? '443' : '80';
	  }

	  this.agent = opts.agent || false;
	  this.hostname = opts.hostname ||
	    (global.location ? location.hostname : 'localhost');
	  this.port = opts.port || (global.location && location.port ?
	       location.port :
	       (this.secure ? 443 : 80));
	  this.query = opts.query || {};
	  if ('string' == typeof this.query) this.query = parseqs.decode(this.query);
	  this.upgrade = false !== opts.upgrade;
	  this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
	  this.forceJSONP = !!opts.forceJSONP;
	  this.jsonp = false !== opts.jsonp;
	  this.forceBase64 = !!opts.forceBase64;
	  this.enablesXDR = !!opts.enablesXDR;
	  this.timestampParam = opts.timestampParam || 't';
	  this.timestampRequests = opts.timestampRequests;
	  this.transports = opts.transports || ['polling', 'websocket'];
	  this.readyState = '';
	  this.writeBuffer = [];
	  this.policyPort = opts.policyPort || 843;
	  this.rememberUpgrade = opts.rememberUpgrade || false;
	  this.binaryType = null;
	  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
	  this.perMessageDeflate = false !== opts.perMessageDeflate ? (opts.perMessageDeflate || {}) : false;

	  if (true === this.perMessageDeflate) this.perMessageDeflate = {};
	  if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {
	    this.perMessageDeflate.threshold = 1024;
	  }

	  // SSL options for Node.js client
	  this.pfx = opts.pfx || null;
	  this.key = opts.key || null;
	  this.passphrase = opts.passphrase || null;
	  this.cert = opts.cert || null;
	  this.ca = opts.ca || null;
	  this.ciphers = opts.ciphers || null;
	  this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? true : opts.rejectUnauthorized;

	  // other options for Node.js client
	  var freeGlobal = typeof global == 'object' && global;
	  if (freeGlobal.global === freeGlobal) {
	    if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {
	      this.extraHeaders = opts.extraHeaders;
	    }
	  }

	  this.open();
	}

	Socket.priorWebsocketSuccess = false;

	/**
	 * Mix in `Emitter`.
	 */

	Emitter(Socket.prototype);

	/**
	 * Protocol version.
	 *
	 * @api public
	 */

	Socket.protocol = parser.protocol; // this is an int

	/**
	 * Expose deps for legacy compatibility
	 * and standalone browser access.
	 */

	Socket.Socket = Socket;
	Socket.Transport = __webpack_require__(23);
	Socket.transports = __webpack_require__(18);
	Socket.parser = __webpack_require__(24);

	/**
	 * Creates transport of the given type.
	 *
	 * @param {String} transport name
	 * @return {Transport}
	 * @api private
	 */

	Socket.prototype.createTransport = function (name) {
	  debug('creating transport "%s"', name);
	  var query = clone(this.query);

	  // append engine.io protocol identifier
	  query.EIO = parser.protocol;

	  // transport name
	  query.transport = name;

	  // session id if we already have one
	  if (this.id) query.sid = this.id;

	  var transport = new transports[name]({
	    agent: this.agent,
	    hostname: this.hostname,
	    port: this.port,
	    secure: this.secure,
	    path: this.path,
	    query: query,
	    forceJSONP: this.forceJSONP,
	    jsonp: this.jsonp,
	    forceBase64: this.forceBase64,
	    enablesXDR: this.enablesXDR,
	    timestampRequests: this.timestampRequests,
	    timestampParam: this.timestampParam,
	    policyPort: this.policyPort,
	    socket: this,
	    pfx: this.pfx,
	    key: this.key,
	    passphrase: this.passphrase,
	    cert: this.cert,
	    ca: this.ca,
	    ciphers: this.ciphers,
	    rejectUnauthorized: this.rejectUnauthorized,
	    perMessageDeflate: this.perMessageDeflate,
	    extraHeaders: this.extraHeaders
	  });

	  return transport;
	};

	function clone (obj) {
	  var o = {};
	  for (var i in obj) {
	    if (obj.hasOwnProperty(i)) {
	      o[i] = obj[i];
	    }
	  }
	  return o;
	}

	/**
	 * Initializes transport to use and starts probe.
	 *
	 * @api private
	 */
	Socket.prototype.open = function () {
	  var transport;
	  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') != -1) {
	    transport = 'websocket';
	  } else if (0 === this.transports.length) {
	    // Emit error on next tick so it can be listened to
	    var self = this;
	    setTimeout(function() {
	      self.emit('error', 'No transports available');
	    }, 0);
	    return;
	  } else {
	    transport = this.transports[0];
	  }
	  this.readyState = 'opening';

	  // Retry with the next transport if the transport is disabled (jsonp: false)
	  try {
	    transport = this.createTransport(transport);
	  } catch (e) {
	    this.transports.shift();
	    this.open();
	    return;
	  }

	  transport.open();
	  this.setTransport(transport);
	};

	/**
	 * Sets the current transport. Disables the existing one (if any).
	 *
	 * @api private
	 */

	Socket.prototype.setTransport = function(transport){
	  debug('setting transport %s', transport.name);
	  var self = this;

	  if (this.transport) {
	    debug('clearing existing transport %s', this.transport.name);
	    this.transport.removeAllListeners();
	  }

	  // set up transport
	  this.transport = transport;

	  // set up transport listeners
	  transport
	  .on('drain', function(){
	    self.onDrain();
	  })
	  .on('packet', function(packet){
	    self.onPacket(packet);
	  })
	  .on('error', function(e){
	    self.onError(e);
	  })
	  .on('close', function(){
	    self.onClose('transport close');
	  });
	};

	/**
	 * Probes a transport.
	 *
	 * @param {String} transport name
	 * @api private
	 */

	Socket.prototype.probe = function (name) {
	  debug('probing transport "%s"', name);
	  var transport = this.createTransport(name, { probe: 1 })
	    , failed = false
	    , self = this;

	  Socket.priorWebsocketSuccess = false;

	  function onTransportOpen(){
	    if (self.onlyBinaryUpgrades) {
	      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
	      failed = failed || upgradeLosesBinary;
	    }
	    if (failed) return;

	    debug('probe transport "%s" opened', name);
	    transport.send([{ type: 'ping', data: 'probe' }]);
	    transport.once('packet', function (msg) {
	      if (failed) return;
	      if ('pong' == msg.type && 'probe' == msg.data) {
	        debug('probe transport "%s" pong', name);
	        self.upgrading = true;
	        self.emit('upgrading', transport);
	        if (!transport) return;
	        Socket.priorWebsocketSuccess = 'websocket' == transport.name;

	        debug('pausing current transport "%s"', self.transport.name);
	        self.transport.pause(function () {
	          if (failed) return;
	          if ('closed' == self.readyState) return;
	          debug('changing transport and sending upgrade packet');

	          cleanup();

	          self.setTransport(transport);
	          transport.send([{ type: 'upgrade' }]);
	          self.emit('upgrade', transport);
	          transport = null;
	          self.upgrading = false;
	          self.flush();
	        });
	      } else {
	        debug('probe transport "%s" failed', name);
	        var err = new Error('probe error');
	        err.transport = transport.name;
	        self.emit('upgradeError', err);
	      }
	    });
	  }

	  function freezeTransport() {
	    if (failed) return;

	    // Any callback called by transport should be ignored since now
	    failed = true;

	    cleanup();

	    transport.close();
	    transport = null;
	  }

	  //Handle any error that happens while probing
	  function onerror(err) {
	    var error = new Error('probe error: ' + err);
	    error.transport = transport.name;

	    freezeTransport();

	    debug('probe transport "%s" failed because of error: %s', name, err);

	    self.emit('upgradeError', error);
	  }

	  function onTransportClose(){
	    onerror("transport closed");
	  }

	  //When the socket is closed while we're probing
	  function onclose(){
	    onerror("socket closed");
	  }

	  //When the socket is upgraded while we're probing
	  function onupgrade(to){
	    if (transport && to.name != transport.name) {
	      debug('"%s" works - aborting "%s"', to.name, transport.name);
	      freezeTransport();
	    }
	  }

	  //Remove all listeners on the transport and on self
	  function cleanup(){
	    transport.removeListener('open', onTransportOpen);
	    transport.removeListener('error', onerror);
	    transport.removeListener('close', onTransportClose);
	    self.removeListener('close', onclose);
	    self.removeListener('upgrading', onupgrade);
	  }

	  transport.once('open', onTransportOpen);
	  transport.once('error', onerror);
	  transport.once('close', onTransportClose);

	  this.once('close', onclose);
	  this.once('upgrading', onupgrade);

	  transport.open();

	};

	/**
	 * Called when connection is deemed open.
	 *
	 * @api public
	 */

	Socket.prototype.onOpen = function () {
	  debug('socket open');
	  this.readyState = 'open';
	  Socket.priorWebsocketSuccess = 'websocket' == this.transport.name;
	  this.emit('open');
	  this.flush();

	  // we check for `readyState` in case an `open`
	  // listener already closed the socket
	  if ('open' == this.readyState && this.upgrade && this.transport.pause) {
	    debug('starting upgrade probes');
	    for (var i = 0, l = this.upgrades.length; i < l; i++) {
	      this.probe(this.upgrades[i]);
	    }
	  }
	};

	/**
	 * Handles a packet.
	 *
	 * @api private
	 */

	Socket.prototype.onPacket = function (packet) {
	  if ('opening' == this.readyState || 'open' == this.readyState) {
	    debug('socket receive: type "%s", data "%s"', packet.type, packet.data);

	    this.emit('packet', packet);

	    // Socket is live - any packet counts
	    this.emit('heartbeat');

	    switch (packet.type) {
	      case 'open':
	        this.onHandshake(parsejson(packet.data));
	        break;

	      case 'pong':
	        this.setPing();
	        this.emit('pong');
	        break;

	      case 'error':
	        var err = new Error('server error');
	        err.code = packet.data;
	        this.onError(err);
	        break;

	      case 'message':
	        this.emit('data', packet.data);
	        this.emit('message', packet.data);
	        break;
	    }
	  } else {
	    debug('packet received with socket readyState "%s"', this.readyState);
	  }
	};

	/**
	 * Called upon handshake completion.
	 *
	 * @param {Object} handshake obj
	 * @api private
	 */

	Socket.prototype.onHandshake = function (data) {
	  this.emit('handshake', data);
	  this.id = data.sid;
	  this.transport.query.sid = data.sid;
	  this.upgrades = this.filterUpgrades(data.upgrades);
	  this.pingInterval = data.pingInterval;
	  this.pingTimeout = data.pingTimeout;
	  this.onOpen();
	  // In case open handler closes socket
	  if  ('closed' == this.readyState) return;
	  this.setPing();

	  // Prolong liveness of socket on heartbeat
	  this.removeListener('heartbeat', this.onHeartbeat);
	  this.on('heartbeat', this.onHeartbeat);
	};

	/**
	 * Resets ping timeout.
	 *
	 * @api private
	 */

	Socket.prototype.onHeartbeat = function (timeout) {
	  clearTimeout(this.pingTimeoutTimer);
	  var self = this;
	  self.pingTimeoutTimer = setTimeout(function () {
	    if ('closed' == self.readyState) return;
	    self.onClose('ping timeout');
	  }, timeout || (self.pingInterval + self.pingTimeout));
	};

	/**
	 * Pings server every `this.pingInterval` and expects response
	 * within `this.pingTimeout` or closes connection.
	 *
	 * @api private
	 */

	Socket.prototype.setPing = function () {
	  var self = this;
	  clearTimeout(self.pingIntervalTimer);
	  self.pingIntervalTimer = setTimeout(function () {
	    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);
	    self.ping();
	    self.onHeartbeat(self.pingTimeout);
	  }, self.pingInterval);
	};

	/**
	* Sends a ping packet.
	*
	* @api private
	*/

	Socket.prototype.ping = function () {
	  var self = this;
	  this.sendPacket('ping', function(){
	    self.emit('ping');
	  });
	};

	/**
	 * Called on `drain` event
	 *
	 * @api private
	 */

	Socket.prototype.onDrain = function() {
	  this.writeBuffer.splice(0, this.prevBufferLen);

	  // setting prevBufferLen = 0 is very important
	  // for example, when upgrading, upgrade packet is sent over,
	  // and a nonzero prevBufferLen could cause problems on `drain`
	  this.prevBufferLen = 0;

	  if (0 === this.writeBuffer.length) {
	    this.emit('drain');
	  } else {
	    this.flush();
	  }
	};

	/**
	 * Flush write buffers.
	 *
	 * @api private
	 */

	Socket.prototype.flush = function () {
	  if ('closed' != this.readyState && this.transport.writable &&
	    !this.upgrading && this.writeBuffer.length) {
	    debug('flushing %d packets in socket', this.writeBuffer.length);
	    this.transport.send(this.writeBuffer);
	    // keep track of current length of writeBuffer
	    // splice writeBuffer and callbackBuffer on `drain`
	    this.prevBufferLen = this.writeBuffer.length;
	    this.emit('flush');
	  }
	};

	/**
	 * Sends a message.
	 *
	 * @param {String} message.
	 * @param {Function} callback function.
	 * @param {Object} options.
	 * @return {Socket} for chaining.
	 * @api public
	 */

	Socket.prototype.write =
	Socket.prototype.send = function (msg, options, fn) {
	  this.sendPacket('message', msg, options, fn);
	  return this;
	};

	/**
	 * Sends a packet.
	 *
	 * @param {String} packet type.
	 * @param {String} data.
	 * @param {Object} options.
	 * @param {Function} callback function.
	 * @api private
	 */

	Socket.prototype.sendPacket = function (type, data, options, fn) {
	  if('function' == typeof data) {
	    fn = data;
	    data = undefined;
	  }

	  if ('function' == typeof options) {
	    fn = options;
	    options = null;
	  }

	  if ('closing' == this.readyState || 'closed' == this.readyState) {
	    return;
	  }

	  options = options || {};
	  options.compress = false !== options.compress;

	  var packet = {
	    type: type,
	    data: data,
	    options: options
	  };
	  this.emit('packetCreate', packet);
	  this.writeBuffer.push(packet);
	  if (fn) this.once('flush', fn);
	  this.flush();
	};

	/**
	 * Closes the connection.
	 *
	 * @api private
	 */

	Socket.prototype.close = function () {
	  if ('opening' == this.readyState || 'open' == this.readyState) {
	    this.readyState = 'closing';

	    var self = this;

	    if (this.writeBuffer.length) {
	      this.once('drain', function() {
	        if (this.upgrading) {
	          waitForUpgrade();
	        } else {
	          close();
	        }
	      });
	    } else if (this.upgrading) {
	      waitForUpgrade();
	    } else {
	      close();
	    }
	  }

	  function close() {
	    self.onClose('forced close');
	    debug('socket closing - telling transport to close');
	    self.transport.close();
	  }

	  function cleanupAndClose() {
	    self.removeListener('upgrade', cleanupAndClose);
	    self.removeListener('upgradeError', cleanupAndClose);
	    close();
	  }

	  function waitForUpgrade() {
	    // wait for upgrade to finish since we can't send packets while pausing a transport
	    self.once('upgrade', cleanupAndClose);
	    self.once('upgradeError', cleanupAndClose);
	  }

	  return this;
	};

	/**
	 * Called upon transport error
	 *
	 * @api private
	 */

	Socket.prototype.onError = function (err) {
	  debug('socket error %j', err);
	  Socket.priorWebsocketSuccess = false;
	  this.emit('error', err);
	  this.onClose('transport error', err);
	};

	/**
	 * Called upon transport close.
	 *
	 * @api private
	 */

	Socket.prototype.onClose = function (reason, desc) {
	  if ('opening' == this.readyState || 'open' == this.readyState || 'closing' == this.readyState) {
	    debug('socket close with reason: "%s"', reason);
	    var self = this;

	    // clear timers
	    clearTimeout(this.pingIntervalTimer);
	    clearTimeout(this.pingTimeoutTimer);

	    // stop event from firing again for transport
	    this.transport.removeAllListeners('close');

	    // ensure transport won't stay open
	    this.transport.close();

	    // ignore further transport communication
	    this.transport.removeAllListeners();

	    // set ready state
	    this.readyState = 'closed';

	    // clear session id
	    this.id = null;

	    // emit close event
	    this.emit('close', reason, desc);

	    // clean buffers after, so users can still
	    // grab the buffers on `close` event
	    self.writeBuffer = [];
	    self.prevBufferLen = 0;
	  }
	};

	/**
	 * Filters upgrades, returning only those matching client transports.
	 *
	 * @param {Array} server upgrades
	 * @api private
	 *
	 */

	Socket.prototype.filterUpgrades = function (upgrades) {
	  var filteredUpgrades = [];
	  for (var i = 0, j = upgrades.length; i<j; i++) {
	    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
	  }
	  return filteredUpgrades;
	};

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Module dependencies
	 */

	var XMLHttpRequest = __webpack_require__(19);
	var XHR = __webpack_require__(21);
	var JSONP = __webpack_require__(37);
	var websocket = __webpack_require__(38);

	/**
	 * Export transports.
	 */

	exports.polling = polling;
	exports.websocket = websocket;

	/**
	 * Polling transport polymorphic constructor.
	 * Decides on xhr vs jsonp based on feature detection.
	 *
	 * @api private
	 */

	function polling(opts){
	  var xhr;
	  var xd = false;
	  var xs = false;
	  var jsonp = false !== opts.jsonp;

	  if (global.location) {
	    var isSSL = 'https:' == location.protocol;
	    var port = location.port;

	    // some user agents have empty `location.port`
	    if (!port) {
	      port = isSSL ? 443 : 80;
	    }

	    xd = opts.hostname != location.hostname || port != opts.port;
	    xs = opts.secure != isSSL;
	  }

	  opts.xdomain = xd;
	  opts.xscheme = xs;
	  xhr = new XMLHttpRequest(opts);

	  if ('open' in xhr && !opts.forceJSONP) {
	    return new XHR(opts);
	  } else {
	    if (!jsonp) throw new Error('JSONP disabled');
	    return new JSONP(opts);
	  }
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	// browser shim for xmlhttprequest module
	var hasCORS = __webpack_require__(20);

	module.exports = function(opts) {
	  var xdomain = opts.xdomain;

	  // scheme must be same when usign XDomainRequest
	  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
	  var xscheme = opts.xscheme;

	  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
	  // https://github.com/Automattic/engine.io-client/pull/217
	  var enablesXDR = opts.enablesXDR;

	  // XMLHttpRequest can be disabled on IE
	  try {
	    if ('undefined' != typeof XMLHttpRequest && (!xdomain || hasCORS)) {
	      return new XMLHttpRequest();
	    }
	  } catch (e) { }

	  // Use XDomainRequest for IE8 if enablesXDR is true
	  // because loading bar keeps flashing when using jsonp-polling
	  // https://github.com/yujiosaka/socke.io-ie8-loading-example
	  try {
	    if ('undefined' != typeof XDomainRequest && !xscheme && enablesXDR) {
	      return new XDomainRequest();
	    }
	  } catch (e) { }

	  if (!xdomain) {
	    try {
	      return new ActiveXObject('Microsoft.XMLHTTP');
	    } catch(e) { }
	  }
	}


/***/ },
/* 20 */
/***/ function(module, exports) {

	
	/**
	 * Module exports.
	 *
	 * Logic borrowed from Modernizr:
	 *
	 *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
	 */

	try {
	  module.exports = typeof XMLHttpRequest !== 'undefined' &&
	    'withCredentials' in new XMLHttpRequest();
	} catch (err) {
	  // if XMLHttp support is disabled in IE then it will throw
	  // when trying to create
	  module.exports = false;
	}


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Module requirements.
	 */

	var XMLHttpRequest = __webpack_require__(19);
	var Polling = __webpack_require__(22);
	var Emitter = __webpack_require__(33);
	var inherit = __webpack_require__(35);
	var debug = __webpack_require__(3)('engine.io-client:polling-xhr');

	/**
	 * Module exports.
	 */

	module.exports = XHR;
	module.exports.Request = Request;

	/**
	 * Empty function
	 */

	function empty(){}

	/**
	 * XHR Polling constructor.
	 *
	 * @param {Object} opts
	 * @api public
	 */

	function XHR(opts){
	  Polling.call(this, opts);

	  if (global.location) {
	    var isSSL = 'https:' == location.protocol;
	    var port = location.port;

	    // some user agents have empty `location.port`
	    if (!port) {
	      port = isSSL ? 443 : 80;
	    }

	    this.xd = opts.hostname != global.location.hostname ||
	      port != opts.port;
	    this.xs = opts.secure != isSSL;
	  } else {
	    this.extraHeaders = opts.extraHeaders;
	  }
	}

	/**
	 * Inherits from Polling.
	 */

	inherit(XHR, Polling);

	/**
	 * XHR supports binary
	 */

	XHR.prototype.supportsBinary = true;

	/**
	 * Creates a request.
	 *
	 * @param {String} method
	 * @api private
	 */

	XHR.prototype.request = function(opts){
	  opts = opts || {};
	  opts.uri = this.uri();
	  opts.xd = this.xd;
	  opts.xs = this.xs;
	  opts.agent = this.agent || false;
	  opts.supportsBinary = this.supportsBinary;
	  opts.enablesXDR = this.enablesXDR;

	  // SSL options for Node.js client
	  opts.pfx = this.pfx;
	  opts.key = this.key;
	  opts.passphrase = this.passphrase;
	  opts.cert = this.cert;
	  opts.ca = this.ca;
	  opts.ciphers = this.ciphers;
	  opts.rejectUnauthorized = this.rejectUnauthorized;

	  // other options for Node.js client
	  opts.extraHeaders = this.extraHeaders;

	  return new Request(opts);
	};

	/**
	 * Sends data.
	 *
	 * @param {String} data to send.
	 * @param {Function} called upon flush.
	 * @api private
	 */

	XHR.prototype.doWrite = function(data, fn){
	  var isBinary = typeof data !== 'string' && data !== undefined;
	  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });
	  var self = this;
	  req.on('success', fn);
	  req.on('error', function(err){
	    self.onError('xhr post error', err);
	  });
	  this.sendXhr = req;
	};

	/**
	 * Starts a poll cycle.
	 *
	 * @api private
	 */

	XHR.prototype.doPoll = function(){
	  debug('xhr poll');
	  var req = this.request();
	  var self = this;
	  req.on('data', function(data){
	    self.onData(data);
	  });
	  req.on('error', function(err){
	    self.onError('xhr poll error', err);
	  });
	  this.pollXhr = req;
	};

	/**
	 * Request constructor
	 *
	 * @param {Object} options
	 * @api public
	 */

	function Request(opts){
	  this.method = opts.method || 'GET';
	  this.uri = opts.uri;
	  this.xd = !!opts.xd;
	  this.xs = !!opts.xs;
	  this.async = false !== opts.async;
	  this.data = undefined != opts.data ? opts.data : null;
	  this.agent = opts.agent;
	  this.isBinary = opts.isBinary;
	  this.supportsBinary = opts.supportsBinary;
	  this.enablesXDR = opts.enablesXDR;

	  // SSL options for Node.js client
	  this.pfx = opts.pfx;
	  this.key = opts.key;
	  this.passphrase = opts.passphrase;
	  this.cert = opts.cert;
	  this.ca = opts.ca;
	  this.ciphers = opts.ciphers;
	  this.rejectUnauthorized = opts.rejectUnauthorized;

	  // other options for Node.js client
	  this.extraHeaders = opts.extraHeaders;

	  this.create();
	}

	/**
	 * Mix in `Emitter`.
	 */

	Emitter(Request.prototype);

	/**
	 * Creates the XHR object and sends the request.
	 *
	 * @api private
	 */

	Request.prototype.create = function(){
	  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };

	  // SSL options for Node.js client
	  opts.pfx = this.pfx;
	  opts.key = this.key;
	  opts.passphrase = this.passphrase;
	  opts.cert = this.cert;
	  opts.ca = this.ca;
	  opts.ciphers = this.ciphers;
	  opts.rejectUnauthorized = this.rejectUnauthorized;

	  var xhr = this.xhr = new XMLHttpRequest(opts);
	  var self = this;

	  try {
	    debug('xhr open %s: %s', this.method, this.uri);
	    xhr.open(this.method, this.uri, this.async);
	    try {
	      if (this.extraHeaders) {
	        xhr.setDisableHeaderCheck(true);
	        for (var i in this.extraHeaders) {
	          if (this.extraHeaders.hasOwnProperty(i)) {
	            xhr.setRequestHeader(i, this.extraHeaders[i]);
	          }
	        }
	      }
	    } catch (e) {}
	    if (this.supportsBinary) {
	      // This has to be done after open because Firefox is stupid
	      // http://stackoverflow.com/questions/13216903/get-binary-data-with-xmlhttprequest-in-a-firefox-extension
	      xhr.responseType = 'arraybuffer';
	    }

	    if ('POST' == this.method) {
	      try {
	        if (this.isBinary) {
	          xhr.setRequestHeader('Content-type', 'application/octet-stream');
	        } else {
	          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
	        }
	      } catch (e) {}
	    }

	    // ie6 check
	    if ('withCredentials' in xhr) {
	      xhr.withCredentials = true;
	    }

	    if (this.hasXDR()) {
	      xhr.onload = function(){
	        self.onLoad();
	      };
	      xhr.onerror = function(){
	        self.onError(xhr.responseText);
	      };
	    } else {
	      xhr.onreadystatechange = function(){
	        if (4 != xhr.readyState) return;
	        if (200 == xhr.status || 1223 == xhr.status) {
	          self.onLoad();
	        } else {
	          // make sure the `error` event handler that's user-set
	          // does not throw in the same tick and gets caught here
	          setTimeout(function(){
	            self.onError(xhr.status);
	          }, 0);
	        }
	      };
	    }

	    debug('xhr data %s', this.data);
	    xhr.send(this.data);
	  } catch (e) {
	    // Need to defer since .create() is called directly fhrom the constructor
	    // and thus the 'error' event can only be only bound *after* this exception
	    // occurs.  Therefore, also, we cannot throw here at all.
	    setTimeout(function() {
	      self.onError(e);
	    }, 0);
	    return;
	  }

	  if (global.document) {
	    this.index = Request.requestsCount++;
	    Request.requests[this.index] = this;
	  }
	};

	/**
	 * Called upon successful response.
	 *
	 * @api private
	 */

	Request.prototype.onSuccess = function(){
	  this.emit('success');
	  this.cleanup();
	};

	/**
	 * Called if we have data.
	 *
	 * @api private
	 */

	Request.prototype.onData = function(data){
	  this.emit('data', data);
	  this.onSuccess();
	};

	/**
	 * Called upon error.
	 *
	 * @api private
	 */

	Request.prototype.onError = function(err){
	  this.emit('error', err);
	  this.cleanup(true);
	};

	/**
	 * Cleans up house.
	 *
	 * @api private
	 */

	Request.prototype.cleanup = function(fromError){
	  if ('undefined' == typeof this.xhr || null === this.xhr) {
	    return;
	  }
	  // xmlhttprequest
	  if (this.hasXDR()) {
	    this.xhr.onload = this.xhr.onerror = empty;
	  } else {
	    this.xhr.onreadystatechange = empty;
	  }

	  if (fromError) {
	    try {
	      this.xhr.abort();
	    } catch(e) {}
	  }

	  if (global.document) {
	    delete Request.requests[this.index];
	  }

	  this.xhr = null;
	};

	/**
	 * Called upon load.
	 *
	 * @api private
	 */

	Request.prototype.onLoad = function(){
	  var data;
	  try {
	    var contentType;
	    try {
	      contentType = this.xhr.getResponseHeader('Content-Type').split(';')[0];
	    } catch (e) {}
	    if (contentType === 'application/octet-stream') {
	      data = this.xhr.response;
	    } else {
	      if (!this.supportsBinary) {
	        data = this.xhr.responseText;
	      } else {
	        try {
	          data = String.fromCharCode.apply(null, new Uint8Array(this.xhr.response));
	        } catch (e) {
	          var ui8Arr = new Uint8Array(this.xhr.response);
	          var dataArray = [];
	          for (var idx = 0, length = ui8Arr.length; idx < length; idx++) {
	            dataArray.push(ui8Arr[idx]);
	          }

	          data = String.fromCharCode.apply(null, dataArray);
	        }
	      }
	    }
	  } catch (e) {
	    this.onError(e);
	  }
	  if (null != data) {
	    this.onData(data);
	  }
	};

	/**
	 * Check if it has XDomainRequest.
	 *
	 * @api private
	 */

	Request.prototype.hasXDR = function(){
	  return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;
	};

	/**
	 * Aborts the request.
	 *
	 * @api public
	 */

	Request.prototype.abort = function(){
	  this.cleanup();
	};

	/**
	 * Aborts pending requests when unloading the window. This is needed to prevent
	 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
	 * emitted.
	 */

	if (global.document) {
	  Request.requestsCount = 0;
	  Request.requests = {};
	  if (global.attachEvent) {
	    global.attachEvent('onunload', unloadHandler);
	  } else if (global.addEventListener) {
	    global.addEventListener('beforeunload', unloadHandler, false);
	  }
	}

	function unloadHandler() {
	  for (var i in Request.requests) {
	    if (Request.requests.hasOwnProperty(i)) {
	      Request.requests[i].abort();
	    }
	  }
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Module dependencies.
	 */

	var Transport = __webpack_require__(23);
	var parseqs = __webpack_require__(34);
	var parser = __webpack_require__(24);
	var inherit = __webpack_require__(35);
	var yeast = __webpack_require__(36);
	var debug = __webpack_require__(3)('engine.io-client:polling');

	/**
	 * Module exports.
	 */

	module.exports = Polling;

	/**
	 * Is XHR2 supported?
	 */

	var hasXHR2 = (function() {
	  var XMLHttpRequest = __webpack_require__(19);
	  var xhr = new XMLHttpRequest({ xdomain: false });
	  return null != xhr.responseType;
	})();

	/**
	 * Polling interface.
	 *
	 * @param {Object} opts
	 * @api private
	 */

	function Polling(opts){
	  var forceBase64 = (opts && opts.forceBase64);
	  if (!hasXHR2 || forceBase64) {
	    this.supportsBinary = false;
	  }
	  Transport.call(this, opts);
	}

	/**
	 * Inherits from Transport.
	 */

	inherit(Polling, Transport);

	/**
	 * Transport name.
	 */

	Polling.prototype.name = 'polling';

	/**
	 * Opens the socket (triggers polling). We write a PING message to determine
	 * when the transport is open.
	 *
	 * @api private
	 */

	Polling.prototype.doOpen = function(){
	  this.poll();
	};

	/**
	 * Pauses polling.
	 *
	 * @param {Function} callback upon buffers are flushed and transport is paused
	 * @api private
	 */

	Polling.prototype.pause = function(onPause){
	  var pending = 0;
	  var self = this;

	  this.readyState = 'pausing';

	  function pause(){
	    debug('paused');
	    self.readyState = 'paused';
	    onPause();
	  }

	  if (this.polling || !this.writable) {
	    var total = 0;

	    if (this.polling) {
	      debug('we are currently polling - waiting to pause');
	      total++;
	      this.once('pollComplete', function(){
	        debug('pre-pause polling complete');
	        --total || pause();
	      });
	    }

	    if (!this.writable) {
	      debug('we are currently writing - waiting to pause');
	      total++;
	      this.once('drain', function(){
	        debug('pre-pause writing complete');
	        --total || pause();
	      });
	    }
	  } else {
	    pause();
	  }
	};

	/**
	 * Starts polling cycle.
	 *
	 * @api public
	 */

	Polling.prototype.poll = function(){
	  debug('polling');
	  this.polling = true;
	  this.doPoll();
	  this.emit('poll');
	};

	/**
	 * Overloads onData to detect payloads.
	 *
	 * @api private
	 */

	Polling.prototype.onData = function(data){
	  var self = this;
	  debug('polling got data %s', data);
	  var callback = function(packet, index, total) {
	    // if its the first message we consider the transport open
	    if ('opening' == self.readyState) {
	      self.onOpen();
	    }

	    // if its a close packet, we close the ongoing requests
	    if ('close' == packet.type) {
	      self.onClose();
	      return false;
	    }

	    // otherwise bypass onData and handle the message
	    self.onPacket(packet);
	  };

	  // decode payload
	  parser.decodePayload(data, this.socket.binaryType, callback);

	  // if an event did not trigger closing
	  if ('closed' != this.readyState) {
	    // if we got data we're not polling
	    this.polling = false;
	    this.emit('pollComplete');

	    if ('open' == this.readyState) {
	      this.poll();
	    } else {
	      debug('ignoring poll - transport state "%s"', this.readyState);
	    }
	  }
	};

	/**
	 * For polling, send a close packet.
	 *
	 * @api private
	 */

	Polling.prototype.doClose = function(){
	  var self = this;

	  function close(){
	    debug('writing close packet');
	    self.write([{ type: 'close' }]);
	  }

	  if ('open' == this.readyState) {
	    debug('transport open - closing');
	    close();
	  } else {
	    // in case we're trying to close while
	    // handshaking is in progress (GH-164)
	    debug('transport not open - deferring close');
	    this.once('open', close);
	  }
	};

	/**
	 * Writes a packets payload.
	 *
	 * @param {Array} data packets
	 * @param {Function} drain callback
	 * @api private
	 */

	Polling.prototype.write = function(packets){
	  var self = this;
	  this.writable = false;
	  var callbackfn = function() {
	    self.writable = true;
	    self.emit('drain');
	  };

	  var self = this;
	  parser.encodePayload(packets, this.supportsBinary, function(data) {
	    self.doWrite(data, callbackfn);
	  });
	};

	/**
	 * Generates uri for connection.
	 *
	 * @api private
	 */

	Polling.prototype.uri = function(){
	  var query = this.query || {};
	  var schema = this.secure ? 'https' : 'http';
	  var port = '';

	  // cache busting is forced
	  if (false !== this.timestampRequests) {
	    query[this.timestampParam] = yeast();
	  }

	  if (!this.supportsBinary && !query.sid) {
	    query.b64 = 1;
	  }

	  query = parseqs.encode(query);

	  // avoid port if default for schema
	  if (this.port && (('https' == schema && this.port != 443) ||
	     ('http' == schema && this.port != 80))) {
	    port = ':' + this.port;
	  }

	  // prepend ? to query
	  if (query.length) {
	    query = '?' + query;
	  }

	  var ipv6 = this.hostname.indexOf(':') !== -1;
	  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
	};


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Module dependencies.
	 */

	var parser = __webpack_require__(24);
	var Emitter = __webpack_require__(33);

	/**
	 * Module exports.
	 */

	module.exports = Transport;

	/**
	 * Transport abstract constructor.
	 *
	 * @param {Object} options.
	 * @api private
	 */

	function Transport (opts) {
	  this.path = opts.path;
	  this.hostname = opts.hostname;
	  this.port = opts.port;
	  this.secure = opts.secure;
	  this.query = opts.query;
	  this.timestampParam = opts.timestampParam;
	  this.timestampRequests = opts.timestampRequests;
	  this.readyState = '';
	  this.agent = opts.agent || false;
	  this.socket = opts.socket;
	  this.enablesXDR = opts.enablesXDR;

	  // SSL options for Node.js client
	  this.pfx = opts.pfx;
	  this.key = opts.key;
	  this.passphrase = opts.passphrase;
	  this.cert = opts.cert;
	  this.ca = opts.ca;
	  this.ciphers = opts.ciphers;
	  this.rejectUnauthorized = opts.rejectUnauthorized;

	  // other options for Node.js client
	  this.extraHeaders = opts.extraHeaders;
	}

	/**
	 * Mix in `Emitter`.
	 */

	Emitter(Transport.prototype);

	/**
	 * Emits an error.
	 *
	 * @param {String} str
	 * @return {Transport} for chaining
	 * @api public
	 */

	Transport.prototype.onError = function (msg, desc) {
	  var err = new Error(msg);
	  err.type = 'TransportError';
	  err.description = desc;
	  this.emit('error', err);
	  return this;
	};

	/**
	 * Opens the transport.
	 *
	 * @api public
	 */

	Transport.prototype.open = function () {
	  if ('closed' == this.readyState || '' == this.readyState) {
	    this.readyState = 'opening';
	    this.doOpen();
	  }

	  return this;
	};

	/**
	 * Closes the transport.
	 *
	 * @api private
	 */

	Transport.prototype.close = function () {
	  if ('opening' == this.readyState || 'open' == this.readyState) {
	    this.doClose();
	    this.onClose();
	  }

	  return this;
	};

	/**
	 * Sends multiple packets.
	 *
	 * @param {Array} packets
	 * @api private
	 */

	Transport.prototype.send = function(packets){
	  if ('open' == this.readyState) {
	    this.write(packets);
	  } else {
	    throw new Error('Transport not open');
	  }
	};

	/**
	 * Called upon open
	 *
	 * @api private
	 */

	Transport.prototype.onOpen = function () {
	  this.readyState = 'open';
	  this.writable = true;
	  this.emit('open');
	};

	/**
	 * Called with data.
	 *
	 * @param {String} data
	 * @api private
	 */

	Transport.prototype.onData = function(data){
	  var packet = parser.decodePacket(data, this.socket.binaryType);
	  this.onPacket(packet);
	};

	/**
	 * Called with a decoded packet.
	 */

	Transport.prototype.onPacket = function (packet) {
	  this.emit('packet', packet);
	};

	/**
	 * Called upon close.
	 *
	 * @api private
	 */

	Transport.prototype.onClose = function () {
	  this.readyState = 'closed';
	  this.emit('close');
	};


/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Module dependencies.
	 */

	var keys = __webpack_require__(25);
	var hasBinary = __webpack_require__(26);
	var sliceBuffer = __webpack_require__(28);
	var base64encoder = __webpack_require__(29);
	var after = __webpack_require__(30);
	var utf8 = __webpack_require__(31);

	/**
	 * Check if we are running an android browser. That requires us to use
	 * ArrayBuffer with polling transports...
	 *
	 * http://ghinda.net/jpeg-blob-ajax-android/
	 */

	var isAndroid = navigator.userAgent.match(/Android/i);

	/**
	 * Check if we are running in PhantomJS.
	 * Uploading a Blob with PhantomJS does not work correctly, as reported here:
	 * https://github.com/ariya/phantomjs/issues/11395
	 * @type boolean
	 */
	var isPhantomJS = /PhantomJS/i.test(navigator.userAgent);

	/**
	 * When true, avoids using Blobs to encode payloads.
	 * @type boolean
	 */
	var dontSendBlobs = isAndroid || isPhantomJS;

	/**
	 * Current protocol version.
	 */

	exports.protocol = 3;

	/**
	 * Packet types.
	 */

	var packets = exports.packets = {
	    open:     0    // non-ws
	  , close:    1    // non-ws
	  , ping:     2
	  , pong:     3
	  , message:  4
	  , upgrade:  5
	  , noop:     6
	};

	var packetslist = keys(packets);

	/**
	 * Premade error packet.
	 */

	var err = { type: 'error', data: 'parser error' };

	/**
	 * Create a blob api even for blob builder when vendor prefixes exist
	 */

	var Blob = __webpack_require__(32);

	/**
	 * Encodes a packet.
	 *
	 *     <packet type id> [ <data> ]
	 *
	 * Example:
	 *
	 *     5hello world
	 *     3
	 *     4
	 *
	 * Binary is encoded in an identical principle
	 *
	 * @api private
	 */

	exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
	  if ('function' == typeof supportsBinary) {
	    callback = supportsBinary;
	    supportsBinary = false;
	  }

	  if ('function' == typeof utf8encode) {
	    callback = utf8encode;
	    utf8encode = null;
	  }

	  var data = (packet.data === undefined)
	    ? undefined
	    : packet.data.buffer || packet.data;

	  if (global.ArrayBuffer && data instanceof ArrayBuffer) {
	    return encodeArrayBuffer(packet, supportsBinary, callback);
	  } else if (Blob && data instanceof global.Blob) {
	    return encodeBlob(packet, supportsBinary, callback);
	  }

	  // might be an object with { base64: true, data: dataAsBase64String }
	  if (data && data.base64) {
	    return encodeBase64Object(packet, callback);
	  }

	  // Sending data as a utf-8 string
	  var encoded = packets[packet.type];

	  // data fragment is optional
	  if (undefined !== packet.data) {
	    encoded += utf8encode ? utf8.encode(String(packet.data)) : String(packet.data);
	  }

	  return callback('' + encoded);

	};

	function encodeBase64Object(packet, callback) {
	  // packet data is an object { base64: true, data: dataAsBase64String }
	  var message = 'b' + exports.packets[packet.type] + packet.data.data;
	  return callback(message);
	}

	/**
	 * Encode packet helpers for binary types
	 */

	function encodeArrayBuffer(packet, supportsBinary, callback) {
	  if (!supportsBinary) {
	    return exports.encodeBase64Packet(packet, callback);
	  }

	  var data = packet.data;
	  var contentArray = new Uint8Array(data);
	  var resultBuffer = new Uint8Array(1 + data.byteLength);

	  resultBuffer[0] = packets[packet.type];
	  for (var i = 0; i < contentArray.length; i++) {
	    resultBuffer[i+1] = contentArray[i];
	  }

	  return callback(resultBuffer.buffer);
	}

	function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
	  if (!supportsBinary) {
	    return exports.encodeBase64Packet(packet, callback);
	  }

	  var fr = new FileReader();
	  fr.onload = function() {
	    packet.data = fr.result;
	    exports.encodePacket(packet, supportsBinary, true, callback);
	  };
	  return fr.readAsArrayBuffer(packet.data);
	}

	function encodeBlob(packet, supportsBinary, callback) {
	  if (!supportsBinary) {
	    return exports.encodeBase64Packet(packet, callback);
	  }

	  if (dontSendBlobs) {
	    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
	  }

	  var length = new Uint8Array(1);
	  length[0] = packets[packet.type];
	  var blob = new Blob([length.buffer, packet.data]);

	  return callback(blob);
	}

	/**
	 * Encodes a packet with binary data in a base64 string
	 *
	 * @param {Object} packet, has `type` and `data`
	 * @return {String} base64 encoded message
	 */

	exports.encodeBase64Packet = function(packet, callback) {
	  var message = 'b' + exports.packets[packet.type];
	  if (Blob && packet.data instanceof global.Blob) {
	    var fr = new FileReader();
	    fr.onload = function() {
	      var b64 = fr.result.split(',')[1];
	      callback(message + b64);
	    };
	    return fr.readAsDataURL(packet.data);
	  }

	  var b64data;
	  try {
	    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
	  } catch (e) {
	    // iPhone Safari doesn't let you apply with typed arrays
	    var typed = new Uint8Array(packet.data);
	    var basic = new Array(typed.length);
	    for (var i = 0; i < typed.length; i++) {
	      basic[i] = typed[i];
	    }
	    b64data = String.fromCharCode.apply(null, basic);
	  }
	  message += global.btoa(b64data);
	  return callback(message);
	};

	/**
	 * Decodes a packet. Changes format to Blob if requested.
	 *
	 * @return {Object} with `type` and `data` (if any)
	 * @api private
	 */

	exports.decodePacket = function (data, binaryType, utf8decode) {
	  // String data
	  if (typeof data == 'string' || data === undefined) {
	    if (data.charAt(0) == 'b') {
	      return exports.decodeBase64Packet(data.substr(1), binaryType);
	    }

	    if (utf8decode) {
	      try {
	        data = utf8.decode(data);
	      } catch (e) {
	        return err;
	      }
	    }
	    var type = data.charAt(0);

	    if (Number(type) != type || !packetslist[type]) {
	      return err;
	    }

	    if (data.length > 1) {
	      return { type: packetslist[type], data: data.substring(1) };
	    } else {
	      return { type: packetslist[type] };
	    }
	  }

	  var asArray = new Uint8Array(data);
	  var type = asArray[0];
	  var rest = sliceBuffer(data, 1);
	  if (Blob && binaryType === 'blob') {
	    rest = new Blob([rest]);
	  }
	  return { type: packetslist[type], data: rest };
	};

	/**
	 * Decodes a packet encoded in a base64 string
	 *
	 * @param {String} base64 encoded message
	 * @return {Object} with `type` and `data` (if any)
	 */

	exports.decodeBase64Packet = function(msg, binaryType) {
	  var type = packetslist[msg.charAt(0)];
	  if (!global.ArrayBuffer) {
	    return { type: type, data: { base64: true, data: msg.substr(1) } };
	  }

	  var data = base64encoder.decode(msg.substr(1));

	  if (binaryType === 'blob' && Blob) {
	    data = new Blob([data]);
	  }

	  return { type: type, data: data };
	};

	/**
	 * Encodes multiple messages (payload).
	 *
	 *     <length>:data
	 *
	 * Example:
	 *
	 *     11:hello world2:hi
	 *
	 * If any contents are binary, they will be encoded as base64 strings. Base64
	 * encoded strings are marked with a b before the length specifier
	 *
	 * @param {Array} packets
	 * @api private
	 */

	exports.encodePayload = function (packets, supportsBinary, callback) {
	  if (typeof supportsBinary == 'function') {
	    callback = supportsBinary;
	    supportsBinary = null;
	  }

	  var isBinary = hasBinary(packets);

	  if (supportsBinary && isBinary) {
	    if (Blob && !dontSendBlobs) {
	      return exports.encodePayloadAsBlob(packets, callback);
	    }

	    return exports.encodePayloadAsArrayBuffer(packets, callback);
	  }

	  if (!packets.length) {
	    return callback('0:');
	  }

	  function setLengthHeader(message) {
	    return message.length + ':' + message;
	  }

	  function encodeOne(packet, doneCallback) {
	    exports.encodePacket(packet, !isBinary ? false : supportsBinary, true, function(message) {
	      doneCallback(null, setLengthHeader(message));
	    });
	  }

	  map(packets, encodeOne, function(err, results) {
	    return callback(results.join(''));
	  });
	};

	/**
	 * Async array map using after
	 */

	function map(ary, each, done) {
	  var result = new Array(ary.length);
	  var next = after(ary.length, done);

	  var eachWithIndex = function(i, el, cb) {
	    each(el, function(error, msg) {
	      result[i] = msg;
	      cb(error, result);
	    });
	  };

	  for (var i = 0; i < ary.length; i++) {
	    eachWithIndex(i, ary[i], next);
	  }
	}

	/*
	 * Decodes data when a payload is maybe expected. Possible binary contents are
	 * decoded from their base64 representation
	 *
	 * @param {String} data, callback method
	 * @api public
	 */

	exports.decodePayload = function (data, binaryType, callback) {
	  if (typeof data != 'string') {
	    return exports.decodePayloadAsBinary(data, binaryType, callback);
	  }

	  if (typeof binaryType === 'function') {
	    callback = binaryType;
	    binaryType = null;
	  }

	  var packet;
	  if (data == '') {
	    // parser error - ignoring payload
	    return callback(err, 0, 1);
	  }

	  var length = ''
	    , n, msg;

	  for (var i = 0, l = data.length; i < l; i++) {
	    var chr = data.charAt(i);

	    if (':' != chr) {
	      length += chr;
	    } else {
	      if ('' == length || (length != (n = Number(length)))) {
	        // parser error - ignoring payload
	        return callback(err, 0, 1);
	      }

	      msg = data.substr(i + 1, n);

	      if (length != msg.length) {
	        // parser error - ignoring payload
	        return callback(err, 0, 1);
	      }

	      if (msg.length) {
	        packet = exports.decodePacket(msg, binaryType, true);

	        if (err.type == packet.type && err.data == packet.data) {
	          // parser error in individual packet - ignoring payload
	          return callback(err, 0, 1);
	        }

	        var ret = callback(packet, i + n, l);
	        if (false === ret) return;
	      }

	      // advance cursor
	      i += n;
	      length = '';
	    }
	  }

	  if (length != '') {
	    // parser error - ignoring payload
	    return callback(err, 0, 1);
	  }

	};

	/**
	 * Encodes multiple messages (payload) as binary.
	 *
	 * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
	 * 255><data>
	 *
	 * Example:
	 * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
	 *
	 * @param {Array} packets
	 * @return {ArrayBuffer} encoded payload
	 * @api private
	 */

	exports.encodePayloadAsArrayBuffer = function(packets, callback) {
	  if (!packets.length) {
	    return callback(new ArrayBuffer(0));
	  }

	  function encodeOne(packet, doneCallback) {
	    exports.encodePacket(packet, true, true, function(data) {
	      return doneCallback(null, data);
	    });
	  }

	  map(packets, encodeOne, function(err, encodedPackets) {
	    var totalLength = encodedPackets.reduce(function(acc, p) {
	      var len;
	      if (typeof p === 'string'){
	        len = p.length;
	      } else {
	        len = p.byteLength;
	      }
	      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
	    }, 0);

	    var resultArray = new Uint8Array(totalLength);

	    var bufferIndex = 0;
	    encodedPackets.forEach(function(p) {
	      var isString = typeof p === 'string';
	      var ab = p;
	      if (isString) {
	        var view = new Uint8Array(p.length);
	        for (var i = 0; i < p.length; i++) {
	          view[i] = p.charCodeAt(i);
	        }
	        ab = view.buffer;
	      }

	      if (isString) { // not true binary
	        resultArray[bufferIndex++] = 0;
	      } else { // true binary
	        resultArray[bufferIndex++] = 1;
	      }

	      var lenStr = ab.byteLength.toString();
	      for (var i = 0; i < lenStr.length; i++) {
	        resultArray[bufferIndex++] = parseInt(lenStr[i]);
	      }
	      resultArray[bufferIndex++] = 255;

	      var view = new Uint8Array(ab);
	      for (var i = 0; i < view.length; i++) {
	        resultArray[bufferIndex++] = view[i];
	      }
	    });

	    return callback(resultArray.buffer);
	  });
	};

	/**
	 * Encode as Blob
	 */

	exports.encodePayloadAsBlob = function(packets, callback) {
	  function encodeOne(packet, doneCallback) {
	    exports.encodePacket(packet, true, true, function(encoded) {
	      var binaryIdentifier = new Uint8Array(1);
	      binaryIdentifier[0] = 1;
	      if (typeof encoded === 'string') {
	        var view = new Uint8Array(encoded.length);
	        for (var i = 0; i < encoded.length; i++) {
	          view[i] = encoded.charCodeAt(i);
	        }
	        encoded = view.buffer;
	        binaryIdentifier[0] = 0;
	      }

	      var len = (encoded instanceof ArrayBuffer)
	        ? encoded.byteLength
	        : encoded.size;

	      var lenStr = len.toString();
	      var lengthAry = new Uint8Array(lenStr.length + 1);
	      for (var i = 0; i < lenStr.length; i++) {
	        lengthAry[i] = parseInt(lenStr[i]);
	      }
	      lengthAry[lenStr.length] = 255;

	      if (Blob) {
	        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
	        doneCallback(null, blob);
	      }
	    });
	  }

	  map(packets, encodeOne, function(err, results) {
	    return callback(new Blob(results));
	  });
	};

	/*
	 * Decodes data when a payload is maybe expected. Strings are decoded by
	 * interpreting each byte as a key code for entries marked to start with 0. See
	 * description of encodePayloadAsBinary
	 *
	 * @param {ArrayBuffer} data, callback method
	 * @api public
	 */

	exports.decodePayloadAsBinary = function (data, binaryType, callback) {
	  if (typeof binaryType === 'function') {
	    callback = binaryType;
	    binaryType = null;
	  }

	  var bufferTail = data;
	  var buffers = [];

	  var numberTooLong = false;
	  while (bufferTail.byteLength > 0) {
	    var tailArray = new Uint8Array(bufferTail);
	    var isString = tailArray[0] === 0;
	    var msgLength = '';

	    for (var i = 1; ; i++) {
	      if (tailArray[i] == 255) break;

	      if (msgLength.length > 310) {
	        numberTooLong = true;
	        break;
	      }

	      msgLength += tailArray[i];
	    }

	    if(numberTooLong) return callback(err, 0, 1);

	    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
	    msgLength = parseInt(msgLength);

	    var msg = sliceBuffer(bufferTail, 0, msgLength);
	    if (isString) {
	      try {
	        msg = String.fromCharCode.apply(null, new Uint8Array(msg));
	      } catch (e) {
	        // iPhone Safari doesn't let you apply to typed arrays
	        var typed = new Uint8Array(msg);
	        msg = '';
	        for (var i = 0; i < typed.length; i++) {
	          msg += String.fromCharCode(typed[i]);
	        }
	      }
	    }

	    buffers.push(msg);
	    bufferTail = sliceBuffer(bufferTail, msgLength);
	  }

	  var total = buffers.length;
	  buffers.forEach(function(buffer, i) {
	    callback(exports.decodePacket(buffer, binaryType, true), i, total);
	  });
	};

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 25 */
/***/ function(module, exports) {

	
	/**
	 * Gets the keys for an object.
	 *
	 * @return {Array} keys
	 * @api private
	 */

	module.exports = Object.keys || function keys (obj){
	  var arr = [];
	  var has = Object.prototype.hasOwnProperty;

	  for (var i in obj) {
	    if (has.call(obj, i)) {
	      arr.push(i);
	    }
	  }
	  return arr;
	};


/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {
	/*
	 * Module requirements.
	 */

	var isArray = __webpack_require__(27);

	/**
	 * Module exports.
	 */

	module.exports = hasBinary;

	/**
	 * Checks for binary data.
	 *
	 * Right now only Buffer and ArrayBuffer are supported..
	 *
	 * @param {Object} anything
	 * @api public
	 */

	function hasBinary(data) {

	  function _hasBinary(obj) {
	    if (!obj) return false;

	    if ( (global.Buffer && global.Buffer.isBuffer(obj)) ||
	         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||
	         (global.Blob && obj instanceof Blob) ||
	         (global.File && obj instanceof File)
	        ) {
	      return true;
	    }

	    if (isArray(obj)) {
	      for (var i = 0; i < obj.length; i++) {
	          if (_hasBinary(obj[i])) {
	              return true;
	          }
	      }
	    } else if (obj && 'object' == typeof obj) {
	      if (obj.toJSON) {
	        obj = obj.toJSON();
	      }

	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {
	          return true;
	        }
	      }
	    }

	    return false;
	  }

	  return _hasBinary(data);
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 27 */
/***/ function(module, exports) {

	module.exports = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};


/***/ },
/* 28 */
/***/ function(module, exports) {

	/**
	 * An abstraction for slicing an arraybuffer even when
	 * ArrayBuffer.prototype.slice is not supported
	 *
	 * @api public
	 */

	module.exports = function(arraybuffer, start, end) {
	  var bytes = arraybuffer.byteLength;
	  start = start || 0;
	  end = end || bytes;

	  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }

	  if (start < 0) { start += bytes; }
	  if (end < 0) { end += bytes; }
	  if (end > bytes) { end = bytes; }

	  if (start >= bytes || start >= end || bytes === 0) {
	    return new ArrayBuffer(0);
	  }

	  var abv = new Uint8Array(arraybuffer);
	  var result = new Uint8Array(end - start);
	  for (var i = start, ii = 0; i < end; i++, ii++) {
	    result[ii] = abv[i];
	  }
	  return result.buffer;
	};


/***/ },
/* 29 */
/***/ function(module, exports) {

	/*
	 * base64-arraybuffer
	 * https://github.com/niklasvh/base64-arraybuffer
	 *
	 * Copyright (c) 2012 Niklas von Hertzen
	 * Licensed under the MIT license.
	 */
	(function(chars){
	  "use strict";

	  exports.encode = function(arraybuffer) {
	    var bytes = new Uint8Array(arraybuffer),
	    i, len = bytes.length, base64 = "";

	    for (i = 0; i < len; i+=3) {
	      base64 += chars[bytes[i] >> 2];
	      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
	      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
	      base64 += chars[bytes[i + 2] & 63];
	    }

	    if ((len % 3) === 2) {
	      base64 = base64.substring(0, base64.length - 1) + "=";
	    } else if (len % 3 === 1) {
	      base64 = base64.substring(0, base64.length - 2) + "==";
	    }

	    return base64;
	  };

	  exports.decode =  function(base64) {
	    var bufferLength = base64.length * 0.75,
	    len = base64.length, i, p = 0,
	    encoded1, encoded2, encoded3, encoded4;

	    if (base64[base64.length - 1] === "=") {
	      bufferLength--;
	      if (base64[base64.length - 2] === "=") {
	        bufferLength--;
	      }
	    }

	    var arraybuffer = new ArrayBuffer(bufferLength),
	    bytes = new Uint8Array(arraybuffer);

	    for (i = 0; i < len; i+=4) {
	      encoded1 = chars.indexOf(base64[i]);
	      encoded2 = chars.indexOf(base64[i+1]);
	      encoded3 = chars.indexOf(base64[i+2]);
	      encoded4 = chars.indexOf(base64[i+3]);

	      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
	      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
	      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
	    }

	    return arraybuffer;
	  };
	})("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");


/***/ },
/* 30 */
/***/ function(module, exports) {

	module.exports = after

	function after(count, callback, err_cb) {
	    var bail = false
	    err_cb = err_cb || noop
	    proxy.count = count

	    return (count === 0) ? callback() : proxy

	    function proxy(err, result) {
	        if (proxy.count <= 0) {
	            throw new Error('after called too many times')
	        }
	        --proxy.count

	        // after first error, rest are passed to err_cb
	        if (err) {
	            bail = true
	            callback(err)
	            // future error callbacks will go to error handler
	            callback = err_cb
	        } else if (proxy.count === 0 && !bail) {
	            callback(null, result)
	        }
	    }
	}

	function noop() {}


/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! https://mths.be/utf8js v2.0.0 by @mathias */
	;(function(root) {

		// Detect free variables `exports`
		var freeExports = typeof exports == 'object' && exports;

		// Detect free variable `module`
		var freeModule = typeof module == 'object' && module &&
			module.exports == freeExports && module;

		// Detect free variable `global`, from Node.js or Browserified code,
		// and use it as `root`
		var freeGlobal = typeof global == 'object' && global;
		if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
			root = freeGlobal;
		}

		/*--------------------------------------------------------------------------*/

		var stringFromCharCode = String.fromCharCode;

		// Taken from https://mths.be/punycode
		function ucs2decode(string) {
			var output = [];
			var counter = 0;
			var length = string.length;
			var value;
			var extra;
			while (counter < length) {
				value = string.charCodeAt(counter++);
				if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
					// high surrogate, and there is a next character
					extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) { // low surrogate
						output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
					} else {
						// unmatched surrogate; only append this code unit, in case the next
						// code unit is the high surrogate of a surrogate pair
						output.push(value);
						counter--;
					}
				} else {
					output.push(value);
				}
			}
			return output;
		}

		// Taken from https://mths.be/punycode
		function ucs2encode(array) {
			var length = array.length;
			var index = -1;
			var value;
			var output = '';
			while (++index < length) {
				value = array[index];
				if (value > 0xFFFF) {
					value -= 0x10000;
					output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
					value = 0xDC00 | value & 0x3FF;
				}
				output += stringFromCharCode(value);
			}
			return output;
		}

		function checkScalarValue(codePoint) {
			if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
				throw Error(
					'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +
					' is not a scalar value'
				);
			}
		}
		/*--------------------------------------------------------------------------*/

		function createByte(codePoint, shift) {
			return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
		}

		function encodeCodePoint(codePoint) {
			if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
				return stringFromCharCode(codePoint);
			}
			var symbol = '';
			if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
				symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
			}
			else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
				checkScalarValue(codePoint);
				symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
				symbol += createByte(codePoint, 6);
			}
			else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
				symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
				symbol += createByte(codePoint, 12);
				symbol += createByte(codePoint, 6);
			}
			symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
			return symbol;
		}

		function utf8encode(string) {
			var codePoints = ucs2decode(string);
			var length = codePoints.length;
			var index = -1;
			var codePoint;
			var byteString = '';
			while (++index < length) {
				codePoint = codePoints[index];
				byteString += encodeCodePoint(codePoint);
			}
			return byteString;
		}

		/*--------------------------------------------------------------------------*/

		function readContinuationByte() {
			if (byteIndex >= byteCount) {
				throw Error('Invalid byte index');
			}

			var continuationByte = byteArray[byteIndex] & 0xFF;
			byteIndex++;

			if ((continuationByte & 0xC0) == 0x80) {
				return continuationByte & 0x3F;
			}

			// If we end up here, it’s not a continuation byte
			throw Error('Invalid continuation byte');
		}

		function decodeSymbol() {
			var byte1;
			var byte2;
			var byte3;
			var byte4;
			var codePoint;

			if (byteIndex > byteCount) {
				throw Error('Invalid byte index');
			}

			if (byteIndex == byteCount) {
				return false;
			}

			// Read first byte
			byte1 = byteArray[byteIndex] & 0xFF;
			byteIndex++;

			// 1-byte sequence (no continuation bytes)
			if ((byte1 & 0x80) == 0) {
				return byte1;
			}

			// 2-byte sequence
			if ((byte1 & 0xE0) == 0xC0) {
				var byte2 = readContinuationByte();
				codePoint = ((byte1 & 0x1F) << 6) | byte2;
				if (codePoint >= 0x80) {
					return codePoint;
				} else {
					throw Error('Invalid continuation byte');
				}
			}

			// 3-byte sequence (may include unpaired surrogates)
			if ((byte1 & 0xF0) == 0xE0) {
				byte2 = readContinuationByte();
				byte3 = readContinuationByte();
				codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
				if (codePoint >= 0x0800) {
					checkScalarValue(codePoint);
					return codePoint;
				} else {
					throw Error('Invalid continuation byte');
				}
			}

			// 4-byte sequence
			if ((byte1 & 0xF8) == 0xF0) {
				byte2 = readContinuationByte();
				byte3 = readContinuationByte();
				byte4 = readContinuationByte();
				codePoint = ((byte1 & 0x0F) << 0x12) | (byte2 << 0x0C) |
					(byte3 << 0x06) | byte4;
				if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
					return codePoint;
				}
			}

			throw Error('Invalid UTF-8 detected');
		}

		var byteArray;
		var byteCount;
		var byteIndex;
		function utf8decode(byteString) {
			byteArray = ucs2decode(byteString);
			byteCount = byteArray.length;
			byteIndex = 0;
			var codePoints = [];
			var tmp;
			while ((tmp = decodeSymbol()) !== false) {
				codePoints.push(tmp);
			}
			return ucs2encode(codePoints);
		}

		/*--------------------------------------------------------------------------*/

		var utf8 = {
			'version': '2.0.0',
			'encode': utf8encode,
			'decode': utf8decode
		};

		// Some AMD build optimizers, like r.js, check for specific condition patterns
		// like the following:
		if (
			true
		) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
				return utf8;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		}	else if (freeExports && !freeExports.nodeType) {
			if (freeModule) { // in Node.js or RingoJS v0.8.0+
				freeModule.exports = utf8;
			} else { // in Narwhal or RingoJS v0.7.0-
				var object = {};
				var hasOwnProperty = object.hasOwnProperty;
				for (var key in utf8) {
					hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
				}
			}
		} else { // in Rhino or a web browser
			root.utf8 = utf8;
		}

	}(this));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)(module), (function() { return this; }())))

/***/ },
/* 32 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Create a blob builder even when vendor prefixes exist
	 */

	var BlobBuilder = global.BlobBuilder
	  || global.WebKitBlobBuilder
	  || global.MSBlobBuilder
	  || global.MozBlobBuilder;

	/**
	 * Check if Blob constructor is supported
	 */

	var blobSupported = (function() {
	  try {
	    var a = new Blob(['hi']);
	    return a.size === 2;
	  } catch(e) {
	    return false;
	  }
	})();

	/**
	 * Check if Blob constructor supports ArrayBufferViews
	 * Fails in Safari 6, so we need to map to ArrayBuffers there.
	 */

	var blobSupportsArrayBufferView = blobSupported && (function() {
	  try {
	    var b = new Blob([new Uint8Array([1,2])]);
	    return b.size === 2;
	  } catch(e) {
	    return false;
	  }
	})();

	/**
	 * Check if BlobBuilder is supported
	 */

	var blobBuilderSupported = BlobBuilder
	  && BlobBuilder.prototype.append
	  && BlobBuilder.prototype.getBlob;

	/**
	 * Helper function that maps ArrayBufferViews to ArrayBuffers
	 * Used by BlobBuilder constructor and old browsers that didn't
	 * support it in the Blob constructor.
	 */

	function mapArrayBufferViews(ary) {
	  for (var i = 0; i < ary.length; i++) {
	    var chunk = ary[i];
	    if (chunk.buffer instanceof ArrayBuffer) {
	      var buf = chunk.buffer;

	      // if this is a subarray, make a copy so we only
	      // include the subarray region from the underlying buffer
	      if (chunk.byteLength !== buf.byteLength) {
	        var copy = new Uint8Array(chunk.byteLength);
	        copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));
	        buf = copy.buffer;
	      }

	      ary[i] = buf;
	    }
	  }
	}

	function BlobBuilderConstructor(ary, options) {
	  options = options || {};

	  var bb = new BlobBuilder();
	  mapArrayBufferViews(ary);

	  for (var i = 0; i < ary.length; i++) {
	    bb.append(ary[i]);
	  }

	  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();
	};

	function BlobConstructor(ary, options) {
	  mapArrayBufferViews(ary);
	  return new Blob(ary, options || {});
	};

	module.exports = (function() {
	  if (blobSupported) {
	    return blobSupportsArrayBufferView ? global.Blob : BlobConstructor;
	  } else if (blobBuilderSupported) {
	    return BlobBuilderConstructor;
	  } else {
	    return undefined;
	  }
	})();

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 33 */
/***/ function(module, exports) {

	
	/**
	 * Expose `Emitter`.
	 */

	module.exports = Emitter;

	/**
	 * Initialize a new `Emitter`.
	 *
	 * @api public
	 */

	function Emitter(obj) {
	  if (obj) return mixin(obj);
	};

	/**
	 * Mixin the emitter properties.
	 *
	 * @param {Object} obj
	 * @return {Object}
	 * @api private
	 */

	function mixin(obj) {
	  for (var key in Emitter.prototype) {
	    obj[key] = Emitter.prototype[key];
	  }
	  return obj;
	}

	/**
	 * Listen on the given `event` with `fn`.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */

	Emitter.prototype.on =
	Emitter.prototype.addEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};
	  (this._callbacks[event] = this._callbacks[event] || [])
	    .push(fn);
	  return this;
	};

	/**
	 * Adds an `event` listener that will be invoked a single
	 * time then automatically removed.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */

	Emitter.prototype.once = function(event, fn){
	  var self = this;
	  this._callbacks = this._callbacks || {};

	  function on() {
	    self.off(event, on);
	    fn.apply(this, arguments);
	  }

	  on.fn = fn;
	  this.on(event, on);
	  return this;
	};

	/**
	 * Remove the given callback for `event` or all
	 * registered callbacks.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */

	Emitter.prototype.off =
	Emitter.prototype.removeListener =
	Emitter.prototype.removeAllListeners =
	Emitter.prototype.removeEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};

	  // all
	  if (0 == arguments.length) {
	    this._callbacks = {};
	    return this;
	  }

	  // specific event
	  var callbacks = this._callbacks[event];
	  if (!callbacks) return this;

	  // remove all handlers
	  if (1 == arguments.length) {
	    delete this._callbacks[event];
	    return this;
	  }

	  // remove specific handler
	  var cb;
	  for (var i = 0; i < callbacks.length; i++) {
	    cb = callbacks[i];
	    if (cb === fn || cb.fn === fn) {
	      callbacks.splice(i, 1);
	      break;
	    }
	  }
	  return this;
	};

	/**
	 * Emit `event` with the given args.
	 *
	 * @param {String} event
	 * @param {Mixed} ...
	 * @return {Emitter}
	 */

	Emitter.prototype.emit = function(event){
	  this._callbacks = this._callbacks || {};
	  var args = [].slice.call(arguments, 1)
	    , callbacks = this._callbacks[event];

	  if (callbacks) {
	    callbacks = callbacks.slice(0);
	    for (var i = 0, len = callbacks.length; i < len; ++i) {
	      callbacks[i].apply(this, args);
	    }
	  }

	  return this;
	};

	/**
	 * Return array of callbacks for `event`.
	 *
	 * @param {String} event
	 * @return {Array}
	 * @api public
	 */

	Emitter.prototype.listeners = function(event){
	  this._callbacks = this._callbacks || {};
	  return this._callbacks[event] || [];
	};

	/**
	 * Check if this emitter has `event` handlers.
	 *
	 * @param {String} event
	 * @return {Boolean}
	 * @api public
	 */

	Emitter.prototype.hasListeners = function(event){
	  return !! this.listeners(event).length;
	};


/***/ },
/* 34 */
/***/ function(module, exports) {

	/**
	 * Compiles a querystring
	 * Returns string representation of the object
	 *
	 * @param {Object}
	 * @api private
	 */

	exports.encode = function (obj) {
	  var str = '';

	  for (var i in obj) {
	    if (obj.hasOwnProperty(i)) {
	      if (str.length) str += '&';
	      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
	    }
	  }

	  return str;
	};

	/**
	 * Parses a simple querystring into an object
	 *
	 * @param {String} qs
	 * @api private
	 */

	exports.decode = function(qs){
	  var qry = {};
	  var pairs = qs.split('&');
	  for (var i = 0, l = pairs.length; i < l; i++) {
	    var pair = pairs[i].split('=');
	    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
	  }
	  return qry;
	};


/***/ },
/* 35 */
/***/ function(module, exports) {

	
	module.exports = function(a, b){
	  var fn = function(){};
	  fn.prototype = b.prototype;
	  a.prototype = new fn;
	  a.prototype.constructor = a;
	};

/***/ },
/* 36 */
/***/ function(module, exports) {

	'use strict';

	var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('')
	  , length = 64
	  , map = {}
	  , seed = 0
	  , i = 0
	  , prev;

	/**
	 * Return a string representing the specified number.
	 *
	 * @param {Number} num The number to convert.
	 * @returns {String} The string representation of the number.
	 * @api public
	 */
	function encode(num) {
	  var encoded = '';

	  do {
	    encoded = alphabet[num % length] + encoded;
	    num = Math.floor(num / length);
	  } while (num > 0);

	  return encoded;
	}

	/**
	 * Return the integer value specified by the given string.
	 *
	 * @param {String} str The string to convert.
	 * @returns {Number} The integer value represented by the string.
	 * @api public
	 */
	function decode(str) {
	  var decoded = 0;

	  for (i = 0; i < str.length; i++) {
	    decoded = decoded * length + map[str.charAt(i)];
	  }

	  return decoded;
	}

	/**
	 * Yeast: A tiny growing id generator.
	 *
	 * @returns {String} A unique id.
	 * @api public
	 */
	function yeast() {
	  var now = encode(+new Date());

	  if (now !== prev) return seed = 0, prev = now;
	  return now +'.'+ encode(seed++);
	}

	//
	// Map each character to its index.
	//
	for (; i < length; i++) map[alphabet[i]] = i;

	//
	// Expose the `yeast`, `encode` and `decode` functions.
	//
	yeast.encode = encode;
	yeast.decode = decode;
	module.exports = yeast;


/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {
	/**
	 * Module requirements.
	 */

	var Polling = __webpack_require__(22);
	var inherit = __webpack_require__(35);

	/**
	 * Module exports.
	 */

	module.exports = JSONPPolling;

	/**
	 * Cached regular expressions.
	 */

	var rNewline = /\n/g;
	var rEscapedNewline = /\\n/g;

	/**
	 * Global JSONP callbacks.
	 */

	var callbacks;

	/**
	 * Callbacks count.
	 */

	var index = 0;

	/**
	 * Noop.
	 */

	function empty () { }

	/**
	 * JSONP Polling constructor.
	 *
	 * @param {Object} opts.
	 * @api public
	 */

	function JSONPPolling (opts) {
	  Polling.call(this, opts);

	  this.query = this.query || {};

	  // define global callbacks array if not present
	  // we do this here (lazily) to avoid unneeded global pollution
	  if (!callbacks) {
	    // we need to consider multiple engines in the same page
	    if (!global.___eio) global.___eio = [];
	    callbacks = global.___eio;
	  }

	  // callback identifier
	  this.index = callbacks.length;

	  // add callback to jsonp global
	  var self = this;
	  callbacks.push(function (msg) {
	    self.onData(msg);
	  });

	  // append to query string
	  this.query.j = this.index;

	  // prevent spurious errors from being emitted when the window is unloaded
	  if (global.document && global.addEventListener) {
	    global.addEventListener('beforeunload', function () {
	      if (self.script) self.script.onerror = empty;
	    }, false);
	  }
	}

	/**
	 * Inherits from Polling.
	 */

	inherit(JSONPPolling, Polling);

	/*
	 * JSONP only supports binary as base64 encoded strings
	 */

	JSONPPolling.prototype.supportsBinary = false;

	/**
	 * Closes the socket.
	 *
	 * @api private
	 */

	JSONPPolling.prototype.doClose = function () {
	  if (this.script) {
	    this.script.parentNode.removeChild(this.script);
	    this.script = null;
	  }

	  if (this.form) {
	    this.form.parentNode.removeChild(this.form);
	    this.form = null;
	    this.iframe = null;
	  }

	  Polling.prototype.doClose.call(this);
	};

	/**
	 * Starts a poll cycle.
	 *
	 * @api private
	 */

	JSONPPolling.prototype.doPoll = function () {
	  var self = this;
	  var script = document.createElement('script');

	  if (this.script) {
	    this.script.parentNode.removeChild(this.script);
	    this.script = null;
	  }

	  script.async = true;
	  script.src = this.uri();
	  script.onerror = function(e){
	    self.onError('jsonp poll error',e);
	  };

	  var insertAt = document.getElementsByTagName('script')[0];
	  if (insertAt) {
	    insertAt.parentNode.insertBefore(script, insertAt);
	  }
	  else {
	    (document.head || document.body).appendChild(script);
	  }
	  this.script = script;

	  var isUAgecko = 'undefined' != typeof navigator && /gecko/i.test(navigator.userAgent);
	  
	  if (isUAgecko) {
	    setTimeout(function () {
	      var iframe = document.createElement('iframe');
	      document.body.appendChild(iframe);
	      document.body.removeChild(iframe);
	    }, 100);
	  }
	};

	/**
	 * Writes with a hidden iframe.
	 *
	 * @param {String} data to send
	 * @param {Function} called upon flush.
	 * @api private
	 */

	JSONPPolling.prototype.doWrite = function (data, fn) {
	  var self = this;

	  if (!this.form) {
	    var form = document.createElement('form');
	    var area = document.createElement('textarea');
	    var id = this.iframeId = 'eio_iframe_' + this.index;
	    var iframe;

	    form.className = 'socketio';
	    form.style.position = 'absolute';
	    form.style.top = '-1000px';
	    form.style.left = '-1000px';
	    form.target = id;
	    form.method = 'POST';
	    form.setAttribute('accept-charset', 'utf-8');
	    area.name = 'd';
	    form.appendChild(area);
	    document.body.appendChild(form);

	    this.form = form;
	    this.area = area;
	  }

	  this.form.action = this.uri();

	  function complete () {
	    initIframe();
	    fn();
	  }

	  function initIframe () {
	    if (self.iframe) {
	      try {
	        self.form.removeChild(self.iframe);
	      } catch (e) {
	        self.onError('jsonp polling iframe removal error', e);
	      }
	    }

	    try {
	      // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
	      var html = '<iframe src="javascript:0" name="'+ self.iframeId +'">';
	      iframe = document.createElement(html);
	    } catch (e) {
	      iframe = document.createElement('iframe');
	      iframe.name = self.iframeId;
	      iframe.src = 'javascript:0';
	    }

	    iframe.id = self.iframeId;

	    self.form.appendChild(iframe);
	    self.iframe = iframe;
	  }

	  initIframe();

	  // escape \n to prevent it from being converted into \r\n by some UAs
	  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
	  data = data.replace(rEscapedNewline, '\\\n');
	  this.area.value = data.replace(rNewline, '\\n');

	  try {
	    this.form.submit();
	  } catch(e) {}

	  if (this.iframe.attachEvent) {
	    this.iframe.onreadystatechange = function(){
	      if (self.iframe.readyState == 'complete') {
	        complete();
	      }
	    };
	  } else {
	    this.iframe.onload = complete;
	  }
	};

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Module dependencies.
	 */

	var Transport = __webpack_require__(23);
	var parser = __webpack_require__(24);
	var parseqs = __webpack_require__(34);
	var inherit = __webpack_require__(35);
	var yeast = __webpack_require__(36);
	var debug = __webpack_require__(3)('engine.io-client:websocket');
	var BrowserWebSocket = global.WebSocket || global.MozWebSocket;

	/**
	 * Get either the `WebSocket` or `MozWebSocket` globals
	 * in the browser or try to resolve WebSocket-compatible
	 * interface exposed by `ws` for Node-like environment.
	 */

	var WebSocket = BrowserWebSocket;
	if (!WebSocket && typeof window === 'undefined') {
	  try {
	    WebSocket = __webpack_require__(39);
	  } catch (e) { }
	}

	/**
	 * Module exports.
	 */

	module.exports = WS;

	/**
	 * WebSocket transport constructor.
	 *
	 * @api {Object} connection options
	 * @api public
	 */

	function WS(opts){
	  var forceBase64 = (opts && opts.forceBase64);
	  if (forceBase64) {
	    this.supportsBinary = false;
	  }
	  this.perMessageDeflate = opts.perMessageDeflate;
	  Transport.call(this, opts);
	}

	/**
	 * Inherits from Transport.
	 */

	inherit(WS, Transport);

	/**
	 * Transport name.
	 *
	 * @api public
	 */

	WS.prototype.name = 'websocket';

	/*
	 * WebSockets support binary
	 */

	WS.prototype.supportsBinary = true;

	/**
	 * Opens socket.
	 *
	 * @api private
	 */

	WS.prototype.doOpen = function(){
	  if (!this.check()) {
	    // let probe timeout
	    return;
	  }

	  var self = this;
	  var uri = this.uri();
	  var protocols = void(0);
	  var opts = {
	    agent: this.agent,
	    perMessageDeflate: this.perMessageDeflate
	  };

	  // SSL options for Node.js client
	  opts.pfx = this.pfx;
	  opts.key = this.key;
	  opts.passphrase = this.passphrase;
	  opts.cert = this.cert;
	  opts.ca = this.ca;
	  opts.ciphers = this.ciphers;
	  opts.rejectUnauthorized = this.rejectUnauthorized;
	  if (this.extraHeaders) {
	    opts.headers = this.extraHeaders;
	  }

	  this.ws = BrowserWebSocket ? new WebSocket(uri) : new WebSocket(uri, protocols, opts);

	  if (this.ws.binaryType === undefined) {
	    this.supportsBinary = false;
	  }

	  if (this.ws.supports && this.ws.supports.binary) {
	    this.supportsBinary = true;
	    this.ws.binaryType = 'buffer';
	  } else {
	    this.ws.binaryType = 'arraybuffer';
	  }

	  this.addEventListeners();
	};

	/**
	 * Adds event listeners to the socket
	 *
	 * @api private
	 */

	WS.prototype.addEventListeners = function(){
	  var self = this;

	  this.ws.onopen = function(){
	    self.onOpen();
	  };
	  this.ws.onclose = function(){
	    self.onClose();
	  };
	  this.ws.onmessage = function(ev){
	    self.onData(ev.data);
	  };
	  this.ws.onerror = function(e){
	    self.onError('websocket error', e);
	  };
	};

	/**
	 * Override `onData` to use a timer on iOS.
	 * See: https://gist.github.com/mloughran/2052006
	 *
	 * @api private
	 */

	if ('undefined' != typeof navigator
	  && /iPad|iPhone|iPod/i.test(navigator.userAgent)) {
	  WS.prototype.onData = function(data){
	    var self = this;
	    setTimeout(function(){
	      Transport.prototype.onData.call(self, data);
	    }, 0);
	  };
	}

	/**
	 * Writes data to socket.
	 *
	 * @param {Array} array of packets.
	 * @api private
	 */

	WS.prototype.write = function(packets){
	  var self = this;
	  this.writable = false;

	  // encodePacket efficient as it uses WS framing
	  // no need for encodePayload
	  var total = packets.length;
	  for (var i = 0, l = total; i < l; i++) {
	    (function(packet) {
	      parser.encodePacket(packet, self.supportsBinary, function(data) {
	        if (!BrowserWebSocket) {
	          // always create a new object (GH-437)
	          var opts = {};
	          if (packet.options) {
	            opts.compress = packet.options.compress;
	          }

	          if (self.perMessageDeflate) {
	            var len = 'string' == typeof data ? global.Buffer.byteLength(data) : data.length;
	            if (len < self.perMessageDeflate.threshold) {
	              opts.compress = false;
	            }
	          }
	        }

	        //Sometimes the websocket has already been closed but the browser didn't
	        //have a chance of informing us about it yet, in that case send will
	        //throw an error
	        try {
	          if (BrowserWebSocket) {
	            // TypeError is thrown when passing the second argument on Safari
	            self.ws.send(data);
	          } else {
	            self.ws.send(data, opts);
	          }
	        } catch (e){
	          debug('websocket closed before onclose event');
	        }

	        --total || done();
	      });
	    })(packets[i]);
	  }

	  function done(){
	    self.emit('flush');

	    // fake drain
	    // defer to next tick to allow Socket to clear writeBuffer
	    setTimeout(function(){
	      self.writable = true;
	      self.emit('drain');
	    }, 0);
	  }
	};

	/**
	 * Called upon close
	 *
	 * @api private
	 */

	WS.prototype.onClose = function(){
	  Transport.prototype.onClose.call(this);
	};

	/**
	 * Closes socket.
	 *
	 * @api private
	 */

	WS.prototype.doClose = function(){
	  if (typeof this.ws !== 'undefined') {
	    this.ws.close();
	  }
	};

	/**
	 * Generates uri for connection.
	 *
	 * @api private
	 */

	WS.prototype.uri = function(){
	  var query = this.query || {};
	  var schema = this.secure ? 'wss' : 'ws';
	  var port = '';

	  // avoid port if default for schema
	  if (this.port && (('wss' == schema && this.port != 443)
	    || ('ws' == schema && this.port != 80))) {
	    port = ':' + this.port;
	  }

	  // append timestamp to URI
	  if (this.timestampRequests) {
	    query[this.timestampParam] = yeast();
	  }

	  // communicate binary support capabilities
	  if (!this.supportsBinary) {
	    query.b64 = 1;
	  }

	  query = parseqs.encode(query);

	  // prepend ? to query
	  if (query.length) {
	    query = '?' + query;
	  }

	  var ipv6 = this.hostname.indexOf(':') !== -1;
	  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
	};

	/**
	 * Feature detection for WebSocket.
	 *
	 * @return {Boolean} whether this transport is available.
	 * @api public
	 */

	WS.prototype.check = function(){
	  return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);
	};

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 39 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 40 */
/***/ function(module, exports) {

	
	var indexOf = [].indexOf;

	module.exports = function(arr, obj){
	  if (indexOf) return arr.indexOf(obj);
	  for (var i = 0; i < arr.length; ++i) {
	    if (arr[i] === obj) return i;
	  }
	  return -1;
	};

/***/ },
/* 41 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * JSON parse.
	 *
	 * @see Based on jQuery#parseJSON (MIT) and JSON2
	 * @api private
	 */

	var rvalidchars = /^[\],:{}\s]*$/;
	var rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
	var rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
	var rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g;
	var rtrimLeft = /^\s+/;
	var rtrimRight = /\s+$/;

	module.exports = function parsejson(data) {
	  if ('string' != typeof data || !data) {
	    return null;
	  }

	  data = data.replace(rtrimLeft, '').replace(rtrimRight, '');

	  // Attempt to parse using the native JSON parser first
	  if (global.JSON && JSON.parse) {
	    return JSON.parse(data);
	  }

	  if (rvalidchars.test(data.replace(rvalidescape, '@')
	      .replace(rvalidtokens, ']')
	      .replace(rvalidbraces, ''))) {
	    return (new Function('return ' + data))();
	  }
	};
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Module dependencies.
	 */

	var parser = __webpack_require__(6);
	var Emitter = __webpack_require__(43);
	var toArray = __webpack_require__(44);
	var on = __webpack_require__(45);
	var bind = __webpack_require__(46);
	var debug = __webpack_require__(3)('socket.io-client:socket');
	var hasBin = __webpack_require__(47);

	/**
	 * Module exports.
	 */

	module.exports = exports = Socket;

	/**
	 * Internal events (blacklisted).
	 * These events can't be emitted by the user.
	 *
	 * @api private
	 */

	var events = {
	  connect: 1,
	  connect_error: 1,
	  connect_timeout: 1,
	  connecting: 1,
	  disconnect: 1,
	  error: 1,
	  reconnect: 1,
	  reconnect_attempt: 1,
	  reconnect_failed: 1,
	  reconnect_error: 1,
	  reconnecting: 1,
	  ping: 1,
	  pong: 1
	};

	/**
	 * Shortcut to `Emitter#emit`.
	 */

	var emit = Emitter.prototype.emit;

	/**
	 * `Socket` constructor.
	 *
	 * @api public
	 */

	function Socket(io, nsp, opts) {
	  this.io = io;
	  this.nsp = nsp;
	  this.json = this; // compat
	  this.ids = 0;
	  this.acks = {};
	  this.receiveBuffer = [];
	  this.sendBuffer = [];
	  this.connected = false;
	  this.disconnected = true;
	  if (opts && opts.query) {
	    this.query = opts.query;
	  }
	  if (this.io.autoConnect) this.open();
	}

	/**
	 * Mix in `Emitter`.
	 */

	Emitter(Socket.prototype);

	/**
	 * Subscribe to open, close and packet events
	 *
	 * @api private
	 */

	Socket.prototype.subEvents = function () {
	  if (this.subs) return;

	  var io = this.io;
	  this.subs = [on(io, 'open', bind(this, 'onopen')), on(io, 'packet', bind(this, 'onpacket')), on(io, 'close', bind(this, 'onclose'))];
	};

	/**
	 * "Opens" the socket.
	 *
	 * @api public
	 */

	Socket.prototype.open = Socket.prototype.connect = function () {
	  if (this.connected) return this;

	  this.subEvents();
	  this.io.open(); // ensure open
	  if ('open' === this.io.readyState) this.onopen();
	  this.emit('connecting');
	  return this;
	};

	/**
	 * Sends a `message` event.
	 *
	 * @return {Socket} self
	 * @api public
	 */

	Socket.prototype.send = function () {
	  var args = toArray(arguments);
	  args.unshift('message');
	  this.emit.apply(this, args);
	  return this;
	};

	/**
	 * Override `emit`.
	 * If the event is in `events`, it's emitted normally.
	 *
	 * @param {String} event name
	 * @return {Socket} self
	 * @api public
	 */

	Socket.prototype.emit = function (ev) {
	  if (events.hasOwnProperty(ev)) {
	    emit.apply(this, arguments);
	    return this;
	  }

	  var args = toArray(arguments);
	  var parserType = parser.EVENT; // default
	  if (hasBin(args)) {
	    parserType = parser.BINARY_EVENT;
	  } // binary
	  var packet = { type: parserType, data: args };

	  packet.options = {};
	  packet.options.compress = !this.flags || false !== this.flags.compress;

	  // event ack callback
	  if ('function' === typeof args[args.length - 1]) {
	    debug('emitting packet with ack id %d', this.ids);
	    this.acks[this.ids] = args.pop();
	    packet.id = this.ids++;
	  }

	  if (this.connected) {
	    this.packet(packet);
	  } else {
	    this.sendBuffer.push(packet);
	  }

	  delete this.flags;

	  return this;
	};

	/**
	 * Sends a packet.
	 *
	 * @param {Object} packet
	 * @api private
	 */

	Socket.prototype.packet = function (packet) {
	  packet.nsp = this.nsp;
	  this.io.packet(packet);
	};

	/**
	 * Called upon engine `open`.
	 *
	 * @api private
	 */

	Socket.prototype.onopen = function () {
	  debug('transport is open - connecting');

	  // write connect packet if necessary
	  if ('/' !== this.nsp) {
	    if (this.query) {
	      this.packet({ type: parser.CONNECT, query: this.query });
	    } else {
	      this.packet({ type: parser.CONNECT });
	    }
	  }
	};

	/**
	 * Called upon engine `close`.
	 *
	 * @param {String} reason
	 * @api private
	 */

	Socket.prototype.onclose = function (reason) {
	  debug('close (%s)', reason);
	  this.connected = false;
	  this.disconnected = true;
	  delete this.id;
	  this.emit('disconnect', reason);
	};

	/**
	 * Called with socket packet.
	 *
	 * @param {Object} packet
	 * @api private
	 */

	Socket.prototype.onpacket = function (packet) {
	  if (packet.nsp !== this.nsp) return;

	  switch (packet.type) {
	    case parser.CONNECT:
	      this.onconnect();
	      break;

	    case parser.EVENT:
	      this.onevent(packet);
	      break;

	    case parser.BINARY_EVENT:
	      this.onevent(packet);
	      break;

	    case parser.ACK:
	      this.onack(packet);
	      break;

	    case parser.BINARY_ACK:
	      this.onack(packet);
	      break;

	    case parser.DISCONNECT:
	      this.ondisconnect();
	      break;

	    case parser.ERROR:
	      this.emit('error', packet.data);
	      break;
	  }
	};

	/**
	 * Called upon a server event.
	 *
	 * @param {Object} packet
	 * @api private
	 */

	Socket.prototype.onevent = function (packet) {
	  var args = packet.data || [];
	  debug('emitting event %j', args);

	  if (null != packet.id) {
	    debug('attaching ack callback to event');
	    args.push(this.ack(packet.id));
	  }

	  if (this.connected) {
	    emit.apply(this, args);
	  } else {
	    this.receiveBuffer.push(args);
	  }
	};

	/**
	 * Produces an ack callback to emit with an event.
	 *
	 * @api private
	 */

	Socket.prototype.ack = function (id) {
	  var self = this;
	  var sent = false;
	  return function () {
	    // prevent double callbacks
	    if (sent) return;
	    sent = true;
	    var args = toArray(arguments);
	    debug('sending ack %j', args);

	    var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;
	    self.packet({
	      type: type,
	      id: id,
	      data: args
	    });
	  };
	};

	/**
	 * Called upon a server acknowlegement.
	 *
	 * @param {Object} packet
	 * @api private
	 */

	Socket.prototype.onack = function (packet) {
	  var ack = this.acks[packet.id];
	  if ('function' === typeof ack) {
	    debug('calling ack %s with %j', packet.id, packet.data);
	    ack.apply(this, packet.data);
	    delete this.acks[packet.id];
	  } else {
	    debug('bad ack %s', packet.id);
	  }
	};

	/**
	 * Called upon server connect.
	 *
	 * @api private
	 */

	Socket.prototype.onconnect = function () {
	  this.connected = true;
	  this.disconnected = false;
	  this.emit('connect');
	  this.emitBuffered();
	};

	/**
	 * Emit buffered events (received and emitted).
	 *
	 * @api private
	 */

	Socket.prototype.emitBuffered = function () {
	  var i;
	  for (i = 0; i < this.receiveBuffer.length; i++) {
	    emit.apply(this, this.receiveBuffer[i]);
	  }
	  this.receiveBuffer = [];

	  for (i = 0; i < this.sendBuffer.length; i++) {
	    this.packet(this.sendBuffer[i]);
	  }
	  this.sendBuffer = [];
	};

	/**
	 * Called upon server disconnect.
	 *
	 * @api private
	 */

	Socket.prototype.ondisconnect = function () {
	  debug('server disconnect (%s)', this.nsp);
	  this.destroy();
	  this.onclose('io server disconnect');
	};

	/**
	 * Called upon forced client/server side disconnections,
	 * this method ensures the manager stops tracking us and
	 * that reconnections don't get triggered for this.
	 *
	 * @api private.
	 */

	Socket.prototype.destroy = function () {
	  if (this.subs) {
	    // clean subscriptions to avoid reconnections
	    for (var i = 0; i < this.subs.length; i++) {
	      this.subs[i].destroy();
	    }
	    this.subs = null;
	  }

	  this.io.destroy(this);
	};

	/**
	 * Disconnects the socket manually.
	 *
	 * @return {Socket} self
	 * @api public
	 */

	Socket.prototype.close = Socket.prototype.disconnect = function () {
	  if (this.connected) {
	    debug('performing disconnect (%s)', this.nsp);
	    this.packet({ type: parser.DISCONNECT });
	  }

	  // remove socket from pool
	  this.destroy();

	  if (this.connected) {
	    // fire events
	    this.onclose('io client disconnect');
	  }
	  return this;
	};

	/**
	 * Sets the compress flag.
	 *
	 * @param {Boolean} if `true`, compresses the sending data
	 * @return {Socket} self
	 * @api public
	 */

	Socket.prototype.compress = function (compress) {
	  this.flags = this.flags || {};
	  this.flags.compress = compress;
	  return this;
	};

/***/ },
/* 43 */
/***/ function(module, exports) {

	
	/**
	 * Expose `Emitter`.
	 */

	module.exports = Emitter;

	/**
	 * Initialize a new `Emitter`.
	 *
	 * @api public
	 */

	function Emitter(obj) {
	  if (obj) return mixin(obj);
	};

	/**
	 * Mixin the emitter properties.
	 *
	 * @param {Object} obj
	 * @return {Object}
	 * @api private
	 */

	function mixin(obj) {
	  for (var key in Emitter.prototype) {
	    obj[key] = Emitter.prototype[key];
	  }
	  return obj;
	}

	/**
	 * Listen on the given `event` with `fn`.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */

	Emitter.prototype.on =
	Emitter.prototype.addEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};
	  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
	    .push(fn);
	  return this;
	};

	/**
	 * Adds an `event` listener that will be invoked a single
	 * time then automatically removed.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */

	Emitter.prototype.once = function(event, fn){
	  function on() {
	    this.off(event, on);
	    fn.apply(this, arguments);
	  }

	  on.fn = fn;
	  this.on(event, on);
	  return this;
	};

	/**
	 * Remove the given callback for `event` or all
	 * registered callbacks.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */

	Emitter.prototype.off =
	Emitter.prototype.removeListener =
	Emitter.prototype.removeAllListeners =
	Emitter.prototype.removeEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};

	  // all
	  if (0 == arguments.length) {
	    this._callbacks = {};
	    return this;
	  }

	  // specific event
	  var callbacks = this._callbacks['$' + event];
	  if (!callbacks) return this;

	  // remove all handlers
	  if (1 == arguments.length) {
	    delete this._callbacks['$' + event];
	    return this;
	  }

	  // remove specific handler
	  var cb;
	  for (var i = 0; i < callbacks.length; i++) {
	    cb = callbacks[i];
	    if (cb === fn || cb.fn === fn) {
	      callbacks.splice(i, 1);
	      break;
	    }
	  }
	  return this;
	};

	/**
	 * Emit `event` with the given args.
	 *
	 * @param {String} event
	 * @param {Mixed} ...
	 * @return {Emitter}
	 */

	Emitter.prototype.emit = function(event){
	  this._callbacks = this._callbacks || {};
	  var args = [].slice.call(arguments, 1)
	    , callbacks = this._callbacks['$' + event];

	  if (callbacks) {
	    callbacks = callbacks.slice(0);
	    for (var i = 0, len = callbacks.length; i < len; ++i) {
	      callbacks[i].apply(this, args);
	    }
	  }

	  return this;
	};

	/**
	 * Return array of callbacks for `event`.
	 *
	 * @param {String} event
	 * @return {Array}
	 * @api public
	 */

	Emitter.prototype.listeners = function(event){
	  this._callbacks = this._callbacks || {};
	  return this._callbacks['$' + event] || [];
	};

	/**
	 * Check if this emitter has `event` handlers.
	 *
	 * @param {String} event
	 * @return {Boolean}
	 * @api public
	 */

	Emitter.prototype.hasListeners = function(event){
	  return !! this.listeners(event).length;
	};


/***/ },
/* 44 */
/***/ function(module, exports) {

	module.exports = toArray

	function toArray(list, index) {
	    var array = []

	    index = index || 0

	    for (var i = index || 0; i < list.length; i++) {
	        array[i - index] = list[i]
	    }

	    return array
	}


/***/ },
/* 45 */
/***/ function(module, exports) {

	"use strict";

	/**
	 * Module exports.
	 */

	module.exports = on;

	/**
	 * Helper for subscriptions.
	 *
	 * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
	 * @param {String} event name
	 * @param {Function} callback
	 * @api public
	 */

	function on(obj, ev, fn) {
	  obj.on(ev, fn);
	  return {
	    destroy: function destroy() {
	      obj.removeListener(ev, fn);
	    }
	  };
	}

/***/ },
/* 46 */
/***/ function(module, exports) {

	/**
	 * Slice reference.
	 */

	var slice = [].slice;

	/**
	 * Bind `obj` to `fn`.
	 *
	 * @param {Object} obj
	 * @param {Function|String} fn or string
	 * @return {Function}
	 * @api public
	 */

	module.exports = function(obj, fn){
	  if ('string' == typeof fn) fn = obj[fn];
	  if ('function' != typeof fn) throw new Error('bind() requires a function');
	  var args = slice.call(arguments, 2);
	  return function(){
	    return fn.apply(obj, args.concat(slice.call(arguments)));
	  }
	};


/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {
	/*
	 * Module requirements.
	 */

	var isArray = __webpack_require__(48);

	/**
	 * Module exports.
	 */

	module.exports = hasBinary;

	/**
	 * Checks for binary data.
	 *
	 * Right now only Buffer and ArrayBuffer are supported..
	 *
	 * @param {Object} anything
	 * @api public
	 */

	function hasBinary(data) {

	  function _hasBinary(obj) {
	    if (!obj) return false;

	    if ( (global.Buffer && global.Buffer.isBuffer && global.Buffer.isBuffer(obj)) ||
	         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||
	         (global.Blob && obj instanceof Blob) ||
	         (global.File && obj instanceof File)
	        ) {
	      return true;
	    }

	    if (isArray(obj)) {
	      for (var i = 0; i < obj.length; i++) {
	          if (_hasBinary(obj[i])) {
	              return true;
	          }
	      }
	    } else if (obj && 'object' == typeof obj) {
	      // see: https://github.com/Automattic/has-binary/pull/4
	      if (obj.toJSON && 'function' == typeof obj.toJSON) {
	        obj = obj.toJSON();
	      }

	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {
	          return true;
	        }
	      }
	    }

	    return false;
	  }

	  return _hasBinary(data);
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 48 */
/***/ function(module, exports) {

	module.exports = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};


/***/ },
/* 49 */
/***/ function(module, exports) {

	
	/**
	 * Expose `Backoff`.
	 */

	module.exports = Backoff;

	/**
	 * Initialize backoff timer with `opts`.
	 *
	 * - `min` initial timeout in milliseconds [100]
	 * - `max` max timeout [10000]
	 * - `jitter` [0]
	 * - `factor` [2]
	 *
	 * @param {Object} opts
	 * @api public
	 */

	function Backoff(opts) {
	  opts = opts || {};
	  this.ms = opts.min || 100;
	  this.max = opts.max || 10000;
	  this.factor = opts.factor || 2;
	  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
	  this.attempts = 0;
	}

	/**
	 * Return the backoff duration.
	 *
	 * @return {Number}
	 * @api public
	 */

	Backoff.prototype.duration = function(){
	  var ms = this.ms * Math.pow(this.factor, this.attempts++);
	  if (this.jitter) {
	    var rand =  Math.random();
	    var deviation = Math.floor(rand * this.jitter * ms);
	    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
	  }
	  return Math.min(ms, this.max) | 0;
	};

	/**
	 * Reset the number of attempts.
	 *
	 * @api public
	 */

	Backoff.prototype.reset = function(){
	  this.attempts = 0;
	};

	/**
	 * Set the minimum duration
	 *
	 * @api public
	 */

	Backoff.prototype.setMin = function(min){
	  this.ms = min;
	};

	/**
	 * Set the maximum duration
	 *
	 * @api public
	 */

	Backoff.prototype.setMax = function(max){
	  this.max = max;
	};

	/**
	 * Set the jitter
	 *
	 * @api public
	 */

	Backoff.prototype.setJitter = function(jitter){
	  this.jitter = jitter;
	};



/***/ }
/******/ ])
});
;
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.wedeploy = global.wedeploy || {})));
}(this, (function (exports) { 'use strict';

var globals = {};

if (typeof window !== 'undefined') {
	globals.window = window;
}

if (typeof document !== 'undefined') {
	globals.document = document;
}

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};





var asyncGenerator = function () {
  function AwaitValue(value) {
    this.value = value;
  }

  function AsyncGenerator(gen) {
    var front, back;

    function send(key, arg) {
      return new Promise(function (resolve, reject) {
        var request = {
          key: key,
          arg: arg,
          resolve: resolve,
          reject: reject,
          next: null
        };

        if (back) {
          back = back.next = request;
        } else {
          front = back = request;
          resume(key, arg);
        }
      });
    }

    function resume(key, arg) {
      try {
        var result = gen[key](arg);
        var value = result.value;

        if (value instanceof AwaitValue) {
          Promise.resolve(value.value).then(function (arg) {
            resume("next", arg);
          }, function (arg) {
            resume("throw", arg);
          });
        } else {
          settle(result.done ? "return" : "normal", result.value);
        }
      } catch (err) {
        settle("throw", err);
      }
    }

    function settle(type, value) {
      switch (type) {
        case "return":
          front.resolve({
            value: value,
            done: true
          });
          break;

        case "throw":
          front.reject(value);
          break;

        default:
          front.resolve({
            value: value,
            done: false
          });
          break;
      }

      front = front.next;

      if (front) {
        resume(front.key, front.arg);
      } else {
        back = null;
      }
    }

    this._invoke = send;

    if (typeof gen.return !== "function") {
      this.return = undefined;
    }
  }

  if (typeof Symbol === "function" && Symbol.asyncIterator) {
    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {
      return this;
    };
  }

  AsyncGenerator.prototype.next = function (arg) {
    return this._invoke("next", arg);
  };

  AsyncGenerator.prototype.throw = function (arg) {
    return this._invoke("throw", arg);
  };

  AsyncGenerator.prototype.return = function (arg) {
    return this._invoke("return", arg);
  };

  return {
    wrap: function (fn) {
      return function () {
        return new AsyncGenerator(fn.apply(this, arguments));
      };
    },
    await: function (value) {
      return new AwaitValue(value);
    }
  };
}();





var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var get$1 = function get$1(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get$1(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};



var set$1 = function set$1(object, property, value, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent !== null) {
      set$1(parent, property, value, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    desc.value = value;
  } else {
    var setter = desc.set;

    if (setter !== undefined) {
      setter.call(receiver, value);
    }
  }

  return value;
};

var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();













var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

/**
 * A collection of core utility functions.
 * @const
 */

var compatibilityModeData_ = void 0;

/**
 * Counter for unique id.
 * @type {Number}
 * @private
 */
var uniqueIdCounter_ = 1;

/**
 * Unique id property prefix.
 * @type {String}
 * @protected
 */
var UID_PROPERTY = 'core_' + (Math.random() * 1e9 >>> 0);

/**
 * When defining a class Foo with an abstract method bar(), you can do:
 * Foo.prototype.bar = abstractMethod
 *
 * Now if a subclass of Foo fails to override bar(), an error will be thrown
 * when bar() is invoked.
 *
 * @type {!Function}
 * @throws {Error} when invoked to indicate the method should be overridden.
 */
function abstractMethod() {
  throw Error('Unimplemented abstract method');
}

/**
 * Loops constructor super classes collecting its properties values. If
 * property is not available on the super class `undefined` will be
 * collected as value for the class hierarchy position.
 * @param {!function()} constructor Class constructor.
 * @param {string} propertyName Property name to be collected.
 * @return {Array.<*>} Array of collected values.
 * TODO(*): Rethink superclass loop.
 */
function collectSuperClassesProperty(constructor, propertyName) {
  var propertyValues = [constructor[propertyName]];
  while (constructor.__proto__ && !constructor.__proto__.isPrototypeOf(Function)) {
    constructor = constructor.__proto__;
    propertyValues.push(constructor[propertyName]);
  }
  return propertyValues;
}

/**
 * Disables Metal.js's compatibility mode.
 */
function disableCompatibilityMode() {
  compatibilityModeData_ = null;
}

/**
 * Enables Metal.js's compatibility mode with the following features from rc
 * and 1.x versions:
 *     - Using "key" to reference component instances. In the current version
 *       this should be done via "ref" instead. This allows old code still
 *       using "key" to keep working like before. NOTE: this may cause
 *       problems, since "key" is meant to be used differently. Only use this
 *       if it's not possible to upgrade the code to use "ref" instead.
 * @param {Object=} opt_data Optional object with data to specify more
 *     details, such as:
 *         - renderers {Array} the template renderers that should be in
 *           compatibility mode, either their constructors or strings
 *           representing them (e.g. 'soy' or 'jsx'). By default, all the ones
 *           that extend from IncrementalDomRenderer.
 * @type {Object}
 */
function enableCompatibilityMode() {
  var opt_data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  compatibilityModeData_ = opt_data;
}

/**
 * Returns the data used for compatibility mode, or nothing if it hasn't been
 * enabled.
 * @return {Object}
 */
function getCompatibilityModeData() {
  // Compatibility mode can be set via the __METAL_COMPATIBILITY__ global var.
  if (!compatibilityModeData_) {
    if (typeof window !== 'undefined' && window.__METAL_COMPATIBILITY__) {
      enableCompatibilityMode(window.__METAL_COMPATIBILITY__);
    }
  }
  return compatibilityModeData_;
}

/**
 * Gets the name of the given function. If the current browser doesn't
 * support the `name` property, this will calculate it from the function's
 * content string.
 * @param {!function()} fn
 * @return {string}
 */
function getFunctionName(fn) {
  if (!fn.name) {
    var str = fn.toString();
    fn.name = str.substring(9, str.indexOf('('));
  }
  return fn.name;
}

/**
 * Gets an unique id. If `opt_object` argument is passed, the object is
 * mutated with an unique id. Consecutive calls with the same object
 * reference won't mutate the object again, instead the current object uid
 * returns. See {@link UID_PROPERTY}.
 * @param {Object=} opt_object Optional object to be mutated with the uid. If
 *     not specified this method only returns the uid.
 * @param {boolean=} opt_noInheritance Optional flag indicating if this
 *     object's uid property can be inherited from parents or not.
 * @throws {Error} when invoked to indicate the method should be overridden.
 */
function getUid(opt_object, opt_noInheritance) {
  if (opt_object) {
    var id = opt_object[UID_PROPERTY];
    if (opt_noInheritance && !opt_object.hasOwnProperty(UID_PROPERTY)) {
      id = null;
    }
    return id || (opt_object[UID_PROPERTY] = uniqueIdCounter_++);
  }
  return uniqueIdCounter_++;
}

/**
 * The identity function. Returns its first argument.
 * @param {*=} opt_returnValue The single value that will be returned.
 * @return {?} The first argument.
 */
function identityFunction(opt_returnValue) {
  return opt_returnValue;
}

/**
 * Returns true if the specified value is a boolean.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is boolean.
 */
function isBoolean(val) {
  return typeof val === 'boolean';
}

/**
 * Returns true if the specified value is not undefined.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is defined.
 */
function isDef(val) {
  return val !== undefined;
}

/**
 * Returns true if value is not undefined or null.
 * @param {*} val
 * @return {boolean}
 */
function isDefAndNotNull(val) {
  return isDef(val) && !isNull(val);
}

/**
 * Returns true if value is a document.
 * @param {*} val
 * @return {boolean}
 */
function isDocument(val) {
  return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 9;
}

/**
 * Returns true if value is a dom element.
 * @param {*} val
 * @return {boolean}
 */
function isElement(val) {
  return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 1;
}

/**
 * Returns true if the specified value is a function.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is a function.
 */
function isFunction(val) {
  return typeof val === 'function';
}

/**
 * Returns true if value is null.
 * @param {*} val
 * @return {boolean}
 */
function isNull(val) {
  return val === null;
}

/**
 * Returns true if the specified value is a number.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is a number.
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Returns true if value is a window.
 * @param {*} val
 * @return {boolean}
 */
function isWindow(val) {
  return val !== null && val === val.window;
}

/**
 * Returns true if the specified value is an object. This includes arrays
 * and functions.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is an object.
 */
function isObject(val) {
  var type = typeof val === 'undefined' ? 'undefined' : _typeof(val);
  return type === 'object' && val !== null || type === 'function';
}

/**
 * Returns true if value is a Promise.
 * @param {*} val
 * @return {boolean}
 */
function isPromise(val) {
  return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && typeof val.then === 'function';
}

/**
 * Returns true if value is a string.
 * @param {*} val
 * @return {boolean}
 */
function isString(val) {
  return typeof val === 'string' || val instanceof String;
}

/**
 * Merges the values of a export function property a class with the values of that
 * property for all its super classes, and stores it as a new static
 * property of that class. If the export function property already existed, it won't
 * be recalculated.
 * @param {!function()} constructor Class constructor.
 * @param {string} propertyName Property name to be collected.
 * @param {function(*, *):*=} opt_mergeFn Function that receives an array filled
 *   with the values of the property for the current class and all its super classes.
 *   Should return the merged value to be stored on the current class.
 * @return {boolean} Returns true if merge happens, false otherwise.
 */
function mergeSuperClassesProperty(constructor, propertyName, opt_mergeFn) {
  var mergedName = propertyName + '_MERGED';
  if (constructor.hasOwnProperty(mergedName)) {
    return false;
  }

  var merged = collectSuperClassesProperty(constructor, propertyName);
  if (opt_mergeFn) {
    merged = opt_mergeFn(merged);
  }
  constructor[mergedName] = merged;
  return true;
}

/**
 * Null function used for default values of callbacks, etc.
 * @return {void} Nothing.
 */
function nullFunction() {}



var core$2 = Object.freeze({
	UID_PROPERTY: UID_PROPERTY,
	abstractMethod: abstractMethod,
	collectSuperClassesProperty: collectSuperClassesProperty,
	disableCompatibilityMode: disableCompatibilityMode,
	enableCompatibilityMode: enableCompatibilityMode,
	getCompatibilityModeData: getCompatibilityModeData,
	getFunctionName: getFunctionName,
	getUid: getUid,
	identityFunction: identityFunction,
	isBoolean: isBoolean,
	isDef: isDef,
	isDefAndNotNull: isDefAndNotNull,
	isDocument: isDocument,
	isElement: isElement,
	isFunction: isFunction,
	isNull: isNull,
	isNumber: isNumber,
	isWindow: isWindow,
	isObject: isObject,
	isPromise: isPromise,
	isString: isString,
	mergeSuperClassesProperty: mergeSuperClassesProperty,
	nullFunction: nullFunction
});

// This file exists just for backwards compatibility, making sure that old
// default imports for this file still work. It's best to use the named exports
// for each function instead though, since that allows bundlers like Rollup to
// reduce the bundle size by removing unused code.

var array = function () {
	function array() {
		classCallCheck(this, array);
	}

	createClass(array, null, [{
		key: 'equal',

		/**
   * Checks if the given arrays have the same content.
   * @param {!Array<*>} arr1
   * @param {!Array<*>} arr2
   * @return {boolean}
   */
		value: function equal(arr1, arr2) {
			if (arr1.length !== arr2.length) {
				return false;
			}
			for (var i = 0; i < arr1.length; i++) {
				if (arr1[i] !== arr2[i]) {
					return false;
				}
			}
			return true;
		}

		/**
   * Returns the first value in the given array that isn't undefined.
   * @param {!Array} arr
   * @return {*}
   */

	}, {
		key: 'firstDefinedValue',
		value: function firstDefinedValue(arr) {
			for (var i = 0; i < arr.length; i++) {
				if (arr[i] !== undefined) {
					return arr[i];
				}
			}
		}

		/**
   * Transforms the input nested array to become flat.
   * @param {Array.<*|Array.<*>>} arr Nested array to flatten.
   * @param {Array.<*>} opt_output Optional output array.
   * @return {Array.<*>} Flat array.
   */

	}, {
		key: 'flatten',
		value: function flatten(arr, opt_output) {
			var output = opt_output || [];
			for (var i = 0; i < arr.length; i++) {
				if (Array.isArray(arr[i])) {
					array.flatten(arr[i], output);
				} else {
					output.push(arr[i]);
				}
			}
			return output;
		}

		/**
   * Removes the first occurrence of a particular value from an array.
   * @param {Array.<T>} arr Array from which to remove value.
   * @param {T} obj Object to remove.
   * @return {boolean} True if an element was removed.
   * @template T
   */

	}, {
		key: 'remove',
		value: function remove(arr, obj) {
			var i = arr.indexOf(obj);
			var rv;
			if (rv = i >= 0) {
				array.removeAt(arr, i);
			}
			return rv;
		}

		/**
   * Removes from an array the element at index i
   * @param {Array} arr Array or array like object from which to remove value.
   * @param {number} i The index to remove.
   * @return {boolean} True if an element was removed.
   */

	}, {
		key: 'removeAt',
		value: function removeAt(arr, i) {
			return Array.prototype.splice.call(arr, i, 1).length === 1;
		}

		/**
   * Slices the given array, just like Array.prototype.slice, but this
   * is faster and working on all array-like objects (like arguments).
   * @param {!Object} arr Array-like object to slice.
   * @param {number} start The index that should start the slice.
   * @param {number=} opt_end The index where the slice should end, not
   *   included in the final array. If not given, all elements after the
   *   start index will be included.
   * @return {!Array}
   */

	}, {
		key: 'slice',
		value: function slice(arr, start, opt_end) {
			var sliced = [];
			var end = isDef(opt_end) ? opt_end : arr.length;
			for (var i = start; i < end; i++) {
				sliced.push(arr[i]);
			}
			return sliced;
		}
	}]);
	return array;
}();

/*!
 * Polyfill from Google's Closure Library.
 * Copyright 2013 The Closure Library Authors. All Rights Reserved.
 */

var async = {};

/**
 * Throw an item without interrupting the current execution context.  For
 * example, if processing a group of items in a loop, sometimes it is useful
 * to report an error while still allowing the rest of the batch to be
 * processed.
 * @param {*} exception
 */
async.throwException = function (exception) {
	// Each throw needs to be in its own context.
	async.nextTick(function () {
		throw exception;
	});
};

/**
 * Fires the provided callback just before the current callstack unwinds, or as
 * soon as possible after the current JS execution context.
 * @param {function(this:THIS)} callback
 * @param {THIS=} opt_context Object to use as the "this value" when calling
 *     the provided function.
 * @template THIS
 */
async.run = function (callback, opt_context) {
	if (!async.run.workQueueScheduled_) {
		// Nothing is currently scheduled, schedule it now.
		async.nextTick(async.run.processWorkQueue);
		async.run.workQueueScheduled_ = true;
	}

	async.run.workQueue_.push(new async.run.WorkItem_(callback, opt_context));
};

/** @private {boolean} */
async.run.workQueueScheduled_ = false;

/** @private {!Array.<!async.run.WorkItem_>} */
async.run.workQueue_ = [];

/**
 * Run any pending async.run work items. This function is not intended
 * for general use, but for use by entry point handlers to run items ahead of
 * async.nextTick.
 */
async.run.processWorkQueue = function () {
	// NOTE: additional work queue items may be pushed while processing.
	while (async.run.workQueue_.length) {
		// Don't let the work queue grow indefinitely.
		var workItems = async.run.workQueue_;
		async.run.workQueue_ = [];
		for (var i = 0; i < workItems.length; i++) {
			var workItem = workItems[i];
			try {
				workItem.fn.call(workItem.scope);
			} catch (e) {
				async.throwException(e);
			}
		}
	}

	// There are no more work items, reset the work queue.
	async.run.workQueueScheduled_ = false;
};

/**
 * @constructor
 * @final
 * @struct
 * @private
 *
 * @param {function()} fn
 * @param {Object|null|undefined} scope
 */
async.run.WorkItem_ = function (fn, scope) {
	/** @const */
	this.fn = fn;
	/** @const */
	this.scope = scope;
};

/**
 * Fires the provided callbacks as soon as possible after the current JS
 * execution context. setTimeout(…, 0) always takes at least 5ms for legacy
 * reasons.
 * @param {function(this:SCOPE)} callback Callback function to fire as soon as
 *     possible.
 * @param {SCOPE=} opt_context Object in whose scope to call the listener.
 * @template SCOPE
 */
async.nextTick = function (callback, opt_context) {
	var cb = callback;
	if (opt_context) {
		cb = callback.bind(opt_context);
	}
	cb = async.nextTick.wrapCallback_(cb);
	// Introduced and currently only supported by IE10.
	// Verify if variable is defined on the current runtime (i.e., node, browser).
	// Can't use typeof enclosed in a function (such as core.isFunction) or an
	// exception will be thrown when the function is called on an environment
	// where the variable is undefined.
	if (typeof setImmediate === 'function') {
		setImmediate(cb);
		return;
	}
	// Look for and cache the custom fallback version of setImmediate.
	if (!async.nextTick.setImmediate_) {
		async.nextTick.setImmediate_ = async.nextTick.getSetImmediateEmulator_();
	}
	async.nextTick.setImmediate_(cb);
};

/**
 * Cache for the setImmediate implementation.
 * @type {function(function())}
 * @private
 */
async.nextTick.setImmediate_ = null;

/**
 * Determines the best possible implementation to run a function as soon as
 * the JS event loop is idle.
 * @return {function(function())} The "setImmediate" implementation.
 * @private
 */
async.nextTick.getSetImmediateEmulator_ = function () {
	// Create a private message channel and use it to postMessage empty messages
	// to ourselves.
	var Channel;

	// Verify if variable is defined on the current runtime (i.e., node, browser).
	// Can't use typeof enclosed in a function (such as core.isFunction) or an
	// exception will be thrown when the function is called on an environment
	// where the variable is undefined.
	if (typeof MessageChannel === 'function') {
		Channel = MessageChannel;
	}

	// If MessageChannel is not available and we are in a browser, implement
	// an iframe based polyfill in browsers that have postMessage and
	// document.addEventListener. The latter excludes IE8 because it has a
	// synchronous postMessage implementation.
	if (typeof Channel === 'undefined' && typeof window !== 'undefined' && window.postMessage && window.addEventListener) {
		/** @constructor */
		Channel = function Channel() {
			// Make an empty, invisible iframe.
			var iframe = document.createElement('iframe');
			iframe.style.display = 'none';
			iframe.src = '';
			document.documentElement.appendChild(iframe);
			var win = iframe.contentWindow;
			var doc = win.document;
			doc.open();
			doc.write('');
			doc.close();
			var message = 'callImmediate' + Math.random();
			var origin = win.location.protocol + '//' + win.location.host;
			var onmessage = function (e) {
				// Validate origin and message to make sure that this message was
				// intended for us.
				if (e.origin !== origin && e.data !== message) {
					return;
				}
				this.port1.onmessage();
			}.bind(this);
			win.addEventListener('message', onmessage, false);
			this.port1 = {};
			this.port2 = {
				postMessage: function postMessage() {
					win.postMessage(message, origin);
				}
			};
		};
	}
	if (typeof Channel !== 'undefined') {
		var channel = new Channel();
		// Use a fifo linked list to call callbacks in the right order.
		var head = {};
		var tail = head;
		channel.port1.onmessage = function () {
			head = head.next;
			var cb = head.cb;
			head.cb = null;
			cb();
		};
		return function (cb) {
			tail.next = {
				cb: cb
			};
			tail = tail.next;
			channel.port2.postMessage(0);
		};
	}
	// Implementation for IE6-8: Script elements fire an asynchronous
	// onreadystatechange event when inserted into the DOM.
	if (typeof document !== 'undefined' && 'onreadystatechange' in document.createElement('script')) {
		return function (cb) {
			var script = document.createElement('script');
			script.onreadystatechange = function () {
				// Clean up and call the callback.
				script.onreadystatechange = null;
				script.parentNode.removeChild(script);
				script = null;
				cb();
				cb = null;
			};
			document.documentElement.appendChild(script);
		};
	}
	// Fall back to setTimeout with 0. In browsers this creates a delay of 5ms
	// or more.
	return function (cb) {
		setTimeout(cb, 0);
	};
};

/**
 * Helper function that is overrided to protect callbacks with entry point
 * monitor if the application monitors entry points.
 * @param {function()} callback Callback function to fire as soon as possible.
 * @return {function()} The wrapped callback.
 * @private
 */
async.nextTick.wrapCallback_ = function (opt_returnValue) {
	return opt_returnValue;
};

/**
 * Disposable utility. When inherited provides the `dispose` function to its
 * subclass, which is responsible for disposing of any object references
 * when an instance won't be used anymore. Subclasses should override
 * `disposeInternal` to implement any specific disposing logic.
 * @constructor
 */

var Disposable = function () {
	function Disposable() {
		classCallCheck(this, Disposable);

		/**
   * Flag indicating if this instance has already been disposed.
   * @type {boolean}
   * @protected
   */
		this.disposed_ = false;
	}

	/**
  * Disposes of this instance's object references. Calls `disposeInternal`.
  */


	createClass(Disposable, [{
		key: 'dispose',
		value: function dispose() {
			if (!this.disposed_) {
				this.disposeInternal();
				this.disposed_ = true;
			}
		}

		/**
   * Subclasses should override this method to implement any specific
   * disposing logic (like clearing references and calling `dispose` on other
   * disposables).
   */

	}, {
		key: 'disposeInternal',
		value: function disposeInternal() {}

		/**
   * Checks if this instance has already been disposed.
   * @return {boolean}
   */

	}, {
		key: 'isDisposed',
		value: function isDisposed() {
			return this.disposed_;
		}
	}]);
	return Disposable;
}();

var object = function () {
	function object() {
		classCallCheck(this, object);
	}

	createClass(object, null, [{
		key: 'mixin',

		/**
   * Copies all the members of a source object to a target object.
   * @param {Object} target Target object.
   * @param {...Object} var_args The objects from which values will be copied.
   * @return {Object} Returns the target object reference.
   */
		value: function mixin(target) {
			var key, source;
			for (var i = 1; i < arguments.length; i++) {
				source = arguments[i];
				for (key in source) {
					target[key] = source[key];
				}
			}
			return target;
		}

		/**
   * Returns an object based on its fully qualified external name.
   * @param {string} name The fully qualified name.
   * @param {object=} opt_obj The object within which to look; default is
   *     <code>window</code>.
   * @return {?} The value (object or primitive) or, if not found, undefined.
   */

	}, {
		key: 'getObjectByName',
		value: function getObjectByName(name, opt_obj) {
			var scope = opt_obj || window;
			var parts = name.split('.');
			return parts.reduce(function (part, key) {
				return part[key];
			}, scope);
		}

		/**
   * Returns a new object with the same keys as the given one, but with
   * their values set to the return values of the specified function.
   * @param {!Object} obj
   * @param {!function(string, *)} fn
   * @return {!Object}
   */

	}, {
		key: 'map',
		value: function map(obj, fn) {
			var mappedObj = {};
			var keys = Object.keys(obj);
			for (var i = 0; i < keys.length; i++) {
				mappedObj[keys[i]] = fn(keys[i], obj[keys[i]]);
			}
			return mappedObj;
		}

		/**
   * Checks if the two given objects are equal. This is done via a shallow
   * check, including only the keys directly contained by the 2 objects.
   * @return {boolean}
   */

	}, {
		key: 'shallowEqual',
		value: function shallowEqual(obj1, obj2) {
			if (obj1 === obj2) {
				return true;
			}

			var keys1 = Object.keys(obj1);
			var keys2 = Object.keys(obj2);
			if (keys1.length !== keys2.length) {
				return false;
			}

			for (var i = 0; i < keys1.length; i++) {
				if (obj1[keys1[i]] !== obj2[keys1[i]]) {
					return false;
				}
			}
			return true;
		}
	}]);
	return object;
}();

var string = function () {
	function string() {
		classCallCheck(this, string);
	}

	createClass(string, null, [{
		key: 'collapseBreakingSpaces',

		/**
   * Removes the breaking spaces from the left and right of the string and
   * collapses the sequences of breaking spaces in the middle into single spaces.
   * The original and the result strings render the same way in HTML.
   * @param {string} str A string in which to collapse spaces.
   * @return {string} Copy of the string with normalized breaking spaces.
   */
		value: function collapseBreakingSpaces(str) {
			return str.replace(/[\t\r\n ]+/g, ' ').replace(/^[\t\r\n ]+|[\t\r\n ]+$/g, '');
		}

		/**
  * Escapes characters in the string that are not safe to use in a RegExp.
  * @param {*} str The string to escape. If not a string, it will be casted
  *     to one.
  * @return {string} A RegExp safe, escaped copy of {@code s}.
  */

	}, {
		key: 'escapeRegex',
		value: function escapeRegex(str) {
			return String(str).replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').replace(/\x08/g, '\\x08');
		}

		/**
  * Returns a string with at least 64-bits of randomness.
  * @return {string} A random string, e.g. sn1s7vb4gcic.
  */

	}, {
		key: 'getRandomString',
		value: function getRandomString() {
			var x = 2147483648;
			return Math.floor(Math.random() * x).toString(36) + Math.abs(Math.floor(Math.random() * x) ^ Date.now()).toString(36);
		}

		/**
   * Calculates the hashcode for a string. The hashcode value is computed by
   * the sum algorithm: s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]. A nice
   * property of using 31 prime is that the multiplication can be replaced by
   * a shift and a subtraction for better performance: 31*i == (i<<5)-i.
   * Modern VMs do this sort of optimization automatically.
   * @param {String} val Target string.
   * @return {Number} Returns the string hashcode.
   */

	}, {
		key: 'hashCode',
		value: function hashCode(val) {
			var hash = 0;
			for (var i = 0, len = val.length; i < len; i++) {
				hash = 31 * hash + val.charCodeAt(i);
				hash %= 0x100000000;
			}
			return hash;
		}

		/**
   * Replaces interval into the string with specified value, e.g.
   * `replaceInterval("abcde", 1, 4, "")` returns "ae".
   * @param {string} str The input string.
   * @param {Number} start Start interval position to be replaced.
   * @param {Number} end End interval position to be replaced.
   * @param {string} value The value that replaces the specified interval.
   * @return {string}
   */

	}, {
		key: 'replaceInterval',
		value: function replaceInterval(str, start, end, value) {
			return str.substring(0, start) + value + str.substring(end);
		}
	}]);
	return string;
}();

/**
 * Class responsible for storing an object that will be printed as JSON
 * when the `toString` method is called.
 */

var Embodied = function () {
	/**
  * Constructs a Embodied instance.
  * @constructor
  */
	function Embodied() {
		classCallCheck(this, Embodied);

		this.body_ = {};
	}

	/**
  * Gets the json object that represents this instance.
  * @return {!Object}
  */


	createClass(Embodied, [{
		key: 'body',
		value: function body() {
			return this.body_;
		}

		/**
   * If the given object is an instance of Embodied, this will
   * return its body content. Otherwise this will return the
   * original object.
   * @param {*} obj
   * @return {*}
   * @static
   */

	}, {
		key: 'toString',


		/**
   * Gets the json string that represents this instance.
   * @return {string}
   */
		value: function toString() {
			return JSON.stringify(this.body());
		}
	}], [{
		key: 'toBody',
		value: function toBody(obj) {
			return obj instanceof Embodied ? obj.body() : obj;
		}
	}]);
	return Embodied;
}();

/**
 * Class responsible for storing and handling the body contents
 * of a Filter instance.
 */

var FilterBody = function () {
	/**
  * Constructs a {@link FilterBody} instance.
  * @param {string} field The name of the field to filter by.
  * @param {*} operatorOrValue If a third param is given, this should
  *   be the filter's operator (like ">="). Otherwise, this will be
  *   used as the filter's value, and the filter's operator will be "=".
  * @param {*=} opt_value The filter's value.
  * @constructor
  */
	function FilterBody(field, operatorOrValue, opt_value) {
		classCallCheck(this, FilterBody);

		var obj = {
			operator: isDef(opt_value) ? operatorOrValue : '='
		};

		var value = isDef(opt_value) ? opt_value : operatorOrValue;

		if (isDefAndNotNull(value)) {
			if (value instanceof Embodied) {
				value = value.body();
			}
			obj.value = value;
		}

		if (isDefAndNotNull(field)) {
			this.createBody_(field, obj);
		} else {
			this.createBody_('and', []);
		}
	}

	/**
  * Composes the current filter with the given operator.
  * @param {string} operator
  * @param {Filter=} opt_filter Another filter to compose this filter with,
  *   if the operator is not unary.
  */


	createClass(FilterBody, [{
		key: 'add',
		value: function add(operator, opt_filter) {
			if (opt_filter) {
				this.addArrayOperator_(operator, opt_filter);
			} else {
				this.createBody_(operator, this.body_);
			}
		}

		/**
   * Composes the current filter with an operator that stores its values in an array.
   * @param {string} operator
   * @param {!Filter} filter
   * @protected
   */

	}, {
		key: 'addArrayOperator_',
		value: function addArrayOperator_(operator, filter) {
			if (!(this.body_[operator] instanceof Array)) {
				this.createBody_(operator, [this.body_]);
			}
			this.body_[operator].push(filter.body());
		}

		/**
   * Adds filters to be composed with this filter body using the given operator.
   * @param {string} operator
   * @param {...*} filters A variable amount of filters to be composed.
   */

	}, {
		key: 'addMany',
		value: function addMany(operator) {
			for (var _len = arguments.length, filters = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
				filters[_key - 1] = arguments[_key];
			}

			for (var i = 0; i < filters.length; i++) {
				this.add(operator, filters[i]);
			}
		}

		/**
   * Creates a new body object, setting the requestd key to the given value.
   * @param {string} key The key to set in the new body object
   * @param {*} value The value the requested key should have in the new body object.
   * @protected
   */

	}, {
		key: 'createBody_',
		value: function createBody_(key, value) {
			this.body_ = {};
			this.body_[key] = value;
		}

		/**
   * Gets the json object that represents this filter's body.
   * @return {!Object}
   */

	}, {
		key: 'getObject',
		value: function getObject() {
			return this.body_;
		}
	}]);
	return FilterBody;
}();

/**
 * Class responsible for building different types of geometric
 * shapes.
 */

var Geo = function () {
	function Geo() {
		classCallCheck(this, Geo);
	}

	createClass(Geo, null, [{
		key: 'boundingBox',

		/**
   * Creates a new {@link BoundingBox} instance.
   * @param {*} upperLeft The upper left point.
   * @param {*} lowerRight The lower right point.
   * @return {!BoundingBox}
   * @static
   */
		value: function boundingBox(upperLeft, lowerRight) {
			return new Geo.BoundingBox(upperLeft, lowerRight);
		}

		/**
   * Creates a new {@link Circle} instance.
   * @param {*} center The circle's center coordinate.
   * @param {string} radius The circle's radius.
   * @return {!Circle}
   * @static
   */

	}, {
		key: 'circle',
		value: function circle(center, radius) {
			return new Geo.Circle(center, radius);
		}

		/**
   * Creates a new {@link Line} instance.
   * @param {...*} points This line's points.
   * @return {!Line}
   * @static
   */

	}, {
		key: 'line',
		value: function line() {
			for (var _len = arguments.length, points = Array(_len), _key = 0; _key < _len; _key++) {
				points[_key] = arguments[_key];
			}

			return new (Function.prototype.bind.apply(Geo.Line, [null].concat(points)))();
		}

		/**
   * Creates a new {@link Point} instance.
   * @param {number} lat The latitude coordinate
   * @param {number} lon The longitude coordinate
   * @return {!Point}
   * @static
   */

	}, {
		key: 'point',
		value: function point(lat, lon) {
			return new Geo.Point(lat, lon);
		}

		/**
   * Creates a new {@link Polygon} instance.
   * @param {...*} points This polygon's points.
   * @return {!Polygon}
   * @static
   */

	}, {
		key: 'polygon',
		value: function polygon() {
			for (var _len2 = arguments.length, points = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
				points[_key2] = arguments[_key2];
			}

			return new (Function.prototype.bind.apply(Geo.Polygon, [null].concat(points)))();
		}
	}]);
	return Geo;
}();

/**
 * Class that represents a point coordinate.
 * @extends {Embodied}
 */


var Point = function (_Embodied) {
	inherits(Point, _Embodied);

	/**
  * Constructs a {@link Point} instance.
  * @param {number} lat The latitude coordinate
  * @param {number} lon The longitude coordinate
  * @constructor
  */
	function Point(lat, lon) {
		classCallCheck(this, Point);

		var _this = possibleConstructorReturn(this, (Point.__proto__ || Object.getPrototypeOf(Point)).call(this));

		_this.body_ = [lat, lon];
		return _this;
	}

	return Point;
}(Embodied);

Geo.Point = Point;

/**
 * Class that represents a line.
 * @extends {Embodied}
 */

var Line = function (_Embodied2) {
	inherits(Line, _Embodied2);

	/**
  * Constructs a {@link Line} instance.
  * @param {...*} points This line's points.
  * @constructor
  */
	function Line() {
		classCallCheck(this, Line);

		var _this2 = possibleConstructorReturn(this, (Line.__proto__ || Object.getPrototypeOf(Line)).call(this));

		for (var _len3 = arguments.length, points = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
			points[_key3] = arguments[_key3];
		}

		_this2.body_ = {
			type: 'linestring',
			coordinates: points.map(function (point) {
				return Embodied.toBody(point);
			})
		};
		return _this2;
	}

	return Line;
}(Embodied);

Geo.Line = Line;

/**
 * Class that represents a bounding box.
 * @extends {Embodied}
 */

var BoundingBox = function (_Embodied3) {
	inherits(BoundingBox, _Embodied3);

	/**
  * Constructs a {@link BoundingBox} instance.
  * @param {*} upperLeft The upper left point.
  * @param {*} lowerRight The lower right point.
  * @constructor
  */
	function BoundingBox(upperLeft, lowerRight) {
		classCallCheck(this, BoundingBox);

		var _this3 = possibleConstructorReturn(this, (BoundingBox.__proto__ || Object.getPrototypeOf(BoundingBox)).call(this));

		_this3.body_ = {
			type: 'envelope',
			coordinates: [Embodied.toBody(upperLeft), Embodied.toBody(lowerRight)]
		};
		return _this3;
	}

	/**
  * Gets this bounding box's points.
  * @return {!Array}
  */


	createClass(BoundingBox, [{
		key: 'getPoints',
		value: function getPoints() {
			return this.body_.coordinates;
		}
	}]);
	return BoundingBox;
}(Embodied);

Geo.BoundingBox = BoundingBox;

/**
 * Class that represents a circle.
 * @extends {Embodied}
 */

var Circle = function (_Embodied4) {
	inherits(Circle, _Embodied4);

	/**
  * Constructs a {@link Circle} instance.
  * @param {*} center The circle's center coordinate.
  * @param {string} radius The circle's radius.
  * @constructor
  */
	function Circle(center, radius) {
		classCallCheck(this, Circle);

		var _this4 = possibleConstructorReturn(this, (Circle.__proto__ || Object.getPrototypeOf(Circle)).call(this));

		_this4.body_ = {
			type: 'circle',
			coordinates: Embodied.toBody(center),
			radius: radius
		};
		return _this4;
	}

	/**
  * Gets this circle's center coordinate.
  * @return {*}
  */


	createClass(Circle, [{
		key: 'getCenter',
		value: function getCenter() {
			return this.body_.coordinates;
		}

		/**
   * Gets this circle's radius.
   * @return {string}
   */

	}, {
		key: 'getRadius',
		value: function getRadius() {
			return this.body_.radius;
		}
	}]);
	return Circle;
}(Embodied);

Geo.Circle = Circle;

/**
 * Class that represents a polygon.
 * @extends {Embodied}
 */

var Polygon = function (_Embodied5) {
	inherits(Polygon, _Embodied5);

	/**
  * Constructs a {@link Polygon} instance.
  * @param {...*} points This polygon's points.
  * @constructor
  */
	function Polygon() {
		classCallCheck(this, Polygon);

		var _this5 = possibleConstructorReturn(this, (Polygon.__proto__ || Object.getPrototypeOf(Polygon)).call(this));

		_this5.body_ = {
			type: 'polygon',
			coordinates: []
		};
		_this5.addCoordinates_.apply(_this5, arguments);
		return _this5;
	}

	/**
  * Adds the given points as coordinates for this polygon.
  * @param {...*} points
  * @protected
  */


	createClass(Polygon, [{
		key: 'addCoordinates_',
		value: function addCoordinates_() {
			for (var _len4 = arguments.length, points = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
				points[_key4] = arguments[_key4];
			}

			this.body_.coordinates.push(points.map(function (point) {
				return Embodied.toBody(point);
			}));
		}

		/**
   * Adds the given points as a hole inside this polygon.
   * @param  {...*} points
   * @chainnable
   */

	}, {
		key: 'hole',
		value: function hole() {
			this.addCoordinates_.apply(this, arguments);
			return this;
		}
	}]);
	return Polygon;
}(Embodied);

Geo.Polygon = Polygon;

/**
 * Class responsible for building range objects to be used by `Filter`.
 * @extends {Embodied}
 */

var Range = function (_Embodied) {
	inherits(Range, _Embodied);

	/**
  * Constructs a {@link Range} instance.
  * @param {*} from
  * @param {*} opt_to
  * @constructor
  */
	function Range(from, opt_to) {
		classCallCheck(this, Range);

		var _this = possibleConstructorReturn(this, (Range.__proto__ || Object.getPrototypeOf(Range)).call(this));

		if (isDefAndNotNull(from)) {
			_this.body_.from = from;
		}
		if (isDefAndNotNull(opt_to)) {
			_this.body_.to = opt_to;
		}
		return _this;
	}

	/**
  * Constructs a {@link Range} instance.
  * @param {*} from
  * @return {!Range}
  * @static
  */


	createClass(Range, null, [{
		key: 'from',
		value: function from(_from) {
			return new Range(_from);
		}

		/**
   * Constructs a {@link Range} instance.
   * @param {*} from
   * @param {*} to
   * @return {!Range}
   * @static
   */

	}, {
		key: 'range',
		value: function range(from, to) {
			return new Range(from, to);
		}

		/**
   * Constructs a {@link Range} instance.
   * @param {*} to
   * @return {!Range}
   * @static
   */

	}, {
		key: 'to',
		value: function to(_to) {
			return new Range(null, _to);
		}
	}]);
	return Range;
}(Embodied);

/**
 * Class responsible for building filters.
 * @extends {Embodied}
 */

var Filter = function (_Embodied) {
	inherits(Filter, _Embodied);

	/**
  * Constructs a {@link Filter} instance.
  * @param {string} field The name of the field to filter by.
  * @param {*} operatorOrValue If a third param is given, this should
  *   be the filter's operator (like ">="). Otherwise, this will be
  *   used as the filter's value, and the filter's operator will be "=".
  * @param {*=} opt_value The filter's value.
  * @constructor
  */
	function Filter(field, operatorOrValue, opt_value) {
		classCallCheck(this, Filter);

		var _this = possibleConstructorReturn(this, (Filter.__proto__ || Object.getPrototypeOf(Filter)).call(this));

		_this.body_ = new FilterBody(field, operatorOrValue, opt_value);
		return _this;
	}

	/**
  * Adds a filter to be composed with this filter using the given operator.
  * @param {string} operator
  * @param {!Filter|string} fieldOrFilter Either a {@link Filter} instance or the
  *   name of the field to filter by.
  * @param {*=} opt_operatorOrValue Either the field's operator or its value.
  * @param {*=} opt_value The filter's value.
  * @chainnable
  */


	createClass(Filter, [{
		key: 'add',
		value: function add(operator, fieldOrFilter, opt_operatorOrValue, opt_value) {
			var filter = fieldOrFilter ? Filter.toFilter(fieldOrFilter, opt_operatorOrValue, opt_value) : null;
			this.body_.add(operator, filter);
			return this;
		}

		/**
   * Adds filters to be composed with this filter using the given operator.
   * @param {string} operator
   * @param {...*} filters A variable amount of filters to be composed.
   * @chainnable
   */

	}, {
		key: 'addMany',
		value: function addMany(operator) {
			var _body_;

			for (var _len = arguments.length, filters = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
				filters[_key - 1] = arguments[_key];
			}

			(_body_ = this.body_).addMany.apply(_body_, [operator].concat(filters));
			return this;
		}

		/**
   * Adds a filter to be composed with this filter using the "and" operator.
   * @param {!Filter|string} fieldOrFilter Either a {@link Filter} instance or the
   *   name of the field to filter by.
   * @param {*=} opt_operatorOrValue Either the field's operator or its value.
   * @param {*=} opt_value The filter's value.
   * @chainnable
   */

	}, {
		key: 'and',
		value: function and(fieldOrFilter, opt_operatorOrValue, opt_value) {
			return this.add('and', fieldOrFilter, opt_operatorOrValue, opt_value);
		}

		/**
   * Returns a {@link Filter} instance that uses the "any" operator.
   * @param {string} field The name of the field to filter by.
   * @param {!(Array|...*)} values A variable amount of values to be used with
   *   the "none" operator. Can be passed either as a single array or as
   *   separate params.
   * @return {!Filter}
   * @static
   */

	}, {
		key: 'body',


		/**
   * Gets the json object that represents this filter.
   * @return {!Object}
   */
		value: function body() {
			return this.body_.getObject();
		}

		/**
   * Returns a {@link Filter} instance that uses the "gd" operator.
   * @param {string} field The field's name.
   * @param {*} locationOrCircle Either a `Geo.Circle` instance or a coordinate.
   * @param {Range|string=} opt_rangeOrDistance Either a `Range` instance or
   *   the distance value.
   * @return {!Filter}
   * @static
   */

	}, {
		key: 'or',


		/**
   * Adds a filter to be composed with this filter using the "or" operator.
   * @param {!Filter|string} fieldOrFilter Either a {@link Filter} instance or
   * the name of the field to filter by.
   * @param {*=} opt_operatorOrValue Either the field's operator or its value.
   * @param {*=} opt_value The filter's value.
   * @chainnable
   */
		value: function or(fieldOrFilter, opt_operatorOrValue, opt_value) {
			return this.add('or', fieldOrFilter, opt_operatorOrValue, opt_value);
		}

		/**
   * Converts the given arguments into a {@link Filter} instance.
   * @param {!Filter|string} fieldOrFilter Either a {@link Filter} instance or
   * the name of the field to filter by.
   * @param {*=} opt_operatorOrValue Either the field's operator or its value.
   * @param {*=} opt_value The filter's value.
   * @return {!Filter}
   */

	}], [{
		key: 'any',
		value: function any(field) {
			var values = Array.prototype.slice.call(arguments, 1);
			if (values.length === 1 && values[0] instanceof Array) {
				values = values[0];
			}
			return new Filter(field, 'any', values);
		}

		/**
   * Returns a {@link Filter} instance that uses the "gp" operator.
   * This is a special use case of `Filter.polygon` for bounding
   * boxes.
   * @param {string} field The field's name.
   * @param {*} boxOrUpperLeft Either a `Geo.BoundingBox` instance, or
   *   a bounding box's upper left coordinate.
   * @param {*=} opt_lowerRight A bounding box's lower right coordinate.
   * @return {!Filter}
   * @static
   */

	}, {
		key: 'boundingBox',
		value: function boundingBox(field, boxOrUpperLeft, opt_lowerRight) {
			if (boxOrUpperLeft instanceof Geo.BoundingBox) {
				return Filter.polygon.apply(Filter, [field].concat(toConsumableArray(boxOrUpperLeft.getPoints())));
			} else {
				return Filter.polygon(field, boxOrUpperLeft, opt_lowerRight);
			}
		}
	}, {
		key: 'distance',
		value: function distance(field, locationOrCircle, opt_rangeOrDistance) {
			var location = locationOrCircle;
			var range = opt_rangeOrDistance;
			if (locationOrCircle instanceof Geo.Circle) {
				location = locationOrCircle.getCenter();
				range = Range.to(locationOrCircle.getRadius());
			} else if (!(opt_rangeOrDistance instanceof Range)) {
				range = Range.to(opt_rangeOrDistance);
			}
			return Filter.distanceInternal_(field, location, range);
		}

		/**
   * Returns a {@link Filter} instance that uses the "gd" operator. This
   * is just an internal helper used by `Filter.distance`.
   * @param {string} field The field's name.
   * @param {*} location A location coordinate.
   * @param {Range} range A `Range` instance.
   * @return {!Filter}
   * @protected
   * @static
   */

	}, {
		key: 'distanceInternal_',
		value: function distanceInternal_(field, location, range) {
			var value = {
				location: Embodied.toBody(location)
			};
			range = range.body();
			if (range.from) {
				value.min = range.from;
			}
			if (range.to) {
				value.max = range.to;
			}
			return Filter.field(field, 'gd', value);
		}

		/**
   * Returns a {@link Filter} instance that uses the "=" operator.
   * @param {string} field The name of the field to filter by.
   * @param {*} value The filter's value.
   * @return {!Filter}
    * @static
   */

	}, {
		key: 'equal',
		value: function equal(field, value) {
			return new Filter(field, '=', value);
		}

		/**
   * Returns a {@link Filter} instance that uses the "exists" operator.
   * @param {string} field The field's name.
   * @return {!Filter}
   * @static
   */

	}, {
		key: 'exists',
		value: function exists(field) {
			return Filter.field(field, 'exists', null);
		}

		/**
   * Returns a {@link Filter} instance that uses the "fuzzy" operator.
   * @param {string} fieldOrQuery If no second string argument is given, this
   *   should be the query string, in which case all fields will be matched.
   *   Otherwise, this should be the name of the field to match.
   * @param {string|number=} opt_queryOrFuzziness If this is a string, it should
   *   be the query, otherwise it should be the fuzziness value.
   * @param {number=} opt_fuzziness The fuzziness value.
   * @return {!Filter}
   * @static
   */

	}, {
		key: 'fuzzy',
		value: function fuzzy(fieldOrQuery, opt_queryOrFuzziness, opt_fuzziness) {
			return Filter.fuzzyInternal_('fuzzy', fieldOrQuery, opt_queryOrFuzziness, opt_fuzziness);
		}

		/**
   * Returns a {@link Filter} instance that uses the given fuzzy operator. This
   * is an internal implementation used by the `Filter.fuzzy` method.
   * @param {string} operator The fuzzy operator.
   * @param {string} fieldOrQuery If no second string argument is given, this
   *   should be the query string, in which case all fields will be matched.
   *   Otherwise, this should be the name of the field to match.
   * @param {string|number=} opt_queryOrFuzziness If this is a string, it should
   *   be the query, otherwise it should be the fuzziness value.
   * @param {number=} opt_fuzziness The fuzziness value.
   * @return {!Filter}
   * @protected
   * @static
   */

	}, {
		key: 'fuzzyInternal_',
		value: function fuzzyInternal_(operator, fieldOrQuery, opt_queryOrFuzziness, opt_fuzziness) {
			var arg2IsString = isString(opt_queryOrFuzziness);

			var value = {
				query: arg2IsString ? opt_queryOrFuzziness : fieldOrQuery
			};
			var fuzziness = arg2IsString ? opt_fuzziness : opt_queryOrFuzziness;
			if (fuzziness) {
				value.fuzziness = fuzziness;
			}

			var field = arg2IsString ? fieldOrQuery : Filter.ALL;
			return Filter.field(field, operator, value);
		}

		/**
   * Returns a {@link Filter} instance that uses the ">" operator.
   * @param {string} field The name of the field to filter by.
   * @param {*} value The filter's value.
   * @return {!Filter}
    * @static
   */

	}, {
		key: 'gt',
		value: function gt(field, value) {
			return new Filter(field, '>', value);
		}

		/**
   * Returns a {@link Filter} instance that uses the ">=" operator.
   * @param {string} field The name of the field to filter by.
   * @param {*} value The filter's value.
   * @return {!Filter}
    * @static
   */

	}, {
		key: 'gte',
		value: function gte(field, value) {
			return new Filter(field, '>=', value);
		}

		/**
   * Returns a {@link Filter} instance that uses the "match" operator.
   * @param {string} fieldOrQuery If no second string argument is given, this
   *   should be the query string, in which case all fields will be matched.
   *   Otherwise, this should be the name of the field to match.
   * @param {string=} opt_query The query string.
   * @return {!Filter}
   * @static
   */

	}, {
		key: 'match',
		value: function match(fieldOrQuery, opt_query) {
			var field = isString(opt_query) ? fieldOrQuery : Filter.ALL;
			var query = isString(opt_query) ? opt_query : fieldOrQuery;
			return Filter.field(field, 'match', query);
		}

		/**
   * Returns a {@link Filter} instance that uses the "missing" operator.
   * @param {string} field The field's name.
   * @return {!Filter}
   * @static
   */

	}, {
		key: 'missing',
		value: function missing(field) {
			return Filter.field(field, 'missing', null);
		}

		/**
   * Returns a {@link Filter} instance that uses the "phrase" operator.
   * @param {string} fieldOrQuery If no second string argument is given, this
   *   should be the query string, in which case all fields will be matched.
   *   Otherwise, this should be the name of the field to match.
   * @param {string=} opt_query The query string.
   * @return {!Filter}
   * @static
   */

	}, {
		key: 'phrase',
		value: function phrase(fieldOrQuery, opt_query) {
			var field = isString(opt_query) ? fieldOrQuery : Filter.ALL;
			var query = isString(opt_query) ? opt_query : fieldOrQuery;
			return Filter.field(field, 'phrase', query);
		}

		/**
   * Returns a {@link Filter} instance that uses the "gp" operator.
   * @param {string} field The name of the field.
   * @param {...!Object} points Objects representing points in the polygon.
   * @return {!Filter}
   * @static
   */

	}, {
		key: 'polygon',
		value: function polygon(field) {
			for (var _len2 = arguments.length, points = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
				points[_key2 - 1] = arguments[_key2];
			}

			points = points.map(function (point) {
				return Embodied.toBody(point);
			});
			return Filter.field(field, 'gp', points);
		}

		/**
   * Returns a {@link Filter} instance that uses the "prefix" operator.
   * @param {string} fieldOrQuery If no second argument is given, this should
   *   be the query string, in which case all fields will be matched. Otherwise,
   *   this should be the name of the field to match.
   * @param {string=} opt_query The query string.
   * @return {!Filter}
   * @static
   */

	}, {
		key: 'prefix',
		value: function prefix(fieldOrQuery, opt_query) {
			var field = opt_query ? fieldOrQuery : Filter.ALL;
			var query = opt_query ? opt_query : fieldOrQuery;
			return Filter.field(field, 'prefix', query);
		}

		/**
   * Returns a {@link Filter} instance that uses the "range" operator.
   * @param {string} field The field's name.
   * @param {*} rangeOrMin Either a `Range` instance or a the range's min value.
   * @param {*=} opt_max The range's max value.
   * @return {!Filter}
   * @static
   */

	}, {
		key: 'range',
		value: function range(field, rangeOrMin, opt_max) {
			var range = rangeOrMin;
			if (!(range instanceof Range)) {
				range = Range.range(rangeOrMin, opt_max);
			}
			return Filter.field(field, 'range', range);
		}

		/**
   * Returns a {@link Filter} instance that uses the "~" operator.
   * @param {string} field The name of the field to filter by.
   * @param {*} value The filter's value.
   * @return {!Filter}
    * @static
   */

	}, {
		key: 'regex',
		value: function regex(field, value) {
			return new Filter(field, '~', value);
		}

		/**
   * Returns a {@link Filter} instance that uses the "gs" operator.
   * @param {string} field The field's name.
   * @param {...!Object} shapes Objects representing shapes.
   * @return {!Filter}
   * @static
   */

	}, {
		key: 'shape',
		value: function shape(field) {
			for (var _len3 = arguments.length, shapes = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
				shapes[_key3 - 1] = arguments[_key3];
			}

			shapes = shapes.map(function (shape) {
				return Embodied.toBody(shape);
			});
			var value = {
				type: 'geometrycollection',
				geometries: shapes
			};
			return Filter.field(field, 'gs', value);
		}

		/**
   * Returns a {@link Filter} instance that uses the "similar" operator.
   * @param {string} fieldOrQuery If no second string argument is given, this
   *   should be the query string, in which case all fields will be matched.
   *   Otherwise, this should be the name of the field to match.
   * @param {?string} query The query string.
   * @return {!Filter}
   * @static
   */

	}, {
		key: 'similar',
		value: function similar(fieldOrQuery, query) {
			var field = isString(query) ? fieldOrQuery : Filter.ALL;
			var value = {
				query: isString(query) ? query : fieldOrQuery
			};
			return Filter.field(field, 'similar', value);
		}

		/**
   * Returns a {@link Filter} instance that uses the "<" operator.
   * @param {string} field The name of the field to filter by.
   * @param {*} value The filter's value.
   * @return {!Filter}
    * @static
   */

	}, {
		key: 'lt',
		value: function lt(field, value) {
			return new Filter(field, '<', value);
		}

		/**
   * Returns a {@link Filter} instance that uses the "<=" operator.
   * @param {string} field The name of the field to filter by.
   * @param {*} value The filter's value.
   * @return {!Filter}
    * @static
   */

	}, {
		key: 'lte',
		value: function lte(field, value) {
			return new Filter(field, '<=', value);
		}

		/**
   * Returns a {@link Filter} instance that uses the "none" operator.
   * @param {string} field The name of the field to filter by.
   * @param {!(Array|...*)} value A variable amount of values to be used with
   * the "none" operator. Can be passed either as a single array or as
   * separate params.
   * @return {!Filter}
   * @static
   */

	}, {
		key: 'none',
		value: function none(field) {
			var values = Array.prototype.slice.call(arguments, 1);
			if (values.length === 1 && values[0] instanceof Array) {
				values = values[0];
			}
			return new Filter(field, 'none', values);
		}

		/**
   * Returns a {@link Filter} instance that uses the "!=" operator.
   * @param {string} field The name of the field to filter by.
   * @param {*} value The filter's value.
   * @return {!Filter}
   * @static
   */

	}, {
		key: 'notEqual',
		value: function notEqual(field, value) {
			return new Filter(field, '!=', value);
		}

		/**
   * Returns a {@link Filter} instance that uses the "not" operator.
   * @param {!Filter|string} fieldOrFilter Either a {@link Filter} instance or
   * the name of the field to filter by.
   * @param {*=} opt_operatorOrValue Either the field's operator or its value.
   * @param {*=} opt_value The filter's value.
   * @return {!Filter}
   * @static
   */

	}, {
		key: 'not',
		value: function not(fieldOrFilter, opt_operatorOrValue, opt_value) {
			return Filter.toFilter(fieldOrFilter, opt_operatorOrValue, opt_value).add('not');
		}

		/**
   * Returns a {@link Filter} instance.
   * @param {string} field The name of the field to filter by.
   * @param {*} operatorOrValue If a third param is given, this should be the
   * filter's operator (like ">="). Otherwise, this will be used as the
   * filter's value, and the filter's operator will be "=".
   * @param {*=} opt_value The filter's value.
   * @return {!Filter}
   * @static
   */

	}, {
		key: 'field',
		value: function field(_field, operatorOrValue, opt_value) {
			return new Filter(_field, operatorOrValue, opt_value);
		}
	}, {
		key: 'toFilter',
		value: function toFilter(fieldOrFilter, opt_operatorOrValue, opt_value) {
			var filter = fieldOrFilter;
			if (!(filter instanceof Filter)) {
				filter = Filter.field(fieldOrFilter, opt_operatorOrValue, opt_value);
			}
			return filter;
		}
	}]);
	return Filter;
}(Embodied);

/**
 * String constant that represents all fields.
 * @type {string}
 * @static
 */


Filter.ALL = '*';

/**
 * Parses the given uri string into an object.
 * @param {*=} opt_uri Optional string URI to parse
 */

function parseFromAnchor(opt_uri) {
	var link = document.createElement('a');
	link.href = opt_uri;
	return {
		hash: link.hash,
		hostname: link.hostname,
		password: link.password,
		pathname: link.pathname[0] === '/' ? link.pathname : '/' + link.pathname,
		port: link.port,
		protocol: link.protocol,
		search: link.search,
		username: link.username
	};
}

/**
 * Parses the given uri string into an object. The URL function will be used
 * when present, otherwise we'll fall back to the anchor node element.
 * @param {*=} opt_uri Optional string URI to parse
 */
function parse(opt_uri) {
	if (isFunction(URL) && URL.length) {
		return new URL(opt_uri);
	} else {
		return parseFromAnchor(opt_uri);
	}
}

/**
 * A cached reference to the create function.
 */
var create$1 = Object.create;

/**
 * Case insensitive string Multimap implementation. Allows multiple values for
 * the same key name.
 * @extends {Disposable}
 */

var MultiMap = function (_Disposable) {
	inherits(MultiMap, _Disposable);

	function MultiMap() {
		classCallCheck(this, MultiMap);

		var _this = possibleConstructorReturn(this, (MultiMap.__proto__ || Object.getPrototypeOf(MultiMap)).call(this));

		_this.keys = create$1(null);
		_this.values = create$1(null);
		return _this;
	}

	/**
  * Adds value to a key name.
  * @param {string} name
  * @param {*} value
  * @chainable
  */


	createClass(MultiMap, [{
		key: 'add',
		value: function add(name, value) {
			this.keys[name.toLowerCase()] = name;
			this.values[name.toLowerCase()] = this.values[name.toLowerCase()] || [];
			this.values[name.toLowerCase()].push(value);
			return this;
		}

		/**
   * Clears map names and values.
   * @chainable
   */

	}, {
		key: 'clear',
		value: function clear() {
			this.keys = create$1(null);
			this.values = create$1(null);
			return this;
		}

		/**
   * Checks if map contains a value to the key name.
   * @param {string} name
   * @return {boolean}
   * @chainable
   */

	}, {
		key: 'contains',
		value: function contains(name) {
			return name.toLowerCase() in this.values;
		}

		/**
   * @inheritDoc
   */

	}, {
		key: 'disposeInternal',
		value: function disposeInternal() {
			this.values = null;
		}

		/**
   * Creates a `MultiMap` instance from the given object.
   * @param {!Object} obj
   * @return {!MultiMap}
   */

	}, {
		key: 'get',


		/**
   * Gets the first added value from a key name.
   * @param {string} name
   * @return {*}
   * @chainable
   */
		value: function get(name) {
			var values = this.values[name.toLowerCase()];
			if (values) {
				return values[0];
			}
		}

		/**
   * Gets all values from a key name.
   * @param {string} name
   * @return {Array.<*>}
   */

	}, {
		key: 'getAll',
		value: function getAll(name) {
			return this.values[name.toLowerCase()];
		}

		/**
   * Returns true if the map is empty, false otherwise.
   * @return {boolean}
   */

	}, {
		key: 'isEmpty',
		value: function isEmpty() {
			return this.size() === 0;
		}

		/**
   * Gets array of key names.
   * @return {Array.<string>}
   */

	}, {
		key: 'names',
		value: function names() {
			var _this2 = this;

			return Object.keys(this.values).map(function (key) {
				return _this2.keys[key];
			});
		}

		/**
   * Removes all values from a key name.
   * @param {string} name
   * @chainable
   */

	}, {
		key: 'remove',
		value: function remove(name) {
			delete this.keys[name.toLowerCase()];
			delete this.values[name.toLowerCase()];
			return this;
		}

		/**
   * Sets the value of a key name. Relevant to replace the current values with
   * a new one.
   * @param {string} name
   * @param {*} value
   * @chainable
   */

	}, {
		key: 'set',
		value: function set(name, value) {
			this.keys[name.toLowerCase()] = name;
			this.values[name.toLowerCase()] = [value];
			return this;
		}

		/**
   * Gets the size of the map key names.
   * @return {number}
   */

	}, {
		key: 'size',
		value: function size() {
			return this.names().length;
		}

		/**
   * Returns the parsed values as a string.
   * @return {string}
   */

	}, {
		key: 'toString',
		value: function toString() {
			return JSON.stringify(this.values);
		}
	}], [{
		key: 'fromObject',
		value: function fromObject(obj) {
			var map = new MultiMap();
			var keys = Object.keys(obj);
			for (var i = 0; i < keys.length; i++) {
				map.set(keys[i], obj[keys[i]]);
			}
			return map;
		}
	}]);
	return MultiMap;
}(Disposable);

/**
 * Generic tree node data structure with arbitrary number of child nodes.
 * @param {V} value Value.
 * @constructor
 */

var TreeNode = function () {
	function TreeNode(value) {
		classCallCheck(this, TreeNode);

		/**
   * The value.
   * @private {V}
   */
		this.value_ = value;

		/**
   * Reference to the parent node or null if it has no parent.
   * @private {TreeNode}
   */
		this.parent_ = null;

		/**
   * Child nodes or null in case of leaf node.
   * @private {Array<!TreeNode>}
   */
		this.children_ = null;
	}

	/**
  * Appends a child node to this node.
  * @param {!TreeNode} child Orphan child node.
  */


	createClass(TreeNode, [{
		key: 'addChild',
		value: function addChild(child) {
			assertChildHasNoParent(child);
			child.setParent(this);
			this.children_ = this.children_ || [];
			this.children_.push(child);
		}

		/**
   * Tells whether this node is the ancestor of the given node.
   * @param {!TreeNode} node A node.
   * @return {boolean} Whether this node is the ancestor of {@code node}.
   */

	}, {
		key: 'contains',
		value: function contains(node) {
			var current = node.getParent();
			while (current) {
				if (current === this) {
					return true;
				}
				current = current.getParent();
			}
			return false;
		}

		/**
   * @return {!Array<TreeNode>} All ancestor nodes in bottom-up order.
   */

	}, {
		key: 'getAncestors',
		value: function getAncestors() {
			var ancestors = [];
			var node = this.getParent();
			while (node) {
				ancestors.push(node);
				node = node.getParent();
			}
			return ancestors;
		}

		/**
   * Gets the child node of this node at the given index.
   * @param {number} index Child index.
   * @return {?TreeNode} The node at the given index
   * or null if not found.
   */

	}, {
		key: 'getChildAt',
		value: function getChildAt(index) {
			return this.getChildren()[index] || null;
		}

		/**
   * @return {?Array<!TreeNode>} Child nodes or null in case of leaf node.
   */

	}, {
		key: 'getChildren',
		value: function getChildren() {
			return this.children_ || TreeNode.EMPTY_ARRAY;
		}

		/**
   * @return {number} The number of children.
   */

	}, {
		key: 'getChildCount',
		value: function getChildCount() {
			return this.getChildren().length;
		}

		/**
   * @return {number} The number of ancestors of the node.
   */

	}, {
		key: 'getDepth',
		value: function getDepth() {
			var depth = 0;
			var node = this;
			while (node.getParent()) {
				depth++;
				node = node.getParent();
			}
			return depth;
		}

		/**
   * @return {?TreeNode} Parent node or null if it has no parent.
   */

	}, {
		key: 'getParent',
		value: function getParent() {
			return this.parent_;
		}

		/**
   * @return {!TreeNode} The root of the tree structure, i.e. the farthest
   * ancestor of the node or the node itself if it has no parents.
   */

	}, {
		key: 'getRoot',
		value: function getRoot() {
			var root = this;
			while (root.getParent()) {
				root = root.getParent();
			}
			return root;
		}

		/**
   * Gets the value.
   * @return {V} The value.
   */

	}, {
		key: 'getValue',
		value: function getValue() {
			return this.value_;
		}

		/**
   * @return {boolean} Whether the node is a leaf node.
   */

	}, {
		key: 'isLeaf',
		value: function isLeaf() {
			return !this.getChildCount();
		}

		/**
   * Removes the given child node of this node.
   * @param {TreeNode} child The node to remove.
   * @return {TreeNode} The removed node if any, null otherwise.
   */

	}, {
		key: 'removeChild',
		value: function removeChild(child) {
			if (array.remove(this.getChildren(), child)) {
				return child;
			}
			return null;
		}

		/**
   * Sets the parent node of this node. The callers must ensure that the
   * parent node and only that has this node among its children.
   * @param {TreeNode} parent The parent to set. If null, the node will be
   * detached from the tree.
   * @protected
   */

	}, {
		key: 'setParent',
		value: function setParent(parent) {
			this.parent_ = parent;
		}

		/**
   * Traverses the subtree. The first callback starts with this node,
   * and visits the descendant nodes depth-first, in preorder.
   * The second callback, starts with deepest child then visits
   * the ancestor nodes depth-first, in postorder. E.g.
   *
   *  	 A
   *    / \
   *   B   C
   *  /   / \
   * D   E   F
   *
   * preorder -> ['A', 'B', 'D', 'C', 'E', 'F']
   * postorder -> ['D', 'B', 'E', 'F', 'C', 'A']
   *
   * @param {function=} opt_preorderFn The callback to execute when visiting a node.
   * @param {function=} opt_postorderFn The callback to execute before leaving a node.
   */

	}, {
		key: 'traverse',
		value: function traverse(opt_preorderFn, opt_postorderFn) {
			if (opt_preorderFn) {
				opt_preorderFn(this);
			}
			this.getChildren().forEach(function (child) {
				return child.traverse(opt_preorderFn, opt_postorderFn);
			});
			if (opt_postorderFn) {
				opt_postorderFn(this);
			}
		}
	}]);
	return TreeNode;
}();

/**
 * Constant for empty array to avoid unnecessary allocations.
 * @private
 */


TreeNode.EMPTY_ARRAY = [];

/**
 * Asserts that child has no parent.
 * @param {TreeNode} child A child.
 * @private
 */
var assertChildHasNoParent = function assertChildHasNoParent(child) {
	if (child.getParent()) {
		throw new Error('Cannot add child with parent.');
	}
};

var parseFn_ = parse;

var Uri = function () {

	/**
  * This class contains setters and getters for the parts of the URI.
  * The following figure displays an example URIs and their component parts.
  *
  *                                  path
  *	                             ┌───┴────┐
  *	  abc://example.com:123/path/data?key=value#fragid1
  *	  └┬┘   └────┬────┘ └┬┘           └───┬───┘ └──┬──┘
  * protocol  hostname  port            search    hash
  *          └──────┬───────┘
  *                host
  *
  * @param {*=} opt_uri Optional string URI to parse
  * @constructor
  */
	function Uri() {
		var opt_uri = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
		classCallCheck(this, Uri);

		this.url = Uri.parse(this.maybeAddProtocolAndHostname_(opt_uri));
	}

	/**
  * Adds parameters to uri from a <code>MultiMap</code> as source.
  * @param {MultiMap} multimap The <code>MultiMap</code> containing the
  *   parameters.
  * @protected
  * @chainable
  */


	createClass(Uri, [{
		key: 'addParametersFromMultiMap',
		value: function addParametersFromMultiMap(multimap) {
			var _this = this;

			multimap.names().forEach(function (name) {
				multimap.getAll(name).forEach(function (value) {
					_this.addParameterValue(name, value);
				});
			});
			return this;
		}

		/**
   * Adds the value of the named query parameters.
   * @param {string} key The parameter to set.
   * @param {*} value The new value. Will be explicitly casted to String.
   * @chainable
   */

	}, {
		key: 'addParameterValue',
		value: function addParameterValue(name, value) {
			this.ensureQueryInitialized_();
			if (isDef(value)) {
				value = String(value);
			}
			this.query.add(name, value);
			return this;
		}

		/**
   * Adds the values of the named query parameter.
   * @param {string} key The parameter to set.
   * @param {*} value The new value.
   * @chainable
   */

	}, {
		key: 'addParameterValues',
		value: function addParameterValues(name, values) {
			var _this2 = this;

			values.forEach(function (value) {
				return _this2.addParameterValue(name, value);
			});
			return this;
		}

		/**
   * Ensures query internal map is initialized and synced with initial value
   * extracted from URI search part.
   * @protected
   */

	}, {
		key: 'ensureQueryInitialized_',
		value: function ensureQueryInitialized_() {
			var _this3 = this;

			if (this.query) {
				return;
			}
			this.query = new MultiMap();
			var search = this.url.search;
			if (search) {
				search.substring(1).split('&').forEach(function (param) {
					var _param$split = param.split('=');

					var _param$split2 = slicedToArray(_param$split, 2);

					var key = _param$split2[0];
					var value = _param$split2[1];

					if (isDef(value)) {
						value = Uri.urlDecode(value);
					}
					_this3.addParameterValue(key, value);
				});
			}
		}

		/**
   * Gets the hash part of uri.
   * @return {string}
   */

	}, {
		key: 'getHash',
		value: function getHash() {
			return this.url.hash || '';
		}

		/**
   * Gets the host part of uri. E.g. <code>[hostname]:[port]</code>.
   * @return {string}
   */

	}, {
		key: 'getHost',
		value: function getHost() {
			var host = this.getHostname();
			if (host) {
				var port = this.getPort();
				if (port && port !== '80') {
					host += ':' + port;
				}
			}
			return host;
		}

		/**
   * Gets the hostname part of uri without protocol and port.
   * @return {string}
   */

	}, {
		key: 'getHostname',
		value: function getHostname() {
			var hostname = this.url.hostname;
			if (hostname === Uri.HOSTNAME_PLACEHOLDER) {
				return '';
			}
			return hostname;
		}

		/**
   * Gets the origin part of uri. E.g. <code>http://[hostname]:[port]</code>.
   * @return {string}
   */

	}, {
		key: 'getOrigin',
		value: function getOrigin() {
			var host = this.getHost();
			if (host) {
				return this.getProtocol() + '//' + host;
			}
			return '';
		}

		/**
   * Returns the first value for a given parameter or undefined if the given
   * parameter name does not appear in the query string.
   * @param {string} paramName Unescaped parameter name.
   * @return {string|undefined} The first value for a given parameter or
   *   undefined if the given parameter name does not appear in the query
   *   string.
   */

	}, {
		key: 'getParameterValue',
		value: function getParameterValue(name) {
			this.ensureQueryInitialized_();
			return this.query.get(name);
		}

		/**
   * Returns the value<b>s</b> for a given parameter as a list of decoded
   * query parameter values.
   * @param {string} name The parameter to get values for.
   * @return {!Array<?>} The values for a given parameter as a list of decoded
   *   query parameter values.
   */

	}, {
		key: 'getParameterValues',
		value: function getParameterValues(name) {
			this.ensureQueryInitialized_();
			return this.query.getAll(name);
		}

		/**
   * Returns the name<b>s</b> of the parameters.
   * @return {!Array<string>} The names for the parameters as a list of
   *   strings.
   */

	}, {
		key: 'getParameterNames',
		value: function getParameterNames() {
			this.ensureQueryInitialized_();
			return this.query.names();
		}

		/**
   * Gets the function currently being used to parse URIs.
   * @return {!function()}
   */

	}, {
		key: 'getPathname',


		/**
   * Gets the pathname part of uri.
   * @return {string}
   */
		value: function getPathname() {
			return this.url.pathname;
		}

		/**
   * Gets the port number part of uri as string.
   * @return {string}
   */

	}, {
		key: 'getPort',
		value: function getPort() {
			return this.url.port;
		}

		/**
   * Gets the protocol part of uri. E.g. <code>http:</code>.
   * @return {string}
   */

	}, {
		key: 'getProtocol',
		value: function getProtocol() {
			return this.url.protocol;
		}

		/**
   * Gets the search part of uri. Search value is retrieved from query
   * parameters.
   * @return {string}
   */

	}, {
		key: 'getSearch',
		value: function getSearch() {
			var _this4 = this;

			var search = '';
			var querystring = '';
			this.getParameterNames().forEach(function (name) {
				_this4.getParameterValues(name).forEach(function (value) {
					querystring += name;
					if (isDef(value)) {
						querystring += '=' + encodeURIComponent(value);
					}
					querystring += '&';
				});
			});
			querystring = querystring.slice(0, -1);
			if (querystring) {
				search += '?' + querystring;
			}
			return search;
		}

		/**
   * Checks if uri contains the parameter.
   * @param {string} name
   * @return {boolean}
   */

	}, {
		key: 'hasParameter',
		value: function hasParameter(name) {
			this.ensureQueryInitialized_();
			return this.query.contains(name);
		}

		/**
   * Makes this URL unique by adding a random param to it. Useful for avoiding
   * cache.
   */

	}, {
		key: 'makeUnique',
		value: function makeUnique() {
			this.setParameterValue(Uri.RANDOM_PARAM, string.getRandomString());
			return this;
		}

		/**
   * Maybe adds protocol and a hostname placeholder on a parial URI if needed.
   * Relevent for compatibility with <code>URL</code> native object.
   * @param {string=} opt_uri
   * @return {string} URI with protocol and hostname placeholder.
   */

	}, {
		key: 'maybeAddProtocolAndHostname_',
		value: function maybeAddProtocolAndHostname_(opt_uri) {
			var url = opt_uri;
			if (opt_uri.indexOf('://') === -1 && opt_uri.indexOf('javascript:') !== 0) {
				// jshint ignore:line

				url = Uri.DEFAULT_PROTOCOL;
				if (opt_uri[0] !== '/' || opt_uri[1] !== '/') {
					url += '//';
				}

				switch (opt_uri.charAt(0)) {
					case '.':
					case '?':
					case '#':
						url += Uri.HOSTNAME_PLACEHOLDER;
						url += '/';
						url += opt_uri;
						break;
					case '':
					case '/':
						if (opt_uri[1] !== '/') {
							url += Uri.HOSTNAME_PLACEHOLDER;
						}
						url += opt_uri;
						break;
					default:
						url += opt_uri;
				}
			}
			return url;
		}

		/**
   * Normalizes the parsed object to be in the expected standard.
   * @param {!Object}
   */

	}, {
		key: 'removeParameter',


		/**
   * Removes the named query parameter.
   * @param {string} name The parameter to remove.
   * @chainable
   */
		value: function removeParameter(name) {
			this.ensureQueryInitialized_();
			this.query.remove(name);
			return this;
		}

		/**
   * Removes uniqueness parameter of the uri.
   * @chainable
   */

	}, {
		key: 'removeUnique',
		value: function removeUnique() {
			this.removeParameter(Uri.RANDOM_PARAM);
			return this;
		}

		/**
   * Sets the hash.
   * @param {string} hash
   * @chainable
   */

	}, {
		key: 'setHash',
		value: function setHash(hash) {
			this.url.hash = hash;
			return this;
		}

		/**
   * Sets the hostname.
   * @param {string} hostname
   * @chainable
   */

	}, {
		key: 'setHostname',
		value: function setHostname(hostname) {
			this.url.hostname = hostname;
			return this;
		}

		/**
   * Sets the value of the named query parameters, clearing previous values
   * for that key.
   * @param {string} key The parameter to set.
   * @param {*} value The new value.
   * @chainable
   */

	}, {
		key: 'setParameterValue',
		value: function setParameterValue(name, value) {
			this.removeParameter(name);
			this.addParameterValue(name, value);
			return this;
		}

		/**
   * Sets the values of the named query parameters, clearing previous values
   * for that key.
   * @param {string} key The parameter to set.
   * @param {*} value The new value.
   * @chainable
   */

	}, {
		key: 'setParameterValues',
		value: function setParameterValues(name, values) {
			var _this5 = this;

			this.removeParameter(name);
			values.forEach(function (value) {
				return _this5.addParameterValue(name, value);
			});
			return this;
		}

		/**
   * Sets the pathname.
   * @param {string} pathname
   * @chainable
   */

	}, {
		key: 'setPathname',
		value: function setPathname(pathname) {
			this.url.pathname = pathname;
			return this;
		}

		/**
   * Sets the port number.
   * @param {*} port Port number.
   * @chainable
   */

	}, {
		key: 'setPort',
		value: function setPort(port) {
			this.url.port = port;
			return this;
		}

		/**
   * Sets the function that will be used for parsing the original string uri
   * into an object.
   * @param {!function()} parseFn
   */

	}, {
		key: 'setProtocol',


		/**
   * Sets the protocol. If missing <code>http:</code> is used as default.
   * @param {string} protocol
   * @chainable
   */
		value: function setProtocol(protocol) {
			this.url.protocol = protocol;
			if (this.url.protocol[this.url.protocol.length - 1] !== ':') {
				this.url.protocol += ':';
			}
			return this;
		}

		/**
   * @return {string} The string form of the url.
   * @override
   */

	}, {
		key: 'toString',
		value: function toString() {
			var href = '';
			var host = this.getHost();
			if (host) {
				href += this.getProtocol() + '//';
			}
			href += host + this.getPathname() + this.getSearch() + this.getHash();
			return href;
		}

		/**
   * Joins the given paths.
   * @param {string} basePath
   * @param {...string} ...paths Any number of paths to be joined with the base url.
   * @static
   */

	}], [{
		key: 'getParseFn',
		value: function getParseFn() {
			return parseFn_;
		}
	}, {
		key: 'normalizeObject',
		value: function normalizeObject(parsed) {
			var length = parsed.pathname ? parsed.pathname.length : 0;
			if (length > 1 && parsed.pathname[length - 1] === '/') {
				parsed.pathname = parsed.pathname.substr(0, length - 1);
			}
			return parsed;
		}

		/**
   * Parses the given uri string into an object.
   * @param {*=} opt_uri Optional string URI to parse
   */

	}, {
		key: 'parse',
		value: function parse(opt_uri) {
			return Uri.normalizeObject(parseFn_(opt_uri));
		}
	}, {
		key: 'setParseFn',
		value: function setParseFn(parseFn) {
			parseFn_ = parseFn;
		}
	}, {
		key: 'joinPaths',
		value: function joinPaths(basePath) {
			for (var _len = arguments.length, paths = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
				paths[_key - 1] = arguments[_key];
			}

			if (basePath.charAt(basePath.length - 1) === '/') {
				basePath = basePath.substring(0, basePath.length - 1);
			}
			paths = paths.map(function (path) {
				return path.charAt(0) === '/' ? path.substring(1) : path;
			});
			return [basePath].concat(paths).join('/').replace(/\/$/, '');
		}

		/**
   * URL-decodes the string. We need to specially handle '+'s because
   * the javascript library doesn't convert them to spaces.
   * @param {string} str The string to url decode.
   * @return {string} The decoded {@code str}.
   */

	}, {
		key: 'urlDecode',
		value: function urlDecode(str) {
			return decodeURIComponent(str.replace(/\+/g, ' '));
		}
	}]);
	return Uri;
}();

/**
 * Default protocol value.
 * @type {string}
 * @default http:
 * @static
 */


Uri.DEFAULT_PROTOCOL = 'http:';

/**
 * Hostname placeholder. Relevant to internal usage only.
 * @type {string}
 * @static
 */
Uri.HOSTNAME_PLACEHOLDER = 'hostname' + Date.now();

/**
 * Name used by the param generated by `makeUnique`.
 * @type {string}
 * @static
 */
Uri.RANDOM_PARAM = 'zx';

function assertBrowserEnvironment() {
	if (!globals.window) {
		throw new Error('Sign-in type not supported in this environment');
	}
}

function assertDefAndNotNull(value, errorMessage) {
	if (!isDefAndNotNull(value)) {
		throw new Error(errorMessage);
	}
}

function assertFunction(value, errorMessage) {
	if (!isFunction(value)) {
		throw new Error(errorMessage);
	}
}

function assertObject(value, errorMessage) {
	if (!isObject(value)) {
		throw new Error(errorMessage);
	}
}

function assertResponseSucceeded(response) {
	if (!response.succeeded()) {
		throw response.body();
	}
	return response;
}

function assertUserSignedIn(user) {
	if (!isDefAndNotNull(user)) {
		throw new Error('You must be signed-in to perform this operation');
	}
}

function assertUriWithNoPath(url, message) {
	var uri = new Uri(url);
	if (uri.getPathname().length > 1) {
		throw new Error(message);
	}
}

/**
 * Class responsible for storing authorization information.
 */

var Auth = function () {
	/**
  * Constructs an {@link Auth} instance.
  * @param {string} tokenOrEmail Either the authorization token, or
  *   the username.
  * @param {string=} opt_password If a username is given as the first param,
  *   this should be the password.
  * @constructor
  */
	function Auth(tokenOrEmail) {
		var opt_password = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
		classCallCheck(this, Auth);

		this.token = isString(opt_password) ? null : tokenOrEmail;
		this.email = isString(opt_password) ? tokenOrEmail : null;
		this.password = opt_password;

		this.createdAt = null;
		this.id = null;
		this.name = null;
		this.photoUrl = null;
		this.wedeployClient = null;
	}

	/**
  * Constructs an {@link Auth} instance.
  * @param {string} tokenOrUsername Either the authorization token, or
  *   the username.
  * @param {string=} opt_password If a username is given as the first param,
  *   this should be the password.
  * @return {!Auth}
  */


	createClass(Auth, [{
		key: 'getCreatedAt',


		/**
   * Gets the created at date.
   * @return {string}
   */
		value: function getCreatedAt() {
			return this.createdAt;
		}

		/**
   * Gets the email.
   * @return {string}
   */

	}, {
		key: 'getEmail',
		value: function getEmail() {
			return this.email;
		}

		/**
   * Gets the id.
   * @return {string}
   */

	}, {
		key: 'getId',
		value: function getId() {
			return this.id;
		}

		/**
   * Gets the name.
   * @return {string}
   */

	}, {
		key: 'getName',
		value: function getName() {
			return this.name;
		}

		/**
   * Gets the password.
   * @return {string}
   */

	}, {
		key: 'getPassword',
		value: function getPassword() {
			return this.password;
		}

		/**
   * Gets the photo url.
   * @return {string}
   */

	}, {
		key: 'getPhotoUrl',
		value: function getPhotoUrl() {
			return this.photoUrl;
		}

		/**
   * Gets the token.
   * @return {string}
   */

	}, {
		key: 'getToken',
		value: function getToken() {
			return this.token;
		}

		/**
   * Checks if created at is set.
   * @return {boolean}
   */

	}, {
		key: 'hasCreatedAt',
		value: function hasCreatedAt() {
			return isDefAndNotNull(this.createdAt);
		}

		/**
   * Checks if the email is set.
   * @return {boolean}
   */

	}, {
		key: 'hasEmail',
		value: function hasEmail() {
			return isDefAndNotNull(this.email);
		}

		/**
   * Checks if the id is set.
   * @return {boolean}
   */

	}, {
		key: 'hasId',
		value: function hasId() {
			return isDefAndNotNull(this.id);
		}

		/**
   * Checks if the name is set.
   * @return {boolean}
   */

	}, {
		key: 'hasName',
		value: function hasName() {
			return isDefAndNotNull(this.name);
		}

		/**
   * Checks if the password is set.
   * @return {boolean}
   */

	}, {
		key: 'hasPassword',
		value: function hasPassword() {
			return isDefAndNotNull(this.password);
		}

		/**
   * Checks if the photo url is set.
   * @return {boolean}
   */

	}, {
		key: 'hasPhotoUrl',
		value: function hasPhotoUrl() {
			return isDefAndNotNull(this.photoUrl);
		}

		/**
   * Checks if the token is set.
   * @return {boolean}
   */

	}, {
		key: 'hasToken',
		value: function hasToken() {
			return isDefAndNotNull(this.token);
		}

		/**
   * Sets created at.
   * @param {string} createdAt
   */

	}, {
		key: 'setCreatedAt',
		value: function setCreatedAt(createdAt) {
			this.createdAt = createdAt;
		}

		/**
   * Sets the email.
   * @param {string} email
   */

	}, {
		key: 'setEmail',
		value: function setEmail(email) {
			this.email = email;
		}

		/**
   * Sets the id.
   * @param {string} id
   */

	}, {
		key: 'setId',
		value: function setId(id) {
			this.id = id;
		}

		/**
   * Sets the name.
   * @param {string} name
   */

	}, {
		key: 'setName',
		value: function setName(name) {
			this.name = name;
		}

		/**
   * Sets the password.
   * @param {string} password
   */

	}, {
		key: 'setPassword',
		value: function setPassword(password) {
			this.password = password;
		}

		/**
   * Sets the photo url.
   * @param {string} photoUrl
   */

	}, {
		key: 'setPhotoUrl',
		value: function setPhotoUrl(photoUrl) {
			this.photoUrl = photoUrl;
		}

		/**
   * Sets the token.
   * @param {string} token
   */

	}, {
		key: 'setToken',
		value: function setToken(token) {
			this.token = token;
		}
	}, {
		key: 'setWedeployClient',
		value: function setWedeployClient(wedeployClient) {
			this.wedeployClient = wedeployClient;
		}

		/**
   * Updates the user.
   * @param {!object} data
   * @return {CompletableFuture}
   */

	}, {
		key: 'updateUser',
		value: function updateUser(data) {
			assertObject(data, 'User data must be specified as object');
			return this.wedeployClient.url(this.wedeployClient.authUrl_).path('/users').auth(this).patch(data).then(function (response) {
				return assertResponseSucceeded(response);
			});
		}

		/**
   * Deletes the current user.
   * @return {CompletableFuture}
   */

	}, {
		key: 'deleteUser',
		value: function deleteUser() {
			assertDefAndNotNull(this.id, 'Cannot delete user without id');
			return this.wedeployClient.url(this.wedeployClient.authUrl_).path('/users', this.id).auth(this).delete().then(function (response) {
				return assertResponseSucceeded(response);
			});
		}
	}], [{
		key: 'create',
		value: function create(tokenOrUsername, opt_password) {
			return new Auth(tokenOrUsername, opt_password);
		}
	}]);
	return Auth;
}();

var ApiHelper = function () {

	/**
  * Constructs an {@link ApiHelper} instance.
  * @constructor
  */
	function ApiHelper(wedeployClient) {
		classCallCheck(this, ApiHelper);

		assertDefAndNotNull(wedeployClient, 'WeDeploy client reference must be specified');
		this.wedeployClient = wedeployClient;
	}

	/**
  * Adds authorization information to this request.
  * @param {!Auth|string} authOrTokenOrEmail Either an {@link Auth} instance,
  * an authorization token, or the email.
  * @param {string=} opt_password If a email is given as the first param,
  * this should be the password.
  * @chainable
  */


	createClass(ApiHelper, [{
		key: 'auth',
		value: function auth(authOrTokenOrEmail, opt_password) {
			this.helperAuthScope = authOrTokenOrEmail;
			if (!(this.helperAuthScope instanceof Auth)) {
				this.helperAuthScope = Auth.create(authOrTokenOrEmail, opt_password);
			}
			return this;
		}
	}]);
	return ApiHelper;
}();

/**
 * Class responsible for encapsulate provider information.
 */

var AuthProvider = function () {
	/**
  * Constructs an {@link AuthProvider} instance.
  * @constructor
  */
	function AuthProvider() {
		classCallCheck(this, AuthProvider);

		this.provider = null;
		this.providerScope = null;
		this.redirectUri = null;
		this.scope = null;
	}

	/**
  * Checks if provider is defined and not null.
  * @return {boolean}
  */


	createClass(AuthProvider, [{
		key: 'hasProvider',
		value: function hasProvider() {
			return isDefAndNotNull(this.provider);
		}

		/**
   * Checks if scope is defined and not null.
   * @return {boolean}
   */

	}, {
		key: 'hasProviderScope',
		value: function hasProviderScope() {
			return isDefAndNotNull(this.providerScope);
		}

		/**
   * Checks if redirect uri is defined and not null.
   * @return {boolean}
   */

	}, {
		key: 'hasRedirectUri',
		value: function hasRedirectUri() {
			return isDefAndNotNull(this.redirectUri);
		}

		/**
   * Checks if scope is defined and not null.
   * @return {boolean}
   */

	}, {
		key: 'hasScope',
		value: function hasScope() {
			return isDefAndNotNull(this.scope);
		}

		/**
   * Makes authorization url.
   * @return {string=} Authorization url.
   */

	}, {
		key: 'makeAuthorizationUrl',
		value: function makeAuthorizationUrl(opt_authUrl) {
			var uri = new Uri(opt_authUrl);

			uri.setPathname('/oauth/authorize');

			if (this.hasProvider()) {
				uri.setParameterValue('provider', this.getProvider());
			}
			if (this.hasProviderScope()) {
				uri.setParameterValue('provider_scope', this.getProviderScope());
			}
			if (this.hasRedirectUri()) {
				uri.setParameterValue('redirect_uri', this.getRedirectUri());
			}
			if (this.hasScope()) {
				uri.setParameterValue('scope', this.getScope());
			}

			return uri.toString();
		}

		/**
   * Gets provider name.
   * @return {string=} Provider name.
   */

	}, {
		key: 'getProvider',
		value: function getProvider() {
			return this.provider;
		}

		/**
   * Gets provider scope.
   * @return {string=} String with scopes.
   */

	}, {
		key: 'getProviderScope',
		value: function getProviderScope() {
			return this.providerScope;
		}

		/**
   * Gets redirect uri.
   * @return {string=}.
   */

	}, {
		key: 'getRedirectUri',
		value: function getRedirectUri() {
			return this.redirectUri;
		}

		/**
   * Gets scope.
   * @return {string=} String with scopes.
   */

	}, {
		key: 'getScope',
		value: function getScope() {
			return this.scope;
		}

		/**
   * Sets provider scope.
   * @param {string=} scope Scope string. Separate by space for multiple
   *   scopes, e.g. "scope1 scope2".
   */

	}, {
		key: 'setProviderScope',
		value: function setProviderScope(providerScope) {
			assertStringIfDefAndNotNull(providerScope, 'Provider scope must be a string');
			this.providerScope = providerScope;
		}

		/**
   * Sets redirect uri.
   * @param {string=} redirectUri.
   */

	}, {
		key: 'setRedirectUri',
		value: function setRedirectUri(redirectUri) {
			assertStringIfDefAndNotNull(redirectUri, 'Redirect uri must be a string');
			this.redirectUri = redirectUri;
		}

		/**
   * Sets scope.
   * @param {string=} scope Scope string. Separate by space for multiple
   *   scopes, e.g. "scope1 scope2".
   */

	}, {
		key: 'setScope',
		value: function setScope(scope) {
			assertStringIfDefAndNotNull(scope, 'Scope must be a string');
			this.scope = scope;
		}
	}]);
	return AuthProvider;
}();

function assertStringIfDefAndNotNull(value, errorMessage) {
	if (isDefAndNotNull(value) && !isString(value)) {
		throw new Error(errorMessage);
	}
}

/**
 * Facebook auth provider implementation.
 */

var FacebookAuthProvider = function (_AuthProvider) {
	inherits(FacebookAuthProvider, _AuthProvider);

	/**
  * Constructs an {@link FacebookAuthProvider} instance.
  * @constructor
  */
	function FacebookAuthProvider() {
		classCallCheck(this, FacebookAuthProvider);

		var _this = possibleConstructorReturn(this, (FacebookAuthProvider.__proto__ || Object.getPrototypeOf(FacebookAuthProvider)).call(this));

		_this.provider = FacebookAuthProvider.PROVIDER;
		return _this;
	}

	return FacebookAuthProvider;
}(AuthProvider);

FacebookAuthProvider.PROVIDER = 'facebook';

/**
 * Github auth provider implementation.
 */

var GithubAuthProvider = function (_AuthProvider) {
	inherits(GithubAuthProvider, _AuthProvider);

	/**
  * Constructs an {@link GithubAuthProvider} instance.
  * @constructor
  */
	function GithubAuthProvider() {
		classCallCheck(this, GithubAuthProvider);

		var _this = possibleConstructorReturn(this, (GithubAuthProvider.__proto__ || Object.getPrototypeOf(GithubAuthProvider)).call(this));

		_this.provider = GithubAuthProvider.PROVIDER;
		return _this;
	}

	return GithubAuthProvider;
}(AuthProvider);

GithubAuthProvider.PROVIDER = 'github';

/**
 * Google auth provider implementation.
 */

var GoogleAuthProvider = function (_AuthProvider) {
	inherits(GoogleAuthProvider, _AuthProvider);

	/**
  * Constructs an {@link GoogleAuthProvider} instance.
  * @constructor
  */
	function GoogleAuthProvider() {
		classCallCheck(this, GoogleAuthProvider);

		var _this = possibleConstructorReturn(this, (GoogleAuthProvider.__proto__ || Object.getPrototypeOf(GoogleAuthProvider)).call(this));

		_this.provider = GoogleAuthProvider.PROVIDER;
		return _this;
	}

	return GoogleAuthProvider;
}(AuthProvider);

GoogleAuthProvider.PROVIDER = 'google';

/* jshint ignore:start */

/**
 * Abstract interface for storing and retrieving data using some persistence
 * mechanism.
 * @constructor
 */

var StorageMechanism = function () {
	function StorageMechanism() {
		classCallCheck(this, StorageMechanism);
	}

	createClass(StorageMechanism, [{
		key: 'clear',

		/**
   * Clear all items from the data storage.
   */
		value: function clear() {
			throw Error('Unimplemented abstract method');
		}

		/**
   * Sets an item in the data storage.
   * @param {string} key The key to set.
   * @param {*} value The value to serialize to a string and save.
   */

	}, {
		key: 'set',
		value: function set(key, value) {
			throw Error('Unimplemented abstract method');
		}

		/**
   * Gets an item from the data storage.
   * @param {string} key The key to get.
   * @return {*} Deserialized value or undefined if not found.
   */

	}, {
		key: 'get',
		value: function get(key) {
			throw Error('Unimplemented abstract method');
		}

		/**
   * Checks if this mechanism is supported in the current environment.
   * Subclasses should override this when necessary.
   */

	}, {
		key: 'keys',


		/**
   * Returns the list of keys stored in the Storage object.
   * @param {!Array<string>} keys
   */
		value: function keys() {
			throw Error('Unimplemented abstract method');
		}

		/**
   * Removes an item from the data storage.
   * @param {string} key The key to remove.
   */

	}, {
		key: 'remove',
		value: function remove(key) {
			throw Error('Unimplemented abstract method');
		}

		/**
   * Returns the number of data items stored in the Storage object.
   * @return {number}
   */

	}, {
		key: 'size',
		value: function size() {
			throw Error('Unimplemented abstract method');
		}
	}], [{
		key: 'isSupported',
		value: function isSupported() {
			return true;
		}
	}]);
	return StorageMechanism;
}();

/* jshint ignore:end */

var Storage = function () {

	/**
  * Provides a convenient API for data persistence using a selected data
  * storage mechanism.
  * @param {!StorageMechanism} mechanism The underlying storage mechanism.
  * @constructor
  */
	function Storage(mechanism) {
		classCallCheck(this, Storage);

		assertMechanismDefAndNotNull(mechanism);
		assertMechanismIntanceOf(mechanism);

		/**
   * The mechanism used to persist key-value pairs.
   * @type {StorageMechanism}
   * @protected
   */
		this.mechanism = mechanism;
	}

	/**
  * Clear all items from the data storage.
  */


	createClass(Storage, [{
		key: 'clear',
		value: function clear() {
			this.mechanism.clear();
		}

		/**
   * Sets an item in the data storage.
   * @param {string} key The key to set.
   * @param {*} value The value to serialize to a string and save.
   */

	}, {
		key: 'set',
		value: function set(key, value) {
			if (!core$2.isDef(value)) {
				this.mechanism.remove(key);
				return;
			}
			this.mechanism.set(key, JSON.stringify(value));
		}

		/**
   * Gets an item from the data storage.
   * @param {string} key The key to get.
   * @return {*} Deserialized value or undefined if not found.
   */

	}, {
		key: 'get',
		value: function get(key) {
			var json;
			try {
				json = this.mechanism.get(key);
			} catch (e) {
				return undefined;
			}
			if (core$2.isNull(json)) {
				return undefined;
			}
			try {
				return JSON.parse(json);
			} catch (e) {
				throw Storage.ErrorCode.INVALID_VALUE;
			}
		}

		/**
   * Returns the list of keys stored in the Storage object.
   * @param {!Array<string>} keys
   */

	}, {
		key: 'keys',
		value: function keys() {
			return this.mechanism.keys();
		}

		/**
   * Removes an item from the data storage.
   * @param {string} key The key to remove.
   */

	}, {
		key: 'remove',
		value: function remove(key) {
			this.mechanism.remove(key);
		}

		/**
   * Returns the number of data items stored in the Storage object.
   * @return {number}
   */

	}, {
		key: 'size',
		value: function size() {
			return this.mechanism.size();
		}

		/**
   * Returns the list of values stored in the Storage object.
   * @param {!Array<string>} values
   */

	}, {
		key: 'values',
		value: function values() {
			var _this = this;

			return this.keys().map(function (key) {
				return _this.get(key);
			});
		}
	}]);
	return Storage;
}();

/**
 * Errors thrown by the storage.
 * @enum {string}
 */


Storage.ErrorCode = {
	INVALID_VALUE: 'Storage: Invalid value was encountered'
};

function assertMechanismDefAndNotNull(mechanism) {
	if (!core$2.isDefAndNotNull(mechanism)) {
		throw Error('Storage mechanism is required');
	}
}

function assertMechanismIntanceOf(mechanism) {
	if (!(mechanism instanceof StorageMechanism)) {
		throw Error('Storage mechanism must me an implementation of StorageMechanism');
	}
}

/**
 * Abstract interface for storing and retrieving data using some persistence
 * mechanism.
 * @constructor
 */

var LocalStorageMechanism = function (_StorageMechanism) {
	inherits(LocalStorageMechanism, _StorageMechanism);

	function LocalStorageMechanism() {
		classCallCheck(this, LocalStorageMechanism);
		return possibleConstructorReturn(this, (LocalStorageMechanism.__proto__ || Object.getPrototypeOf(LocalStorageMechanism)).apply(this, arguments));
	}

	createClass(LocalStorageMechanism, [{
		key: 'storage',

		/**
   * Returns reference for global local storage. by default
   */
		value: function storage() {
			return LocalStorageMechanism.globals.localStorage;
		}

		/**
   * @inheritDoc
   */

	}, {
		key: 'clear',
		value: function clear() {
			this.storage().clear();
		}

		/**
   * @inheritDoc
   */

	}, {
		key: 'keys',
		value: function keys() {
			return Object.keys(this.storage());
		}

		/**
   * @inheritDoc
   */

	}, {
		key: 'get',
		value: function get(key) {
			return this.storage().getItem(key);
		}

		/**
   * @inheritDoc
   */

	}, {
		key: 'remove',


		/**
   * @inheritDoc
   */
		value: function remove(key) {
			this.storage().removeItem(key);
		}

		/**
   * @inheritDoc
   */

	}, {
		key: 'set',
		value: function set(key, value) {
			this.storage().setItem(key, value);
		}

		/**
   * @inheritDoc
   */

	}, {
		key: 'size',
		value: function size() {
			return this.storage().length;
		}
	}], [{
		key: 'isSupported',
		value: function isSupported() {
			return typeof window !== 'undefined';
		}
	}]);
	return LocalStorageMechanism;
}(StorageMechanism);

if (LocalStorageMechanism.isSupported()) {
	LocalStorageMechanism.globals = {
		localStorage: window.localStorage
	};
}

/**
 * Class responsible for encapsulate auth api calls.
 */

var AuthApiHelper = function (_ApiHelper) {
	inherits(AuthApiHelper, _ApiHelper);

	/**
  * Constructs an {@link AuthApiHelper} instance.
  * @constructor
  */
	function AuthApiHelper(wedeployClient) {
		classCallCheck(this, AuthApiHelper);

		var _this = possibleConstructorReturn(this, (AuthApiHelper.__proto__ || Object.getPrototypeOf(AuthApiHelper)).call(this, wedeployClient));

		_this.currentUser = null;
		_this.onSignInCallback = null;
		_this.onSignOutCallback = null;
		if (LocalStorageMechanism.isSupported()) {
			_this.storage = new Storage(new LocalStorageMechanism());
		}

		_this.processSignIn_();

		_this.provider = {
			Facebook: FacebookAuthProvider,
			Google: GoogleAuthProvider,
			Github: GithubAuthProvider
		};
		return _this;
	}

	/**
  * Creates user.
  * @param {!object} data The data to be used to create the user.
  * @return {CancellablePromise}
  */


	createClass(AuthApiHelper, [{
		key: 'createUser',
		value: function createUser(data) {
			var _this2 = this;

			assertObject(data, 'User data must be specified as object');
			return this.wedeployClient.url(this.wedeployClient.authUrl_).path('/users').post(data).then(function (response) {
				return assertResponseSucceeded(response);
			}).then(function (response) {
				return _this2.makeUserAuthFromData(response.body());
			});
		}

		/**
   * Gets the current browser url without the fragment part.
   * @return {!string}
   * @protected
   */

	}, {
		key: 'getHrefWithoutFragment_',
		value: function getHrefWithoutFragment_() {
			var location = globals.window.location;
			return location.protocol + '//' + location.host + location.pathname + (location.search ? location.search : '');
		}

		/**
   * Gets the access token from the url fragment and removes it.
   * @return {?string}
   * @protected
   */

	}, {
		key: 'getRedirectAccessToken_',
		value: function getRedirectAccessToken_() {
			if (globals.window) {
				var fragment = globals.window.location.hash;
				if (fragment.indexOf('#access_token=') === 0) {
					return fragment.substring(14);
				}
			}
			return null;
		}

		/**
   * Gets user by id.
   * @param {!string} userId
   * @return {CancellablePromise}
   */

	}, {
		key: 'getUser',
		value: function getUser(userId) {
			var _this3 = this;

			assertDefAndNotNull(userId, 'User userId must be specified');
			assertUserSignedIn(this.currentUser);
			return this.wedeployClient.url(this.wedeployClient.authUrl_).path('/users', userId).auth(this.resolveAuthScope().token).get().then(function (response) {
				return assertResponseSucceeded(response);
			}).then(function (response) {
				return _this3.makeUserAuthFromData(response.body());
			});
		}

		/**
   * Loads current user. Requires a user token as argument.
   * @param {!string} token
   * @return {CancellablePromise}
   */

	}, {
		key: 'loadCurrentUser',
		value: function loadCurrentUser(token) {
			var _this4 = this;

			assertDefAndNotNull(token, 'User token must be specified');
			return this.wedeployClient.url(this.wedeployClient.authUrl_).path('/user').auth(token).get().then(function (response) {
				var data = response.body();
				data.token = token;
				_this4.currentUser = _this4.makeUserAuthFromData(data);
				if (_this4.storage) {
					_this4.storage.set('currentUser', data);
				}
				return _this4.currentUser;
			});
		}

		/**
   * Makes user Auth from data object.
   * @param {object} data
   * @return {Auth}
   * @protected
   */

	}, {
		key: 'makeUserAuthFromData',
		value: function makeUserAuthFromData(data) {
			var auth = new Auth();
			auth.setWedeployClient(this.wedeployClient);
			auth.setCreatedAt(data.createdAt);
			auth.setEmail(data.email);
			auth.setId(data.id);
			auth.setName(data.name);
			auth.setPhotoUrl(data.photoUrl);
			auth.setToken(data.token);
			return auth;
		}

		/**
   * Calls the on sign in callback if set.
   * @protected
   */

	}, {
		key: 'maybeCallOnSignInCallback_',
		value: function maybeCallOnSignInCallback_() {
			if (this.onSignInCallback) {
				this.onSignInCallback.call(this, this.currentUser);
			}
		}

		/**
   * Calls the on sign out callback if set.
   * @protected
   */

	}, {
		key: 'maybeCallOnSignOutCallback_',
		value: function maybeCallOnSignOutCallback_() {
			if (this.onSignOutCallback) {
				this.onSignOutCallback.call(this, this.currentUser);
			}
		}

		/**
   * Fires passed callback when a user sign-in. Note that it keeps only the
   * last callback passed.
   * @param {!Function} callback
   */

	}, {
		key: 'onSignIn',
		value: function onSignIn(callback) {
			assertFunction(callback, 'Sign-in callback must be a function');
			this.onSignInCallback = callback;
		}

		/**
   * Fires passed callback when a user sign-out. Note that it keeps only the
   * last callback passed.
   * @param {!Function} callback
   */

	}, {
		key: 'onSignOut',
		value: function onSignOut(callback) {
			assertFunction(callback, 'Sign-out callback must be a function');
			this.onSignOutCallback = callback;
		}

		/**
   * Processes sign-in by detecting a presence of a fragment
   * <code>#access_token=</code> in the url or, alternatively, by local
   * storage current user.
   */

	}, {
		key: 'processSignIn_',
		value: function processSignIn_() {
			var _this5 = this;

			var redirectAccessToken = this.getRedirectAccessToken_();
			if (redirectAccessToken) {
				this.removeUrlFragmentCompletely_();
				this.loadCurrentUser(redirectAccessToken).then(function () {
					return _this5.maybeCallOnSignInCallback_();
				});
				return;
			}
			var currentUser = this.storage && this.storage.get('currentUser');
			if (currentUser) {
				this.currentUser = this.makeUserAuthFromData(currentUser);
			}
		}

		/**
   * Removes fragment from url by performing a push state to the current path.
   * @protected
   */

	}, {
		key: 'removeUrlFragmentCompletely_',
		value: function removeUrlFragmentCompletely_() {
			globals.window.history.pushState({}, document.title, window.location.pathname + window.location.search);
		}

		/**
   * Resolves auth scope from last login or api helper.
   * @return {Auth}
   */

	}, {
		key: 'resolveAuthScope',
		value: function resolveAuthScope() {
			if (this.helperAuthScope) {
				return this.helperAuthScope;
			}
			return this.currentUser;
		}

		/**
   * Sends password reset email to the specified email if found in database.
   * For security reasons call do not fail if email not found.
   * @param {!string} email
   * @return {CancellablePromise}
   */

	}, {
		key: 'sendPasswordResetEmail',
		value: function sendPasswordResetEmail(email) {
			assertDefAndNotNull(email, 'Send password reset email must be specified');
			return this.wedeployClient.url(this.wedeployClient.authUrl_).path('/user/recover').param('email', email).post().then(function (response) {
				return assertResponseSucceeded(response);
			});
		}

		/**
   * Signs in using email and password.
   * @param {!string} email
   * @param {!string} password
   * @return {CancellablePromise}
   */

	}, {
		key: 'signInWithEmailAndPassword',
		value: function signInWithEmailAndPassword(email, password) {
			var _this6 = this;

			assertDefAndNotNull(email, 'Sign-in email must be specified');
			assertDefAndNotNull(password, 'Sign-in password must be specified');

			return this.wedeployClient.url(this.wedeployClient.authUrl_).path('/oauth/token').param('grant_type', 'password').param('username', email).param('password', password).get().then(function (response) {
				return assertResponseSucceeded(response);
			}).then(function (response) {
				return _this6.loadCurrentUser(response.body().access_token);
			}).then(function (user) {
				_this6.maybeCallOnSignInCallback_();
				return user;
			});
		}

		/**
   * Signs in with redirect. Some providers and environment may not support
   * this flow.
   * @param {AuthProvider} provider
   */

	}, {
		key: 'signInWithRedirect',
		value: function signInWithRedirect(provider) {
			assertBrowserEnvironment();
			assertDefAndNotNull(provider, 'Sign-in provider must be defined');
			assertSupportedProvider(provider);

			if (!provider.hasRedirectUri()) {
				provider.setRedirectUri(this.getHrefWithoutFragment_());
			}
			globals.window.location.href = provider.makeAuthorizationUrl(this.wedeployClient.authUrl_);
		}

		/**
   * Signs out <code>currentUser</code> and removes from <code>localStorage</code>.
   * @return {[type]} [description]
   */

	}, {
		key: 'signOut',
		value: function signOut() {
			var _this7 = this;

			assertUserSignedIn(this.currentUser);
			return this.wedeployClient.url(this.wedeployClient.authUrl_).path('/oauth/revoke').param('token', this.currentUser.token).get().then(function (response) {
				return assertResponseSucceeded(response);
			}).then(function (response) {
				_this7.maybeCallOnSignOutCallback_();
				_this7.unloadCurrentUser_();
				return response;
			});
		}

		/**
   * Unloads all information for <code>currentUser</code> and removes from
   * <code>localStorage</code> if present.
   * @return {[type]} [description]
   */

	}, {
		key: 'unloadCurrentUser_',
		value: function unloadCurrentUser_() {
			this.currentUser = null;
			if (this.storage) {
				this.storage.remove('currentUser');
			}
		}
	}]);
	return AuthApiHelper;
}(ApiHelper);

function assertSupportedProvider(provider) {
	switch (provider.constructor.PROVIDER) {
		case FacebookAuthProvider.PROVIDER:
		case GithubAuthProvider.PROVIDER:
		case GoogleAuthProvider.PROVIDER:
			break;
		default:
			throw new Error('Sign-in provider not supported');
	}
}

/**
 * Class that represents a search aggregation.
 */

var Aggregation = function () {
	/**
  * Constructs an {@link Aggregation} instance.
  * @param {string} field The aggregation field.
  * @param {string} operator The aggregation operator.
  * @param {*=} opt_value The aggregation value.
  * @constructor
  */
	function Aggregation(field, operator, opt_value) {
		classCallCheck(this, Aggregation);

		this.field_ = field;
		this.operator_ = operator;
		this.value_ = opt_value;
	}

	/**
  * Creates an {@link Aggregation} instance with the "avg" operator.
  * @param {string} field The aggregation field.
  * @return {!Aggregation}
  * @static
  */


	createClass(Aggregation, [{
		key: 'getField',


		/**
   * Gets this aggregation's field.
   * @return {string}
   */
		value: function getField() {
			return this.field_;
		}

		/**
   * Gets this aggregation's operator.
   * @return {string}
   */

	}, {
		key: 'getOperator',
		value: function getOperator() {
			return this.operator_;
		}

		/**
   * Gets this aggregation's value.
   * @return {*}
   */

	}, {
		key: 'getValue',
		value: function getValue() {
			return this.value_;
		}

		/**
   * Creates an {@link Aggregation} instance with the "histogram" operator.
   * @param {string} field The aggregation field.
   * @param {number} interval The histogram's interval.
   * @return {!Aggregation}
   * @static
   */

	}], [{
		key: 'avg',
		value: function avg(field) {
			return Aggregation.field(field, 'avg');
		}

		/**
   * Creates an {@link Aggregation} instance with the "count" operator.
   * @param {string} field The aggregation field.
   * @return {!Aggregation}
   * @static
   */

	}, {
		key: 'count',
		value: function count(field) {
			return Aggregation.field(field, 'count');
		}

		/**
   * Creates an {@link DistanceAggregation} instance with the "geoDistance" operator.
   * @param {string} field The aggregation field.
   * @param {*} location The aggregation location.
   * @param {...!Range} ranges The aggregation ranges.
   * @return {!DistanceAggregation}
   * @static
   */

	}, {
		key: 'distance',
		value: function distance(field, location) {
			for (var _len = arguments.length, ranges = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
				ranges[_key - 2] = arguments[_key];
			}

			return new (Function.prototype.bind.apply(Aggregation.DistanceAggregation, [null].concat([field, location], ranges)))();
		}

		/**
   * Creates an {@link Aggregation} instance with the "extendedStats" operator.
   * @param {string} field The aggregation field.
   * @return {!Aggregation}
   * @static
   */

	}, {
		key: 'extendedStats',
		value: function extendedStats(field) {
			return Aggregation.field(field, 'extendedStats');
		}
	}, {
		key: 'histogram',
		value: function histogram(field, interval) {
			return new Aggregation(field, 'histogram', interval);
		}

		/**
   * Creates an {@link Aggregation} instance with the "max" operator.
   * @param {string} field The aggregation field.
   * @return {!Aggregation}
   * @static
   */

	}, {
		key: 'max',
		value: function max(field) {
			return Aggregation.field(field, 'max');
		}

		/**
   * Creates an {@link Aggregation} instance with the "min" operator.
   * @param {string} field The aggregation field.
   * @return {!Aggregation}
   * @static
   */

	}, {
		key: 'min',
		value: function min(field) {
			return Aggregation.field(field, 'min');
		}

		/**
   * Creates an {@link Aggregation} instance with the "missing" operator.
   * @param {string} field The aggregation field.
   * @return {!Aggregation}
   * @static
   */

	}, {
		key: 'missing',
		value: function missing(field) {
			return Aggregation.field(field, 'missing');
		}

		/**
   * Creates a new {@link Aggregation} instance.
   * @param {string} field The aggregation field.
   * @param {string} operator The aggregation operator.
   * @return {!Aggregation}
   * @static
   */

	}, {
		key: 'field',
		value: function field(_field, operator) {
			return new Aggregation(_field, operator);
		}

		/**
   * Creates an {@link RangeAggregation} instance with the "range" operator.
   * @param {string} field The aggregation field.
   * @param {...!Range} ranges The aggregation ranges.
   * @return {!RangeAggregation}
   * @static
   */

	}, {
		key: 'range',
		value: function range(field) {
			for (var _len2 = arguments.length, ranges = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
				ranges[_key2 - 1] = arguments[_key2];
			}

			return new (Function.prototype.bind.apply(Aggregation.RangeAggregation, [null].concat([field], ranges)))();
		}

		/**
   * Creates an {@link Aggregation} instance with the "stats" operator.
   * @param {string} field The aggregation field.
   * @return {!Aggregation}
   * @static
   */

	}, {
		key: 'stats',
		value: function stats(field) {
			return Aggregation.field(field, 'stats');
		}

		/**
   * Creates an {@link Aggregation} instance with the "sum" operator.
   * @param {string} field The aggregation field.
   * @return {!Aggregation}
   * @static
   */

	}, {
		key: 'sum',
		value: function sum(field) {
			return Aggregation.field(field, 'sum');
		}

		/**
   * Creates an {@link Aggregation} instance with the "terms" operator.
   * @param {string} field The aggregation field.
   * @return {!Aggregation}
   * @static
   */

	}, {
		key: 'terms',
		value: function terms(field) {
			return Aggregation.field(field, 'terms');
		}
	}]);
	return Aggregation;
}();

/**
 * Class that represents a distance aggregation.
 * @extends {Aggregation}
 */


var DistanceAggregation = function (_Aggregation) {
	inherits(DistanceAggregation, _Aggregation);

	/**
  * Constructs an {@link DistanceAggregation} instance.
  * @param {string} field The aggregation field.
  * @param {*} location The aggregation location.
  * @param {...!Range} ranges The aggregation ranges.
  * @constructor
  */
	function DistanceAggregation(field, location) {
		classCallCheck(this, DistanceAggregation);

		var _this = possibleConstructorReturn(this, (DistanceAggregation.__proto__ || Object.getPrototypeOf(DistanceAggregation)).call(this, field, 'geoDistance', {}));

		_this.value_.location = Embodied.toBody(location);

		for (var _len3 = arguments.length, ranges = Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
			ranges[_key3 - 2] = arguments[_key3];
		}

		_this.value_.ranges = ranges.map(function (range) {
			return range.body();
		});
		return _this;
	}

	/**
  * Adds a range to this aggregation.
  * @param {*} rangeOrFrom
  * @param {*=} opt_to
  * @chainnable
  */


	createClass(DistanceAggregation, [{
		key: 'range',
		value: function range(rangeOrFrom, opt_to) {
			var range = rangeOrFrom;
			if (!(range instanceof Range)) {
				range = Range.range(rangeOrFrom, opt_to);
			}
			this.value_.ranges.push(range.body());
			return this;
		}

		/**
   * Sets this aggregation's unit.
   * @param {string} unit
   * @chainnable
   */

	}, {
		key: 'unit',
		value: function unit(_unit) {
			this.value_.unit = _unit;
			return this;
		}
	}]);
	return DistanceAggregation;
}(Aggregation);

Aggregation.DistanceAggregation = DistanceAggregation;

/**
 * Class that represents a range aggregation.
 * @extends {Aggregation}
 */

var RangeAggregation = function (_Aggregation2) {
	inherits(RangeAggregation, _Aggregation2);

	/**
  * Constructs an {@link RangeAggregation} instance.
  * @param {string} field The aggregation field.
  * @param {...!Range} ranges The aggregation ranges.
  * @constructor
  */
	function RangeAggregation(field) {
		classCallCheck(this, RangeAggregation);

		var _this2 = possibleConstructorReturn(this, (RangeAggregation.__proto__ || Object.getPrototypeOf(RangeAggregation)).call(this, field, 'range'));

		for (var _len4 = arguments.length, ranges = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
			ranges[_key4 - 1] = arguments[_key4];
		}

		_this2.value_ = ranges.map(function (range) {
			return range.body();
		});
		return _this2;
	}

	/**
  * Adds a range to this aggregation.
  * @param {*} rangeOrFrom
  * @param {*=} opt_to
  * @chainnable
  */


	createClass(RangeAggregation, [{
		key: 'range',
		value: function range(rangeOrFrom, opt_to) {
			var range = rangeOrFrom;
			if (!(range instanceof Range)) {
				range = Range.range(rangeOrFrom, opt_to);
			}
			this.value_.push(range.body());
			return this;
		}
	}]);
	return RangeAggregation;
}(Aggregation);

Aggregation.RangeAggregation = RangeAggregation;

/**
 * Class responsible for building queries.
 * @extends {Embodied}
 */

var Query = function (_Embodied) {
	inherits(Query, _Embodied);

	function Query() {
		classCallCheck(this, Query);
		return possibleConstructorReturn(this, (Query.__proto__ || Object.getPrototypeOf(Query)).apply(this, arguments));
	}

	createClass(Query, [{
		key: 'aggregate',


		/**
   * Adds an aggregation to this {@link Query} instance.
   * @param {string} name The aggregation name.
   * @param {!Aggregation|string} aggregationOrField Either an
   *   {@link Aggregation} instance or the name of the aggregation field.
   * @param {string=} opt_operator The aggregation operator.
   * @chainnable
   */
		value: function aggregate(name, aggregationOrField, opt_operator) {
			var aggregation = aggregationOrField;
			if (!(aggregation instanceof Aggregation)) {
				aggregation = Aggregation.field(aggregationOrField, opt_operator);
			}

			var field = aggregation.getField();
			var value = {};
			value[field] = {
				name: name,
				operator: aggregation.getOperator()
			};
			if (isDefAndNotNull(aggregation.getValue())) {
				value[field].value = aggregation.getValue();
			}

			if (!this.body_.aggregation) {
				this.body_.aggregation = [];
			}
			this.body_.aggregation.push(value);
			return this;
		}

		/**
   * Sets this query's type to "count".
   * @chainnable
   */

	}, {
		key: 'count',
		value: function count() {
			return this.type('count');
		}

		/**
   * Sets this query's type to "fetch".
   * @chainnable
   */

	}, {
		key: 'fetch',
		value: function fetch() {
			return this.type('fetch');
		}

		/**
   * Adds a filter to this Query.
   * @param {!Filter|string} fieldOrFilter Either a {@link Filter} or the
   *   name of the field to filter by.
   * @param {*=} opt_operatorOrValue Either the field's operator or its value.
   * @param {*=} opt_value The filter's value.
   * @chainnable
   */

	}, {
		key: 'filter',
		value: function filter(fieldOrFilter, opt_operatorOrValue, opt_value) {
			var filter = Filter.toFilter(fieldOrFilter, opt_operatorOrValue, opt_value);
			if (!this.body_.filter) {
				this.body_.filter = [];
			}
			this.body_.filter.push(filter.body());
			return this;
		}

		/**
   * Sets the query offset.
   * @param {number} offset The index of the first entry that should be returned
   *   by this query.
   * @chainnable
   */

	}, {
		key: 'offset',
		value: function offset(_offset2) {
			this.body_.offset = _offset2;
			return this;
		}

		/**
   * Adds a highlight entry to this {@link Query} instance.
   * @param {string} field The field's name.
   * @chainnable
   */

	}, {
		key: 'highlight',
		value: function highlight(field) {
			if (!this.body_.highlight) {
				this.body_.highlight = [];
			}

			this.body_.highlight.push(field);
			return this;
		}

		/**
   * Sets the query limit.
   * @param {number} limit The max amount of entries that this query should return.
   * @chainnable
   */

	}, {
		key: 'limit',
		value: function limit(_limit2) {
			this.body_.limit = _limit2;
			return this;
		}

		/**
   * Adds a search to this {@link Query} instance.
   * @param {!Filter|string} filterOrTextOrField If no other arguments
   *   are passed to this function, this should be either a {@link Filter}
   *   instance or a text to be used in a match filter. In both cases
   *   the filter will be applied to all fields. Another option is to
   *   pass this as a field name instead, together with other arguments
   *   so the filter can be created.
   * @param {string=} opt_textOrOperator Either a text to be used in a
   *   match filter, or the operator that should be used.
   * @param {*=} opt_value The value to be used by the filter. Should
   *   only be passed if an operator was passed as the second argument.
   * @chainnable
   */

	}, {
		key: 'search',
		value: function search(filterOrTextOrField, opt_textOrOperator, opt_value) {
			var filter = filterOrTextOrField;

			if (opt_value) {
				filter = Filter.field(filterOrTextOrField, opt_textOrOperator, opt_value);
			} else if (opt_textOrOperator) {
				filter = Filter.match(filterOrTextOrField, opt_textOrOperator);
			} else if (!(filter instanceof Filter)) {
				filter = Filter.match(filterOrTextOrField);
			}

			if (!this.body_.search) {
				this.body_.search = [];
			}

			if (isDefAndNotNull(filterOrTextOrField)) {
				this.body_.search.push(filter.body());
			} else {
				this.body_.search.push({});
			}

			return this;
		}

		/**
   * Adds a sort entry to this query, specifying the field this query should be
   * sorted by and, optionally, the sort direction.
   * @param {string} field The field that the query should be sorted by.
   * @param {string=} opt_direction The direction the sort operation should use.
   *   If none is given, "asc" is used by default.
   * @chainnable
   */

	}, {
		key: 'sort',
		value: function sort(field, opt_direction) {
			if (!this.body_.sort) {
				this.body_.sort = [];
			}
			var sortEntry = {};
			sortEntry[field] = opt_direction || 'asc';
			this.body_.sort.push(sortEntry);
			return this;
		}

		/**
   * Sets the query type.
   * @param {string} type The query's type. For example: "count", "fetch".
   * @chainnable
   */

	}, {
		key: 'type',
		value: function type(_type2) {
			this.body_.type = _type2;
			return this;
		}
	}], [{
		key: 'aggregate',

		/**
   * Adds an aggregation to this {@link Query} instance.
   * @param {string} name The aggregation name.
   * @param {!Aggregation|string} aggregationOrField Either an
   *   {@link Aggregation} instance or the name of the aggregation field.
   * @param {string=} opt_operator The aggregation operator.
   * @return {!Query}
   * @static
   */
		value: function aggregate(name, aggregationOrField, opt_operator) {
			return new Query().aggregate(name, aggregationOrField, opt_operator);
		}

		/**
   * Sets this query's type to "count".
   * @return {!Query}
   * @static
   */

	}, {
		key: 'count',
		value: function count() {
			return new Query().type('count');
		}

		/**
   * Sets this query's type to "fetch".
   * @return {!Query}
   * @static
   */

	}, {
		key: 'fetch',
		value: function fetch() {
			return new Query().type('fetch');
		}

		/**
   * Adds a filter to this Query.
   * @param {!Filter|string} fieldOrFilter Either a {@link Filter} or the
   *   name of the field to filter by.
   * @param {*=} opt_operatorOrValue Either the field's operator or its value.
   * @param {*=} opt_value The filter's value.
   * @return {!Query}
   * @static
   */

	}, {
		key: 'filter',
		value: function filter(fieldOrFilter, opt_operatorOrValue, opt_value) {
			return new Query().filter(fieldOrFilter, opt_operatorOrValue, opt_value);
		}

		/**
   * Sets the query offset.
   * @param {number} offset The index of the first entry that should be returned
   *   by this query.
   * @return {!Query}
   * @static
   */

	}, {
		key: 'offset',
		value: function offset(_offset) {
			return new Query().offset(_offset);
		}

		/**
   * Adds a highlight entry to this {@link Query} instance.
   * @param {string} field The field's name.
   * @return {!Query}
   * @static
   */

	}, {
		key: 'highlight',
		value: function highlight(field) {
			return new Query().highlight(field);
		}

		/**
   * Sets the query limit.
   * @param {number} limit The max amount of entries that this query should return.
   * @return {!Query}
   * @static
   */

	}, {
		key: 'limit',
		value: function limit(_limit) {
			return new Query().limit(_limit);
		}

		/**
   * Adds a search to this {@link Query} instance.
   * @param {!Filter|string} filterOrTextOrField If no other arguments
   *   are passed to this function, this should be either a {@link Filter}
   *   instance or a text to be used in a match filter. In both cases
   *   the filter will be applied to all fields. Another option is to
   *   pass this as a field name instead, together with other arguments
   *   so the filter can be created.
   * @param {string=} opt_textOrOperator Either a text to be used in a
   *   match filter, or the operator that should be used.
   * @param {*=} opt_value The value to be used by the filter. Should
   *   only be passed if an operator was passed as the second argument.
   * @return {!Query}
   * @static
   */

	}, {
		key: 'search',
		value: function search(filterOrTextOrField, opt_textOrOperator, opt_value) {
			return new Query().search(filterOrTextOrField, opt_textOrOperator, opt_value);
		}

		/**
   * Adds a sort entry to this query, specifying the field this query should be
   * sorted by and, optionally, the sort direction.
   * @param {string} field The field that the query should be sorted by.
   * @param {string=} opt_direction The direction the sort operation should use.
   *   If none is given, "asc" is used by default.
   * @return {!Query}
   * @static
   */

	}, {
		key: 'sort',
		value: function sort(field, opt_direction) {
			return new Query().sort(field, opt_direction);
		}

		/**
   * Sets the query type.
   * @param {string} type The query's type. For example: "count", "fetch".
   * @return {!Query}
   * @static
   */

	}, {
		key: 'type',
		value: function type(_type) {
			return new Query().type(_type);
		}
	}]);
	return Query;
}(Embodied);

/**
 * Class responsible for encapsulate data api calls.
 */

var DataApiHelper = function (_ApiHelper) {
	inherits(DataApiHelper, _ApiHelper);

	/**
  * Constructs an {@link DataApiHelper} instance.
  * @param {@link WeDeploy} instance.
  * @constructor
  */
	function DataApiHelper(wedeployClient) {
		classCallCheck(this, DataApiHelper);
		return possibleConstructorReturn(this, (DataApiHelper.__proto__ || Object.getPrototypeOf(DataApiHelper)).call(this, wedeployClient));
	}

	/**
  * Adds a filter to this request's {@link Query}.
  * @param {!Filter|string} fieldOrFilter Either a Filter instance or the
  *   name of the field to filter by.
  * @param {*=} opt_operatorOrValue Either the field's operator or its value.
  * @param {*=} opt_value The filter's value.
  * @chainable
  */


	createClass(DataApiHelper, [{
		key: 'where',
		value: function where(fieldOrFilter, opt_operatorOrValue, opt_value) {
			this.getOrCreateFilter_().and(fieldOrFilter, opt_operatorOrValue, opt_value);
			return this;
		}

		/**
   * Adds a filter to be composed with this filter using the "or" operator.
   * @param {!Filter|string} fieldOrFilter Either a {@link Filter} instance or
   *   the name of the field to filter by.
   * @param {*=} opt_operatorOrValue Either the field's operator or its value.
   * @param {*=} opt_value The filter's value.
   * @chainnable
   */

	}, {
		key: 'or',
		value: function or(fieldOrFilter, opt_operatorOrValue, opt_value) {
			if (this.getOrCreateFilter_().body().and.length === 0) {
				throw Error('It\'s required to have a condition before using an \'or()\' for the first time.');
			}
			this.getOrCreateFilter_().or(fieldOrFilter, opt_operatorOrValue, opt_value);
			return this;
		}

		/**
   * Adds a filter to be compose with this filter using "none" operator.
   * @param {string} field The name of the field to filter by.
   * @param {!(Array|...*)} args A variable amount of values to be used with
   * the "none" operator. Can be passed either as a single array or as
   * separate params.
   * @chainnable
   */

	}, {
		key: 'none',
		value: function none(field) {
			for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
				args[_key - 1] = arguments[_key];
			}

			return this.where(Filter.none(field, args));
		}

		/**
   * Adds a filter to be compose with this filter using "match" operator.
   * @param {string} fieldOrQuery If no second string argument is given, this
   * should be the query string, in which case all fields will be matched.
   * Otherwise, this should be the name of the field to match.
   * @param {string=} opt_query The query string.
   * @chainnable
   */

	}, {
		key: 'match',
		value: function match(field, value) {
			return this.where(Filter.match(field, value));
		}

		/**
   * Adds a filter to be compose with this filter using "similar" operator.
   * @param {string} fieldOrQuery If no second string argument is given, this
   * should be the query string, in which case all fields will be matched.
   * Otherwise, this should be the name of the field to match.
   * @param {?string} query The query string.
   * @chainnable
   */

	}, {
		key: 'similar',
		value: function similar(fieldOrQuery, query) {
			return this.where(Filter.similar(fieldOrQuery, query));
		}

		/**
   * Returns a {@link Filter} instance that uses the "<" operator.
   * @param {string} field The name of the field to filter by.
   * @param {*} value The filter's value.
   * @return {!Filter}
    * @static
   */

	}, {
		key: 'lt',
		value: function lt(field, value) {
			return this.where(Filter.lt(field, value));
		}

		/**
   * Returns a {@link Filter} instance that uses the "<=" operator.
   * @param {string} field The name of the field to filter by.
   * @param {*} value The filter's value.
   * @return {!Filter}
    * @static
   */

	}, {
		key: 'lte',
		value: function lte(field, value) {
			return this.where(Filter.lte(field, value));
		}

		/**
   * Adds a filter to be compose with this filter using "any" operator.
   * @param {string} field The name of the field to filter by.
   * @param {!(Array|...*)} args A variable amount of values to be used with
   * the "none" operator. Can be passed either as a single array or as
   * separate params.
   * @chainnable
   */

	}, {
		key: 'any',
		value: function any(field) {
			for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
				args[_key2 - 1] = arguments[_key2];
			}

			return this.where(Filter.any(field, args));
		}

		/**
   * Adds a filter to be compose with this filter using "gp" operator. This is a
   * special use case of `Filter.polygon` for bounding boxes.
   * @param {string} field The field's name.
   * @param {*} boxOrUpperLeft Either a `Geo.BoundingBox` instance, or a
   * bounding box's upper left coordinate.
   * @param {*=} opt_lowerRight A bounding box's lower right coordinate.
   * @chainnable
   */

	}, {
		key: 'boundingBox',
		value: function boundingBox(field, boxOrUpperLeft, opt_lowerRight) {
			return this.where(Filter.boundingBox(field, boxOrUpperLeft, opt_lowerRight));
		}

		/**
   * Adds a filter to be compose with this filter using "gd" operator.
   * @param {string} field The field's name.
   * @param {*} locationOrCircle Either a `Geo.Circle` instance or a
   * coordinate.
   * @param {Range|string=} opt_rangeOrDistance Either a `Range` instance or
   * the distance value.
   * @return {!Filter}
   * @chainnable
   */

	}, {
		key: 'distance',
		value: function distance(field, locationOrCircle, opt_rangeOrDistance) {
			return this.where(Filter.distance(field, locationOrCircle, opt_rangeOrDistance));
		}

		/**
   * Adds a filter to be compose with this filter using "range" operator.
   * @param {string} field The field's name.
   * @param {*} rangeOrMin Either a `Range` instance or a the range's min
   * value.
   * @param {*=} opt_max The range's max value.
   * @return {!Filter}
   * @chainnable
   */

	}, {
		key: 'range',
		value: function range(field, rangeOrMin, opt_max) {
			return this.where(Filter.range(field, rangeOrMin, opt_max));
		}

		/**
   * Sets the limit for this request's {@link Query}.
   * @param {number} limit The max amount of entries that this request should return.
   * @chainable
   */

	}, {
		key: 'limit',
		value: function limit(_limit) {
			this.getOrCreateQuery_().limit(_limit);
			return this;
		}

		/**
   * Sets the offset for this request's {@link Query}.
   * @param {number} offset The index of the first entry that should be
   * returned by this query.
   * @chainable
   */

	}, {
		key: 'offset',
		value: function offset(_offset) {
			this.getOrCreateQuery_().offset(_offset);
			return this;
		}

		/**
   * Adds a highlight entry to this request's {@link Query} instance.
   * @param {string} field The field's name.
   * @chainable
   */

	}, {
		key: 'highlight',
		value: function highlight(field) {
			this.getOrCreateQuery_().highlight(field);
			return this;
		}

		/**
   * Adds an aggregation to this {@link Query} instance.
   * @param {string} name The aggregation name.
   * @param {!Aggregation|string} aggregationOrField Either an {@link
   * Aggregation} instance or the name of the aggregation field.
   * @param {string=} opt_operator The aggregation operator.
   * @chainable
   */

	}, {
		key: 'aggregate',
		value: function aggregate(name, aggregationOrField, opt_operator) {
			this.getOrCreateQuery_().aggregate(name, aggregationOrField, opt_operator);
			return this;
		}

		/**
   * Sets this request's query type to 'count'.
   * @chainnable
   */

	}, {
		key: 'count',
		value: function count() {
			this.getOrCreateQuery_().type('count');
			return this;
		}

		/**
   * Adds a sort query to this request's body.
   * @param {string} field The field that the query should be sorted by.
   * @param {string=} opt_direction The direction the sort operation should
   * use. If none is given, 'asc' is used by default.
   * @chainnable
   */

	}, {
		key: 'orderBy',
		value: function orderBy(field, opt_direction) {
			this.getOrCreateQuery_().sort(field, opt_direction);
			return this;
		}

		/**
   * Creates an object (or multiple objects) and saves it to WeDeploy data. If
   * there's a validation registered in the collection and the request is
   * successful, the resulting object (or array of objects) is returned. The
   * data parameter can be either an Object or an Array of Objects.
   * These Objects describe the attributes on the objects that are to be created.
   * ```javascript
   * var data = WeDeploy.data('http://demodata.wedeploy.io');
   *
   * data.create('movies', {'title'=> 'Star Wars: Episode I – The Phantom Menace'})
   * 		 .then(function(movie){
   * 			 console.log(movie)
   *     });
   *
   * data.create('movies', [{'title'=> 'Star Wars: Episode II – Attack of the Clones'},
   * 												{'title'=> 'Star Wars: Episode III – Revenge of the Sith'})
   * 		 .then(function(movies){
   * 			 console.log(movies)
   *     });
   * ```
   * @param {string} collection Collection (key) used to create the new data.
   * @param {Object} data Attributes on the object that is to be created.
   * @return {!CancellablePromise}
   */

	}, {
		key: 'create',
		value: function create(collection, data) {
			assertDefAndNotNull(collection, 'Collection key must be specified.');
			assertObject(data, 'Data can\'t be empty.');

			return this.wedeployClient.url(this.wedeployClient.dataUrl_).auth(this.helperAuthScope).path(collection).post(data).then(function (response) {
				return assertResponseSucceeded(response);
			}).then(function (response) {
				return response.body();
			});
		}

		/**
   * Update the attributes of a document form the passed-in object and saves
   * the record. If the object is invalid, the saving will fail and an error
   * object will be returned.
   *
   * ```javascript
   * var data = WeDeploy.data('http://demodata.wedeploy.io');
   *
   * data.update('movies/1019112353', {'title'=> 'Star Wars: Episode I'})
   * 		 .then(function(movie){
   * 			 console.log(movie)
   *     });
   * ```
   * @param {string} document Key used to update the document.
   * @param {Object} data Attributes on the object that is to be updated.
   * @return {!CancellablePromise}
   */

	}, {
		key: 'update',
		value: function update(document, data) {
			assertDefAndNotNull(document, 'Document key must be specified.');
			assertObject(data, 'Data must be specified.');

			return this.wedeployClient.url(this.wedeployClient.dataUrl_).auth(this.helperAuthScope).path(document).put(data).then(function (response) {
				return assertResponseSucceeded(response);
			}).then(function (response) {
				return response.body();
			});
		}

		/**
   * Deletes a [document/field/collection].
   * @param {string} key Key used to delete the
   * document/field/collection.
   * @return {!CancellablePromise}
   */

	}, {
		key: 'delete',
		value: function _delete(key) {
			assertDefAndNotNull(key, 'Document/Field/Collection key must be specified');

			return this.wedeployClient.url(this.wedeployClient.dataUrl_).auth(this.helperAuthScope).path(key).delete().then(function (response) {
				return assertResponseSucceeded(response);
			}).then(function () {
				return undefined;
			});
		}

		/**
   * Retrieve data from a [document/field/collection].
   * @param {string} key Key used to delete the document/field/collection.
   * @return {!CancellablePromise}
   */

	}, {
		key: 'get',
		value: function get(key) {
			assertDefAndNotNull(key, 'Document/Field/Collection key must be specified');

			this.addFiltersToQuery_();

			return this.wedeployClient.url(this.wedeployClient.dataUrl_).auth(this.helperAuthScope).path(key).get(this.query_).then(function (response) {
				return assertResponseSucceeded(response);
			}).then(function (response) {
				return response.body();
			});
		}

		/**
   * Retrieve data from a [document/field/collection] and put it in a search
   * format.
   * @param {string} key Key used to delete the document/field/collection.
   * @return {!CancellablePromise}
   */

	}, {
		key: 'search',
		value: function search(key) {
			assertDefAndNotNull(key, 'Document/Field/Collection key must be specified');

			this.onSearch_();

			this.addFiltersToQuery_();

			return this.wedeployClient.url(this.wedeployClient.dataUrl_).auth(this.helperAuthScope).path(key).get(this.query_).then(function (response) {
				return assertResponseSucceeded(response);
			}).then(function (response) {
				return response.body();
			});
		}

		/**
   * Creates new socket.io instance. Monitor the arrival of new broadcasted
   * data.
   * @param  {string} collection key/collection used to find organized data.
   * @param  {Object=} opt_options Object with Socket IO options.
   * @return {!io} Socket IO reference. Server events can be listened on it.
   */

	}, {
		key: 'watch',
		value: function watch(collection, opt_options) {
			assertDefAndNotNull(collection, 'Collection key must be specified');

			this.addFiltersToQuery_();

			return this.wedeployClient.url(this.wedeployClient.dataUrl_).auth(this.helperAuthScope).path(collection).watch(this.query_, opt_options);
		}

		/**
   * Gets the currentl used main {@link Filter} object. If none exists yet, a
   * new one is created.
   * @return {!Query}
   * @protected
   */

	}, {
		key: 'getOrCreateFilter_',
		value: function getOrCreateFilter_() {
			if (!this.filter_) {
				this.filter_ = new Filter();
			}
			return this.filter_;
		}

		/**
   * Gets the currently used {@link Query} object. If none exists yet,
   * a new one is created.
   * @return {!Query}
   * @protected
   */

	}, {
		key: 'getOrCreateQuery_',
		value: function getOrCreateQuery_() {
			if (!this.query_) {
				this.query_ = new Query();
			}
			return this.query_;
		}

		/**
   * Load the currently used main {@link Filter} object into the currently
   * used {@link Query}.
   * @chainable
   * @protected
   */

	}, {
		key: 'addFiltersToQuery_',
		value: function addFiltersToQuery_() {
			if (isDef(this.filter_) && this.toSearch_ !== true) {
				this.getOrCreateQuery_().filter(this.filter_);
			}
			return this;
		}

		/**
   * Adds a search to this request's {@link Query} instance.
   * @chainable
   * @protected
   */

	}, {
		key: 'onSearch_',
		value: function onSearch_() {
			if (isDef(this.filter_)) {
				this.getOrCreateQuery_().search(this.getOrCreateFilter_());
			} else {
				throw Error('It\'s required to have a condition before using an \'search()\' for the first time.');
			}
			this.toSearch_ = true;
			return this;
		}
	}]);
	return DataApiHelper;
}(ApiHelper);

/**
 * Abstraction layer for string to base64 conversion
 * reference: https://github.com/nodejs/node/issues/3462
 */

var Base64 = function () {
	function Base64() {
		classCallCheck(this, Base64);
	}

	createClass(Base64, null, [{
		key: 'encodeString',

		/**
   * Creates a base-64 encoded ASCII string from a "string" of binary data.
   * @param {string} string to be encoded.
   * @return {string}
   * @static
   */
		value: function encodeString(string) {
			if (typeof btoa === 'function') {
				return btoa(string);
			}

			return new Buffer(string.toString(), 'binary');
		}
	}]);
	return Base64;
}();

/*!
 * Promises polyfill from Google's Closure Library.
 *
 *      Copyright 2013 The Closure Library Authors. All Rights Reserved.
 *
 * NOTE(eduardo): Promise support is not ready on all supported browsers,
 * therefore metal-promise is temporarily using Google's promises as polyfill.
 * It supports cancellable promises and has clean and fast implementation.
 */

/**
 * Provides a more strict interface for Thenables in terms of
 * http://promisesaplus.com for interop with {@see CancellablePromise}.
 *
 * @interface
 * @extends {IThenable.<TYPE>}
 * @template TYPE
 */
var Thenable = function Thenable() {};

/**
 * Adds callbacks that will operate on the result of the Thenable, returning a
 * new child Promise.
 *
 * If the Thenable is fulfilled, the {@code onFulfilled} callback will be
 * invoked with the fulfillment value as argument, and the child Promise will
 * be fulfilled with the return value of the callback. If the callback throws
 * an exception, the child Promise will be rejected with the thrown value
 * instead.
 *
 * If the Thenable is rejected, the {@code onRejected} callback will be invoked
 * with the rejection reason as argument, and the child Promise will be rejected
 * with the return value of the callback or thrown value.
 *
 * @param {?(function(this:THIS, TYPE):
 *             (RESULT|IThenable.<RESULT>|Thenable))=} opt_onFulfilled A
 *     function that will be invoked with the fulfillment value if the Promise
 *     is fullfilled.
 * @param {?(function(*): *)=} opt_onRejected A function that will be invoked
 *     with the rejection reason if the Promise is rejected.
 * @param {THIS=} opt_context An optional context object that will be the
 *     execution context for the callbacks. By default, functions are executed
 *     with the default this.
 * @return {!CancellablePromise.<RESULT>} A new Promise that will receive the
 *     result of the fulfillment or rejection callback.
 * @template RESULT,THIS
 */
Thenable.prototype.then = function () {};

/**
 * An expando property to indicate that an object implements
 * {@code Thenable}.
 *
 * {@see addImplementation}.
 *
 * @const
 */
Thenable.IMPLEMENTED_BY_PROP = '$goog_Thenable';

/**
 * Marks a given class (constructor) as an implementation of Thenable, so
 * that we can query that fact at runtime. The class must have already
 * implemented the interface.
 * Exports a 'then' method on the constructor prototype, so that the objects
 * also implement the extern {@see Thenable} interface for interop with
 * other Promise implementations.
 * @param {function(new:Thenable,...[?])} ctor The class constructor. The
 *     corresponding class must have already implemented the interface.
 */
Thenable.addImplementation = function (ctor) {
  ctor.prototype.then = ctor.prototype.then;
  ctor.prototype.$goog_Thenable = true;
};

/**
 * @param {*} object
 * @return {boolean} Whether a given instance implements {@code Thenable}.
 *     The class/superclass of the instance must call {@code addImplementation}.
 */
Thenable.isImplementedBy = function (object$$1) {
  if (!object$$1) {
    return false;
  }
  try {
    return !!object$$1.$goog_Thenable;
  } catch (e) {
    // Property access seems to be forbidden.
    return false;
  }
};

/**
 * Like bind(), except that a 'this object' is not required. Useful when the
 * target function is already bound.
 *
 * Usage:
 * var g = partial(f, arg1, arg2);
 * g(arg3, arg4);
 *
 * @param {Function} fn A function to partially apply.
 * @param {...*} var_args Additional arguments that are partially applied to fn.
 * @return {!Function} A partially-applied form of the function bind() was
 *     invoked as a method of.
 */
var partial = function partial(fn) {
  var args = Array.prototype.slice.call(arguments, 1);
  return function () {
    // Clone the array (with slice()) and append additional arguments
    // to the existing arguments.
    var newArgs = args.slice();
    newArgs.push.apply(newArgs, arguments);
    return fn.apply(this, newArgs);
  };
};

/**
 * Promises provide a result that may be resolved asynchronously. A Promise may
 * be resolved by being fulfilled or rejected with a value, which will be known
 * as the fulfillment value or the rejection reason. Whether fulfilled or
 * rejected, the Promise result is immutable once it is set.
 *
 * Promises may represent results of any type, including undefined. Rejection
 * reasons are typically Errors, but may also be of any type. Closure Promises
 * allow for optional type annotations that enforce that fulfillment values are
 * of the appropriate types at compile time.
 *
 * The result of a Promise is accessible by calling {@code then} and registering
 * {@code onFulfilled} and {@code onRejected} callbacks. Once the Promise
 * resolves, the relevant callbacks are invoked with the fulfillment value or
 * rejection reason as argument. Callbacks are always invoked in the order they
 * were registered, even when additional {@code then} calls are made from inside
 * another callback. A callback is always run asynchronously sometime after the
 * scope containing the registering {@code then} invocation has returned.
 *
 * If a Promise is resolved with another Promise, the first Promise will block
 * until the second is resolved, and then assumes the same result as the second
 * Promise. This allows Promises to depend on the results of other Promises,
 * linking together multiple asynchronous operations.
 *
 * This implementation is compatible with the Promises/A+ specification and
 * passes that specification's conformance test suite. A Closure Promise may be
 * resolved with a Promise instance (or sufficiently compatible Promise-like
 * object) created by other Promise implementations. From the specification,
 * Promise-like objects are known as "Thenables".
 *
 * @see http://promisesaplus.com/
 *
 * @param {function(
 *             this:RESOLVER_CONTEXT,
 *             function((TYPE|IThenable.<TYPE>|Thenable)),
 *             function(*)): void} resolver
 *     Initialization function that is invoked immediately with {@code resolve}
 *     and {@code reject} functions as arguments. The Promise is resolved or
 *     rejected with the first argument passed to either function.
 * @param {RESOLVER_CONTEXT=} opt_context An optional context for executing the
 *     resolver function. If unspecified, the resolver function will be executed
 *     in the default scope.
 * @constructor
 * @struct
 * @final
 * @implements {Thenable.<TYPE>}
 * @template TYPE,RESOLVER_CONTEXT
 */
var CancellablePromise = function CancellablePromise(resolver, opt_context) {
  /**
   * The internal state of this Promise. Either PENDING, FULFILLED, REJECTED, or
   * BLOCKED.
   * @private {CancellablePromise.State_}
   */
  this.state_ = CancellablePromise.State_.PENDING;

  /**
   * The resolved result of the Promise. Immutable once set with either a
   * fulfillment value or rejection reason.
   * @private {*}
   */
  this.result_ = undefined;

  /**
   * For Promises created by calling {@code then()}, the originating parent.
   * @private {CancellablePromise}
   */
  this.parent_ = null;

  /**
   * The list of {@code onFulfilled} and {@code onRejected} callbacks added to
   * this Promise by calls to {@code then()}.
   * @private {Array.<CancellablePromise.CallbackEntry_>}
   */
  this.callbackEntries_ = null;

  /**
   * Whether the Promise is in the queue of Promises to execute.
   * @private {boolean}
   */
  this.executing_ = false;

  if (CancellablePromise.UNHANDLED_REJECTION_DELAY > 0) {
    /**
     * A timeout ID used when the {@code UNHANDLED_REJECTION_DELAY} is greater
     * than 0 milliseconds. The ID is set when the Promise is rejected, and
     * cleared only if an {@code onRejected} callback is invoked for the
     * Promise (or one of its descendants) before the delay is exceeded.
     *
     * If the rejection is not handled before the timeout completes, the
     * rejection reason is passed to the unhandled rejection handler.
     * @private {number}
     */
    this.unhandledRejectionId_ = 0;
  } else if (CancellablePromise.UNHANDLED_REJECTION_DELAY === 0) {
    /**
     * When the {@code UNHANDLED_REJECTION_DELAY} is set to 0 milliseconds, a
     * boolean that is set if the Promise is rejected, and reset to false if an
     * {@code onRejected} callback is invoked for the Promise (or one of its
     * descendants). If the rejection is not handled before the next timestep,
     * the rejection reason is passed to the unhandled rejection handler.
     * @private {boolean}
     */
    this.hadUnhandledRejection_ = false;
  }

  try {
    var self = this;
    resolver.call(opt_context, function (value) {
      self.resolve_(CancellablePromise.State_.FULFILLED, value);
    }, function (reason) {
      self.resolve_(CancellablePromise.State_.REJECTED, reason);
    });
  } catch (e) {
    this.resolve_(CancellablePromise.State_.REJECTED, e);
  }
};

/**
 * The delay in milliseconds before a rejected Promise's reason is passed to
 * the rejection handler. By default, the rejection handler rethrows the
 * rejection reason so that it appears in the developer console or
 * {@code window.onerror} handler.
 * Rejections are rethrown as quickly as possible by default. A negative value
 * disables rejection handling entirely.
 * @type {number}
 */
CancellablePromise.UNHANDLED_REJECTION_DELAY = 0;

/**
 * The possible internal states for a Promise. These states are not directly
 * observable to external callers.
 * @enum {number}
 * @private
 */
CancellablePromise.State_ = {
  /** The Promise is waiting for resolution. */
  PENDING: 0,

  /** The Promise is blocked waiting for the result of another Thenable. */
  BLOCKED: 1,

  /** The Promise has been resolved with a fulfillment value. */
  FULFILLED: 2,

  /** The Promise has been resolved with a rejection reason. */
  REJECTED: 3
};

/**
 * Typedef for entries in the callback chain. Each call to {@code then},
 * {@code thenCatch}, or {@code thenAlways} creates an entry containing the
 * functions that may be invoked once the Promise is resolved.
 *
 * @typedef {{
 *   child: CancellablePromise,
 *   onFulfilled: function(*),
 *   onRejected: function(*)
 * }}
 * @private
 */
CancellablePromise.CallbackEntry_ = null;

/**
 * @param {(TYPE|Thenable.<TYPE>|Thenable)=} opt_value
 * @return {!CancellablePromise.<TYPE>} A new Promise that is immediately resolved
 *     with the given value.
 * @template TYPE
 */
CancellablePromise.resolve = function (opt_value) {
  return new CancellablePromise(function (resolve) {
    resolve(opt_value);
  });
};

/**
 * @param {*=} opt_reason
 * @return {!CancellablePromise} A new Promise that is immediately rejected with the
 *     given reason.
 */
CancellablePromise.reject = function (opt_reason) {
  return new CancellablePromise(function (resolve, reject) {
    reject(opt_reason);
  });
};

/**
 * @param {!Array.<!(Thenable.<TYPE>|Thenable)>} promises
 * @return {!CancellablePromise.<TYPE>} A Promise that receives the result of the
 *     first Promise (or Promise-like) input to complete.
 * @template TYPE
 */
CancellablePromise.race = function (promises) {
  return new CancellablePromise(function (resolve, reject) {
    if (!promises.length) {
      resolve(undefined);
    }
    for (var i = 0, promise; promise = promises[i]; i++) {
      promise.then(resolve, reject);
    }
  });
};

/**
 * @param {!Array.<!(Thenable.<TYPE>|Thenable)>} promises
 * @return {!CancellablePromise.<!Array.<TYPE>>} A Promise that receives a list of
 *     every fulfilled value once every input Promise (or Promise-like) is
 *     successfully fulfilled, or is rejected by the first rejection result.
 * @template TYPE
 */
CancellablePromise.all = function (promises) {
  return new CancellablePromise(function (resolve, reject) {
    var toFulfill = promises.length;
    var values = [];

    if (!toFulfill) {
      resolve(values);
      return;
    }

    var onFulfill = function onFulfill(index, value) {
      toFulfill--;
      values[index] = value;
      if (toFulfill === 0) {
        resolve(values);
      }
    };

    var onReject = function onReject(reason) {
      reject(reason);
    };

    for (var i = 0, promise; promise = promises[i]; i++) {
      promise.then(partial(onFulfill, i), onReject);
    }
  });
};

/**
 * @param {!Array.<!(Thenable.<TYPE>|Thenable)>} promises
 * @return {!CancellablePromise.<TYPE>} A Promise that receives the value of
 *     the first input to be fulfilled, or is rejected with a list of every
 *     rejection reason if all inputs are rejected.
 * @template TYPE
 */
CancellablePromise.firstFulfilled = function (promises) {
  return new CancellablePromise(function (resolve, reject) {
    var toReject = promises.length;
    var reasons = [];

    if (!toReject) {
      resolve(undefined);
      return;
    }

    var onFulfill = function onFulfill(value) {
      resolve(value);
    };

    var onReject = function onReject(index, reason) {
      toReject--;
      reasons[index] = reason;
      if (toReject === 0) {
        reject(reasons);
      }
    };

    for (var i = 0, promise; promise = promises[i]; i++) {
      promise.then(onFulfill, partial(onReject, i));
    }
  });
};

/**
 * Adds callbacks that will operate on the result of the Promise, returning a
 * new child Promise.
 *
 * If the Promise is fulfilled, the {@code onFulfilled} callback will be invoked
 * with the fulfillment value as argument, and the child Promise will be
 * fulfilled with the return value of the callback. If the callback throws an
 * exception, the child Promise will be rejected with the thrown value instead.
 *
 * If the Promise is rejected, the {@code onRejected} callback will be invoked
 * with the rejection reason as argument, and the child Promise will be rejected
 * with the return value (or thrown value) of the callback.
 *
 * @override
 */
CancellablePromise.prototype.then = function (opt_onFulfilled, opt_onRejected, opt_context) {
  return this.addChildPromise_(isFunction(opt_onFulfilled) ? opt_onFulfilled : null, isFunction(opt_onRejected) ? opt_onRejected : null, opt_context);
};
Thenable.addImplementation(CancellablePromise);

/**
 * Adds a callback that will be invoked whether the Promise is fulfilled or
 * rejected. The callback receives no argument, and no new child Promise is
 * created. This is useful for ensuring that cleanup takes place after certain
 * asynchronous operations. Callbacks added with {@code thenAlways} will be
 * executed in the same order with other calls to {@code then},
 * {@code thenAlways}, or {@code thenCatch}.
 *
 * Since it does not produce a new child Promise, cancellation propagation is
 * not prevented by adding callbacks with {@code thenAlways}. A Promise that has
 * a cleanup handler added with {@code thenAlways} will be canceled if all of
 * its children created by {@code then} (or {@code thenCatch}) are canceled.
 *
 * @param {function(this:THIS): void} onResolved A function that will be invoked
 *     when the Promise is resolved.
 * @param {THIS=} opt_context An optional context object that will be the
 *     execution context for the callbacks. By default, functions are executed
 *     in the global scope.
 * @return {!CancellablePromise.<TYPE>} This Promise, for chaining additional calls.
 * @template THIS
 */
CancellablePromise.prototype.thenAlways = function (onResolved, opt_context) {
  var callback = function callback() {
    try {
      // Ensure that no arguments are passed to onResolved.
      onResolved.call(opt_context);
    } catch (err) {
      CancellablePromise.handleRejection_.call(null, err);
    }
  };

  this.addCallbackEntry_({
    child: null,
    onRejected: callback,
    onFulfilled: callback
  });
  return this;
};

/**
 * Adds a callback that will be invoked only if the Promise is rejected. This
 * is equivalent to {@code then(null, onRejected)}.
 *
 * @param {!function(this:THIS, *): *} onRejected A function that will be
 *     invoked with the rejection reason if the Promise is rejected.
 * @param {THIS=} opt_context An optional context object that will be the
 *     execution context for the callbacks. By default, functions are executed
 *     in the global scope.
 * @return {!CancellablePromise} A new Promise that will receive the result of the
 *     callback.
 * @template THIS
 */
CancellablePromise.prototype.thenCatch = function (onRejected, opt_context) {
  return this.addChildPromise_(null, onRejected, opt_context);
};

/**
 * Alias of {@link CancellablePromise.prototype.thenCatch}
 */
CancellablePromise.prototype.catch = CancellablePromise.prototype.thenCatch;

/**
 * Cancels the Promise if it is still pending by rejecting it with a cancel
 * Error. No action is performed if the Promise is already resolved.
 *
 * All child Promises of the canceled Promise will be rejected with the same
 * cancel error, as with normal Promise rejection. If the Promise to be canceled
 * is the only child of a pending Promise, the parent Promise will also be
 * canceled. Cancellation may propagate upward through multiple generations.
 *
 * @param {string=} opt_message An optional debugging message for describing the
 *     cancellation reason.
 */
CancellablePromise.prototype.cancel = function (opt_message) {
  if (this.state_ === CancellablePromise.State_.PENDING) {
    async.run(function () {
      var err = new CancellablePromise.CancellationError(opt_message);
      err.IS_CANCELLATION_ERROR = true;
      this.cancelInternal_(err);
    }, this);
  }
};

/**
 * Cancels this Promise with the given error.
 *
 * @param {!Error} err The cancellation error.
 * @private
 */
CancellablePromise.prototype.cancelInternal_ = function (err) {
  if (this.state_ === CancellablePromise.State_.PENDING) {
    if (this.parent_) {
      // Cancel the Promise and remove it from the parent's child list.
      this.parent_.cancelChild_(this, err);
    } else {
      this.resolve_(CancellablePromise.State_.REJECTED, err);
    }
  }
};

/**
 * Cancels a child Promise from the list of callback entries. If the Promise has
 * not already been resolved, reject it with a cancel error. If there are no
 * other children in the list of callback entries, propagate the cancellation
 * by canceling this Promise as well.
 *
 * @param {!CancellablePromise} childPromise The Promise to cancel.
 * @param {!Error} err The cancel error to use for rejecting the Promise.
 * @private
 */
CancellablePromise.prototype.cancelChild_ = function (childPromise, err) {
  if (!this.callbackEntries_) {
    return;
  }
  var childCount = 0;
  var childIndex = -1;

  // Find the callback entry for the childPromise, and count whether there are
  // additional child Promises.
  for (var i = 0, entry; entry = this.callbackEntries_[i]; i++) {
    var child = entry.child;
    if (child) {
      childCount++;
      if (child === childPromise) {
        childIndex = i;
      }
      if (childIndex >= 0 && childCount > 1) {
        break;
      }
    }
  }

  // If the child Promise was the only child, cancel this Promise as well.
  // Otherwise, reject only the child Promise with the cancel error.
  if (childIndex >= 0) {
    if (this.state_ === CancellablePromise.State_.PENDING && childCount === 1) {
      this.cancelInternal_(err);
    } else {
      var callbackEntry = this.callbackEntries_.splice(childIndex, 1)[0];
      this.executeCallback_(callbackEntry, CancellablePromise.State_.REJECTED, err);
    }
  }
};

/**
 * Adds a callback entry to the current Promise, and schedules callback
 * execution if the Promise has already been resolved.
 *
 * @param {CancellablePromise.CallbackEntry_} callbackEntry Record containing
 *     {@code onFulfilled} and {@code onRejected} callbacks to execute after
 *     the Promise is resolved.
 * @private
 */
CancellablePromise.prototype.addCallbackEntry_ = function (callbackEntry) {
  if ((!this.callbackEntries_ || !this.callbackEntries_.length) && (this.state_ === CancellablePromise.State_.FULFILLED || this.state_ === CancellablePromise.State_.REJECTED)) {
    this.scheduleCallbacks_();
  }
  if (!this.callbackEntries_) {
    this.callbackEntries_ = [];
  }
  this.callbackEntries_.push(callbackEntry);
};

/**
 * Creates a child Promise and adds it to the callback entry list. The result of
 * the child Promise is determined by the state of the parent Promise and the
 * result of the {@code onFulfilled} or {@code onRejected} callbacks as
 * specified in the Promise resolution procedure.
 *
 * @see http://promisesaplus.com/#the__method
 *
 * @param {?function(this:THIS, TYPE):
 *          (RESULT|CancellablePromise.<RESULT>|Thenable)} onFulfilled A callback that
 *     will be invoked if the Promise is fullfilled, or null.
 * @param {?function(this:THIS, *): *} onRejected A callback that will be
 *     invoked if the Promise is rejected, or null.
 * @param {THIS=} opt_context An optional execution context for the callbacks.
 *     in the default calling context.
 * @return {!CancellablePromise} The child Promise.
 * @template RESULT,THIS
 * @private
 */
CancellablePromise.prototype.addChildPromise_ = function (onFulfilled, onRejected, opt_context) {

  var callbackEntry = {
    child: null,
    onFulfilled: null,
    onRejected: null
  };

  callbackEntry.child = new CancellablePromise(function (resolve, reject) {
    // Invoke onFulfilled, or resolve with the parent's value if absent.
    callbackEntry.onFulfilled = onFulfilled ? function (value) {
      try {
        var result = onFulfilled.call(opt_context, value);
        resolve(result);
      } catch (err) {
        reject(err);
      }
    } : resolve;

    // Invoke onRejected, or reject with the parent's reason if absent.
    callbackEntry.onRejected = onRejected ? function (reason) {
      try {
        var result = onRejected.call(opt_context, reason);
        if (!isDef(result) && reason.IS_CANCELLATION_ERROR) {
          // Propagate cancellation to children if no other result is returned.
          reject(reason);
        } else {
          resolve(result);
        }
      } catch (err) {
        reject(err);
      }
    } : reject;
  });

  callbackEntry.child.parent_ = this;
  this.addCallbackEntry_(
  /** @type {CancellablePromise.CallbackEntry_} */callbackEntry);
  return callbackEntry.child;
};

/**
 * Unblocks the Promise and fulfills it with the given value.
 *
 * @param {TYPE} value
 * @private
 */
CancellablePromise.prototype.unblockAndFulfill_ = function (value) {
  if (this.state_ !== CancellablePromise.State_.BLOCKED) {
    throw new Error('CancellablePromise is not blocked.');
  }
  this.state_ = CancellablePromise.State_.PENDING;
  this.resolve_(CancellablePromise.State_.FULFILLED, value);
};

/**
 * Unblocks the Promise and rejects it with the given rejection reason.
 *
 * @param {*} reason
 * @private
 */
CancellablePromise.prototype.unblockAndReject_ = function (reason) {
  if (this.state_ !== CancellablePromise.State_.BLOCKED) {
    throw new Error('CancellablePromise is not blocked.');
  }
  this.state_ = CancellablePromise.State_.PENDING;
  this.resolve_(CancellablePromise.State_.REJECTED, reason);
};

/**
 * Attempts to resolve a Promise with a given resolution state and value. This
 * is a no-op if the given Promise has already been resolved.
 *
 * If the given result is a Thenable (such as another Promise), the Promise will
 * be resolved with the same state and result as the Thenable once it is itself
 * resolved.
 *
 * If the given result is not a Thenable, the Promise will be fulfilled or
 * rejected with that result based on the given state.
 *
 * @see http://promisesaplus.com/#the_promise_resolution_procedure
 *
 * @param {CancellablePromise.State_} state
 * @param {*} x The result to apply to the Promise.
 * @private
 */
CancellablePromise.prototype.resolve_ = function (state, x) {
  if (this.state_ !== CancellablePromise.State_.PENDING) {
    return;
  }

  if (this === x) {
    state = CancellablePromise.State_.REJECTED;
    x = new TypeError('CancellablePromise cannot resolve to itself');
  } else if (Thenable.isImplementedBy(x)) {
    x = /** @type {!Thenable} */x;
    this.state_ = CancellablePromise.State_.BLOCKED;
    x.then(this.unblockAndFulfill_, this.unblockAndReject_, this);
    return;
  } else if (isObject(x)) {
    try {
      var then = x.then;
      if (isFunction(then)) {
        this.tryThen_(x, then);
        return;
      }
    } catch (e) {
      state = CancellablePromise.State_.REJECTED;
      x = e;
    }
  }

  this.result_ = x;
  this.state_ = state;
  this.scheduleCallbacks_();

  if (state === CancellablePromise.State_.REJECTED && !x.IS_CANCELLATION_ERROR) {
    CancellablePromise.addUnhandledRejection_(this, x);
  }
};

/**
 * Attempts to call the {@code then} method on an object in the hopes that it is
 * a Promise-compatible instance. This allows interoperation between different
 * Promise implementations, however a non-compliant object may cause a Promise
 * to hang indefinitely. If the {@code then} method throws an exception, the
 * dependent Promise will be rejected with the thrown value.
 *
 * @see http://promisesaplus.com/#point-70
 *
 * @param {Thenable} thenable An object with a {@code then} method that may be
 *     compatible with the Promise/A+ specification.
 * @param {!Function} then The {@code then} method of the Thenable object.
 * @private
 */
CancellablePromise.prototype.tryThen_ = function (thenable, then) {
  this.state_ = CancellablePromise.State_.BLOCKED;
  var promise = this;
  var called = false;

  var resolve = function resolve(value) {
    if (!called) {
      called = true;
      promise.unblockAndFulfill_(value);
    }
  };

  var reject = function reject(reason) {
    if (!called) {
      called = true;
      promise.unblockAndReject_(reason);
    }
  };

  try {
    then.call(thenable, resolve, reject);
  } catch (e) {
    reject(e);
  }
};

/**
 * Executes the pending callbacks of a resolved Promise after a timeout.
 *
 * Section 2.2.4 of the Promises/A+ specification requires that Promise
 * callbacks must only be invoked from a call stack that only contains Promise
 * implementation code, which we accomplish by invoking callback execution after
 * a timeout. If {@code startExecution_} is called multiple times for the same
 * Promise, the callback chain will be evaluated only once. Additional callbacks
 * may be added during the evaluation phase, and will be executed in the same
 * event loop.
 *
 * All Promises added to the waiting list during the same browser event loop
 * will be executed in one batch to avoid using a separate timeout per Promise.
 *
 * @private
 */
CancellablePromise.prototype.scheduleCallbacks_ = function () {
  if (!this.executing_) {
    this.executing_ = true;
    async.run(this.executeCallbacks_, this);
  }
};

/**
 * Executes all pending callbacks for this Promise.
 *
 * @private
 */
CancellablePromise.prototype.executeCallbacks_ = function () {
  while (this.callbackEntries_ && this.callbackEntries_.length) {
    var entries = this.callbackEntries_;
    this.callbackEntries_ = [];

    for (var i = 0; i < entries.length; i++) {
      this.executeCallback_(entries[i], this.state_, this.result_);
    }
  }
  this.executing_ = false;
};

/**
 * Executes a pending callback for this Promise. Invokes an {@code onFulfilled}
 * or {@code onRejected} callback based on the resolved state of the Promise.
 *
 * @param {!CancellablePromise.CallbackEntry_} callbackEntry An entry containing the
 *     onFulfilled and/or onRejected callbacks for this step.
 * @param {CancellablePromise.State_} state The resolution status of the Promise,
 *     either FULFILLED or REJECTED.
 * @param {*} result The resolved result of the Promise.
 * @private
 */
CancellablePromise.prototype.executeCallback_ = function (callbackEntry, state, result) {
  if (state === CancellablePromise.State_.FULFILLED) {
    callbackEntry.onFulfilled(result);
  } else {
    this.removeUnhandledRejection_();
    callbackEntry.onRejected(result);
  }
};

/**
 * Marks this rejected Promise as having being handled. Also marks any parent
 * Promises in the rejected state as handled. The rejection handler will no
 * longer be invoked for this Promise (if it has not been called already).
 *
 * @private
 */
CancellablePromise.prototype.removeUnhandledRejection_ = function () {
  var p;
  if (CancellablePromise.UNHANDLED_REJECTION_DELAY > 0) {
    for (p = this; p && p.unhandledRejectionId_; p = p.parent_) {
      clearTimeout(p.unhandledRejectionId_);
      p.unhandledRejectionId_ = 0;
    }
  } else if (CancellablePromise.UNHANDLED_REJECTION_DELAY === 0) {
    for (p = this; p && p.hadUnhandledRejection_; p = p.parent_) {
      p.hadUnhandledRejection_ = false;
    }
  }
};

/**
 * Marks this rejected Promise as unhandled. If no {@code onRejected} callback
 * is called for this Promise before the {@code UNHANDLED_REJECTION_DELAY}
 * expires, the reason will be passed to the unhandled rejection handler. The
 * handler typically rethrows the rejection reason so that it becomes visible in
 * the developer console.
 *
 * @param {!CancellablePromise} promise The rejected Promise.
 * @param {*} reason The Promise rejection reason.
 * @private
 */
CancellablePromise.addUnhandledRejection_ = function (promise, reason) {
  if (CancellablePromise.UNHANDLED_REJECTION_DELAY > 0) {
    promise.unhandledRejectionId_ = setTimeout(function () {
      CancellablePromise.handleRejection_.call(null, reason);
    }, CancellablePromise.UNHANDLED_REJECTION_DELAY);
  } else if (CancellablePromise.UNHANDLED_REJECTION_DELAY === 0) {
    promise.hadUnhandledRejection_ = true;
    async.run(function () {
      if (promise.hadUnhandledRejection_) {
        CancellablePromise.handleRejection_.call(null, reason);
      }
    });
  }
};

/**
 * A method that is invoked with the rejection reasons for Promises that are
 * rejected but have no {@code onRejected} callbacks registered yet.
 * @type {function(*)}
 * @private
 */
CancellablePromise.handleRejection_ = async.throwException;

/**
 * Sets a handler that will be called with reasons from unhandled rejected
 * Promises. If the rejected Promise (or one of its descendants) has an
 * {@code onRejected} callback registered, the rejection will be considered
 * handled, and the rejection handler will not be called.
 *
 * By default, unhandled rejections are rethrown so that the error may be
 * captured by the developer console or a {@code window.onerror} handler.
 *
 * @param {function(*)} handler A function that will be called with reasons from
 *     rejected Promises. Defaults to {@code async.throwException}.
 */
CancellablePromise.setUnhandledRejectionHandler = function (handler) {
  CancellablePromise.handleRejection_ = handler;
};

/**
 * Error used as a rejection reason for canceled Promises.
 *
 * @param {string=} opt_message
 * @constructor
 * @extends {Error}
 * @final
 */
CancellablePromise.CancellationError = function (_Error) {
  inherits(_class, _Error);

  function _class(opt_message) {
    classCallCheck(this, _class);

    var _this = possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).call(this, opt_message));

    if (opt_message) {
      _this.message = opt_message;
    }
    return _this;
  }

  return _class;
}(Error);

/** @override */
CancellablePromise.CancellationError.prototype.name = 'cancel';

var Ajax = function () {
	function Ajax() {
		classCallCheck(this, Ajax);
	}

	createClass(Ajax, null, [{
		key: 'parseResponseHeaders',


		/**
   * XmlHttpRequest's getAllResponseHeaders() method returns a string of
   * response headers according to the format described on the spec:
   * {@link http://www.w3.org/TR/XMLHttpRequest/#the-getallresponseheaders-method}.
   * This method parses that string into a user-friendly name/value pair
   * object.
   * @param {string} allHeaders All headers as string.
   * @return {!Array.<Object<string, string>>}
   */
		value: function parseResponseHeaders(allHeaders) {
			var headers = [];
			if (!allHeaders) {
				return headers;
			}
			var pairs = allHeaders.split('\r\n');
			for (var i = 0; i < pairs.length; i++) {
				var index = pairs[i].indexOf(': ');
				if (index > 0) {
					var name = pairs[i].substring(0, index);
					var value = pairs[i].substring(index + 2);
					headers.push({
						name: name,
						value: value
					});
				}
			}
			return headers;
		}

		/**
   * Requests the url using XMLHttpRequest.
   * @param {!string} url
   * @param {!string} method
   * @param {?string} body
   * @param {MultiMap=} opt_headers
   * @param {MultiMap=} opt_params
   * @param {number=} opt_timeout
   * @param {boolean=} opt_sync
   * @param {boolean=} opt_withCredentials
   * @return {Promise} Deferred ajax request.
   * @protected
   */

	}, {
		key: 'request',
		value: function request(url, method, body, opt_headers, opt_params, opt_timeout, opt_sync, opt_withCredentials) {
			url = url || '';
			method = method || 'GET';

			var request = new XMLHttpRequest();

			var promise = new CancellablePromise(function (resolve, reject) {
				request.onload = function () {
					if (request.aborted) {
						request.onerror();
						return;
					}
					resolve(request);
				};
				request.onerror = function () {
					var error = new Error('Request error');
					error.request = request;
					reject(error);
				};
			}).thenCatch(function (reason) {
				request.abort();
				throw reason;
			}).thenAlways(function () {
				clearTimeout(timeout);
			});

			if (opt_params) {
				url = new Uri(url).addParametersFromMultiMap(opt_params).toString();
			}

			request.open(method, url, !opt_sync);

			if (opt_withCredentials) {
				request.withCredentials = true;
			}

			if (opt_headers) {
				opt_headers.names().forEach(function (name) {
					request.setRequestHeader(name, opt_headers.getAll(name).join(', '));
				});
			}

			request.send(isDef(body) ? body : null);

			if (isDefAndNotNull(opt_timeout)) {
				var timeout = setTimeout(function () {
					promise.cancel('Request timeout');
				}, opt_timeout);
			}

			return promise;
		}
	}]);
	return Ajax;
}();

/**
 * Provides a convenient interface for data transport.
 * @interface
 */

var Transport = function () {
	function Transport() {
		classCallCheck(this, Transport);
	}

	createClass(Transport, [{
		key: 'send',


		/**
   * Sends a message for the specified client.
   * @param {!ClientRequest} clientRequest
   * @return {!Promise} Deferred request.
   */
		value: function send() {}
	}]);
	return Transport;
}();

/**
 * Represents a client message (e.g. a request or a response).
 */

var ClientMessage = function () {
	function ClientMessage() {
		classCallCheck(this, ClientMessage);

		this.headers_ = new MultiMap();
	}

	/**
  * Fluent getter and setter for request body.
  * @param {*=} opt_body Request body to be set. If none is given,
  *   the current value of the body will be returned.
  * @return {*} Returns request body if no body value was given. Otherwise
  *   returns the {@link ClientMessage} object itself, so calls can be chained.
  * @chainable Chainable when used as setter.
  */


	createClass(ClientMessage, [{
		key: 'body',
		value: function body(opt_body) {
			if (isDef(opt_body)) {
				this.body_ = opt_body;
				return this;
			}
			return this.body_;
		}

		/**
   * Adds a header. If a header with the same name already exists, it will not be
   * overwritten, but the new value will be stored as well. The order is preserved.
   * @param {string} name
   * @param {string} value
   * @chainable
   */

	}, {
		key: 'header',
		value: function header(name, value) {
			if (arguments.length !== 2) {
				throw new Error('Invalid arguments');
			}
			this.headers_.set(name, value);
			return this;
		}

		/**
   * Fluent getter and setter for request headers.
   * @param {MultiMap|Object=} opt_headers Request headers list to
   *   be set. If none is given the current value of the headers will
   *   be returned.
   * @return {!MultiMap|ClientMessage} Returns map of request headers
   *   if no new value was given. Otherwise returns the {@link ClientMessage}
   *   object itself, so calls can be chained.
   * @chainable Chainable when used as setter.
   */

	}, {
		key: 'headers',
		value: function headers(opt_headers) {
			if (isDef(opt_headers)) {
				if (opt_headers instanceof MultiMap) {
					this.headers_ = opt_headers;
				} else {
					this.headers_.values = opt_headers;
				}
				return opt_headers;
			}
			return this.headers_;
		}

		/**
   * Removes the body.
   */

	}, {
		key: 'removeBody',
		value: function removeBody() {
			this.body_ = undefined;
		}
	}]);
	return ClientMessage;
}();

/**
 * Represents a client response object.
 * @extends {ClientMessage}
 */

var ClientResponse = function (_ClientMessage) {
	inherits(ClientResponse, _ClientMessage);

	function ClientResponse(clientRequest) {
		classCallCheck(this, ClientResponse);

		var _this = possibleConstructorReturn(this, (ClientResponse.__proto__ || Object.getPrototypeOf(ClientResponse)).call(this));

		if (!clientRequest) {
			throw new Error('Can\'t create response without request');
		}
		_this.clientRequest_ = clientRequest;
		return _this;
	}

	/**
  * Returns request that created this response.
  * @return {!ClientRequest}
  */


	createClass(ClientResponse, [{
		key: 'request',
		value: function request() {
			return this.clientRequest_;
		}

		/**
   * Fluent getter and setter for response status code.
   * @param {number=} opt_statusCode Request status code to be set. If none is given,
   *   the current status code value will be returned.
   * @return {!ClientMessage|number} Returns response status code if no new value was
   *   given. Otherwise returns the {@link ClientMessage} object itself, so calls can
   *   be chained.
   * @chainable Chainable when used as setter.
   */

	}, {
		key: 'statusCode',
		value: function statusCode(opt_statusCode) {
			if (isDef(opt_statusCode)) {
				this.statusCode_ = opt_statusCode;
				return this;
			}
			return this.statusCode_;
		}

		/**
   * Fluent getter and setter for response status text.
   * @param {string=} opt_statusText Request status text to be set. If none is given,
   *   the current status text value will be returned.
   * @return {!ClientMessage|number} Returns response status text if no new value was
   *   given. Otherwise returns the {@link ClientMessage} object itself, so calls can
   *   be chained.
   * @chainable Chainable when used as setter.
   */

	}, {
		key: 'statusText',
		value: function statusText(opt_statusText) {
			if (isDef(opt_statusText)) {
				this.statusText_ = opt_statusText;
				return this;
			}
			return this.statusText_;
		}

		/**
   * Checks if response succeeded. Any status code 2xx or 3xx is considered valid.
   * @return {boolean}
   */

	}, {
		key: 'succeeded',
		value: function succeeded() {
			return this.statusCode() >= 200 && this.statusCode() <= 399;
		}
	}]);
	return ClientResponse;
}(ClientMessage);

/**
 * The implementation of an ajax transport to be used with {@link WeDeploy}.
 * @extends {Transport}
 */

var AjaxTransport = function (_Transport) {
	inherits(AjaxTransport, _Transport);

	function AjaxTransport() {
		classCallCheck(this, AjaxTransport);
		return possibleConstructorReturn(this, (AjaxTransport.__proto__ || Object.getPrototypeOf(AjaxTransport)).apply(this, arguments));
	}

	createClass(AjaxTransport, [{
		key: 'send',

		/**
   * @inheritDoc
   */
		value: function send(clientRequest) {
			var deferred = Ajax.request(clientRequest.url(), clientRequest.method(), clientRequest.body(), clientRequest.headers(), clientRequest.params(), null, false, clientRequest.withCredentials());

			return deferred.then(function (response) {
				var clientResponse = new ClientResponse(clientRequest);
				clientResponse.body(response.responseText);
				clientResponse.statusCode(response.status);
				clientResponse.statusText(response.statusText);
				Ajax.parseResponseHeaders(response.getAllResponseHeaders()).forEach(function (header) {
					clientResponse.header(header.name, header.value);
				});
				return clientResponse;
			});
		}
	}]);
	return AjaxTransport;
}(Transport);

/**
 * Provides a factory for data transport.
 */

var TransportFactory = function () {
	function TransportFactory() {
		classCallCheck(this, TransportFactory);

		this.transports = {};
		this.transports[TransportFactory.DEFAULT_TRANSPORT_NAME] = TransportFactory[TransportFactory.DEFAULT_TRANSPORT_NAME];
	}

	/**
  * Returns {@link TransportFactory} instance.
  */


	createClass(TransportFactory, [{
		key: 'get',


		/**
   * Gets an instance of the transport implementation with the given name.
   * @param {string} implementationName
   * @return {!Transport}
   */
		value: function get(implementationName) {
			var TransportClass = this.transports[implementationName];

			if (!TransportClass) {
				throw new Error('Invalid transport name: ' + implementationName);
			}

			try {
				return new TransportClass();
			} catch (err) {
				throw new Error('Can\'t create transport', err);
			}
		}

		/**
   * Returns the default transport implementation.
   * @return {!Transport}
   */

	}, {
		key: 'getDefault',
		value: function getDefault() {
			return this.get(TransportFactory.DEFAULT_TRANSPORT_NAME);
		}
	}], [{
		key: 'instance',
		value: function instance() {
			if (!TransportFactory.instance_) {
				TransportFactory.instance_ = new TransportFactory();
			}
			return TransportFactory.instance_;
		}
	}]);
	return TransportFactory;
}();

TransportFactory.DEFAULT_TRANSPORT_NAME = 'default';

TransportFactory[TransportFactory.DEFAULT_TRANSPORT_NAME] = AjaxTransport;

/**
 * Represents a client request object.
 * @extends {ClientMessage}
 */

var ClientRequest = function (_ClientMessage) {
	inherits(ClientRequest, _ClientMessage);

	function ClientRequest() {
		classCallCheck(this, ClientRequest);

		var _this = possibleConstructorReturn(this, (ClientRequest.__proto__ || Object.getPrototypeOf(ClientRequest)).call(this));

		_this.params_ = new MultiMap();
		_this.withCredentials_ = true;
		return _this;
	}

	/**
  * Fluent getter and setter for with credentials option.
  * @param {boolean=} opt_withCredentials
  * @chainable Chainable when used as setter.
  */


	createClass(ClientRequest, [{
		key: 'withCredentials',
		value: function withCredentials(opt_withCredentials) {
			if (isDef(opt_withCredentials)) {
				this.withCredentials_ = !!opt_withCredentials;
				return this;
			}
			return this.withCredentials_;
		}

		/**
   * Fluent getter and setter for request method.
   * @param {string=} opt_method Request method to be set. If none is given,
   *   the current method value will be returned.
   * @return {!ClientMessage|string} Returns request method if no new value was
   *   given. Otherwise returns the {@link ClientMessage} object itself, so
   *   calls can be chained.
   * @chainable Chainable when used as setter.
   */

	}, {
		key: 'method',
		value: function method(opt_method) {
			if (isDef(opt_method)) {
				this.method_ = opt_method;
				return this;
			}
			return this.method_ || ClientRequest.DEFAULT_METHOD;
		}

		/**
   * Adds a query. If a query with the same name already exists, it will not
   * be overwritten, but new value will be stored as well. The order is preserved.
   * @param {string} name
   * @param {string} value
   * @chainable
   */

	}, {
		key: 'param',
		value: function param(name, value) {
			if (arguments.length !== 2) {
				throw new Error('Invalid arguments');
			}
			this.params_.set(name, value);
			return this;
		}

		/**
   * Fluent getter and setter for request querystring.
   * @param {MultiMap|Object=} opt_params Request querystring map to be set.
   *   If none is given the current value of the params will be returned.
   * @return {!MultiMap|ClientMessage} Returns map of request querystring if
   *   no new value was given. Otherwise returns the {@link ClientMessage}
   *   object itself, so calls can be chained.
   */

	}, {
		key: 'params',
		value: function params(opt_params) {
			if (isDef(opt_params)) {
				if (opt_params instanceof MultiMap) {
					this.params_ = opt_params;
				} else {
					this.params_.values = opt_params;
				}
				return opt_params;
			}
			return this.params_;
		}

		/**
   * Fluent getter and setter for request url.
   * @param {string=} opt_url Request url to be set. If none is given,
   *   the current value of the url will be returned.
   * @return {!ClientMessage|string} Returns request url if no new value was given.
   *   Otherwise returns the {@link ClientMessage} object itself, so calls can be
   *   chained.
   * @chainable Chainable when used as setter.
   */

	}, {
		key: 'url',
		value: function url(opt_url) {
			if (isDef(opt_url)) {
				this.url_ = opt_url;
				return this;
			}
			return this.url_;
		}
	}]);
	return ClientRequest;
}(ClientMessage);

ClientRequest.DEFAULT_METHOD = 'GET';

var io;

// Optimistic initialization of `io` reference from global `globals.window.io`.
if (typeof globals.window !== 'undefined') {
	io = globals.window.io;
}

/**
 * The main class for making api requests. Sending requests returns a promise
 * that is resolved when the response arrives. Usage example:
 * ```javascript
 * WeDeploy
 *   .url('/data/tasks')
 *   .post({desc: 'Buy milkl'})
 *   .then(function(response) {
 *     // Handle response here.
 *     console.log(response.body())
 *   });
 * ```
 */

var WeDeploy$1 = function () {
	/**
  * WeDeploy constructor function.
  * @param {string} url The base url.
  * @param {...string} paths Any amount of paths to be appended to the base
  * url.
  * @constructor
  */
	function WeDeploy(url) {
		for (var _len = arguments.length, paths = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
			paths[_key - 1] = arguments[_key];
		}

		classCallCheck(this, WeDeploy);

		if (arguments.length === 0) {
			throw new Error('Invalid arguments, try `new WeDeploy(baseUrl, url)`');
		}

		this.auth_ = null;
		this.body_ = null;
		this.url_ = Uri.joinPaths.apply(Uri, [url || ''].concat(paths));
		this.headers_ = new MultiMap();
		this.params_ = new MultiMap();
		this.withCredentials_ = true;

		this.header('Content-Type', 'application/json');
		this.header('X-Requested-With', 'XMLHttpRequest');
	}

	/**
  * Static factory for creating WeDeploy data for the given url.
  * @param {string=} opt_dataUrl The url that points to the data services.
  * @return @return {data} WeDeploy data instance.
  */


	createClass(WeDeploy, [{
		key: 'auth',


		/**
   * Adds authorization information to this request.
   * @param {!Auth|string} authOrTokenOrEmail Either an {@link Auth} instance,
   * an authorization token, or the email.
   * @param {string=} opt_password If a email is given as the first param,
   * this should be the password.
   * @chainable
   */
		value: function auth(authOrTokenOrEmail, opt_password) {
			this.auth_ = authOrTokenOrEmail;
			if (!(this.auth_ instanceof Auth)) {
				this.auth_ = Auth.create(authOrTokenOrEmail, opt_password);
			}
			return this;
		}

		/**
   * Static factory for creating WeDeploy auth for the given url.
   * @param {string=} opt_authUrl The url that points to the auth service.
   */

	}, {
		key: 'body',


		/**
   * Sets the body that will be sent with this request.
   * @param {*} body
   * @chainable
   */
		value: function body(_body) {
			this.body_ = _body;
			return this;
		}

		/**
   * Converts the given body object to query params.
   * @param {!ClientRequest} clientRequest Client request.
   * @param {*} body
   * @protected
   */

	}, {
		key: 'convertBodyToParams_',
		value: function convertBodyToParams_(clientRequest, body) {
			if (isString(body)) {
				body = {
					body: body
				};
			} else if (body instanceof Embodied) {
				body = body.body();
			}
			Object.keys(body || {}).forEach(function (name) {
				return clientRequest.param(name, body[name]);
			});
		}

		/**
   * Creates client request and encode.
   * @param {string} method
   * @param {*} body
   * @return {!ClientRequest} Client request.
   * @protected
   */

	}, {
		key: 'createClientRequest_',
		value: function createClientRequest_(method, body) {
			var clientRequest = new ClientRequest();

			clientRequest.body(body || this.body_);

			if (!isDefAndNotNull(clientRequest.body())) {
				if (this.formData_) {
					clientRequest.body(this.formData_);
				}
			}

			clientRequest.method(method);
			clientRequest.headers(this.headers());
			clientRequest.params(this.params());
			clientRequest.url(this.url());
			clientRequest.withCredentials(this.withCredentials_);

			this.encode(clientRequest);

			return clientRequest;
		}

		/**
   * Decodes clientResponse body, parsing the body for example.
   * @param {!ClientResponse} clientResponse The response object to be
   * decoded.
   * @return {!ClientResponse} The decoded response.
   */

	}, {
		key: 'decode',
		value: function decode(clientResponse) {
			if (WeDeploy.isContentTypeJson(clientResponse)) {
				try {
					clientResponse.body(JSON.parse(clientResponse.body()));
				} catch (err) {}
			}
			return clientResponse;
		}

		/**
   * Sends message with the DELETE http verb.
   * @param {string=} opt_body Content to be sent as the request's body.
   * @return {!CancellablePromise}
   */

	}, {
		key: 'delete',
		value: function _delete(opt_body) {
			return this.sendAsync('DELETE', opt_body);
		}

		/**
   * Encodes the given {@link ClientRequest}, converting its body to an
   * appropriate format for example.
   * @param {!ClientRequest} clientRequest The request object to encode.
   * @return {!ClientRequest} The encoded request.
   */

	}, {
		key: 'encode',
		value: function encode(clientRequest) {
			var body = clientRequest.body();

			if (isElement(body)) {
				body = new FormData(body);
				clientRequest.body(body);
			}

			body = this.maybeWrapWithQuery_(body);
			if (clientRequest.method() === 'GET') {
				this.convertBodyToParams_(clientRequest, body);
				clientRequest.removeBody();
				body = null;
			}

			if (typeof FormData !== 'undefined' && body instanceof FormData) {
				clientRequest.headers().remove('content-type');
			} else if (body instanceof Embodied) {
				clientRequest.body(body.toString());
			} else if (WeDeploy.isContentTypeJson(clientRequest)) {
				clientRequest.body(JSON.stringify(clientRequest.body()));
			}

			this.encodeParams_(clientRequest);
			this.resolveAuthentication_(clientRequest);

			return clientRequest;
		}

		/**
   * Encodes the params for the given request, according to their types.
   * @param {!ClientRequest} clientRequest
   * @protected
   */

	}, {
		key: 'encodeParams_',
		value: function encodeParams_(clientRequest) {
			var params = clientRequest.params();
			params.names().forEach(function (name) {
				var values = params.getAll(name);
				values.forEach(function (value, index) {
					if (value instanceof Embodied) {
						value = value.toString();
					} else if (isObject(value) || value instanceof Array) {
						value = JSON.stringify(value);
					}
					values[index] = value;
				});
			});
		}

		/**
   * Adds a key/value pair to be sent via the body in a `multipart/form-data` format.
   * If the body is set by other means (for example, through the `body` method), this
   * will be ignored.
   * @param {string} name
   * @param {*} value
   * @chainable
   */

	}, {
		key: 'form',
		value: function form(name, value) {
			if (typeof FormData === 'undefined') {
				throw new Error('form() is only available when FormData API is available.');
			}

			if (!this.formData_) {
				this.formData_ = new FormData();
			}
			this.formData_.append(name, value);
			return this;
		}

		/**
   * Sends message with the GET http verb.
   * @param {*=} opt_params Params to be added to the request url.
   * @return {!CancellablePromise}
   */

	}, {
		key: 'get',
		value: function get(opt_params) {
			return this.sendAsync('GET', opt_params);
		}

		/**
   * Adds a header. If the header with the same name already exists, it will
   * not be overwritten, but new value will be stored. The order is preserved.
   * @param {string} name Header key.
   * @param {*} value Header value.
   * @chainable
   */

	}, {
		key: 'header',
		value: function header(name, value) {
			if (arguments.length !== 2) {
				throw new Error('Invalid arguments');
			}
			this.headers_.set(name, value);
			return this;
		}

		/**
   * Gets the headers.
   * @return {!MultiMap}
   */

	}, {
		key: 'headers',
		value: function headers() {
			return this.headers_;
		}

		/**
   * Wraps the given `Embodied` instance with a {@link Query} instance if needed.
   * @param {Embodied} embodied
   * @return {Embodied}
   * @protected
   */

	}, {
		key: 'maybeWrapWithQuery_',
		value: function maybeWrapWithQuery_(embodied) {
			if (embodied instanceof Filter) {
				embodied = Query.filter(embodied);
			}
			return embodied;
		}

		/**
   * Adds a query. If the query with the same name already exists, it will not
   * be overwritten, but new value will be stored. The order is preserved.
   * @param {string} name Param key.
   * @param {*} value Param value.
   * @chainable
   */

	}, {
		key: 'param',
		value: function param(name, value) {
			if (arguments.length !== 2) {
				throw new Error('Invalid arguments');
			}
			this.params_.set(name, value);
			return this;
		}

		/**
   * Gets the query strings map.
   * @return {!MultiMap}
   */

	}, {
		key: 'params',
		value: function params() {
			return this.params_;
		}

		/**
   * Sends message with the PATCH http verb.
   * @param {string=} opt_body Content to be sent as the request's body.
   * @return {!CancellablePromise}
   */

	}, {
		key: 'patch',
		value: function patch(opt_body) {
			return this.sendAsync('PATCH', opt_body);
		}

		/**
   * Creates a new {@link WeDeploy} instance for handling the url resulting in the
   * union of the current url with the given paths.
   * @param {...string} paths Any number of paths.
   * @return {!WeDeploy} A new {@link WeDeploy} instance for handling the given paths.
   */

	}, {
		key: 'path',
		value: function path() {
			for (var _len2 = arguments.length, paths = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
				paths[_key2] = arguments[_key2];
			}

			return new (Function.prototype.bind.apply(WeDeploy, [null].concat([this.url()], paths)))().use(this.customTransport_);
		}

		/**
   * Sends message with the POST http verb.
   * @param {string=} opt_body Content to be sent as the request's body.
   * @return {!CancellablePromise}
   */

	}, {
		key: 'post',
		value: function post(opt_body) {
			return this.sendAsync('POST', opt_body);
		}

		/**
   * Sends message with the PUT http verb.
   * @param {string=} opt_body Content to be sent as the request's body.
   * @return {!CancellablePromise}
   */

	}, {
		key: 'put',
		value: function put(opt_body) {
			return this.sendAsync('PUT', opt_body);
		}

		/**
   * Adds the authentication information to the request.
   * @param {!ClientRequest} clientRequest
   * @protected
   */

	}, {
		key: 'resolveAuthentication_',
		value: function resolveAuthentication_(clientRequest) {
			if (!this.auth_) {
				return;
			}
			if (this.auth_.hasToken()) {
				clientRequest.header('Authorization', 'Bearer ' + this.auth_.token);
			} else {
				var credentials = this.auth_.email + ':' + this.auth_.password;
				clientRequest.header('Authorization', 'Basic ' + Base64.encodeString(credentials));
			}
		}

		/**
   * Uses transport to send request with given method name and body
   * asynchronously.
   * @param {string} method The HTTP method to be used when sending data.
   * @param {string} body Content to be sent as the request's body.
   * @return {!CancellablePromise} Deferred request.
   */

	}, {
		key: 'sendAsync',
		value: function sendAsync(method, body) {
			var transport = this.customTransport_ || TransportFactory.instance().getDefault();

			var clientRequest = this.createClientRequest_(method, body);

			return transport.send(clientRequest).then(this.decode);
		}

		/**
   * Sets the socket transport
   * @param {Object} socket implementation object.
   */

	}, {
		key: 'url',


		/**
   * Returns the URL used by this client.
   */
		value: function url() {
			return this.url_;
		}

		/**
   * Specifies {@link Transport} implementation.
   * @param {!Transport} transport The transport implementation that should be
   * used.
   */

	}, {
		key: 'use',
		value: function use(transport) {
			this.customTransport_ = transport;
			return this;
		}

		/**
   * Creates new socket.io instance. The parameters passed to socket.io
   * constructor will be provided:
   *
   * ```javascript
   * WeDeploy.url('http://domain:8080/path/a').watch({id: 'myId'}, {foo: true});
   * // Equals:
   * io('domain:8080/?url=path%2Fa%3Fid%3DmyId', {foo: true});
   * ```
   *
   * @param {Object=} opt_params Params to be sent with the Socket IO request.
   * @param {Object=} opt_options Object with Socket IO options.
   * @return {!io} Socket IO reference. Server events can be listened on it.
   */

	}, {
		key: 'watch',
		value: function watch(opt_params, opt_options) {
			if (typeof io === 'undefined') {
				throw new Error('Socket.io client not loaded');
			}

			var clientRequest = this.createClientRequest_('GET', opt_params);
			var uri = new Uri(clientRequest.url());
			uri.addParametersFromMultiMap(clientRequest.params());

			opt_options = opt_options || {
				forceNew: true
			};
			opt_options.query = 'url=' + encodeURIComponent(uri.getPathname() + uri.getSearch());
			opt_options.path = opt_options.path || uri.getPathname();

			return io(uri.getHost(), opt_options);
		}

		/**
   * @param {boolean} opt_withCredentials
   */

	}, {
		key: 'withCredentials',
		value: function withCredentials(_withCredentials) {
			this.withCredentials_ = !!_withCredentials;
			return this;
		}
	}], [{
		key: 'data',
		value: function data(opt_dataUrl) {
			assertUriWithNoPath(opt_dataUrl, 'The data url should not have a path');

			if (isString(opt_dataUrl)) {
				WeDeploy.dataUrl_ = opt_dataUrl;
			}

			var data = new DataApiHelper(WeDeploy);

			data.auth(WeDeploy.auth().currentUser);

			return data;
		}
	}, {
		key: 'auth',
		value: function auth(opt_authUrl) {
			if (isString(opt_authUrl)) {
				WeDeploy.authUrl_ = opt_authUrl;
			}
			if (!WeDeploy.auth_) {
				WeDeploy.auth_ = new AuthApiHelper(WeDeploy);
			}
			return WeDeploy.auth_;
		}
	}, {
		key: 'socket',
		value: function socket(_socket) {
			io = _socket;
		}

		/**
   * Static factory for creating WeDeploy client for the given url.
   * @param {string} url The url that the client should use for sending requests.
   */

	}, {
		key: 'url',
		value: function url(_url) {
			return new WeDeploy(_url).use(this.customTransport_);
		}
	}]);
	return WeDeploy;
}();

WeDeploy$1.isContentTypeJson = function (clientMessage) {
	var contentType = clientMessage.headers().get('content-type') || '';
	return contentType.indexOf('application/json') === 0;
};

WeDeploy$1.auth_ = null;
WeDeploy$1.authUrl_ = '';
WeDeploy$1.data_ = null;
WeDeploy$1.dataUrl_ = '';

globals.window.Filter = Filter;
globals.window.Geo = Geo;
globals.window.Query = Query;
globals.window.Range = Range;
globals.window.WeDeploy = WeDeploy$1;

exports.Filter = Filter;
exports.Geo = Geo;
exports.Query = Query;
exports.Range = Range;
exports.WeDeploy = WeDeploy$1;
exports['default'] = WeDeploy$1;

Object.defineProperty(exports, '__esModule', { value: true });

})));



//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNvY2tldC5pby5qcyIsInNyYy9nbG9iYWxzL2dsb2JhbHMuanMiLCJub2RlX21vZHVsZXMvbWV0YWwvc3JjL2NvcmVOYW1lZC5qcyIsIm5vZGVfbW9kdWxlcy9tZXRhbC9zcmMvY29yZS5qcyIsIm5vZGVfbW9kdWxlcy9tZXRhbC9zcmMvYXJyYXkvYXJyYXkuanMiLCJub2RlX21vZHVsZXMvbWV0YWwvc3JjL2FzeW5jL2FzeW5jLmpzIiwibm9kZV9tb2R1bGVzL21ldGFsL3NyYy9kaXNwb3NhYmxlL0Rpc3Bvc2FibGUuanMiLCJub2RlX21vZHVsZXMvbWV0YWwvc3JjL29iamVjdC9vYmplY3QuanMiLCJub2RlX21vZHVsZXMvbWV0YWwvc3JjL3N0cmluZy9zdHJpbmcuanMiLCJzcmMvYXBpLXF1ZXJ5L0VtYm9kaWVkLmpzIiwic3JjL2FwaS1xdWVyeS9GaWx0ZXJCb2R5LmpzIiwic3JjL2FwaS1xdWVyeS9HZW8uanMiLCJzcmMvYXBpLXF1ZXJ5L1JhbmdlLmpzIiwic3JjL2FwaS1xdWVyeS9GaWx0ZXIuanMiLCJub2RlX21vZHVsZXMvbWV0YWwtdXJpL3NyYy9wYXJzZUZyb21BbmNob3IuanMiLCJub2RlX21vZHVsZXMvbWV0YWwtdXJpL3NyYy9wYXJzZS5qcyIsIm5vZGVfbW9kdWxlcy9tZXRhbC1zdHJ1Y3RzL3NyYy9NdWx0aU1hcC5qcyIsIm5vZGVfbW9kdWxlcy9tZXRhbC1zdHJ1Y3RzL3NyYy9UcmVlTm9kZS5qcyIsIm5vZGVfbW9kdWxlcy9tZXRhbC11cmkvc3JjL1VyaS5qcyIsInNyYy9hcGkvYXNzZXJ0aW9ucy5qcyIsInNyYy9hcGkvYXV0aC9BdXRoLmpzIiwic3JjL2FwaS9BcGlIZWxwZXIuanMiLCJzcmMvYXBpL2F1dGgvQXV0aFByb3ZpZGVyLmpzIiwic3JjL2FwaS9hdXRoL0ZhY2Vib29rQXV0aFByb3ZpZGVyLmpzIiwic3JjL2FwaS9hdXRoL0dpdGh1YkF1dGhQcm92aWRlci5qcyIsInNyYy9hcGkvYXV0aC9Hb29nbGVBdXRoUHJvdmlkZXIuanMiLCJub2RlX21vZHVsZXMvbWV0YWwtc3RvcmFnZS9zcmMvbWVjaGFuaXNtL1N0b3JhZ2VNZWNoYW5pc20uanMiLCJub2RlX21vZHVsZXMvbWV0YWwtc3RvcmFnZS9zcmMvU3RvcmFnZS5qcyIsIm5vZGVfbW9kdWxlcy9tZXRhbC1zdG9yYWdlL3NyYy9tZWNoYW5pc20vTG9jYWxTdG9yYWdlTWVjaGFuaXNtLmpzIiwic3JjL2FwaS9hdXRoL0F1dGhBcGlIZWxwZXIuanMiLCJzcmMvYXBpLXF1ZXJ5L0FnZ3JlZ2F0aW9uLmpzIiwic3JjL2FwaS1xdWVyeS9RdWVyeS5qcyIsInNyYy9hcGkvZGF0YS9EYXRhQXBpSGVscGVyLmpzIiwic3JjL2NyeXB0L0Jhc2U2NC5qcyIsIm5vZGVfbW9kdWxlcy9tZXRhbC1wcm9taXNlL3NyYy9wcm9taXNlL1Byb21pc2UuanMiLCJub2RlX21vZHVsZXMvbWV0YWwtYWpheC9zcmMvQWpheC5qcyIsInNyYy9hcGkvVHJhbnNwb3J0LmpzIiwic3JjL2FwaS9DbGllbnRNZXNzYWdlLmpzIiwic3JjL2FwaS9DbGllbnRSZXNwb25zZS5qcyIsInNyYy9hcGkvYnJvd3Nlci9BamF4VHJhbnNwb3J0LmpzIiwic3JjL2FwaS9UcmFuc3BvcnRGYWN0b3J5LmpzIiwic3JjL2FwaS9DbGllbnRSZXF1ZXN0LmpzIiwic3JjL2FwaS9XZURlcGxveS5qcyIsInNyYy9lbnYvYnJvd3Nlci5qcyJdLCJuYW1lcyI6WyJnbG9iYWxzIiwid2luZG93IiwiZG9jdW1lbnQiLCJjb21wYXRpYmlsaXR5TW9kZURhdGFfIiwidW5pcXVlSWRDb3VudGVyXyIsIlVJRF9QUk9QRVJUWSIsIk1hdGgiLCJyYW5kb20iLCJhYnN0cmFjdE1ldGhvZCIsIkVycm9yIiwiY29sbGVjdFN1cGVyQ2xhc3Nlc1Byb3BlcnR5IiwiY29uc3RydWN0b3IiLCJwcm9wZXJ0eU5hbWUiLCJwcm9wZXJ0eVZhbHVlcyIsIl9fcHJvdG9fXyIsImlzUHJvdG90eXBlT2YiLCJGdW5jdGlvbiIsInB1c2giLCJkaXNhYmxlQ29tcGF0aWJpbGl0eU1vZGUiLCJlbmFibGVDb21wYXRpYmlsaXR5TW9kZSIsIm9wdF9kYXRhIiwiZ2V0Q29tcGF0aWJpbGl0eU1vZGVEYXRhIiwiX19NRVRBTF9DT01QQVRJQklMSVRZX18iLCJnZXRGdW5jdGlvbk5hbWUiLCJmbiIsIm5hbWUiLCJzdHIiLCJ0b1N0cmluZyIsInN1YnN0cmluZyIsImluZGV4T2YiLCJnZXRVaWQiLCJvcHRfb2JqZWN0Iiwib3B0X25vSW5oZXJpdGFuY2UiLCJpZCIsImhhc093blByb3BlcnR5IiwiaWRlbnRpdHlGdW5jdGlvbiIsIm9wdF9yZXR1cm5WYWx1ZSIsImlzQm9vbGVhbiIsInZhbCIsImlzRGVmIiwidW5kZWZpbmVkIiwiaXNEZWZBbmROb3ROdWxsIiwiaXNOdWxsIiwiaXNEb2N1bWVudCIsIm5vZGVUeXBlIiwiaXNFbGVtZW50IiwiaXNGdW5jdGlvbiIsImlzTnVtYmVyIiwiaXNXaW5kb3ciLCJpc09iamVjdCIsInR5cGUiLCJpc1Byb21pc2UiLCJ0aGVuIiwiaXNTdHJpbmciLCJTdHJpbmciLCJtZXJnZVN1cGVyQ2xhc3Nlc1Byb3BlcnR5Iiwib3B0X21lcmdlRm4iLCJtZXJnZWROYW1lIiwibWVyZ2VkIiwibnVsbEZ1bmN0aW9uIiwiYXJyYXkiLCJhcnIxIiwiYXJyMiIsImxlbmd0aCIsImkiLCJhcnIiLCJvcHRfb3V0cHV0Iiwib3V0cHV0IiwiQXJyYXkiLCJpc0FycmF5IiwiZmxhdHRlbiIsIm9iaiIsInJ2IiwicmVtb3ZlQXQiLCJwcm90b3R5cGUiLCJzcGxpY2UiLCJjYWxsIiwic3RhcnQiLCJvcHRfZW5kIiwic2xpY2VkIiwiZW5kIiwiYXN5bmMiLCJ0aHJvd0V4Y2VwdGlvbiIsImV4Y2VwdGlvbiIsIm5leHRUaWNrIiwicnVuIiwiY2FsbGJhY2siLCJvcHRfY29udGV4dCIsIndvcmtRdWV1ZVNjaGVkdWxlZF8iLCJwcm9jZXNzV29ya1F1ZXVlIiwid29ya1F1ZXVlXyIsIldvcmtJdGVtXyIsIndvcmtJdGVtcyIsIndvcmtJdGVtIiwic2NvcGUiLCJlIiwiY2IiLCJiaW5kIiwid3JhcENhbGxiYWNrXyIsInNldEltbWVkaWF0ZSIsInNldEltbWVkaWF0ZV8iLCJnZXRTZXRJbW1lZGlhdGVFbXVsYXRvcl8iLCJDaGFubmVsIiwiTWVzc2FnZUNoYW5uZWwiLCJwb3N0TWVzc2FnZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJpZnJhbWUiLCJjcmVhdGVFbGVtZW50Iiwic3R5bGUiLCJkaXNwbGF5Iiwic3JjIiwiZG9jdW1lbnRFbGVtZW50IiwiYXBwZW5kQ2hpbGQiLCJ3aW4iLCJjb250ZW50V2luZG93IiwiZG9jIiwib3BlbiIsIndyaXRlIiwiY2xvc2UiLCJtZXNzYWdlIiwib3JpZ2luIiwibG9jYXRpb24iLCJwcm90b2NvbCIsImhvc3QiLCJvbm1lc3NhZ2UiLCJkYXRhIiwicG9ydDEiLCJwb3J0MiIsImNoYW5uZWwiLCJoZWFkIiwidGFpbCIsIm5leHQiLCJzY3JpcHQiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJEaXNwb3NhYmxlIiwiZGlzcG9zZWRfIiwiZGlzcG9zZUludGVybmFsIiwib2JqZWN0IiwidGFyZ2V0Iiwia2V5Iiwic291cmNlIiwiYXJndW1lbnRzIiwib3B0X29iaiIsInBhcnRzIiwic3BsaXQiLCJyZWR1Y2UiLCJwYXJ0IiwibWFwcGVkT2JqIiwia2V5cyIsIk9iamVjdCIsIm9iajEiLCJvYmoyIiwia2V5czEiLCJrZXlzMiIsInN0cmluZyIsInJlcGxhY2UiLCJ4IiwiZmxvb3IiLCJhYnMiLCJEYXRlIiwibm93IiwiaGFzaCIsImxlbiIsImNoYXJDb2RlQXQiLCJ2YWx1ZSIsIkVtYm9kaWVkIiwiYm9keV8iLCJKU09OIiwic3RyaW5naWZ5IiwiYm9keSIsIkZpbHRlckJvZHkiLCJmaWVsZCIsIm9wZXJhdG9yT3JWYWx1ZSIsIm9wdF92YWx1ZSIsImNvcmUiLCJjcmVhdGVCb2R5XyIsIm9wZXJhdG9yIiwib3B0X2ZpbHRlciIsImFkZEFycmF5T3BlcmF0b3JfIiwiZmlsdGVyIiwiZmlsdGVycyIsImFkZCIsIkdlbyIsInVwcGVyTGVmdCIsImxvd2VyUmlnaHQiLCJCb3VuZGluZ0JveCIsImNlbnRlciIsInJhZGl1cyIsIkNpcmNsZSIsInBvaW50cyIsIkxpbmUiLCJsYXQiLCJsb24iLCJQb2ludCIsIlBvbHlnb24iLCJtYXAiLCJ0b0JvZHkiLCJwb2ludCIsImNvb3JkaW5hdGVzIiwiYWRkQ29vcmRpbmF0ZXNfIiwiUmFuZ2UiLCJmcm9tIiwib3B0X3RvIiwidG8iLCJGaWx0ZXIiLCJmaWVsZE9yRmlsdGVyIiwib3B0X29wZXJhdG9yT3JWYWx1ZSIsInRvRmlsdGVyIiwiYWRkTWFueSIsImdldE9iamVjdCIsInZhbHVlcyIsInNsaWNlIiwiYm94T3JVcHBlckxlZnQiLCJvcHRfbG93ZXJSaWdodCIsInBvbHlnb24iLCJnZXRQb2ludHMiLCJsb2NhdGlvbk9yQ2lyY2xlIiwib3B0X3JhbmdlT3JEaXN0YW5jZSIsInJhbmdlIiwiZ2V0Q2VudGVyIiwiZ2V0UmFkaXVzIiwiZGlzdGFuY2VJbnRlcm5hbF8iLCJtaW4iLCJtYXgiLCJmaWVsZE9yUXVlcnkiLCJvcHRfcXVlcnlPckZ1enppbmVzcyIsIm9wdF9mdXp6aW5lc3MiLCJmdXp6eUludGVybmFsXyIsImFyZzJJc1N0cmluZyIsImZ1enppbmVzcyIsIkFMTCIsIm9wdF9xdWVyeSIsInF1ZXJ5IiwicmFuZ2VPck1pbiIsIm9wdF9tYXgiLCJzaGFwZXMiLCJzaGFwZSIsInBhcnNlRnJvbUFuY2hvciIsIm9wdF91cmkiLCJsaW5rIiwiaHJlZiIsImhvc3RuYW1lIiwicGFzc3dvcmQiLCJwYXRobmFtZSIsInBvcnQiLCJzZWFyY2giLCJ1c2VybmFtZSIsInBhcnNlIiwiVVJMIiwiY3JlYXRlIiwiTXVsdGlNYXAiLCJ0b0xvd2VyQ2FzZSIsInNpemUiLCJuYW1lcyIsInNldCIsIlRyZWVOb2RlIiwidmFsdWVfIiwicGFyZW50XyIsImNoaWxkcmVuXyIsImNoaWxkIiwic2V0UGFyZW50Iiwibm9kZSIsImN1cnJlbnQiLCJnZXRQYXJlbnQiLCJhbmNlc3RvcnMiLCJpbmRleCIsImdldENoaWxkcmVuIiwiRU1QVFlfQVJSQVkiLCJkZXB0aCIsInJvb3QiLCJnZXRDaGlsZENvdW50IiwicmVtb3ZlIiwicGFyZW50Iiwib3B0X3ByZW9yZGVyRm4iLCJvcHRfcG9zdG9yZGVyRm4iLCJmb3JFYWNoIiwidHJhdmVyc2UiLCJhc3NlcnRDaGlsZEhhc05vUGFyZW50IiwicGFyc2VGbl8iLCJVcmkiLCJ1cmwiLCJtYXliZUFkZFByb3RvY29sQW5kSG9zdG5hbWVfIiwibXVsdGltYXAiLCJnZXRBbGwiLCJhZGRQYXJhbWV0ZXJWYWx1ZSIsImVuc3VyZVF1ZXJ5SW5pdGlhbGl6ZWRfIiwicGFyYW0iLCJ1cmxEZWNvZGUiLCJnZXRIb3N0bmFtZSIsImdldFBvcnQiLCJIT1NUTkFNRV9QTEFDRUhPTERFUiIsImdldEhvc3QiLCJnZXRQcm90b2NvbCIsImdldCIsInF1ZXJ5c3RyaW5nIiwiZ2V0UGFyYW1ldGVyTmFtZXMiLCJnZXRQYXJhbWV0ZXJWYWx1ZXMiLCJlbmNvZGVVUklDb21wb25lbnQiLCJjb250YWlucyIsInNldFBhcmFtZXRlclZhbHVlIiwiUkFORE9NX1BBUkFNIiwiZ2V0UmFuZG9tU3RyaW5nIiwiREVGQVVMVF9QUk9UT0NPTCIsImNoYXJBdCIsInJlbW92ZVBhcmFtZXRlciIsImdldFBhdGhuYW1lIiwiZ2V0U2VhcmNoIiwiZ2V0SGFzaCIsInBhcnNlZCIsInN1YnN0ciIsIm5vcm1hbGl6ZU9iamVjdCIsInBhcnNlRm4iLCJiYXNlUGF0aCIsInBhdGhzIiwicGF0aCIsImNvbmNhdCIsImpvaW4iLCJkZWNvZGVVUklDb21wb25lbnQiLCJhc3NlcnRCcm93c2VyRW52aXJvbm1lbnQiLCJhc3NlcnREZWZBbmROb3ROdWxsIiwiZXJyb3JNZXNzYWdlIiwiYXNzZXJ0RnVuY3Rpb24iLCJhc3NlcnRPYmplY3QiLCJhc3NlcnRSZXNwb25zZVN1Y2NlZWRlZCIsInJlc3BvbnNlIiwic3VjY2VlZGVkIiwiYXNzZXJ0VXNlclNpZ25lZEluIiwidXNlciIsImFzc2VydFVyaVdpdGhOb1BhdGgiLCJ1cmkiLCJBdXRoIiwidG9rZW5PckVtYWlsIiwib3B0X3Bhc3N3b3JkIiwidG9rZW4iLCJlbWFpbCIsImNyZWF0ZWRBdCIsInBob3RvVXJsIiwid2VkZXBsb3lDbGllbnQiLCJhdXRoVXJsXyIsImF1dGgiLCJwYXRjaCIsImRlbGV0ZSIsInRva2VuT3JVc2VybmFtZSIsIkFwaUhlbHBlciIsImF1dGhPclRva2VuT3JFbWFpbCIsImhlbHBlckF1dGhTY29wZSIsIkF1dGhQcm92aWRlciIsInByb3ZpZGVyIiwicHJvdmlkZXJTY29wZSIsInJlZGlyZWN0VXJpIiwib3B0X2F1dGhVcmwiLCJzZXRQYXRobmFtZSIsImhhc1Byb3ZpZGVyIiwiZ2V0UHJvdmlkZXIiLCJoYXNQcm92aWRlclNjb3BlIiwiZ2V0UHJvdmlkZXJTY29wZSIsImhhc1JlZGlyZWN0VXJpIiwiZ2V0UmVkaXJlY3RVcmkiLCJoYXNTY29wZSIsImdldFNjb3BlIiwiYXNzZXJ0U3RyaW5nSWZEZWZBbmROb3ROdWxsIiwiRmFjZWJvb2tBdXRoUHJvdmlkZXIiLCJQUk9WSURFUiIsIkdpdGh1YkF1dGhQcm92aWRlciIsIkdvb2dsZUF1dGhQcm92aWRlciIsIlN0b3JhZ2VNZWNoYW5pc20iLCJTdG9yYWdlIiwibWVjaGFuaXNtIiwiY2xlYXIiLCJqc29uIiwiRXJyb3JDb2RlIiwiSU5WQUxJRF9WQUxVRSIsImFzc2VydE1lY2hhbmlzbURlZkFuZE5vdE51bGwiLCJhc3NlcnRNZWNoYW5pc21JbnRhbmNlT2YiLCJMb2NhbFN0b3JhZ2VNZWNoYW5pc20iLCJsb2NhbFN0b3JhZ2UiLCJzdG9yYWdlIiwiZ2V0SXRlbSIsInJlbW92ZUl0ZW0iLCJzZXRJdGVtIiwiaXNTdXBwb3J0ZWQiLCJBdXRoQXBpSGVscGVyIiwiY3VycmVudFVzZXIiLCJvblNpZ25JbkNhbGxiYWNrIiwib25TaWduT3V0Q2FsbGJhY2siLCJwcm9jZXNzU2lnbkluXyIsInBvc3QiLCJtYWtlVXNlckF1dGhGcm9tRGF0YSIsImZyYWdtZW50IiwidXNlcklkIiwicmVzb2x2ZUF1dGhTY29wZSIsInNldFdlZGVwbG95Q2xpZW50Iiwic2V0Q3JlYXRlZEF0Iiwic2V0RW1haWwiLCJzZXRJZCIsInNldE5hbWUiLCJzZXRQaG90b1VybCIsInNldFRva2VuIiwicmVkaXJlY3RBY2Nlc3NUb2tlbiIsImdldFJlZGlyZWN0QWNjZXNzVG9rZW5fIiwicmVtb3ZlVXJsRnJhZ21lbnRDb21wbGV0ZWx5XyIsImxvYWRDdXJyZW50VXNlciIsIm1heWJlQ2FsbE9uU2lnbkluQ2FsbGJhY2tfIiwiaGlzdG9yeSIsInB1c2hTdGF0ZSIsInRpdGxlIiwiYWNjZXNzX3Rva2VuIiwic2V0UmVkaXJlY3RVcmkiLCJnZXRIcmVmV2l0aG91dEZyYWdtZW50XyIsIm1ha2VBdXRob3JpemF0aW9uVXJsIiwibWF5YmVDYWxsT25TaWduT3V0Q2FsbGJhY2tfIiwidW5sb2FkQ3VycmVudFVzZXJfIiwiYXNzZXJ0U3VwcG9ydGVkUHJvdmlkZXIiLCJBZ2dyZWdhdGlvbiIsImZpZWxkXyIsIm9wZXJhdG9yXyIsInJhbmdlcyIsIkRpc3RhbmNlQWdncmVnYXRpb24iLCJpbnRlcnZhbCIsIlJhbmdlQWdncmVnYXRpb24iLCJyYW5nZU9yRnJvbSIsInVuaXQiLCJRdWVyeSIsImFnZ3JlZ2F0aW9uT3JGaWVsZCIsIm9wdF9vcGVyYXRvciIsImFnZ3JlZ2F0aW9uIiwiZ2V0RmllbGQiLCJnZXRPcGVyYXRvciIsImdldFZhbHVlIiwib2Zmc2V0IiwiaGlnaGxpZ2h0IiwibGltaXQiLCJmaWx0ZXJPclRleHRPckZpZWxkIiwib3B0X3RleHRPck9wZXJhdG9yIiwibWF0Y2giLCJvcHRfZGlyZWN0aW9uIiwic29ydCIsInNvcnRFbnRyeSIsImFnZ3JlZ2F0ZSIsIkRhdGFBcGlIZWxwZXIiLCJnZXRPckNyZWF0ZUZpbHRlcl8iLCJhbmQiLCJvciIsImFyZ3MiLCJ3aGVyZSIsIm5vbmUiLCJzaW1pbGFyIiwibHQiLCJsdGUiLCJhbnkiLCJib3VuZGluZ0JveCIsImRpc3RhbmNlIiwiZ2V0T3JDcmVhdGVRdWVyeV8iLCJjb2xsZWN0aW9uIiwiZGF0YVVybF8iLCJwdXQiLCJhZGRGaWx0ZXJzVG9RdWVyeV8iLCJxdWVyeV8iLCJvblNlYXJjaF8iLCJvcHRfb3B0aW9ucyIsIndhdGNoIiwiZmlsdGVyXyIsInRvU2VhcmNoXyIsIkJhc2U2NCIsImJ0b2EiLCJCdWZmZXIiLCJUaGVuYWJsZSIsIklNUExFTUVOVEVEX0JZX1BST1AiLCJhZGRJbXBsZW1lbnRhdGlvbiIsImN0b3IiLCIkZ29vZ19UaGVuYWJsZSIsImlzSW1wbGVtZW50ZWRCeSIsInBhcnRpYWwiLCJuZXdBcmdzIiwiYXBwbHkiLCJDYW5jZWxsYWJsZVByb21pc2UiLCJyZXNvbHZlciIsInN0YXRlXyIsIlN0YXRlXyIsIlBFTkRJTkciLCJyZXN1bHRfIiwiY2FsbGJhY2tFbnRyaWVzXyIsImV4ZWN1dGluZ18iLCJVTkhBTkRMRURfUkVKRUNUSU9OX0RFTEFZIiwidW5oYW5kbGVkUmVqZWN0aW9uSWRfIiwiaGFkVW5oYW5kbGVkUmVqZWN0aW9uXyIsInNlbGYiLCJyZXNvbHZlXyIsIkZVTEZJTExFRCIsInJlYXNvbiIsIlJFSkVDVEVEIiwiQ2FsbGJhY2tFbnRyeV8iLCJyZXNvbHZlIiwicmVqZWN0Iiwib3B0X3JlYXNvbiIsInJhY2UiLCJwcm9taXNlcyIsInByb21pc2UiLCJhbGwiLCJ0b0Z1bGZpbGwiLCJvbkZ1bGZpbGwiLCJvblJlamVjdCIsImZpcnN0RnVsZmlsbGVkIiwidG9SZWplY3QiLCJyZWFzb25zIiwib3B0X29uRnVsZmlsbGVkIiwib3B0X29uUmVqZWN0ZWQiLCJhZGRDaGlsZFByb21pc2VfIiwidGhlbkFsd2F5cyIsIm9uUmVzb2x2ZWQiLCJlcnIiLCJoYW5kbGVSZWplY3Rpb25fIiwiYWRkQ2FsbGJhY2tFbnRyeV8iLCJ0aGVuQ2F0Y2giLCJvblJlamVjdGVkIiwiY2F0Y2giLCJjYW5jZWwiLCJvcHRfbWVzc2FnZSIsIkNhbmNlbGxhdGlvbkVycm9yIiwiSVNfQ0FOQ0VMTEFUSU9OX0VSUk9SIiwiY2FuY2VsSW50ZXJuYWxfIiwiY2FuY2VsQ2hpbGRfIiwiY2hpbGRQcm9taXNlIiwiY2hpbGRDb3VudCIsImNoaWxkSW5kZXgiLCJlbnRyeSIsImNhbGxiYWNrRW50cnkiLCJleGVjdXRlQ2FsbGJhY2tfIiwic2NoZWR1bGVDYWxsYmFja3NfIiwib25GdWxmaWxsZWQiLCJyZXN1bHQiLCJ1bmJsb2NrQW5kRnVsZmlsbF8iLCJCTE9DS0VEIiwidW5ibG9ja0FuZFJlamVjdF8iLCJzdGF0ZSIsIlR5cGVFcnJvciIsInRyeVRoZW5fIiwiYWRkVW5oYW5kbGVkUmVqZWN0aW9uXyIsInRoZW5hYmxlIiwiY2FsbGVkIiwiZXhlY3V0ZUNhbGxiYWNrc18iLCJlbnRyaWVzIiwicmVtb3ZlVW5oYW5kbGVkUmVqZWN0aW9uXyIsInAiLCJzZXRUaW1lb3V0Iiwic2V0VW5oYW5kbGVkUmVqZWN0aW9uSGFuZGxlciIsImhhbmRsZXIiLCJBamF4IiwiYWxsSGVhZGVycyIsImhlYWRlcnMiLCJwYWlycyIsIm1ldGhvZCIsIm9wdF9oZWFkZXJzIiwib3B0X3BhcmFtcyIsIm9wdF90aW1lb3V0Iiwib3B0X3N5bmMiLCJvcHRfd2l0aENyZWRlbnRpYWxzIiwicmVxdWVzdCIsIlhNTEh0dHBSZXF1ZXN0IiwiUHJvbWlzZSIsIm9ubG9hZCIsImFib3J0ZWQiLCJvbmVycm9yIiwiZXJyb3IiLCJhYm9ydCIsInRpbWVvdXQiLCJhZGRQYXJhbWV0ZXJzRnJvbU11bHRpTWFwIiwid2l0aENyZWRlbnRpYWxzIiwic2V0UmVxdWVzdEhlYWRlciIsInNlbmQiLCJUcmFuc3BvcnQiLCJDbGllbnRNZXNzYWdlIiwiaGVhZGVyc18iLCJvcHRfYm9keSIsIkNsaWVudFJlc3BvbnNlIiwiY2xpZW50UmVxdWVzdCIsImNsaWVudFJlcXVlc3RfIiwib3B0X3N0YXR1c0NvZGUiLCJzdGF0dXNDb2RlXyIsIm9wdF9zdGF0dXNUZXh0Iiwic3RhdHVzVGV4dF8iLCJzdGF0dXNDb2RlIiwiQWpheFRyYW5zcG9ydCIsImRlZmVycmVkIiwicGFyYW1zIiwiY2xpZW50UmVzcG9uc2UiLCJyZXNwb25zZVRleHQiLCJzdGF0dXMiLCJzdGF0dXNUZXh0IiwicGFyc2VSZXNwb25zZUhlYWRlcnMiLCJnZXRBbGxSZXNwb25zZUhlYWRlcnMiLCJoZWFkZXIiLCJUcmFuc3BvcnRGYWN0b3J5IiwidHJhbnNwb3J0cyIsIkRFRkFVTFRfVFJBTlNQT1JUX05BTUUiLCJpbXBsZW1lbnRhdGlvbk5hbWUiLCJUcmFuc3BvcnRDbGFzcyIsImluc3RhbmNlXyIsIkNsaWVudFJlcXVlc3QiLCJwYXJhbXNfIiwid2l0aENyZWRlbnRpYWxzXyIsIm9wdF9tZXRob2QiLCJtZXRob2RfIiwiREVGQVVMVF9NRVRIT0QiLCJvcHRfdXJsIiwidXJsXyIsImlvIiwiV2VEZXBsb3kiLCJhdXRoXyIsImpvaW5QYXRocyIsImZvcm1EYXRhXyIsImVuY29kZSIsImlzQ29udGVudFR5cGVKc29uIiwic2VuZEFzeW5jIiwiRm9ybURhdGEiLCJtYXliZVdyYXBXaXRoUXVlcnlfIiwiY29udmVydEJvZHlUb1BhcmFtc18iLCJyZW1vdmVCb2R5IiwiZW5jb2RlUGFyYW1zXyIsInJlc29sdmVBdXRoZW50aWNhdGlvbl8iLCJhcHBlbmQiLCJlbWJvZGllZCIsInVzZSIsImN1c3RvbVRyYW5zcG9ydF8iLCJoYXNUb2tlbiIsImNyZWRlbnRpYWxzIiwiZW5jb2RlU3RyaW5nIiwidHJhbnNwb3J0IiwiaW5zdGFuY2UiLCJnZXREZWZhdWx0IiwiY3JlYXRlQ2xpZW50UmVxdWVzdF8iLCJkZWNvZGUiLCJvcHRfZGF0YVVybCIsInNvY2tldCIsImNsaWVudE1lc3NhZ2UiLCJjb250ZW50VHlwZSIsImRhdGFfIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzVnUEEsSUFBSUEsVUFBVSxFQUFkOztBQUVBLElBQUksT0FBT0MsTUFBUCxLQUFrQixXQUF0QixFQUFtQztTQUMxQkEsTUFBUixHQUFpQkEsTUFBakI7OztBQUdELElBQUksT0FBT0MsUUFBUCxLQUFvQixXQUF4QixFQUFxQztTQUM1QkEsUUFBUixHQUFtQkEsUUFBbkI7Q0FHRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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Y0FBY0QsY0FBY3JGLE9BQWQsR0FBd0JoUSxHQUF4QixDQUE0QixjQUE1QixLQUErQyxFQUFuRTtRQUNPc1YsWUFBWWhtQixPQUFaLENBQW9CLGtCQUFwQixNQUE0QyxDQUFuRDtDQUZEOztBQUtBb2tCLFdBQVNDLEtBQVQsR0FBaUIsSUFBakI7QUFDQUQsV0FBUzdRLFFBQVQsR0FBb0IsRUFBcEI7QUFDQTZRLFdBQVM2QixLQUFULEdBQWlCLElBQWpCO0FBQ0E3QixXQUFTekosUUFBVCxHQUFvQixFQUFwQixDQUVBOztBQzlkQXhjLFFBQVFDLE1BQVIsQ0FBZTZNLE1BQWYsR0FBd0JBLE1BQXhCO0FBQ0E5TSxRQUFRQyxNQUFSLENBQWV1TCxHQUFmLEdBQXFCQSxHQUFyQjtBQUNBeEwsUUFBUUMsTUFBUixDQUFldWEsS0FBZixHQUF1QkEsS0FBdkI7QUFDQXhhLFFBQVFDLE1BQVIsQ0FBZXlNLEtBQWYsR0FBdUJBLEtBQXZCO0FBQ0ExTSxRQUFRQyxNQUFSLENBQWVnbUIsUUFBZixHQUEwQkEsVUFBMUIsQ0FFQSxBQUNBIiwiZmlsZSI6ImFwaS5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcImlvXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcImlvXCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge30sXG4vKioqKioqLyBcdFx0XHRpZDogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4vKioqKioqLyBcdFx0fTtcblxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cblxuXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cblx0LyoqXG5cdCAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG5cdCAqL1xuXG5cdHZhciB1cmwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXHR2YXIgcGFyc2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblx0dmFyIE1hbmFnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcblx0dmFyIGRlYnVnID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKSgnc29ja2V0LmlvLWNsaWVudCcpO1xuXG5cdC8qKlxuXHQgKiBNb2R1bGUgZXhwb3J0cy5cblx0ICovXG5cblx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gbG9va3VwO1xuXG5cdC8qKlxuXHQgKiBNYW5hZ2VycyBjYWNoZS5cblx0ICovXG5cblx0dmFyIGNhY2hlID0gZXhwb3J0cy5tYW5hZ2VycyA9IHt9O1xuXG5cdC8qKlxuXHQgKiBMb29rcyB1cCBhbiBleGlzdGluZyBgTWFuYWdlcmAgZm9yIG11bHRpcGxleGluZy5cblx0ICogSWYgdGhlIHVzZXIgc3VtbW9uczpcblx0ICpcblx0ICogICBgaW8oJ2h0dHA6Ly9sb2NhbGhvc3QvYScpO2Bcblx0ICogICBgaW8oJ2h0dHA6Ly9sb2NhbGhvc3QvYicpO2Bcblx0ICpcblx0ICogV2UgcmV1c2UgdGhlIGV4aXN0aW5nIGluc3RhbmNlIGJhc2VkIG9uIHNhbWUgc2NoZW1lL3BvcnQvaG9zdCxcblx0ICogYW5kIHdlIGluaXRpYWxpemUgc29ja2V0cyBmb3IgZWFjaCBuYW1lc3BhY2UuXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIGxvb2t1cCh1cmksIG9wdHMpIHtcblx0ICBpZiAoKHR5cGVvZiB1cmkgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHVyaSkpID09PSAnb2JqZWN0Jykge1xuXHQgICAgb3B0cyA9IHVyaTtcblx0ICAgIHVyaSA9IHVuZGVmaW5lZDtcblx0ICB9XG5cblx0ICBvcHRzID0gb3B0cyB8fCB7fTtcblxuXHQgIHZhciBwYXJzZWQgPSB1cmwodXJpKTtcblx0ICB2YXIgc291cmNlID0gcGFyc2VkLnNvdXJjZTtcblx0ICB2YXIgaWQgPSBwYXJzZWQuaWQ7XG5cdCAgdmFyIHBhdGggPSBwYXJzZWQucGF0aDtcblx0ICB2YXIgc2FtZU5hbWVzcGFjZSA9IGNhY2hlW2lkXSAmJiBwYXRoIGluIGNhY2hlW2lkXS5uc3BzO1xuXHQgIHZhciBuZXdDb25uZWN0aW9uID0gb3B0cy5mb3JjZU5ldyB8fCBvcHRzWydmb3JjZSBuZXcgY29ubmVjdGlvbiddIHx8IGZhbHNlID09PSBvcHRzLm11bHRpcGxleCB8fCBzYW1lTmFtZXNwYWNlO1xuXG5cdCAgdmFyIGlvO1xuXG5cdCAgaWYgKG5ld0Nvbm5lY3Rpb24pIHtcblx0ICAgIGRlYnVnKCdpZ25vcmluZyBzb2NrZXQgY2FjaGUgZm9yICVzJywgc291cmNlKTtcblx0ICAgIGlvID0gTWFuYWdlcihzb3VyY2UsIG9wdHMpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBpZiAoIWNhY2hlW2lkXSkge1xuXHQgICAgICBkZWJ1ZygnbmV3IGlvIGluc3RhbmNlIGZvciAlcycsIHNvdXJjZSk7XG5cdCAgICAgIGNhY2hlW2lkXSA9IE1hbmFnZXIoc291cmNlLCBvcHRzKTtcblx0ICAgIH1cblx0ICAgIGlvID0gY2FjaGVbaWRdO1xuXHQgIH1cblx0ICBpZiAocGFyc2VkLnF1ZXJ5ICYmICFvcHRzLnF1ZXJ5KSB7XG5cdCAgICBvcHRzLnF1ZXJ5ID0gcGFyc2VkLnF1ZXJ5O1xuXHQgIH0gZWxzZSBpZiAob3B0cyAmJiAnb2JqZWN0JyA9PT0gX3R5cGVvZihvcHRzLnF1ZXJ5KSkge1xuXHQgICAgb3B0cy5xdWVyeSA9IGVuY29kZVF1ZXJ5U3RyaW5nKG9wdHMucXVlcnkpO1xuXHQgIH1cblx0ICByZXR1cm4gaW8uc29ja2V0KHBhcnNlZC5wYXRoLCBvcHRzKTtcblx0fVxuXHQvKipcblx0ICogIEhlbHBlciBtZXRob2QgdG8gcGFyc2UgcXVlcnkgb2JqZWN0cyB0byBzdHJpbmcuXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBxdWVyeVxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfVxuXHQgKi9cblx0ZnVuY3Rpb24gZW5jb2RlUXVlcnlTdHJpbmcob2JqKSB7XG5cdCAgdmFyIHN0ciA9IFtdO1xuXHQgIGZvciAodmFyIHAgaW4gb2JqKSB7XG5cdCAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHApKSB7XG5cdCAgICAgIHN0ci5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChwKSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChvYmpbcF0pKTtcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIHN0ci5qb2luKCcmJyk7XG5cdH1cblx0LyoqXG5cdCAqIFByb3RvY29sIHZlcnNpb24uXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGV4cG9ydHMucHJvdG9jb2wgPSBwYXJzZXIucHJvdG9jb2w7XG5cblx0LyoqXG5cdCAqIGBjb25uZWN0YC5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IHVyaVxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRleHBvcnRzLmNvbm5lY3QgPSBsb29rdXA7XG5cblx0LyoqXG5cdCAqIEV4cG9zZSBjb25zdHJ1Y3RvcnMgZm9yIHN0YW5kYWxvbmUgYnVpbGQuXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGV4cG9ydHMuTWFuYWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuXHRleHBvcnRzLlNvY2tldCA9IF9fd2VicGFja19yZXF1aXJlX18oNDIpO1xuXG4vKioqLyB9LFxuLyogMSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkgeyd1c2Ugc3RyaWN0JztcblxuXHQvKipcblx0ICogTW9kdWxlIGRlcGVuZGVuY2llcy5cblx0ICovXG5cblx0dmFyIHBhcnNldXJpID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblx0dmFyIGRlYnVnID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKSgnc29ja2V0LmlvLWNsaWVudDp1cmwnKTtcblxuXHQvKipcblx0ICogTW9kdWxlIGV4cG9ydHMuXG5cdCAqL1xuXG5cdG1vZHVsZS5leHBvcnRzID0gdXJsO1xuXG5cdC8qKlxuXHQgKiBVUkwgcGFyc2VyLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdXJsXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBBbiBvYmplY3QgbWVhbnQgdG8gbWltaWMgd2luZG93LmxvY2F0aW9uLlxuXHQgKiAgICAgICAgICAgICAgICAgRGVmYXVsdHMgdG8gd2luZG93LmxvY2F0aW9uLlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRmdW5jdGlvbiB1cmwodXJpLCBsb2MpIHtcblx0ICB2YXIgb2JqID0gdXJpO1xuXG5cdCAgLy8gZGVmYXVsdCB0byB3aW5kb3cubG9jYXRpb25cblx0ICBsb2MgPSBsb2MgfHwgZ2xvYmFsLmxvY2F0aW9uO1xuXHQgIGlmIChudWxsID09IHVyaSkgdXJpID0gbG9jLnByb3RvY29sICsgJy8vJyArIGxvYy5ob3N0O1xuXG5cdCAgLy8gcmVsYXRpdmUgcGF0aCBzdXBwb3J0XG5cdCAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgdXJpKSB7XG5cdCAgICBpZiAoJy8nID09PSB1cmkuY2hhckF0KDApKSB7XG5cdCAgICAgIGlmICgnLycgPT09IHVyaS5jaGFyQXQoMSkpIHtcblx0ICAgICAgICB1cmkgPSBsb2MucHJvdG9jb2wgKyB1cmk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdXJpID0gbG9jLmhvc3QgKyB1cmk7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgaWYgKCEvXihodHRwcz98d3NzPyk6XFwvXFwvLy50ZXN0KHVyaSkpIHtcblx0ICAgICAgZGVidWcoJ3Byb3RvY29sLWxlc3MgdXJsICVzJywgdXJpKTtcblx0ICAgICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgbG9jKSB7XG5cdCAgICAgICAgdXJpID0gbG9jLnByb3RvY29sICsgJy8vJyArIHVyaTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICB1cmkgPSAnaHR0cHM6Ly8nICsgdXJpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIC8vIHBhcnNlXG5cdCAgICBkZWJ1ZygncGFyc2UgJXMnLCB1cmkpO1xuXHQgICAgb2JqID0gcGFyc2V1cmkodXJpKTtcblx0ICB9XG5cblx0ICAvLyBtYWtlIHN1cmUgd2UgdHJlYXQgYGxvY2FsaG9zdDo4MGAgYW5kIGBsb2NhbGhvc3RgIGVxdWFsbHlcblx0ICBpZiAoIW9iai5wb3J0KSB7XG5cdCAgICBpZiAoL14oaHR0cHx3cykkLy50ZXN0KG9iai5wcm90b2NvbCkpIHtcblx0ICAgICAgb2JqLnBvcnQgPSAnODAnO1xuXHQgICAgfSBlbHNlIGlmICgvXihodHRwfHdzKXMkLy50ZXN0KG9iai5wcm90b2NvbCkpIHtcblx0ICAgICAgb2JqLnBvcnQgPSAnNDQzJztcblx0ICAgIH1cblx0ICB9XG5cblx0ICBvYmoucGF0aCA9IG9iai5wYXRoIHx8ICcvJztcblxuXHQgIHZhciBpcHY2ID0gb2JqLmhvc3QuaW5kZXhPZignOicpICE9PSAtMTtcblx0ICB2YXIgaG9zdCA9IGlwdjYgPyAnWycgKyBvYmouaG9zdCArICddJyA6IG9iai5ob3N0O1xuXG5cdCAgLy8gZGVmaW5lIHVuaXF1ZSBpZFxuXHQgIG9iai5pZCA9IG9iai5wcm90b2NvbCArICc6Ly8nICsgaG9zdCArICc6JyArIG9iai5wb3J0O1xuXHQgIC8vIGRlZmluZSBocmVmXG5cdCAgb2JqLmhyZWYgPSBvYmoucHJvdG9jb2wgKyAnOi8vJyArIGhvc3QgKyAobG9jICYmIGxvYy5wb3J0ID09PSBvYmoucG9ydCA/ICcnIDogJzonICsgb2JqLnBvcnQpO1xuXG5cdCAgcmV0dXJuIG9iajtcblx0fVxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSgpKSkpXG5cbi8qKiovIH0sXG4vKiAyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQvKipcblx0ICogUGFyc2VzIGFuIFVSSVxuXHQgKlxuXHQgKiBAYXV0aG9yIFN0ZXZlbiBMZXZpdGhhbiA8c3RldmVubGV2aXRoYW4uY29tPiAoTUlUIGxpY2Vuc2UpXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHR2YXIgcmUgPSAvXig/Oig/IVteOkBdKzpbXjpAXFwvXSpAKShodHRwfGh0dHBzfHdzfHdzcyk6XFwvXFwvKT8oKD86KChbXjpAXSopKD86OihbXjpAXSopKT8pP0ApPygoPzpbYS1mMC05XXswLDR9Oil7Miw3fVthLWYwLTldezAsNH18W146XFwvPyNdKikoPzo6KFxcZCopKT8pKCgoXFwvKD86W14/I10oPyFbXj8jXFwvXSpcXC5bXj8jXFwvLl0rKD86Wz8jXXwkKSkpKlxcLz8pPyhbXj8jXFwvXSopKSg/OlxcPyhbXiNdKikpPyg/OiMoLiopKT8pLztcblxuXHR2YXIgcGFydHMgPSBbXG5cdCAgICAnc291cmNlJywgJ3Byb3RvY29sJywgJ2F1dGhvcml0eScsICd1c2VySW5mbycsICd1c2VyJywgJ3Bhc3N3b3JkJywgJ2hvc3QnLCAncG9ydCcsICdyZWxhdGl2ZScsICdwYXRoJywgJ2RpcmVjdG9yeScsICdmaWxlJywgJ3F1ZXJ5JywgJ2FuY2hvcidcblx0XTtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNldXJpKHN0cikge1xuXHQgICAgdmFyIHNyYyA9IHN0cixcblx0ICAgICAgICBiID0gc3RyLmluZGV4T2YoJ1snKSxcblx0ICAgICAgICBlID0gc3RyLmluZGV4T2YoJ10nKTtcblxuXHQgICAgaWYgKGIgIT0gLTEgJiYgZSAhPSAtMSkge1xuXHQgICAgICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgYikgKyBzdHIuc3Vic3RyaW5nKGIsIGUpLnJlcGxhY2UoLzovZywgJzsnKSArIHN0ci5zdWJzdHJpbmcoZSwgc3RyLmxlbmd0aCk7XG5cdCAgICB9XG5cblx0ICAgIHZhciBtID0gcmUuZXhlYyhzdHIgfHwgJycpLFxuXHQgICAgICAgIHVyaSA9IHt9LFxuXHQgICAgICAgIGkgPSAxNDtcblxuXHQgICAgd2hpbGUgKGktLSkge1xuXHQgICAgICAgIHVyaVtwYXJ0c1tpXV0gPSBtW2ldIHx8ICcnO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoYiAhPSAtMSAmJiBlICE9IC0xKSB7XG5cdCAgICAgICAgdXJpLnNvdXJjZSA9IHNyYztcblx0ICAgICAgICB1cmkuaG9zdCA9IHVyaS5ob3N0LnN1YnN0cmluZygxLCB1cmkuaG9zdC5sZW5ndGggLSAxKS5yZXBsYWNlKC87L2csICc6Jyk7XG5cdCAgICAgICAgdXJpLmF1dGhvcml0eSA9IHVyaS5hdXRob3JpdHkucmVwbGFjZSgnWycsICcnKS5yZXBsYWNlKCddJywgJycpLnJlcGxhY2UoLzsvZywgJzonKTtcblx0ICAgICAgICB1cmkuaXB2NnVyaSA9IHRydWU7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB1cmk7XG5cdH07XG5cblxuLyoqKi8gfSxcbi8qIDMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdFxuXHQvKipcblx0ICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuXHQgKlxuXHQgKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG5cdCAqL1xuXG5cdGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cdGV4cG9ydHMubG9nID0gbG9nO1xuXHRleHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuXHRleHBvcnRzLnNhdmUgPSBzYXZlO1xuXHRleHBvcnRzLmxvYWQgPSBsb2FkO1xuXHRleHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcblx0ZXhwb3J0cy5zdG9yYWdlID0gJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZVxuXHQgICAgICAgICAgICAgICAmJiAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lLnN0b3JhZ2Vcblx0ICAgICAgICAgICAgICAgICAgPyBjaHJvbWUuc3RvcmFnZS5sb2NhbFxuXHQgICAgICAgICAgICAgICAgICA6IGxvY2Fsc3RvcmFnZSgpO1xuXG5cdC8qKlxuXHQgKiBDb2xvcnMuXG5cdCAqL1xuXG5cdGV4cG9ydHMuY29sb3JzID0gW1xuXHQgICdsaWdodHNlYWdyZWVuJyxcblx0ICAnZm9yZXN0Z3JlZW4nLFxuXHQgICdnb2xkZW5yb2QnLFxuXHQgICdkb2RnZXJibHVlJyxcblx0ICAnZGFya29yY2hpZCcsXG5cdCAgJ2NyaW1zb24nXG5cdF07XG5cblx0LyoqXG5cdCAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG5cdCAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuXHQgKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG5cdCAqXG5cdCAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcblx0ICAvLyBpcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuXHQgIHJldHVybiAoJ1dlYmtpdEFwcGVhcmFuY2UnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSkgfHxcblx0ICAgIC8vIGlzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcblx0ICAgICh3aW5kb3cuY29uc29sZSAmJiAoY29uc29sZS5maXJlYnVnIHx8IChjb25zb2xlLmV4Y2VwdGlvbiAmJiBjb25zb2xlLnRhYmxlKSkpIHx8XG5cdCAgICAvLyBpcyBmaXJlZm94ID49IHYzMT9cblx0ICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuXHQgICAgKG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG5cdCAqL1xuXG5cdGV4cG9ydHMuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24odikge1xuXHQgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIGZvcm1hdEFyZ3MoKSB7XG5cdCAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG5cdCAgdmFyIHVzZUNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXG5cdCAgYXJnc1swXSA9ICh1c2VDb2xvcnMgPyAnJWMnIDogJycpXG5cdCAgICArIHRoaXMubmFtZXNwYWNlXG5cdCAgICArICh1c2VDb2xvcnMgPyAnICVjJyA6ICcgJylcblx0ICAgICsgYXJnc1swXVxuXHQgICAgKyAodXNlQ29sb3JzID8gJyVjICcgOiAnICcpXG5cdCAgICArICcrJyArIGV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuXHQgIGlmICghdXNlQ29sb3JzKSByZXR1cm4gYXJncztcblxuXHQgIHZhciBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcblx0ICBhcmdzID0gW2FyZ3NbMF0sIGMsICdjb2xvcjogaW5oZXJpdCddLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzLCAxKSk7XG5cblx0ICAvLyB0aGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuXHQgIC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cblx0ICAvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cblx0ICB2YXIgaW5kZXggPSAwO1xuXHQgIHZhciBsYXN0QyA9IDA7XG5cdCAgYXJnc1swXS5yZXBsYWNlKC8lW2EteiVdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG5cdCAgICBpZiAoJyUlJyA9PT0gbWF0Y2gpIHJldHVybjtcblx0ICAgIGluZGV4Kys7XG5cdCAgICBpZiAoJyVjJyA9PT0gbWF0Y2gpIHtcblx0ICAgICAgLy8gd2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG5cdCAgICAgIC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG5cdCAgICAgIGxhc3RDID0gaW5kZXg7XG5cdCAgICB9XG5cdCAgfSk7XG5cblx0ICBhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG5cdCAgcmV0dXJuIGFyZ3M7XG5cdH1cblxuXHQvKipcblx0ICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXG5cdCAqIE5vLW9wIHdoZW4gYGNvbnNvbGUubG9nYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIGxvZygpIHtcblx0ICAvLyB0aGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOC85LCB3aGVyZVxuXHQgIC8vIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uIGRvZXNuJ3QgaGF2ZSAnYXBwbHknXG5cdCAgcmV0dXJuICdvYmplY3QnID09PSB0eXBlb2YgY29uc29sZVxuXHQgICAgJiYgY29uc29sZS5sb2dcblx0ICAgICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlLCBhcmd1bWVudHMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0ZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG5cdCAgdHJ5IHtcblx0ICAgIGlmIChudWxsID09IG5hbWVzcGFjZXMpIHtcblx0ICAgICAgZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBleHBvcnRzLnN0b3JhZ2UuZGVidWcgPSBuYW1lc3BhY2VzO1xuXHQgICAgfVxuXHQgIH0gY2F0Y2goZSkge31cblx0fVxuXG5cdC8qKlxuXHQgKiBMb2FkIGBuYW1lc3BhY2VzYC5cblx0ICpcblx0ICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0ZnVuY3Rpb24gbG9hZCgpIHtcblx0ICB2YXIgcjtcblx0ICB0cnkge1xuXHQgICAgciA9IGV4cG9ydHMuc3RvcmFnZS5kZWJ1Zztcblx0ICB9IGNhdGNoKGUpIHt9XG5cdCAgcmV0dXJuIHI7XG5cdH1cblxuXHQvKipcblx0ICogRW5hYmxlIG5hbWVzcGFjZXMgbGlzdGVkIGluIGBsb2NhbFN0b3JhZ2UuZGVidWdgIGluaXRpYWxseS5cblx0ICovXG5cblx0ZXhwb3J0cy5lbmFibGUobG9hZCgpKTtcblxuXHQvKipcblx0ICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuXHQgKlxuXHQgKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3Ncblx0ICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2Vcblx0ICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cblx0ICpcblx0ICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0ZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCl7XG5cdCAgdHJ5IHtcblx0ICAgIHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlO1xuXHQgIH0gY2F0Y2ggKGUpIHt9XG5cdH1cblxuXG4vKioqLyB9LFxuLyogNCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XG5cdC8qKlxuXHQgKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG5cdCAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG5cdCAqXG5cdCAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cblx0ICovXG5cblx0ZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZGVidWc7XG5cdGV4cG9ydHMuY29lcmNlID0gY29lcmNlO1xuXHRleHBvcnRzLmRpc2FibGUgPSBkaXNhYmxlO1xuXHRleHBvcnRzLmVuYWJsZSA9IGVuYWJsZTtcblx0ZXhwb3J0cy5lbmFibGVkID0gZW5hYmxlZDtcblx0ZXhwb3J0cy5odW1hbml6ZSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cblx0LyoqXG5cdCAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuXHQgKi9cblxuXHRleHBvcnRzLm5hbWVzID0gW107XG5cdGV4cG9ydHMuc2tpcHMgPSBbXTtcblxuXHQvKipcblx0ICogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuXHQgKlxuXHQgKiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlcmNhc2VkIGxldHRlciwgaS5lLiBcIm5cIi5cblx0ICovXG5cblx0ZXhwb3J0cy5mb3JtYXR0ZXJzID0ge307XG5cblx0LyoqXG5cdCAqIFByZXZpb3VzbHkgYXNzaWduZWQgY29sb3IuXG5cdCAqL1xuXG5cdHZhciBwcmV2Q29sb3IgPSAwO1xuXG5cdC8qKlxuXHQgKiBQcmV2aW91cyBsb2cgdGltZXN0YW1wLlxuXHQgKi9cblxuXHR2YXIgcHJldlRpbWU7XG5cblx0LyoqXG5cdCAqIFNlbGVjdCBhIGNvbG9yLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRmdW5jdGlvbiBzZWxlY3RDb2xvcigpIHtcblx0ICByZXR1cm4gZXhwb3J0cy5jb2xvcnNbcHJldkNvbG9yKysgJSBleHBvcnRzLmNvbG9ycy5sZW5ndGhdO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRmdW5jdGlvbiBkZWJ1ZyhuYW1lc3BhY2UpIHtcblxuXHQgIC8vIGRlZmluZSB0aGUgYGRpc2FibGVkYCB2ZXJzaW9uXG5cdCAgZnVuY3Rpb24gZGlzYWJsZWQoKSB7XG5cdCAgfVxuXHQgIGRpc2FibGVkLmVuYWJsZWQgPSBmYWxzZTtcblxuXHQgIC8vIGRlZmluZSB0aGUgYGVuYWJsZWRgIHZlcnNpb25cblx0ICBmdW5jdGlvbiBlbmFibGVkKCkge1xuXG5cdCAgICB2YXIgc2VsZiA9IGVuYWJsZWQ7XG5cblx0ICAgIC8vIHNldCBgZGlmZmAgdGltZXN0YW1wXG5cdCAgICB2YXIgY3VyciA9ICtuZXcgRGF0ZSgpO1xuXHQgICAgdmFyIG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcblx0ICAgIHNlbGYuZGlmZiA9IG1zO1xuXHQgICAgc2VsZi5wcmV2ID0gcHJldlRpbWU7XG5cdCAgICBzZWxmLmN1cnIgPSBjdXJyO1xuXHQgICAgcHJldlRpbWUgPSBjdXJyO1xuXG5cdCAgICAvLyBhZGQgdGhlIGBjb2xvcmAgaWYgbm90IHNldFxuXHQgICAgaWYgKG51bGwgPT0gc2VsZi51c2VDb2xvcnMpIHNlbGYudXNlQ29sb3JzID0gZXhwb3J0cy51c2VDb2xvcnMoKTtcblx0ICAgIGlmIChudWxsID09IHNlbGYuY29sb3IgJiYgc2VsZi51c2VDb2xvcnMpIHNlbGYuY29sb3IgPSBzZWxlY3RDb2xvcigpO1xuXG5cdCAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cblx0ICAgIGFyZ3NbMF0gPSBleHBvcnRzLmNvZXJjZShhcmdzWzBdKTtcblxuXHQgICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgYXJnc1swXSkge1xuXHQgICAgICAvLyBhbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlb1xuXHQgICAgICBhcmdzID0gWyclbyddLmNvbmNhdChhcmdzKTtcblx0ICAgIH1cblxuXHQgICAgLy8gYXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcblx0ICAgIHZhciBpbmRleCA9IDA7XG5cdCAgICBhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXolXSkvZywgZnVuY3Rpb24obWF0Y2gsIGZvcm1hdCkge1xuXHQgICAgICAvLyBpZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG5cdCAgICAgIGlmIChtYXRjaCA9PT0gJyUlJykgcmV0dXJuIG1hdGNoO1xuXHQgICAgICBpbmRleCsrO1xuXHQgICAgICB2YXIgZm9ybWF0dGVyID0gZXhwb3J0cy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG5cdCAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZm9ybWF0dGVyKSB7XG5cdCAgICAgICAgdmFyIHZhbCA9IGFyZ3NbaW5kZXhdO1xuXHQgICAgICAgIG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuXHQgICAgICAgIC8vIG5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcblx0ICAgICAgICBhcmdzLnNwbGljZShpbmRleCwgMSk7XG5cdCAgICAgICAgaW5kZXgtLTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gbWF0Y2g7XG5cdCAgICB9KTtcblxuXHQgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBleHBvcnRzLmZvcm1hdEFyZ3MpIHtcblx0ICAgICAgYXJncyA9IGV4cG9ydHMuZm9ybWF0QXJncy5hcHBseShzZWxmLCBhcmdzKTtcblx0ICAgIH1cblx0ICAgIHZhciBsb2dGbiA9IGVuYWJsZWQubG9nIHx8IGV4cG9ydHMubG9nIHx8IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG5cdCAgICBsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcblx0ICB9XG5cdCAgZW5hYmxlZC5lbmFibGVkID0gdHJ1ZTtcblxuXHQgIHZhciBmbiA9IGV4cG9ydHMuZW5hYmxlZChuYW1lc3BhY2UpID8gZW5hYmxlZCA6IGRpc2FibGVkO1xuXG5cdCAgZm4ubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuXG5cdCAgcmV0dXJuIGZuO1xuXHR9XG5cblx0LyoqXG5cdCAqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcblx0ICogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcblx0ICBleHBvcnRzLnNhdmUobmFtZXNwYWNlcyk7XG5cblx0ICB2YXIgc3BsaXQgPSAobmFtZXNwYWNlcyB8fCAnJykuc3BsaXQoL1tcXHMsXSsvKTtcblx0ICB2YXIgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHQgICAgaWYgKCFzcGxpdFtpXSkgY29udGludWU7IC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG5cdCAgICBuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcblx0ICAgIGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcblx0ICAgICAgZXhwb3J0cy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zdWJzdHIoMSkgKyAnJCcpKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGV4cG9ydHMubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcblx0ICAgIH1cblx0ICB9XG5cdH1cblxuXHQvKipcblx0ICogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIGRpc2FibGUoKSB7XG5cdCAgZXhwb3J0cy5lbmFibGUoJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG5cdCAgdmFyIGksIGxlbjtcblx0ICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdCAgICBpZiAoZXhwb3J0cy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG5cdCAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIH1cblx0ICB9XG5cdCAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHQgICAgaWYgKGV4cG9ydHMubmFtZXNbaV0udGVzdChuYW1lKSkge1xuXHQgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvZXJjZSBgdmFsYC5cblx0ICpcblx0ICogQHBhcmFtIHtNaXhlZH0gdmFsXG5cdCAqIEByZXR1cm4ge01peGVkfVxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0ZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuXHQgIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikgcmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcblx0ICByZXR1cm4gdmFsO1xuXHR9XG5cblxuLyoqKi8gfSxcbi8qIDUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdC8qKlxuXHQgKiBIZWxwZXJzLlxuXHQgKi9cblxuXHR2YXIgcyA9IDEwMDA7XG5cdHZhciBtID0gcyAqIDYwO1xuXHR2YXIgaCA9IG0gKiA2MDtcblx0dmFyIGQgPSBoICogMjQ7XG5cdHZhciB5ID0gZCAqIDM2NS4yNTtcblxuXHQvKipcblx0ICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cblx0ICpcblx0ICogT3B0aW9uczpcblx0ICpcblx0ICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG5cdCAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKXtcblx0ICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0ICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIHZhbCkgcmV0dXJuIHBhcnNlKHZhbCk7XG5cdCAgcmV0dXJuIG9wdGlvbnMubG9uZ1xuXHQgICAgPyBsb25nKHZhbClcblx0ICAgIDogc2hvcnQodmFsKTtcblx0fTtcblxuXHQvKipcblx0ICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIHBhcnNlKHN0cikge1xuXHQgIHN0ciA9ICcnICsgc3RyO1xuXHQgIGlmIChzdHIubGVuZ3RoID4gMTAwMDApIHJldHVybjtcblx0ICB2YXIgbWF0Y2ggPSAvXigoPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKHN0cik7XG5cdCAgaWYgKCFtYXRjaCkgcmV0dXJuO1xuXHQgIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG5cdCAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcblx0ICBzd2l0Y2ggKHR5cGUpIHtcblx0ICAgIGNhc2UgJ3llYXJzJzpcblx0ICAgIGNhc2UgJ3llYXInOlxuXHQgICAgY2FzZSAneXJzJzpcblx0ICAgIGNhc2UgJ3lyJzpcblx0ICAgIGNhc2UgJ3knOlxuXHQgICAgICByZXR1cm4gbiAqIHk7XG5cdCAgICBjYXNlICdkYXlzJzpcblx0ICAgIGNhc2UgJ2RheSc6XG5cdCAgICBjYXNlICdkJzpcblx0ICAgICAgcmV0dXJuIG4gKiBkO1xuXHQgICAgY2FzZSAnaG91cnMnOlxuXHQgICAgY2FzZSAnaG91cic6XG5cdCAgICBjYXNlICdocnMnOlxuXHQgICAgY2FzZSAnaHInOlxuXHQgICAgY2FzZSAnaCc6XG5cdCAgICAgIHJldHVybiBuICogaDtcblx0ICAgIGNhc2UgJ21pbnV0ZXMnOlxuXHQgICAgY2FzZSAnbWludXRlJzpcblx0ICAgIGNhc2UgJ21pbnMnOlxuXHQgICAgY2FzZSAnbWluJzpcblx0ICAgIGNhc2UgJ20nOlxuXHQgICAgICByZXR1cm4gbiAqIG07XG5cdCAgICBjYXNlICdzZWNvbmRzJzpcblx0ICAgIGNhc2UgJ3NlY29uZCc6XG5cdCAgICBjYXNlICdzZWNzJzpcblx0ICAgIGNhc2UgJ3NlYyc6XG5cdCAgICBjYXNlICdzJzpcblx0ICAgICAgcmV0dXJuIG4gKiBzO1xuXHQgICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcblx0ICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcblx0ICAgIGNhc2UgJ21zZWNzJzpcblx0ICAgIGNhc2UgJ21zZWMnOlxuXHQgICAgY2FzZSAnbXMnOlxuXHQgICAgICByZXR1cm4gbjtcblx0ICB9XG5cdH1cblxuXHQvKipcblx0ICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuXHQgKlxuXHQgKiBAcGFyYW0ge051bWJlcn0gbXNcblx0ICogQHJldHVybiB7U3RyaW5nfVxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0ZnVuY3Rpb24gc2hvcnQobXMpIHtcblx0ICBpZiAobXMgPj0gZCkgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcblx0ICBpZiAobXMgPj0gaCkgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcblx0ICBpZiAobXMgPj0gbSkgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcblx0ICBpZiAobXMgPj0gcykgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcblx0ICByZXR1cm4gbXMgKyAnbXMnO1xuXHR9XG5cblx0LyoqXG5cdCAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuXHQgKlxuXHQgKiBAcGFyYW0ge051bWJlcn0gbXNcblx0ICogQHJldHVybiB7U3RyaW5nfVxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0ZnVuY3Rpb24gbG9uZyhtcykge1xuXHQgIHJldHVybiBwbHVyYWwobXMsIGQsICdkYXknKVxuXHQgICAgfHwgcGx1cmFsKG1zLCBoLCAnaG91cicpXG5cdCAgICB8fCBwbHVyYWwobXMsIG0sICdtaW51dGUnKVxuXHQgICAgfHwgcGx1cmFsKG1zLCBzLCAnc2Vjb25kJylcblx0ICAgIHx8IG1zICsgJyBtcyc7XG5cdH1cblxuXHQvKipcblx0ICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIHBsdXJhbChtcywgbiwgbmFtZSkge1xuXHQgIGlmIChtcyA8IG4pIHJldHVybjtcblx0ICBpZiAobXMgPCBuICogMS41KSByZXR1cm4gTWF0aC5mbG9vcihtcyAvIG4pICsgJyAnICsgbmFtZTtcblx0ICByZXR1cm4gTWF0aC5jZWlsKG1zIC8gbikgKyAnICcgKyBuYW1lICsgJ3MnO1xuXHR9XG5cblxuLyoqKi8gfSxcbi8qIDYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdFxuXHQvKipcblx0ICogTW9kdWxlIGRlcGVuZGVuY2llcy5cblx0ICovXG5cblx0dmFyIGRlYnVnID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKSgnc29ja2V0LmlvLXBhcnNlcicpO1xuXHR2YXIganNvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cdHZhciBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG5cdHZhciBFbWl0dGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cdHZhciBiaW5hcnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcblx0dmFyIGlzQnVmID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG5cblx0LyoqXG5cdCAqIFByb3RvY29sIHZlcnNpb24uXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGV4cG9ydHMucHJvdG9jb2wgPSA0O1xuXG5cdC8qKlxuXHQgKiBQYWNrZXQgdHlwZXMuXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGV4cG9ydHMudHlwZXMgPSBbXG5cdCAgJ0NPTk5FQ1QnLFxuXHQgICdESVNDT05ORUNUJyxcblx0ICAnRVZFTlQnLFxuXHQgICdBQ0snLFxuXHQgICdFUlJPUicsXG5cdCAgJ0JJTkFSWV9FVkVOVCcsXG5cdCAgJ0JJTkFSWV9BQ0snXG5cdF07XG5cblx0LyoqXG5cdCAqIFBhY2tldCB0eXBlIGBjb25uZWN0YC5cblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZXhwb3J0cy5DT05ORUNUID0gMDtcblxuXHQvKipcblx0ICogUGFja2V0IHR5cGUgYGRpc2Nvbm5lY3RgLlxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRleHBvcnRzLkRJU0NPTk5FQ1QgPSAxO1xuXG5cdC8qKlxuXHQgKiBQYWNrZXQgdHlwZSBgZXZlbnRgLlxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRleHBvcnRzLkVWRU5UID0gMjtcblxuXHQvKipcblx0ICogUGFja2V0IHR5cGUgYGFja2AuXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGV4cG9ydHMuQUNLID0gMztcblxuXHQvKipcblx0ICogUGFja2V0IHR5cGUgYGVycm9yYC5cblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZXhwb3J0cy5FUlJPUiA9IDQ7XG5cblx0LyoqXG5cdCAqIFBhY2tldCB0eXBlICdiaW5hcnkgZXZlbnQnXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGV4cG9ydHMuQklOQVJZX0VWRU5UID0gNTtcblxuXHQvKipcblx0ICogUGFja2V0IHR5cGUgYGJpbmFyeSBhY2tgLiBGb3IgYWNrcyB3aXRoIGJpbmFyeSBhcmd1bWVudHMuXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGV4cG9ydHMuQklOQVJZX0FDSyA9IDY7XG5cblx0LyoqXG5cdCAqIEVuY29kZXIgY29uc3RydWN0b3IuXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGV4cG9ydHMuRW5jb2RlciA9IEVuY29kZXI7XG5cblx0LyoqXG5cdCAqIERlY29kZXIgY29uc3RydWN0b3IuXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGV4cG9ydHMuRGVjb2RlciA9IERlY29kZXI7XG5cblx0LyoqXG5cdCAqIEEgc29ja2V0LmlvIEVuY29kZXIgaW5zdGFuY2Vcblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZnVuY3Rpb24gRW5jb2RlcigpIHt9XG5cblx0LyoqXG5cdCAqIEVuY29kZSBhIHBhY2tldCBhcyBhIHNpbmdsZSBzdHJpbmcgaWYgbm9uLWJpbmFyeSwgb3IgYXMgYVxuXHQgKiBidWZmZXIgc2VxdWVuY2UsIGRlcGVuZGluZyBvbiBwYWNrZXQgdHlwZS5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIHBhY2tldCBvYmplY3Rcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBmdW5jdGlvbiB0byBoYW5kbGUgZW5jb2RpbmdzIChsaWtlbHkgZW5naW5lLndyaXRlKVxuXHQgKiBAcmV0dXJuIENhbGxzIGNhbGxiYWNrIHdpdGggQXJyYXkgb2YgZW5jb2RpbmdzXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdEVuY29kZXIucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uKG9iaiwgY2FsbGJhY2spe1xuXHQgIGRlYnVnKCdlbmNvZGluZyBwYWNrZXQgJWonLCBvYmopO1xuXG5cdCAgaWYgKGV4cG9ydHMuQklOQVJZX0VWRU5UID09IG9iai50eXBlIHx8IGV4cG9ydHMuQklOQVJZX0FDSyA9PSBvYmoudHlwZSkge1xuXHQgICAgZW5jb2RlQXNCaW5hcnkob2JqLCBjYWxsYmFjayk7XG5cdCAgfVxuXHQgIGVsc2Uge1xuXHQgICAgdmFyIGVuY29kaW5nID0gZW5jb2RlQXNTdHJpbmcob2JqKTtcblx0ICAgIGNhbGxiYWNrKFtlbmNvZGluZ10pO1xuXHQgIH1cblx0fTtcblxuXHQvKipcblx0ICogRW5jb2RlIHBhY2tldCBhcyBzdHJpbmcuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcblx0ICogQHJldHVybiB7U3RyaW5nfSBlbmNvZGVkXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRmdW5jdGlvbiBlbmNvZGVBc1N0cmluZyhvYmopIHtcblx0ICB2YXIgc3RyID0gJyc7XG5cdCAgdmFyIG5zcCA9IGZhbHNlO1xuXG5cdCAgLy8gZmlyc3QgaXMgdHlwZVxuXHQgIHN0ciArPSBvYmoudHlwZTtcblxuXHQgIC8vIGF0dGFjaG1lbnRzIGlmIHdlIGhhdmUgdGhlbVxuXHQgIGlmIChleHBvcnRzLkJJTkFSWV9FVkVOVCA9PSBvYmoudHlwZSB8fCBleHBvcnRzLkJJTkFSWV9BQ0sgPT0gb2JqLnR5cGUpIHtcblx0ICAgIHN0ciArPSBvYmouYXR0YWNobWVudHM7XG5cdCAgICBzdHIgKz0gJy0nO1xuXHQgIH1cblxuXHQgIC8vIGlmIHdlIGhhdmUgYSBuYW1lc3BhY2Ugb3RoZXIgdGhhbiBgL2Bcblx0ICAvLyB3ZSBhcHBlbmQgaXQgZm9sbG93ZWQgYnkgYSBjb21tYSBgLGBcblx0ICBpZiAob2JqLm5zcCAmJiAnLycgIT0gb2JqLm5zcCkge1xuXHQgICAgbnNwID0gdHJ1ZTtcblx0ICAgIHN0ciArPSBvYmoubnNwO1xuXHQgIH1cblxuXHQgIC8vIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IHRoZSBpZFxuXHQgIGlmIChudWxsICE9IG9iai5pZCkge1xuXHQgICAgaWYgKG5zcCkge1xuXHQgICAgICBzdHIgKz0gJywnO1xuXHQgICAgICBuc3AgPSBmYWxzZTtcblx0ICAgIH1cblx0ICAgIHN0ciArPSBvYmouaWQ7XG5cdCAgfVxuXG5cdCAgLy8ganNvbiBkYXRhXG5cdCAgaWYgKG51bGwgIT0gb2JqLmRhdGEpIHtcblx0ICAgIGlmIChuc3ApIHN0ciArPSAnLCc7XG5cdCAgICBzdHIgKz0ganNvbi5zdHJpbmdpZnkob2JqLmRhdGEpO1xuXHQgIH1cblxuXHQgIGRlYnVnKCdlbmNvZGVkICVqIGFzICVzJywgb2JqLCBzdHIpO1xuXHQgIHJldHVybiBzdHI7XG5cdH1cblxuXHQvKipcblx0ICogRW5jb2RlIHBhY2tldCBhcyAnYnVmZmVyIHNlcXVlbmNlJyBieSByZW1vdmluZyBibG9icywgYW5kXG5cdCAqIGRlY29uc3RydWN0aW5nIHBhY2tldCBpbnRvIG9iamVjdCB3aXRoIHBsYWNlaG9sZGVycyBhbmRcblx0ICogYSBsaXN0IG9mIGJ1ZmZlcnMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcblx0ICogQHJldHVybiB7QnVmZmVyfSBlbmNvZGVkXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRmdW5jdGlvbiBlbmNvZGVBc0JpbmFyeShvYmosIGNhbGxiYWNrKSB7XG5cblx0ICBmdW5jdGlvbiB3cml0ZUVuY29kaW5nKGJsb2JsZXNzRGF0YSkge1xuXHQgICAgdmFyIGRlY29uc3RydWN0aW9uID0gYmluYXJ5LmRlY29uc3RydWN0UGFja2V0KGJsb2JsZXNzRGF0YSk7XG5cdCAgICB2YXIgcGFjayA9IGVuY29kZUFzU3RyaW5nKGRlY29uc3RydWN0aW9uLnBhY2tldCk7XG5cdCAgICB2YXIgYnVmZmVycyA9IGRlY29uc3RydWN0aW9uLmJ1ZmZlcnM7XG5cblx0ICAgIGJ1ZmZlcnMudW5zaGlmdChwYWNrKTsgLy8gYWRkIHBhY2tldCBpbmZvIHRvIGJlZ2lubmluZyBvZiBkYXRhIGxpc3Rcblx0ICAgIGNhbGxiYWNrKGJ1ZmZlcnMpOyAvLyB3cml0ZSBhbGwgdGhlIGJ1ZmZlcnNcblx0ICB9XG5cblx0ICBiaW5hcnkucmVtb3ZlQmxvYnMob2JqLCB3cml0ZUVuY29kaW5nKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIHNvY2tldC5pbyBEZWNvZGVyIGluc3RhbmNlXG5cdCAqXG5cdCAqIEByZXR1cm4ge09iamVjdH0gZGVjb2RlclxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRmdW5jdGlvbiBEZWNvZGVyKCkge1xuXHQgIHRoaXMucmVjb25zdHJ1Y3RvciA9IG51bGw7XG5cdH1cblxuXHQvKipcblx0ICogTWl4IGluIGBFbWl0dGVyYCB3aXRoIERlY29kZXIuXG5cdCAqL1xuXG5cdEVtaXR0ZXIoRGVjb2Rlci5wcm90b3R5cGUpO1xuXG5cdC8qKlxuXHQgKiBEZWNvZGVzIGFuIGVjb2RlZCBwYWNrZXQgc3RyaW5nIGludG8gcGFja2V0IEpTT04uXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBvYmogLSBlbmNvZGVkIHBhY2tldFxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IHBhY2tldFxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHREZWNvZGVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihvYmopIHtcblx0ICB2YXIgcGFja2V0O1xuXHQgIGlmICgnc3RyaW5nJyA9PSB0eXBlb2Ygb2JqKSB7XG5cdCAgICBwYWNrZXQgPSBkZWNvZGVTdHJpbmcob2JqKTtcblx0ICAgIGlmIChleHBvcnRzLkJJTkFSWV9FVkVOVCA9PSBwYWNrZXQudHlwZSB8fCBleHBvcnRzLkJJTkFSWV9BQ0sgPT0gcGFja2V0LnR5cGUpIHsgLy8gYmluYXJ5IHBhY2tldCdzIGpzb25cblx0ICAgICAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbmV3IEJpbmFyeVJlY29uc3RydWN0b3IocGFja2V0KTtcblxuXHQgICAgICAvLyBubyBhdHRhY2htZW50cywgbGFiZWxlZCBiaW5hcnkgYnV0IG5vIGJpbmFyeSBkYXRhIHRvIGZvbGxvd1xuXHQgICAgICBpZiAodGhpcy5yZWNvbnN0cnVjdG9yLnJlY29uUGFjay5hdHRhY2htZW50cyA9PT0gMCkge1xuXHQgICAgICAgIHRoaXMuZW1pdCgnZGVjb2RlZCcsIHBhY2tldCk7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSB7IC8vIG5vbi1iaW5hcnkgZnVsbCBwYWNrZXRcblx0ICAgICAgdGhpcy5lbWl0KCdkZWNvZGVkJywgcGFja2V0KTtcblx0ICAgIH1cblx0ICB9XG5cdCAgZWxzZSBpZiAoaXNCdWYob2JqKSB8fCBvYmouYmFzZTY0KSB7IC8vIHJhdyBiaW5hcnkgZGF0YVxuXHQgICAgaWYgKCF0aGlzLnJlY29uc3RydWN0b3IpIHtcblx0ICAgICAgdGhyb3cgbmV3IEVycm9yKCdnb3QgYmluYXJ5IGRhdGEgd2hlbiBub3QgcmVjb25zdHJ1Y3RpbmcgYSBwYWNrZXQnKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHBhY2tldCA9IHRoaXMucmVjb25zdHJ1Y3Rvci50YWtlQmluYXJ5RGF0YShvYmopO1xuXHQgICAgICBpZiAocGFja2V0KSB7IC8vIHJlY2VpdmVkIGZpbmFsIGJ1ZmZlclxuXHQgICAgICAgIHRoaXMucmVjb25zdHJ1Y3RvciA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5lbWl0KCdkZWNvZGVkJywgcGFja2V0KTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblx0ICBlbHNlIHtcblx0ICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biB0eXBlOiAnICsgb2JqKTtcblx0ICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIERlY29kZSBhIHBhY2tldCBTdHJpbmcgKEpTT04gZGF0YSlcblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0clxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IHBhY2tldFxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0ZnVuY3Rpb24gZGVjb2RlU3RyaW5nKHN0cikge1xuXHQgIHZhciBwID0ge307XG5cdCAgdmFyIGkgPSAwO1xuXG5cdCAgLy8gbG9vayB1cCB0eXBlXG5cdCAgcC50eXBlID0gTnVtYmVyKHN0ci5jaGFyQXQoMCkpO1xuXHQgIGlmIChudWxsID09IGV4cG9ydHMudHlwZXNbcC50eXBlXSkgcmV0dXJuIGVycm9yKCk7XG5cblx0ICAvLyBsb29rIHVwIGF0dGFjaG1lbnRzIGlmIHR5cGUgYmluYXJ5XG5cdCAgaWYgKGV4cG9ydHMuQklOQVJZX0VWRU5UID09IHAudHlwZSB8fCBleHBvcnRzLkJJTkFSWV9BQ0sgPT0gcC50eXBlKSB7XG5cdCAgICB2YXIgYnVmID0gJyc7XG5cdCAgICB3aGlsZSAoc3RyLmNoYXJBdCgrK2kpICE9ICctJykge1xuXHQgICAgICBidWYgKz0gc3RyLmNoYXJBdChpKTtcblx0ICAgICAgaWYgKGkgPT0gc3RyLmxlbmd0aCkgYnJlYWs7XG5cdCAgICB9XG5cdCAgICBpZiAoYnVmICE9IE51bWJlcihidWYpIHx8IHN0ci5jaGFyQXQoaSkgIT0gJy0nKSB7XG5cdCAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBhdHRhY2htZW50cycpO1xuXHQgICAgfVxuXHQgICAgcC5hdHRhY2htZW50cyA9IE51bWJlcihidWYpO1xuXHQgIH1cblxuXHQgIC8vIGxvb2sgdXAgbmFtZXNwYWNlIChpZiBhbnkpXG5cdCAgaWYgKCcvJyA9PSBzdHIuY2hhckF0KGkgKyAxKSkge1xuXHQgICAgcC5uc3AgPSAnJztcblx0ICAgIHdoaWxlICgrK2kpIHtcblx0ICAgICAgdmFyIGMgPSBzdHIuY2hhckF0KGkpO1xuXHQgICAgICBpZiAoJywnID09IGMpIGJyZWFrO1xuXHQgICAgICBwLm5zcCArPSBjO1xuXHQgICAgICBpZiAoaSA9PSBzdHIubGVuZ3RoKSBicmVhaztcblx0ICAgIH1cblx0ICB9IGVsc2Uge1xuXHQgICAgcC5uc3AgPSAnLyc7XG5cdCAgfVxuXG5cdCAgLy8gbG9vayB1cCBpZFxuXHQgIHZhciBuZXh0ID0gc3RyLmNoYXJBdChpICsgMSk7XG5cdCAgaWYgKCcnICE9PSBuZXh0ICYmIE51bWJlcihuZXh0KSA9PSBuZXh0KSB7XG5cdCAgICBwLmlkID0gJyc7XG5cdCAgICB3aGlsZSAoKytpKSB7XG5cdCAgICAgIHZhciBjID0gc3RyLmNoYXJBdChpKTtcblx0ICAgICAgaWYgKG51bGwgPT0gYyB8fCBOdW1iZXIoYykgIT0gYykge1xuXHQgICAgICAgIC0taTtcblx0ICAgICAgICBicmVhaztcblx0ICAgICAgfVxuXHQgICAgICBwLmlkICs9IHN0ci5jaGFyQXQoaSk7XG5cdCAgICAgIGlmIChpID09IHN0ci5sZW5ndGgpIGJyZWFrO1xuXHQgICAgfVxuXHQgICAgcC5pZCA9IE51bWJlcihwLmlkKTtcblx0ICB9XG5cblx0ICAvLyBsb29rIHVwIGpzb24gZGF0YVxuXHQgIGlmIChzdHIuY2hhckF0KCsraSkpIHtcblx0ICAgIHRyeSB7XG5cdCAgICAgIHAuZGF0YSA9IGpzb24ucGFyc2Uoc3RyLnN1YnN0cihpKSk7XG5cdCAgICB9IGNhdGNoKGUpe1xuXHQgICAgICByZXR1cm4gZXJyb3IoKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBkZWJ1ZygnZGVjb2RlZCAlcyBhcyAlaicsIHN0ciwgcCk7XG5cdCAgcmV0dXJuIHA7XG5cdH1cblxuXHQvKipcblx0ICogRGVhbGxvY2F0ZXMgYSBwYXJzZXIncyByZXNvdXJjZXNcblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0RGVjb2Rlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuXHQgIGlmICh0aGlzLnJlY29uc3RydWN0b3IpIHtcblx0ICAgIHRoaXMucmVjb25zdHJ1Y3Rvci5maW5pc2hlZFJlY29uc3RydWN0aW9uKCk7XG5cdCAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBBIG1hbmFnZXIgb2YgYSBiaW5hcnkgZXZlbnQncyAnYnVmZmVyIHNlcXVlbmNlJy4gU2hvdWxkXG5cdCAqIGJlIGNvbnN0cnVjdGVkIHdoZW5ldmVyIGEgcGFja2V0IG9mIHR5cGUgQklOQVJZX0VWRU5UIGlzXG5cdCAqIGRlY29kZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcblx0ICogQHJldHVybiB7QmluYXJ5UmVjb25zdHJ1Y3Rvcn0gaW5pdGlhbGl6ZWQgcmVjb25zdHJ1Y3RvclxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0ZnVuY3Rpb24gQmluYXJ5UmVjb25zdHJ1Y3RvcihwYWNrZXQpIHtcblx0ICB0aGlzLnJlY29uUGFjayA9IHBhY2tldDtcblx0ICB0aGlzLmJ1ZmZlcnMgPSBbXTtcblx0fVxuXG5cdC8qKlxuXHQgKiBNZXRob2QgdG8gYmUgY2FsbGVkIHdoZW4gYmluYXJ5IGRhdGEgcmVjZWl2ZWQgZnJvbSBjb25uZWN0aW9uXG5cdCAqIGFmdGVyIGEgQklOQVJZX0VWRU5UIHBhY2tldC5cblx0ICpcblx0ICogQHBhcmFtIHtCdWZmZXIgfCBBcnJheUJ1ZmZlcn0gYmluRGF0YSAtIHRoZSByYXcgYmluYXJ5IGRhdGEgcmVjZWl2ZWRcblx0ICogQHJldHVybiB7bnVsbCB8IE9iamVjdH0gcmV0dXJucyBudWxsIGlmIG1vcmUgYmluYXJ5IGRhdGEgaXMgZXhwZWN0ZWQgb3Jcblx0ICogICBhIHJlY29uc3RydWN0ZWQgcGFja2V0IG9iamVjdCBpZiBhbGwgYnVmZmVycyBoYXZlIGJlZW4gcmVjZWl2ZWQuXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRCaW5hcnlSZWNvbnN0cnVjdG9yLnByb3RvdHlwZS50YWtlQmluYXJ5RGF0YSA9IGZ1bmN0aW9uKGJpbkRhdGEpIHtcblx0ICB0aGlzLmJ1ZmZlcnMucHVzaChiaW5EYXRhKTtcblx0ICBpZiAodGhpcy5idWZmZXJzLmxlbmd0aCA9PSB0aGlzLnJlY29uUGFjay5hdHRhY2htZW50cykgeyAvLyBkb25lIHdpdGggYnVmZmVyIGxpc3Rcblx0ICAgIHZhciBwYWNrZXQgPSBiaW5hcnkucmVjb25zdHJ1Y3RQYWNrZXQodGhpcy5yZWNvblBhY2ssIHRoaXMuYnVmZmVycyk7XG5cdCAgICB0aGlzLmZpbmlzaGVkUmVjb25zdHJ1Y3Rpb24oKTtcblx0ICAgIHJldHVybiBwYWNrZXQ7XG5cdCAgfVxuXHQgIHJldHVybiBudWxsO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDbGVhbnMgdXAgYmluYXJ5IHBhY2tldCByZWNvbnN0cnVjdGlvbiB2YXJpYWJsZXMuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRCaW5hcnlSZWNvbnN0cnVjdG9yLnByb3RvdHlwZS5maW5pc2hlZFJlY29uc3RydWN0aW9uID0gZnVuY3Rpb24oKSB7XG5cdCAgdGhpcy5yZWNvblBhY2sgPSBudWxsO1xuXHQgIHRoaXMuYnVmZmVycyA9IFtdO1xuXHR9O1xuXG5cdGZ1bmN0aW9uIGVycm9yKGRhdGEpe1xuXHQgIHJldHVybiB7XG5cdCAgICB0eXBlOiBleHBvcnRzLkVSUk9SLFxuXHQgICAgZGF0YTogJ3BhcnNlciBlcnJvcidcblx0ICB9O1xuXHR9XG5cblxuLyoqKi8gfSxcbi8qIDcgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzsvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24obW9kdWxlLCBnbG9iYWwpIHsvKiEgSlNPTiB2My4zLjIgfCBodHRwOi8vYmVzdGllanMuZ2l0aHViLmlvL2pzb24zIHwgQ29weXJpZ2h0IDIwMTItMjAxNCwgS2l0IENhbWJyaWRnZSB8IGh0dHA6Ly9raXQubWl0LWxpY2Vuc2Uub3JnICovXG5cdDsoZnVuY3Rpb24gKCkge1xuXHQgIC8vIERldGVjdCB0aGUgYGRlZmluZWAgZnVuY3Rpb24gZXhwb3NlZCBieSBhc3luY2hyb25vdXMgbW9kdWxlIGxvYWRlcnMuIFRoZVxuXHQgIC8vIHN0cmljdCBgZGVmaW5lYCBjaGVjayBpcyBuZWNlc3NhcnkgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBgci5qc2AuXG5cdCAgdmFyIGlzTG9hZGVyID0gXCJmdW5jdGlvblwiID09PSBcImZ1bmN0aW9uXCIgJiYgX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblxuXHQgIC8vIEEgc2V0IG9mIHR5cGVzIHVzZWQgdG8gZGlzdGluZ3Vpc2ggb2JqZWN0cyBmcm9tIHByaW1pdGl2ZXMuXG5cdCAgdmFyIG9iamVjdFR5cGVzID0ge1xuXHQgICAgXCJmdW5jdGlvblwiOiB0cnVlLFxuXHQgICAgXCJvYmplY3RcIjogdHJ1ZVxuXHQgIH07XG5cblx0ICAvLyBEZXRlY3QgdGhlIGBleHBvcnRzYCBvYmplY3QgZXhwb3NlZCBieSBDb21tb25KUyBpbXBsZW1lbnRhdGlvbnMuXG5cdCAgdmFyIGZyZWVFeHBvcnRzID0gb2JqZWN0VHlwZXNbdHlwZW9mIGV4cG9ydHNdICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuXHQgIC8vIFVzZSB0aGUgYGdsb2JhbGAgb2JqZWN0IGV4cG9zZWQgYnkgTm9kZSAoaW5jbHVkaW5nIEJyb3dzZXJpZnkgdmlhXG5cdCAgLy8gYGluc2VydC1tb2R1bGUtZ2xvYmFsc2ApLCBOYXJ3aGFsLCBhbmQgUmluZ28gYXMgdGhlIGRlZmF1bHQgY29udGV4dCxcblx0ICAvLyBhbmQgdGhlIGB3aW5kb3dgIG9iamVjdCBpbiBicm93c2Vycy4gUmhpbm8gZXhwb3J0cyBhIGBnbG9iYWxgIGZ1bmN0aW9uXG5cdCAgLy8gaW5zdGVhZC5cblx0ICB2YXIgcm9vdCA9IG9iamVjdFR5cGVzW3R5cGVvZiB3aW5kb3ddICYmIHdpbmRvdyB8fCB0aGlzLFxuXHQgICAgICBmcmVlR2xvYmFsID0gZnJlZUV4cG9ydHMgJiYgb2JqZWN0VHlwZXNbdHlwZW9mIG1vZHVsZV0gJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgdHlwZW9mIGdsb2JhbCA9PSBcIm9iamVjdFwiICYmIGdsb2JhbDtcblxuXHQgIGlmIChmcmVlR2xvYmFsICYmIChmcmVlR2xvYmFsW1wiZ2xvYmFsXCJdID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWxbXCJ3aW5kb3dcIl0gPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbFtcInNlbGZcIl0gPT09IGZyZWVHbG9iYWwpKSB7XG5cdCAgICByb290ID0gZnJlZUdsb2JhbDtcblx0ICB9XG5cblx0ICAvLyBQdWJsaWM6IEluaXRpYWxpemVzIEpTT04gMyB1c2luZyB0aGUgZ2l2ZW4gYGNvbnRleHRgIG9iamVjdCwgYXR0YWNoaW5nIHRoZVxuXHQgIC8vIGBzdHJpbmdpZnlgIGFuZCBgcGFyc2VgIGZ1bmN0aW9ucyB0byB0aGUgc3BlY2lmaWVkIGBleHBvcnRzYCBvYmplY3QuXG5cdCAgZnVuY3Rpb24gcnVuSW5Db250ZXh0KGNvbnRleHQsIGV4cG9ydHMpIHtcblx0ICAgIGNvbnRleHQgfHwgKGNvbnRleHQgPSByb290W1wiT2JqZWN0XCJdKCkpO1xuXHQgICAgZXhwb3J0cyB8fCAoZXhwb3J0cyA9IHJvb3RbXCJPYmplY3RcIl0oKSk7XG5cblx0ICAgIC8vIE5hdGl2ZSBjb25zdHJ1Y3RvciBhbGlhc2VzLlxuXHQgICAgdmFyIE51bWJlciA9IGNvbnRleHRbXCJOdW1iZXJcIl0gfHwgcm9vdFtcIk51bWJlclwiXSxcblx0ICAgICAgICBTdHJpbmcgPSBjb250ZXh0W1wiU3RyaW5nXCJdIHx8IHJvb3RbXCJTdHJpbmdcIl0sXG5cdCAgICAgICAgT2JqZWN0ID0gY29udGV4dFtcIk9iamVjdFwiXSB8fCByb290W1wiT2JqZWN0XCJdLFxuXHQgICAgICAgIERhdGUgPSBjb250ZXh0W1wiRGF0ZVwiXSB8fCByb290W1wiRGF0ZVwiXSxcblx0ICAgICAgICBTeW50YXhFcnJvciA9IGNvbnRleHRbXCJTeW50YXhFcnJvclwiXSB8fCByb290W1wiU3ludGF4RXJyb3JcIl0sXG5cdCAgICAgICAgVHlwZUVycm9yID0gY29udGV4dFtcIlR5cGVFcnJvclwiXSB8fCByb290W1wiVHlwZUVycm9yXCJdLFxuXHQgICAgICAgIE1hdGggPSBjb250ZXh0W1wiTWF0aFwiXSB8fCByb290W1wiTWF0aFwiXSxcblx0ICAgICAgICBuYXRpdmVKU09OID0gY29udGV4dFtcIkpTT05cIl0gfHwgcm9vdFtcIkpTT05cIl07XG5cblx0ICAgIC8vIERlbGVnYXRlIHRvIHRoZSBuYXRpdmUgYHN0cmluZ2lmeWAgYW5kIGBwYXJzZWAgaW1wbGVtZW50YXRpb25zLlxuXHQgICAgaWYgKHR5cGVvZiBuYXRpdmVKU09OID09IFwib2JqZWN0XCIgJiYgbmF0aXZlSlNPTikge1xuXHQgICAgICBleHBvcnRzLnN0cmluZ2lmeSA9IG5hdGl2ZUpTT04uc3RyaW5naWZ5O1xuXHQgICAgICBleHBvcnRzLnBhcnNlID0gbmF0aXZlSlNPTi5wYXJzZTtcblx0ICAgIH1cblxuXHQgICAgLy8gQ29udmVuaWVuY2UgYWxpYXNlcy5cblx0ICAgIHZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGUsXG5cdCAgICAgICAgZ2V0Q2xhc3MgPSBvYmplY3RQcm90by50b1N0cmluZyxcblx0ICAgICAgICBpc1Byb3BlcnR5LCBmb3JFYWNoLCB1bmRlZjtcblxuXHQgICAgLy8gVGVzdCB0aGUgYERhdGUjZ2V0VVRDKmAgbWV0aG9kcy4gQmFzZWQgb24gd29yayBieSBAWWFmZmxlLlxuXHQgICAgdmFyIGlzRXh0ZW5kZWQgPSBuZXcgRGF0ZSgtMzUwOTgyNzMzNDU3MzI5Mik7XG5cdCAgICB0cnkge1xuXHQgICAgICAvLyBUaGUgYGdldFVUQ0Z1bGxZZWFyYCwgYE1vbnRoYCwgYW5kIGBEYXRlYCBtZXRob2RzIHJldHVybiBub25zZW5zaWNhbFxuXHQgICAgICAvLyByZXN1bHRzIGZvciBjZXJ0YWluIGRhdGVzIGluIE9wZXJhID49IDEwLjUzLlxuXHQgICAgICBpc0V4dGVuZGVkID0gaXNFeHRlbmRlZC5nZXRVVENGdWxsWWVhcigpID09IC0xMDkyNTIgJiYgaXNFeHRlbmRlZC5nZXRVVENNb250aCgpID09PSAwICYmIGlzRXh0ZW5kZWQuZ2V0VVRDRGF0ZSgpID09PSAxICYmXG5cdCAgICAgICAgLy8gU2FmYXJpIDwgMi4wLjIgc3RvcmVzIHRoZSBpbnRlcm5hbCBtaWxsaXNlY29uZCB0aW1lIHZhbHVlIGNvcnJlY3RseSxcblx0ICAgICAgICAvLyBidXQgY2xpcHMgdGhlIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgZGF0ZSBtZXRob2RzIHRvIHRoZSByYW5nZSBvZlxuXHQgICAgICAgIC8vIHNpZ25lZCAzMi1iaXQgaW50ZWdlcnMgKFstMiAqKiAzMSwgMiAqKiAzMSAtIDFdKS5cblx0ICAgICAgICBpc0V4dGVuZGVkLmdldFVUQ0hvdXJzKCkgPT0gMTAgJiYgaXNFeHRlbmRlZC5nZXRVVENNaW51dGVzKCkgPT0gMzcgJiYgaXNFeHRlbmRlZC5nZXRVVENTZWNvbmRzKCkgPT0gNiAmJiBpc0V4dGVuZGVkLmdldFVUQ01pbGxpc2Vjb25kcygpID09IDcwODtcblx0ICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cblxuXHQgICAgLy8gSW50ZXJuYWw6IERldGVybWluZXMgd2hldGhlciB0aGUgbmF0aXZlIGBKU09OLnN0cmluZ2lmeWAgYW5kIGBwYXJzZWBcblx0ICAgIC8vIGltcGxlbWVudGF0aW9ucyBhcmUgc3BlYy1jb21wbGlhbnQuIEJhc2VkIG9uIHdvcmsgYnkgS2VuIFNueWRlci5cblx0ICAgIGZ1bmN0aW9uIGhhcyhuYW1lKSB7XG5cdCAgICAgIGlmIChoYXNbbmFtZV0gIT09IHVuZGVmKSB7XG5cdCAgICAgICAgLy8gUmV0dXJuIGNhY2hlZCBmZWF0dXJlIHRlc3QgcmVzdWx0LlxuXHQgICAgICAgIHJldHVybiBoYXNbbmFtZV07XG5cdCAgICAgIH1cblx0ICAgICAgdmFyIGlzU3VwcG9ydGVkO1xuXHQgICAgICBpZiAobmFtZSA9PSBcImJ1Zy1zdHJpbmctY2hhci1pbmRleFwiKSB7XG5cdCAgICAgICAgLy8gSUUgPD0gNyBkb2Vzbid0IHN1cHBvcnQgYWNjZXNzaW5nIHN0cmluZyBjaGFyYWN0ZXJzIHVzaW5nIHNxdWFyZVxuXHQgICAgICAgIC8vIGJyYWNrZXQgbm90YXRpb24uIElFIDggb25seSBzdXBwb3J0cyB0aGlzIGZvciBwcmltaXRpdmVzLlxuXHQgICAgICAgIGlzU3VwcG9ydGVkID0gXCJhXCJbMF0gIT0gXCJhXCI7XG5cdCAgICAgIH0gZWxzZSBpZiAobmFtZSA9PSBcImpzb25cIikge1xuXHQgICAgICAgIC8vIEluZGljYXRlcyB3aGV0aGVyIGJvdGggYEpTT04uc3RyaW5naWZ5YCBhbmQgYEpTT04ucGFyc2VgIGFyZVxuXHQgICAgICAgIC8vIHN1cHBvcnRlZC5cblx0ICAgICAgICBpc1N1cHBvcnRlZCA9IGhhcyhcImpzb24tc3RyaW5naWZ5XCIpICYmIGhhcyhcImpzb24tcGFyc2VcIik7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdmFyIHZhbHVlLCBzZXJpYWxpemVkID0gJ3tcImFcIjpbMSx0cnVlLGZhbHNlLG51bGwsXCJcXFxcdTAwMDBcXFxcYlxcXFxuXFxcXGZcXFxcclxcXFx0XCJdfSc7XG5cdCAgICAgICAgLy8gVGVzdCBgSlNPTi5zdHJpbmdpZnlgLlxuXHQgICAgICAgIGlmIChuYW1lID09IFwianNvbi1zdHJpbmdpZnlcIikge1xuXHQgICAgICAgICAgdmFyIHN0cmluZ2lmeSA9IGV4cG9ydHMuc3RyaW5naWZ5LCBzdHJpbmdpZnlTdXBwb3J0ZWQgPSB0eXBlb2Ygc3RyaW5naWZ5ID09IFwiZnVuY3Rpb25cIiAmJiBpc0V4dGVuZGVkO1xuXHQgICAgICAgICAgaWYgKHN0cmluZ2lmeVN1cHBvcnRlZCkge1xuXHQgICAgICAgICAgICAvLyBBIHRlc3QgZnVuY3Rpb24gb2JqZWN0IHdpdGggYSBjdXN0b20gYHRvSlNPTmAgbWV0aG9kLlxuXHQgICAgICAgICAgICAodmFsdWUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgcmV0dXJuIDE7XG5cdCAgICAgICAgICAgIH0pLnRvSlNPTiA9IHZhbHVlO1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgIHN0cmluZ2lmeVN1cHBvcnRlZCA9XG5cdCAgICAgICAgICAgICAgICAvLyBGaXJlZm94IDMuMWIxIGFuZCBiMiBzZXJpYWxpemUgc3RyaW5nLCBudW1iZXIsIGFuZCBib29sZWFuXG5cdCAgICAgICAgICAgICAgICAvLyBwcmltaXRpdmVzIGFzIG9iamVjdCBsaXRlcmFscy5cblx0ICAgICAgICAgICAgICAgIHN0cmluZ2lmeSgwKSA9PT0gXCIwXCIgJiZcblx0ICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCBiMiwgYW5kIEpTT04gMiBzZXJpYWxpemUgd3JhcHBlZCBwcmltaXRpdmVzIGFzIG9iamVjdFxuXHQgICAgICAgICAgICAgICAgLy8gbGl0ZXJhbHMuXG5cdCAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IE51bWJlcigpKSA9PT0gXCIwXCIgJiZcblx0ICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgU3RyaW5nKCkpID09ICdcIlwiJyAmJlxuXHQgICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIHZhbHVlIGlzIGBudWxsYCwgYHVuZGVmaW5lZGAsIG9yXG5cdCAgICAgICAgICAgICAgICAvLyBkb2VzIG5vdCBkZWZpbmUgYSBjYW5vbmljYWwgSlNPTiByZXByZXNlbnRhdGlvbiAodGhpcyBhcHBsaWVzIHRvXG5cdCAgICAgICAgICAgICAgICAvLyBvYmplY3RzIHdpdGggYHRvSlNPTmAgcHJvcGVydGllcyBhcyB3ZWxsLCAqdW5sZXNzKiB0aGV5IGFyZSBuZXN0ZWRcblx0ICAgICAgICAgICAgICAgIC8vIHdpdGhpbiBhbiBvYmplY3Qgb3IgYXJyYXkpLlxuXHQgICAgICAgICAgICAgICAgc3RyaW5naWZ5KGdldENsYXNzKSA9PT0gdW5kZWYgJiZcblx0ICAgICAgICAgICAgICAgIC8vIElFIDggc2VyaWFsaXplcyBgdW5kZWZpbmVkYCBhcyBgXCJ1bmRlZmluZWRcImAuIFNhZmFyaSA8PSA1LjEuNyBhbmRcblx0ICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIzIHBhc3MgdGhpcyB0ZXN0LlxuXHQgICAgICAgICAgICAgICAgc3RyaW5naWZ5KHVuZGVmKSA9PT0gdW5kZWYgJiZcblx0ICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA8PSA1LjEuNyBhbmQgRkYgMy4xYjMgdGhyb3cgYEVycm9yYHMgYW5kIGBUeXBlRXJyb3Jgcyxcblx0ICAgICAgICAgICAgICAgIC8vIHJlc3BlY3RpdmVseSwgaWYgdGhlIHZhbHVlIGlzIG9taXR0ZWQgZW50aXJlbHkuXG5cdCAgICAgICAgICAgICAgICBzdHJpbmdpZnkoKSA9PT0gdW5kZWYgJiZcblx0ICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCAyIHRocm93IGFuIGVycm9yIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSBudW1iZXIsXG5cdCAgICAgICAgICAgICAgICAvLyBzdHJpbmcsIGFycmF5LCBvYmplY3QsIEJvb2xlYW4sIG9yIGBudWxsYCBsaXRlcmFsLiBUaGlzIGFwcGxpZXMgdG9cblx0ICAgICAgICAgICAgICAgIC8vIG9iamVjdHMgd2l0aCBjdXN0b20gYHRvSlNPTmAgbWV0aG9kcyBhcyB3ZWxsLCB1bmxlc3MgdGhleSBhcmUgbmVzdGVkXG5cdCAgICAgICAgICAgICAgICAvLyBpbnNpZGUgb2JqZWN0IG9yIGFycmF5IGxpdGVyYWxzLiBZVUkgMy4wLjBiMSBpZ25vcmVzIGN1c3RvbSBgdG9KU09OYFxuXHQgICAgICAgICAgICAgICAgLy8gbWV0aG9kcyBlbnRpcmVseS5cblx0ICAgICAgICAgICAgICAgIHN0cmluZ2lmeSh2YWx1ZSkgPT09IFwiMVwiICYmXG5cdCAgICAgICAgICAgICAgICBzdHJpbmdpZnkoW3ZhbHVlXSkgPT0gXCJbMV1cIiAmJlxuXHQgICAgICAgICAgICAgICAgLy8gUHJvdG90eXBlIDw9IDEuNi4xIHNlcmlhbGl6ZXMgYFt1bmRlZmluZWRdYCBhcyBgXCJbXVwiYCBpbnN0ZWFkIG9mXG5cdCAgICAgICAgICAgICAgICAvLyBgXCJbbnVsbF1cImAuXG5cdCAgICAgICAgICAgICAgICBzdHJpbmdpZnkoW3VuZGVmXSkgPT0gXCJbbnVsbF1cIiAmJlxuXHQgICAgICAgICAgICAgICAgLy8gWVVJIDMuMC4wYjEgZmFpbHMgdG8gc2VyaWFsaXplIGBudWxsYCBsaXRlcmFscy5cblx0ICAgICAgICAgICAgICAgIHN0cmluZ2lmeShudWxsKSA9PSBcIm51bGxcIiAmJlxuXHQgICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgaGFsdHMgc2VyaWFsaXphdGlvbiBpZiBhbiBhcnJheSBjb250YWlucyBhIGZ1bmN0aW9uOlxuXHQgICAgICAgICAgICAgICAgLy8gYFsxLCB0cnVlLCBnZXRDbGFzcywgMV1gIHNlcmlhbGl6ZXMgYXMgXCJbMSx0cnVlLF0sXCIuIEZGIDMuMWIzXG5cdCAgICAgICAgICAgICAgICAvLyBlbGlkZXMgbm9uLUpTT04gdmFsdWVzIGZyb20gb2JqZWN0cyBhbmQgYXJyYXlzLCB1bmxlc3MgdGhleVxuXHQgICAgICAgICAgICAgICAgLy8gZGVmaW5lIGN1c3RvbSBgdG9KU09OYCBtZXRob2RzLlxuXHQgICAgICAgICAgICAgICAgc3RyaW5naWZ5KFt1bmRlZiwgZ2V0Q2xhc3MsIG51bGxdKSA9PSBcIltudWxsLG51bGwsbnVsbF1cIiAmJlxuXHQgICAgICAgICAgICAgICAgLy8gU2ltcGxlIHNlcmlhbGl6YXRpb24gdGVzdC4gRkYgMy4xYjEgdXNlcyBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZXNcblx0ICAgICAgICAgICAgICAgIC8vIHdoZXJlIGNoYXJhY3RlciBlc2NhcGUgY29kZXMgYXJlIGV4cGVjdGVkIChlLmcuLCBgXFxiYCA9PiBgXFx1MDAwOGApLlxuXHQgICAgICAgICAgICAgICAgc3RyaW5naWZ5KHsgXCJhXCI6IFt2YWx1ZSwgdHJ1ZSwgZmFsc2UsIG51bGwsIFwiXFx4MDBcXGJcXG5cXGZcXHJcXHRcIl0gfSkgPT0gc2VyaWFsaXplZCAmJlxuXHQgICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEgYW5kIGIyIGlnbm9yZSB0aGUgYGZpbHRlcmAgYW5kIGB3aWR0aGAgYXJndW1lbnRzLlxuXHQgICAgICAgICAgICAgICAgc3RyaW5naWZ5KG51bGwsIHZhbHVlKSA9PT0gXCIxXCIgJiZcblx0ICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbMSwgMl0sIG51bGwsIDEpID09IFwiW1xcbiAxLFxcbiAyXFxuXVwiICYmXG5cdCAgICAgICAgICAgICAgICAvLyBKU09OIDIsIFByb3RvdHlwZSA8PSAxLjcsIGFuZCBvbGRlciBXZWJLaXQgYnVpbGRzIGluY29ycmVjdGx5XG5cdCAgICAgICAgICAgICAgICAvLyBzZXJpYWxpemUgZXh0ZW5kZWQgeWVhcnMuXG5cdCAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoLTguNjRlMTUpKSA9PSAnXCItMjcxODIxLTA0LTIwVDAwOjAwOjAwLjAwMFpcIicgJiZcblx0ICAgICAgICAgICAgICAgIC8vIFRoZSBtaWxsaXNlY29uZHMgYXJlIG9wdGlvbmFsIGluIEVTIDUsIGJ1dCByZXF1aXJlZCBpbiA1LjEuXG5cdCAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoOC42NGUxNSkpID09ICdcIisyNzU3NjAtMDktMTNUMDA6MDA6MDAuMDAwWlwiJyAmJlxuXHQgICAgICAgICAgICAgICAgLy8gRmlyZWZveCA8PSAxMS4wIGluY29ycmVjdGx5IHNlcmlhbGl6ZXMgeWVhcnMgcHJpb3IgdG8gMCBhcyBuZWdhdGl2ZVxuXHQgICAgICAgICAgICAgICAgLy8gZm91ci1kaWdpdCB5ZWFycyBpbnN0ZWFkIG9mIHNpeC1kaWdpdCB5ZWFycy4gQ3JlZGl0czogQFlhZmZsZS5cblx0ICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSgtNjIxOTg3NTUyZTUpKSA9PSAnXCItMDAwMDAxLTAxLTAxVDAwOjAwOjAwLjAwMFpcIicgJiZcblx0ICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA8PSA1LjEuNSBhbmQgT3BlcmEgPj0gMTAuNTMgaW5jb3JyZWN0bHkgc2VyaWFsaXplIG1pbGxpc2Vjb25kXG5cdCAgICAgICAgICAgICAgICAvLyB2YWx1ZXMgbGVzcyB0aGFuIDEwMDAuIENyZWRpdHM6IEBZYWZmbGUuXG5cdCAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoLTEpKSA9PSAnXCIxOTY5LTEyLTMxVDIzOjU5OjU5Ljk5OVpcIic7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuXHQgICAgICAgICAgICAgIHN0cmluZ2lmeVN1cHBvcnRlZCA9IGZhbHNlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgICBpc1N1cHBvcnRlZCA9IHN0cmluZ2lmeVN1cHBvcnRlZDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gVGVzdCBgSlNPTi5wYXJzZWAuXG5cdCAgICAgICAgaWYgKG5hbWUgPT0gXCJqc29uLXBhcnNlXCIpIHtcblx0ICAgICAgICAgIHZhciBwYXJzZSA9IGV4cG9ydHMucGFyc2U7XG5cdCAgICAgICAgICBpZiAodHlwZW9mIHBhcnNlID09IFwiZnVuY3Rpb25cIikge1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCBiMiB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhIGJhcmUgbGl0ZXJhbCBpcyBwcm92aWRlZC5cblx0ICAgICAgICAgICAgICAvLyBDb25mb3JtaW5nIGltcGxlbWVudGF0aW9ucyBzaG91bGQgYWxzbyBjb2VyY2UgdGhlIGluaXRpYWwgYXJndW1lbnQgdG9cblx0ICAgICAgICAgICAgICAvLyBhIHN0cmluZyBwcmlvciB0byBwYXJzaW5nLlxuXHQgICAgICAgICAgICAgIGlmIChwYXJzZShcIjBcIikgPT09IDAgJiYgIXBhcnNlKGZhbHNlKSkge1xuXHQgICAgICAgICAgICAgICAgLy8gU2ltcGxlIHBhcnNpbmcgdGVzdC5cblx0ICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2Uoc2VyaWFsaXplZCk7XG5cdCAgICAgICAgICAgICAgICB2YXIgcGFyc2VTdXBwb3J0ZWQgPSB2YWx1ZVtcImFcIl0ubGVuZ3RoID09IDUgJiYgdmFsdWVbXCJhXCJdWzBdID09PSAxO1xuXHQgICAgICAgICAgICAgICAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XG5cdCAgICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDUuMS4yIGFuZCBGRiAzLjFiMSBhbGxvdyB1bmVzY2FwZWQgdGFicyBpbiBzdHJpbmdzLlxuXHQgICAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gIXBhcnNlKCdcIlxcdFwiJyk7XG5cdCAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cblx0ICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgIC8vIEZGIDQuMCBhbmQgNC4wLjEgYWxsb3cgbGVhZGluZyBgK2Agc2lnbnMgYW5kIGxlYWRpbmdcblx0ICAgICAgICAgICAgICAgICAgICAgIC8vIGRlY2ltYWwgcG9pbnRzLiBGRiA0LjAsIDQuMC4xLCBhbmQgSUUgOS0xMCBhbHNvIGFsbG93XG5cdCAgICAgICAgICAgICAgICAgICAgICAvLyBjZXJ0YWluIG9jdGFsIGxpdGVyYWxzLlxuXHQgICAgICAgICAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSBwYXJzZShcIjAxXCIpICE9PSAxO1xuXHQgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cblx0ICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICBpZiAocGFyc2VTdXBwb3J0ZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgLy8gRkYgNC4wLCA0LjAuMSwgYW5kIFJoaW5vIDEuN1IzLVI0IGFsbG93IHRyYWlsaW5nIGRlY2ltYWxcblx0ICAgICAgICAgICAgICAgICAgICAgIC8vIHBvaW50cy4gVGhlc2UgZW52aXJvbm1lbnRzLCBhbG9uZyB3aXRoIEZGIDMuMWIxIGFuZCAyLFxuXHQgICAgICAgICAgICAgICAgICAgICAgLy8gYWxzbyBhbGxvdyB0cmFpbGluZyBjb21tYXMgaW4gSlNPTiBvYmplY3RzIGFuZCBhcnJheXMuXG5cdCAgICAgICAgICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IHBhcnNlKFwiMS5cIikgIT09IDE7XG5cdCAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuXHQgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcblx0ICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IGZhbHNlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgICBpc1N1cHBvcnRlZCA9IHBhcnNlU3VwcG9ydGVkO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gaGFzW25hbWVdID0gISFpc1N1cHBvcnRlZDtcblx0ICAgIH1cblxuXHQgICAgaWYgKCFoYXMoXCJqc29uXCIpKSB7XG5cdCAgICAgIC8vIENvbW1vbiBgW1tDbGFzc11dYCBuYW1lIGFsaWFzZXMuXG5cdCAgICAgIHZhciBmdW5jdGlvbkNsYXNzID0gXCJbb2JqZWN0IEZ1bmN0aW9uXVwiLFxuXHQgICAgICAgICAgZGF0ZUNsYXNzID0gXCJbb2JqZWN0IERhdGVdXCIsXG5cdCAgICAgICAgICBudW1iZXJDbGFzcyA9IFwiW29iamVjdCBOdW1iZXJdXCIsXG5cdCAgICAgICAgICBzdHJpbmdDbGFzcyA9IFwiW29iamVjdCBTdHJpbmddXCIsXG5cdCAgICAgICAgICBhcnJheUNsYXNzID0gXCJbb2JqZWN0IEFycmF5XVwiLFxuXHQgICAgICAgICAgYm9vbGVhbkNsYXNzID0gXCJbb2JqZWN0IEJvb2xlYW5dXCI7XG5cblx0ICAgICAgLy8gRGV0ZWN0IGluY29tcGxldGUgc3VwcG9ydCBmb3IgYWNjZXNzaW5nIHN0cmluZyBjaGFyYWN0ZXJzIGJ5IGluZGV4LlxuXHQgICAgICB2YXIgY2hhckluZGV4QnVnZ3kgPSBoYXMoXCJidWctc3RyaW5nLWNoYXItaW5kZXhcIik7XG5cblx0ICAgICAgLy8gRGVmaW5lIGFkZGl0aW9uYWwgdXRpbGl0eSBtZXRob2RzIGlmIHRoZSBgRGF0ZWAgbWV0aG9kcyBhcmUgYnVnZ3kuXG5cdCAgICAgIGlmICghaXNFeHRlbmRlZCkge1xuXHQgICAgICAgIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5cdCAgICAgICAgLy8gQSBtYXBwaW5nIGJldHdlZW4gdGhlIG1vbnRocyBvZiB0aGUgeWVhciBhbmQgdGhlIG51bWJlciBvZiBkYXlzIGJldHdlZW5cblx0ICAgICAgICAvLyBKYW51YXJ5IDFzdCBhbmQgdGhlIGZpcnN0IG9mIHRoZSByZXNwZWN0aXZlIG1vbnRoLlxuXHQgICAgICAgIHZhciBNb250aHMgPSBbMCwgMzEsIDU5LCA5MCwgMTIwLCAxNTEsIDE4MSwgMjEyLCAyNDMsIDI3MywgMzA0LCAzMzRdO1xuXHQgICAgICAgIC8vIEludGVybmFsOiBDYWxjdWxhdGVzIHRoZSBudW1iZXIgb2YgZGF5cyBiZXR3ZWVuIHRoZSBVbml4IGVwb2NoIGFuZCB0aGVcblx0ICAgICAgICAvLyBmaXJzdCBkYXkgb2YgdGhlIGdpdmVuIG1vbnRoLlxuXHQgICAgICAgIHZhciBnZXREYXkgPSBmdW5jdGlvbiAoeWVhciwgbW9udGgpIHtcblx0ICAgICAgICAgIHJldHVybiBNb250aHNbbW9udGhdICsgMzY1ICogKHllYXIgLSAxOTcwKSArIGZsb29yKCh5ZWFyIC0gMTk2OSArIChtb250aCA9ICsobW9udGggPiAxKSkpIC8gNCkgLSBmbG9vcigoeWVhciAtIDE5MDEgKyBtb250aCkgLyAxMDApICsgZmxvb3IoKHllYXIgLSAxNjAxICsgbW9udGgpIC8gNDAwKTtcblx0ICAgICAgICB9O1xuXHQgICAgICB9XG5cblx0ICAgICAgLy8gSW50ZXJuYWw6IERldGVybWluZXMgaWYgYSBwcm9wZXJ0eSBpcyBhIGRpcmVjdCBwcm9wZXJ0eSBvZiB0aGUgZ2l2ZW5cblx0ICAgICAgLy8gb2JqZWN0LiBEZWxlZ2F0ZXMgdG8gdGhlIG5hdGl2ZSBgT2JqZWN0I2hhc093blByb3BlcnR5YCBtZXRob2QuXG5cdCAgICAgIGlmICghKGlzUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eSkpIHtcblx0ICAgICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG5cdCAgICAgICAgICB2YXIgbWVtYmVycyA9IHt9LCBjb25zdHJ1Y3Rvcjtcblx0ICAgICAgICAgIGlmICgobWVtYmVycy5fX3Byb3RvX18gPSBudWxsLCBtZW1iZXJzLl9fcHJvdG9fXyA9IHtcblx0ICAgICAgICAgICAgLy8gVGhlICpwcm90byogcHJvcGVydHkgY2Fubm90IGJlIHNldCBtdWx0aXBsZSB0aW1lcyBpbiByZWNlbnRcblx0ICAgICAgICAgICAgLy8gdmVyc2lvbnMgb2YgRmlyZWZveCBhbmQgU2VhTW9ua2V5LlxuXHQgICAgICAgICAgICBcInRvU3RyaW5nXCI6IDFcblx0ICAgICAgICAgIH0sIG1lbWJlcnMpLnRvU3RyaW5nICE9IGdldENsYXNzKSB7XG5cdCAgICAgICAgICAgIC8vIFNhZmFyaSA8PSAyLjAuMyBkb2Vzbid0IGltcGxlbWVudCBgT2JqZWN0I2hhc093blByb3BlcnR5YCwgYnV0XG5cdCAgICAgICAgICAgIC8vIHN1cHBvcnRzIHRoZSBtdXRhYmxlICpwcm90byogcHJvcGVydHkuXG5cdCAgICAgICAgICAgIGlzUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcblx0ICAgICAgICAgICAgICAvLyBDYXB0dXJlIGFuZCBicmVhayB0aGUgb2JqZWN0J3MgcHJvdG90eXBlIGNoYWluIChzZWUgc2VjdGlvbiA4LjYuMlxuXHQgICAgICAgICAgICAgIC8vIG9mIHRoZSBFUyA1LjEgc3BlYykuIFRoZSBwYXJlbnRoZXNpemVkIGV4cHJlc3Npb24gcHJldmVudHMgYW5cblx0ICAgICAgICAgICAgICAvLyB1bnNhZmUgdHJhbnNmb3JtYXRpb24gYnkgdGhlIENsb3N1cmUgQ29tcGlsZXIuXG5cdCAgICAgICAgICAgICAgdmFyIG9yaWdpbmFsID0gdGhpcy5fX3Byb3RvX18sIHJlc3VsdCA9IHByb3BlcnR5IGluICh0aGlzLl9fcHJvdG9fXyA9IG51bGwsIHRoaXMpO1xuXHQgICAgICAgICAgICAgIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHByb3RvdHlwZSBjaGFpbi5cblx0ICAgICAgICAgICAgICB0aGlzLl9fcHJvdG9fXyA9IG9yaWdpbmFsO1xuXHQgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAvLyBDYXB0dXJlIGEgcmVmZXJlbmNlIHRvIHRoZSB0b3AtbGV2ZWwgYE9iamVjdGAgY29uc3RydWN0b3IuXG5cdCAgICAgICAgICAgIGNvbnN0cnVjdG9yID0gbWVtYmVycy5jb25zdHJ1Y3Rvcjtcblx0ICAgICAgICAgICAgLy8gVXNlIHRoZSBgY29uc3RydWN0b3JgIHByb3BlcnR5IHRvIHNpbXVsYXRlIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIGluXG5cdCAgICAgICAgICAgIC8vIG90aGVyIGVudmlyb25tZW50cy5cblx0ICAgICAgICAgICAgaXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuXHQgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSAodGhpcy5jb25zdHJ1Y3RvciB8fCBjb25zdHJ1Y3RvcikucHJvdG90eXBlO1xuXHQgICAgICAgICAgICAgIHJldHVybiBwcm9wZXJ0eSBpbiB0aGlzICYmICEocHJvcGVydHkgaW4gcGFyZW50ICYmIHRoaXNbcHJvcGVydHldID09PSBwYXJlbnRbcHJvcGVydHldKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICAgIG1lbWJlcnMgPSBudWxsO1xuXHQgICAgICAgICAgcmV0dXJuIGlzUHJvcGVydHkuY2FsbCh0aGlzLCBwcm9wZXJ0eSk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgfVxuXG5cdCAgICAgIC8vIEludGVybmFsOiBOb3JtYWxpemVzIHRoZSBgZm9yLi4uaW5gIGl0ZXJhdGlvbiBhbGdvcml0aG0gYWNyb3NzXG5cdCAgICAgIC8vIGVudmlyb25tZW50cy4gRWFjaCBlbnVtZXJhdGVkIGtleSBpcyB5aWVsZGVkIHRvIGEgYGNhbGxiYWNrYCBmdW5jdGlvbi5cblx0ICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG5cdCAgICAgICAgdmFyIHNpemUgPSAwLCBQcm9wZXJ0aWVzLCBtZW1iZXJzLCBwcm9wZXJ0eTtcblxuXHQgICAgICAgIC8vIFRlc3RzIGZvciBidWdzIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50J3MgYGZvci4uLmluYCBhbGdvcml0aG0uIFRoZVxuXHQgICAgICAgIC8vIGB2YWx1ZU9mYCBwcm9wZXJ0eSBpbmhlcml0cyB0aGUgbm9uLWVudW1lcmFibGUgZmxhZyBmcm9tXG5cdCAgICAgICAgLy8gYE9iamVjdC5wcm90b3R5cGVgIGluIG9sZGVyIHZlcnNpb25zIG9mIElFLCBOZXRzY2FwZSwgYW5kIE1vemlsbGEuXG5cdCAgICAgICAgKFByb3BlcnRpZXMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICB0aGlzLnZhbHVlT2YgPSAwO1xuXHQgICAgICAgIH0pLnByb3RvdHlwZS52YWx1ZU9mID0gMDtcblxuXHQgICAgICAgIC8vIEl0ZXJhdGUgb3ZlciBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgYFByb3BlcnRpZXNgIGNsYXNzLlxuXHQgICAgICAgIG1lbWJlcnMgPSBuZXcgUHJvcGVydGllcygpO1xuXHQgICAgICAgIGZvciAocHJvcGVydHkgaW4gbWVtYmVycykge1xuXHQgICAgICAgICAgLy8gSWdub3JlIGFsbCBwcm9wZXJ0aWVzIGluaGVyaXRlZCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC5cblx0ICAgICAgICAgIGlmIChpc1Byb3BlcnR5LmNhbGwobWVtYmVycywgcHJvcGVydHkpKSB7XG5cdCAgICAgICAgICAgIHNpemUrKztcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgUHJvcGVydGllcyA9IG1lbWJlcnMgPSBudWxsO1xuXG5cdCAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBpdGVyYXRpb24gYWxnb3JpdGhtLlxuXHQgICAgICAgIGlmICghc2l6ZSkge1xuXHQgICAgICAgICAgLy8gQSBsaXN0IG9mIG5vbi1lbnVtZXJhYmxlIHByb3BlcnRpZXMgaW5oZXJpdGVkIGZyb20gYE9iamVjdC5wcm90b3R5cGVgLlxuXHQgICAgICAgICAgbWVtYmVycyA9IFtcInZhbHVlT2ZcIiwgXCJ0b1N0cmluZ1wiLCBcInRvTG9jYWxlU3RyaW5nXCIsIFwicHJvcGVydHlJc0VudW1lcmFibGVcIiwgXCJpc1Byb3RvdHlwZU9mXCIsIFwiaGFzT3duUHJvcGVydHlcIiwgXCJjb25zdHJ1Y3RvclwiXTtcblx0ICAgICAgICAgIC8vIElFIDw9IDgsIE1vemlsbGEgMS4wLCBhbmQgTmV0c2NhcGUgNi4yIGlnbm9yZSBzaGFkb3dlZCBub24tZW51bWVyYWJsZVxuXHQgICAgICAgICAgLy8gcHJvcGVydGllcy5cblx0ICAgICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuXHQgICAgICAgICAgICB2YXIgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLCBwcm9wZXJ0eSwgbGVuZ3RoO1xuXHQgICAgICAgICAgICB2YXIgaGFzUHJvcGVydHkgPSAhaXNGdW5jdGlvbiAmJiB0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yICE9IFwiZnVuY3Rpb25cIiAmJiBvYmplY3RUeXBlc1t0eXBlb2Ygb2JqZWN0Lmhhc093blByb3BlcnR5XSAmJiBvYmplY3QuaGFzT3duUHJvcGVydHkgfHwgaXNQcm9wZXJ0eTtcblx0ICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcblx0ICAgICAgICAgICAgICAvLyBHZWNrbyA8PSAxLjAgZW51bWVyYXRlcyB0aGUgYHByb3RvdHlwZWAgcHJvcGVydHkgb2YgZnVuY3Rpb25zIHVuZGVyXG5cdCAgICAgICAgICAgICAgLy8gY2VydGFpbiBjb25kaXRpb25zOyBJRSBkb2VzIG5vdC5cblx0ICAgICAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmIGhhc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcblx0ICAgICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcblx0ICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgLy8gTWFudWFsbHkgaW52b2tlIHRoZSBjYWxsYmFjayBmb3IgZWFjaCBub24tZW51bWVyYWJsZSBwcm9wZXJ0eS5cblx0ICAgICAgICAgICAgZm9yIChsZW5ndGggPSBtZW1iZXJzLmxlbmd0aDsgcHJvcGVydHkgPSBtZW1iZXJzWy0tbGVuZ3RoXTsgaGFzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSAmJiBjYWxsYmFjayhwcm9wZXJ0eSkpO1xuXHQgICAgICAgICAgfTtcblx0ICAgICAgICB9IGVsc2UgaWYgKHNpemUgPT0gMikge1xuXHQgICAgICAgICAgLy8gU2FmYXJpIDw9IDIuMC40IGVudW1lcmF0ZXMgc2hhZG93ZWQgcHJvcGVydGllcyB0d2ljZS5cblx0ICAgICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuXHQgICAgICAgICAgICAvLyBDcmVhdGUgYSBzZXQgb2YgaXRlcmF0ZWQgcHJvcGVydGllcy5cblx0ICAgICAgICAgICAgdmFyIG1lbWJlcnMgPSB7fSwgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLCBwcm9wZXJ0eTtcblx0ICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcblx0ICAgICAgICAgICAgICAvLyBTdG9yZSBlYWNoIHByb3BlcnR5IG5hbWUgdG8gcHJldmVudCBkb3VibGUgZW51bWVyYXRpb24uIFRoZVxuXHQgICAgICAgICAgICAgIC8vIGBwcm90b3R5cGVgIHByb3BlcnR5IG9mIGZ1bmN0aW9ucyBpcyBub3QgZW51bWVyYXRlZCBkdWUgdG8gY3Jvc3MtXG5cdCAgICAgICAgICAgICAgLy8gZW52aXJvbm1lbnQgaW5jb25zaXN0ZW5jaWVzLlxuXHQgICAgICAgICAgICAgIGlmICghKGlzRnVuY3Rpb24gJiYgcHJvcGVydHkgPT0gXCJwcm90b3R5cGVcIikgJiYgIWlzUHJvcGVydHkuY2FsbChtZW1iZXJzLCBwcm9wZXJ0eSkgJiYgKG1lbWJlcnNbcHJvcGVydHldID0gMSkgJiYgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG5cdCAgICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG5cdCAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9O1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAvLyBObyBidWdzIGRldGVjdGVkOyB1c2UgdGhlIHN0YW5kYXJkIGBmb3IuLi5pbmAgYWxnb3JpdGhtLlxuXHQgICAgICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG5cdCAgICAgICAgICAgIHZhciBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5LCBpc0NvbnN0cnVjdG9yO1xuXHQgICAgICAgICAgICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xuXHQgICAgICAgICAgICAgIGlmICghKGlzRnVuY3Rpb24gJiYgcHJvcGVydHkgPT0gXCJwcm90b3R5cGVcIikgJiYgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpICYmICEoaXNDb25zdHJ1Y3RvciA9IHByb3BlcnR5ID09PSBcImNvbnN0cnVjdG9yXCIpKSB7XG5cdCAgICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG5cdCAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIC8vIE1hbnVhbGx5IGludm9rZSB0aGUgY2FsbGJhY2sgZm9yIHRoZSBgY29uc3RydWN0b3JgIHByb3BlcnR5IGR1ZSB0b1xuXHQgICAgICAgICAgICAvLyBjcm9zcy1lbnZpcm9ubWVudCBpbmNvbnNpc3RlbmNpZXMuXG5cdCAgICAgICAgICAgIGlmIChpc0NvbnN0cnVjdG9yIHx8IGlzUHJvcGVydHkuY2FsbChvYmplY3QsIChwcm9wZXJ0eSA9IFwiY29uc3RydWN0b3JcIikpKSB7XG5cdCAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9O1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gZm9yRWFjaChvYmplY3QsIGNhbGxiYWNrKTtcblx0ICAgICAgfTtcblxuXHQgICAgICAvLyBQdWJsaWM6IFNlcmlhbGl6ZXMgYSBKYXZhU2NyaXB0IGB2YWx1ZWAgYXMgYSBKU09OIHN0cmluZy4gVGhlIG9wdGlvbmFsXG5cdCAgICAgIC8vIGBmaWx0ZXJgIGFyZ3VtZW50IG1heSBzcGVjaWZ5IGVpdGhlciBhIGZ1bmN0aW9uIHRoYXQgYWx0ZXJzIGhvdyBvYmplY3QgYW5kXG5cdCAgICAgIC8vIGFycmF5IG1lbWJlcnMgYXJlIHNlcmlhbGl6ZWQsIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MgYW5kIG51bWJlcnMgdGhhdFxuXHQgICAgICAvLyBpbmRpY2F0ZXMgd2hpY2ggcHJvcGVydGllcyBzaG91bGQgYmUgc2VyaWFsaXplZC4gVGhlIG9wdGlvbmFsIGB3aWR0aGBcblx0ICAgICAgLy8gYXJndW1lbnQgbWF5IGJlIGVpdGhlciBhIHN0cmluZyBvciBudW1iZXIgdGhhdCBzcGVjaWZpZXMgdGhlIGluZGVudGF0aW9uXG5cdCAgICAgIC8vIGxldmVsIG9mIHRoZSBvdXRwdXQuXG5cdCAgICAgIGlmICghaGFzKFwianNvbi1zdHJpbmdpZnlcIikpIHtcblx0ICAgICAgICAvLyBJbnRlcm5hbDogQSBtYXAgb2YgY29udHJvbCBjaGFyYWN0ZXJzIGFuZCB0aGVpciBlc2NhcGVkIGVxdWl2YWxlbnRzLlxuXHQgICAgICAgIHZhciBFc2NhcGVzID0ge1xuXHQgICAgICAgICAgOTI6IFwiXFxcXFxcXFxcIixcblx0ICAgICAgICAgIDM0OiAnXFxcXFwiJyxcblx0ICAgICAgICAgIDg6IFwiXFxcXGJcIixcblx0ICAgICAgICAgIDEyOiBcIlxcXFxmXCIsXG5cdCAgICAgICAgICAxMDogXCJcXFxcblwiLFxuXHQgICAgICAgICAgMTM6IFwiXFxcXHJcIixcblx0ICAgICAgICAgIDk6IFwiXFxcXHRcIlxuXHQgICAgICAgIH07XG5cblx0ICAgICAgICAvLyBJbnRlcm5hbDogQ29udmVydHMgYHZhbHVlYCBpbnRvIGEgemVyby1wYWRkZWQgc3RyaW5nIHN1Y2ggdGhhdCBpdHNcblx0ICAgICAgICAvLyBsZW5ndGggaXMgYXQgbGVhc3QgZXF1YWwgdG8gYHdpZHRoYC4gVGhlIGB3aWR0aGAgbXVzdCBiZSA8PSA2LlxuXHQgICAgICAgIHZhciBsZWFkaW5nWmVyb2VzID0gXCIwMDAwMDBcIjtcblx0ICAgICAgICB2YXIgdG9QYWRkZWRTdHJpbmcgPSBmdW5jdGlvbiAod2lkdGgsIHZhbHVlKSB7XG5cdCAgICAgICAgICAvLyBUaGUgYHx8IDBgIGV4cHJlc3Npb24gaXMgbmVjZXNzYXJ5IHRvIHdvcmsgYXJvdW5kIGEgYnVnIGluXG5cdCAgICAgICAgICAvLyBPcGVyYSA8PSA3LjU0dTIgd2hlcmUgYDAgPT0gLTBgLCBidXQgYFN0cmluZygtMCkgIT09IFwiMFwiYC5cblx0ICAgICAgICAgIHJldHVybiAobGVhZGluZ1plcm9lcyArICh2YWx1ZSB8fCAwKSkuc2xpY2UoLXdpZHRoKTtcblx0ICAgICAgICB9O1xuXG5cdCAgICAgICAgLy8gSW50ZXJuYWw6IERvdWJsZS1xdW90ZXMgYSBzdHJpbmcgYHZhbHVlYCwgcmVwbGFjaW5nIGFsbCBBU0NJSSBjb250cm9sXG5cdCAgICAgICAgLy8gY2hhcmFjdGVycyAoY2hhcmFjdGVycyB3aXRoIGNvZGUgdW5pdCB2YWx1ZXMgYmV0d2VlbiAwIGFuZCAzMSkgd2l0aFxuXHQgICAgICAgIC8vIHRoZWlyIGVzY2FwZWQgZXF1aXZhbGVudHMuIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhlXG5cdCAgICAgICAgLy8gYFF1b3RlKHZhbHVlKWAgb3BlcmF0aW9uIGRlZmluZWQgaW4gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMy5cblx0ICAgICAgICB2YXIgdW5pY29kZVByZWZpeCA9IFwiXFxcXHUwMFwiO1xuXHQgICAgICAgIHZhciBxdW90ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgICAgdmFyIHJlc3VsdCA9ICdcIicsIGluZGV4ID0gMCwgbGVuZ3RoID0gdmFsdWUubGVuZ3RoLCB1c2VDaGFySW5kZXggPSAhY2hhckluZGV4QnVnZ3kgfHwgbGVuZ3RoID4gMTA7XG5cdCAgICAgICAgICB2YXIgc3ltYm9scyA9IHVzZUNoYXJJbmRleCAmJiAoY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5zcGxpdChcIlwiKSA6IHZhbHVlKTtcblx0ICAgICAgICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuXHQgICAgICAgICAgICB2YXIgY2hhckNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KGluZGV4KTtcblx0ICAgICAgICAgICAgLy8gSWYgdGhlIGNoYXJhY3RlciBpcyBhIGNvbnRyb2wgY2hhcmFjdGVyLCBhcHBlbmQgaXRzIFVuaWNvZGUgb3Jcblx0ICAgICAgICAgICAgLy8gc2hvcnRoYW5kIGVzY2FwZSBzZXF1ZW5jZTsgb3RoZXJ3aXNlLCBhcHBlbmQgdGhlIGNoYXJhY3RlciBhcy1pcy5cblx0ICAgICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xuXHQgICAgICAgICAgICAgIGNhc2UgODogY2FzZSA5OiBjYXNlIDEwOiBjYXNlIDEyOiBjYXNlIDEzOiBjYXNlIDM0OiBjYXNlIDkyOlxuXHQgICAgICAgICAgICAgICAgcmVzdWx0ICs9IEVzY2FwZXNbY2hhckNvZGVdO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA8IDMyKSB7XG5cdCAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSB1bmljb2RlUHJlZml4ICsgdG9QYWRkZWRTdHJpbmcoMiwgY2hhckNvZGUudG9TdHJpbmcoMTYpKTtcblx0ICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICByZXN1bHQgKz0gdXNlQ2hhckluZGV4ID8gc3ltYm9sc1tpbmRleF0gOiB2YWx1ZS5jaGFyQXQoaW5kZXgpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgJ1wiJztcblx0ICAgICAgICB9O1xuXG5cdCAgICAgICAgLy8gSW50ZXJuYWw6IFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZXMgYW4gb2JqZWN0LiBJbXBsZW1lbnRzIHRoZVxuXHQgICAgICAgIC8vIGBTdHIoa2V5LCBob2xkZXIpYCwgYEpPKHZhbHVlKWAsIGFuZCBgSkEodmFsdWUpYCBvcGVyYXRpb25zLlxuXHQgICAgICAgIHZhciBzZXJpYWxpemUgPSBmdW5jdGlvbiAocHJvcGVydHksIG9iamVjdCwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjaykge1xuXHQgICAgICAgICAgdmFyIHZhbHVlLCBjbGFzc05hbWUsIHllYXIsIG1vbnRoLCBkYXRlLCB0aW1lLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCByZXN1bHRzLCBlbGVtZW50LCBpbmRleCwgbGVuZ3RoLCBwcmVmaXgsIHJlc3VsdDtcblx0ICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgIC8vIE5lY2Vzc2FyeSBmb3IgaG9zdCBvYmplY3Qgc3VwcG9ydC5cblx0ICAgICAgICAgICAgdmFsdWUgPSBvYmplY3RbcHJvcGVydHldO1xuXHQgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuXHQgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiICYmIHZhbHVlKSB7XG5cdCAgICAgICAgICAgIGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpO1xuXHQgICAgICAgICAgICBpZiAoY2xhc3NOYW1lID09IGRhdGVDbGFzcyAmJiAhaXNQcm9wZXJ0eS5jYWxsKHZhbHVlLCBcInRvSlNPTlwiKSkge1xuXHQgICAgICAgICAgICAgIGlmICh2YWx1ZSA+IC0xIC8gMCAmJiB2YWx1ZSA8IDEgLyAwKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBEYXRlcyBhcmUgc2VyaWFsaXplZCBhY2NvcmRpbmcgdG8gdGhlIGBEYXRlI3RvSlNPTmAgbWV0aG9kXG5cdCAgICAgICAgICAgICAgICAvLyBzcGVjaWZpZWQgaW4gRVMgNS4xIHNlY3Rpb24gMTUuOS41LjQ0LiBTZWUgc2VjdGlvbiAxNS45LjEuMTVcblx0ICAgICAgICAgICAgICAgIC8vIGZvciB0aGUgSVNPIDg2MDEgZGF0ZSB0aW1lIHN0cmluZyBmb3JtYXQuXG5cdCAgICAgICAgICAgICAgICBpZiAoZ2V0RGF5KSB7XG5cdCAgICAgICAgICAgICAgICAgIC8vIE1hbnVhbGx5IGNvbXB1dGUgdGhlIHllYXIsIG1vbnRoLCBkYXRlLCBob3VycywgbWludXRlcyxcblx0ICAgICAgICAgICAgICAgICAgLy8gc2Vjb25kcywgYW5kIG1pbGxpc2Vjb25kcyBpZiB0aGUgYGdldFVUQypgIG1ldGhvZHMgYXJlXG5cdCAgICAgICAgICAgICAgICAgIC8vIGJ1Z2d5LiBBZGFwdGVkIGZyb20gQFlhZmZsZSdzIGBkYXRlLXNoaW1gIHByb2plY3QuXG5cdCAgICAgICAgICAgICAgICAgIGRhdGUgPSBmbG9vcih2YWx1ZSAvIDg2NGU1KTtcblx0ICAgICAgICAgICAgICAgICAgZm9yICh5ZWFyID0gZmxvb3IoZGF0ZSAvIDM2NS4yNDI1KSArIDE5NzAgLSAxOyBnZXREYXkoeWVhciArIDEsIDApIDw9IGRhdGU7IHllYXIrKyk7XG5cdCAgICAgICAgICAgICAgICAgIGZvciAobW9udGggPSBmbG9vcigoZGF0ZSAtIGdldERheSh5ZWFyLCAwKSkgLyAzMC40Mik7IGdldERheSh5ZWFyLCBtb250aCArIDEpIDw9IGRhdGU7IG1vbnRoKyspO1xuXHQgICAgICAgICAgICAgICAgICBkYXRlID0gMSArIGRhdGUgLSBnZXREYXkoeWVhciwgbW9udGgpO1xuXHQgICAgICAgICAgICAgICAgICAvLyBUaGUgYHRpbWVgIHZhbHVlIHNwZWNpZmllcyB0aGUgdGltZSB3aXRoaW4gdGhlIGRheSAoc2VlIEVTXG5cdCAgICAgICAgICAgICAgICAgIC8vIDUuMSBzZWN0aW9uIDE1LjkuMS4yKS4gVGhlIGZvcm11bGEgYChBICUgQiArIEIpICUgQmAgaXMgdXNlZFxuXHQgICAgICAgICAgICAgICAgICAvLyB0byBjb21wdXRlIGBBIG1vZHVsbyBCYCwgYXMgdGhlIGAlYCBvcGVyYXRvciBkb2VzIG5vdFxuXHQgICAgICAgICAgICAgICAgICAvLyBjb3JyZXNwb25kIHRvIHRoZSBgbW9kdWxvYCBvcGVyYXRpb24gZm9yIG5lZ2F0aXZlIG51bWJlcnMuXG5cdCAgICAgICAgICAgICAgICAgIHRpbWUgPSAodmFsdWUgJSA4NjRlNSArIDg2NGU1KSAlIDg2NGU1O1xuXHQgICAgICAgICAgICAgICAgICAvLyBUaGUgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIGFuZCBtaWxsaXNlY29uZHMgYXJlIG9idGFpbmVkIGJ5XG5cdCAgICAgICAgICAgICAgICAgIC8vIGRlY29tcG9zaW5nIHRoZSB0aW1lIHdpdGhpbiB0aGUgZGF5LiBTZWUgc2VjdGlvbiAxNS45LjEuMTAuXG5cdCAgICAgICAgICAgICAgICAgIGhvdXJzID0gZmxvb3IodGltZSAvIDM2ZTUpICUgMjQ7XG5cdCAgICAgICAgICAgICAgICAgIG1pbnV0ZXMgPSBmbG9vcih0aW1lIC8gNmU0KSAlIDYwO1xuXHQgICAgICAgICAgICAgICAgICBzZWNvbmRzID0gZmxvb3IodGltZSAvIDFlMykgJSA2MDtcblx0ICAgICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gdGltZSAlIDFlMztcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgIHllYXIgPSB2YWx1ZS5nZXRVVENGdWxsWWVhcigpO1xuXHQgICAgICAgICAgICAgICAgICBtb250aCA9IHZhbHVlLmdldFVUQ01vbnRoKCk7XG5cdCAgICAgICAgICAgICAgICAgIGRhdGUgPSB2YWx1ZS5nZXRVVENEYXRlKCk7XG5cdCAgICAgICAgICAgICAgICAgIGhvdXJzID0gdmFsdWUuZ2V0VVRDSG91cnMoKTtcblx0ICAgICAgICAgICAgICAgICAgbWludXRlcyA9IHZhbHVlLmdldFVUQ01pbnV0ZXMoKTtcblx0ICAgICAgICAgICAgICAgICAgc2Vjb25kcyA9IHZhbHVlLmdldFVUQ1NlY29uZHMoKTtcblx0ICAgICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gdmFsdWUuZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAvLyBTZXJpYWxpemUgZXh0ZW5kZWQgeWVhcnMgY29ycmVjdGx5LlxuXHQgICAgICAgICAgICAgICAgdmFsdWUgPSAoeWVhciA8PSAwIHx8IHllYXIgPj0gMWU0ID8gKHllYXIgPCAwID8gXCItXCIgOiBcIitcIikgKyB0b1BhZGRlZFN0cmluZyg2LCB5ZWFyIDwgMCA/IC15ZWFyIDogeWVhcikgOiB0b1BhZGRlZFN0cmluZyg0LCB5ZWFyKSkgK1xuXHQgICAgICAgICAgICAgICAgICBcIi1cIiArIHRvUGFkZGVkU3RyaW5nKDIsIG1vbnRoICsgMSkgKyBcIi1cIiArIHRvUGFkZGVkU3RyaW5nKDIsIGRhdGUpICtcblx0ICAgICAgICAgICAgICAgICAgLy8gTW9udGhzLCBkYXRlcywgaG91cnMsIG1pbnV0ZXMsIGFuZCBzZWNvbmRzIHNob3VsZCBoYXZlIHR3b1xuXHQgICAgICAgICAgICAgICAgICAvLyBkaWdpdHM7IG1pbGxpc2Vjb25kcyBzaG91bGQgaGF2ZSB0aHJlZS5cblx0ICAgICAgICAgICAgICAgICAgXCJUXCIgKyB0b1BhZGRlZFN0cmluZygyLCBob3VycykgKyBcIjpcIiArIHRvUGFkZGVkU3RyaW5nKDIsIG1pbnV0ZXMpICsgXCI6XCIgKyB0b1BhZGRlZFN0cmluZygyLCBzZWNvbmRzKSArXG5cdCAgICAgICAgICAgICAgICAgIC8vIE1pbGxpc2Vjb25kcyBhcmUgb3B0aW9uYWwgaW4gRVMgNS4wLCBidXQgcmVxdWlyZWQgaW4gNS4xLlxuXHQgICAgICAgICAgICAgICAgICBcIi5cIiArIHRvUGFkZGVkU3RyaW5nKDMsIG1pbGxpc2Vjb25kcykgKyBcIlpcIjtcblx0ICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuXHQgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUudG9KU09OID09IFwiZnVuY3Rpb25cIiAmJiAoKGNsYXNzTmFtZSAhPSBudW1iZXJDbGFzcyAmJiBjbGFzc05hbWUgIT0gc3RyaW5nQ2xhc3MgJiYgY2xhc3NOYW1lICE9IGFycmF5Q2xhc3MpIHx8IGlzUHJvcGVydHkuY2FsbCh2YWx1ZSwgXCJ0b0pTT05cIikpKSB7XG5cdCAgICAgICAgICAgICAgLy8gUHJvdG90eXBlIDw9IDEuNi4xIGFkZHMgbm9uLXN0YW5kYXJkIGB0b0pTT05gIG1ldGhvZHMgdG8gdGhlXG5cdCAgICAgICAgICAgICAgLy8gYE51bWJlcmAsIGBTdHJpbmdgLCBgRGF0ZWAsIGFuZCBgQXJyYXlgIHByb3RvdHlwZXMuIEpTT04gM1xuXHQgICAgICAgICAgICAgIC8vIGlnbm9yZXMgYWxsIGB0b0pTT05gIG1ldGhvZHMgb24gdGhlc2Ugb2JqZWN0cyB1bmxlc3MgdGhleSBhcmVcblx0ICAgICAgICAgICAgICAvLyBkZWZpbmVkIGRpcmVjdGx5IG9uIGFuIGluc3RhbmNlLlxuXHQgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9KU09OKHByb3BlcnR5KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG5cdCAgICAgICAgICAgIC8vIElmIGEgcmVwbGFjZW1lbnQgZnVuY3Rpb24gd2FzIHByb3ZpZGVkLCBjYWxsIGl0IHRvIG9idGFpbiB0aGUgdmFsdWVcblx0ICAgICAgICAgICAgLy8gZm9yIHNlcmlhbGl6YXRpb24uXG5cdCAgICAgICAgICAgIHZhbHVlID0gY2FsbGJhY2suY2FsbChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh2YWx1ZSk7XG5cdCAgICAgICAgICBpZiAoY2xhc3NOYW1lID09IGJvb2xlYW5DbGFzcykge1xuXHQgICAgICAgICAgICAvLyBCb29sZWFucyBhcmUgcmVwcmVzZW50ZWQgbGl0ZXJhbGx5LlxuXHQgICAgICAgICAgICByZXR1cm4gXCJcIiArIHZhbHVlO1xuXHQgICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gbnVtYmVyQ2xhc3MpIHtcblx0ICAgICAgICAgICAgLy8gSlNPTiBudW1iZXJzIG11c3QgYmUgZmluaXRlLiBgSW5maW5pdHlgIGFuZCBgTmFOYCBhcmUgc2VyaWFsaXplZCBhc1xuXHQgICAgICAgICAgICAvLyBgXCJudWxsXCJgLlxuXHQgICAgICAgICAgICByZXR1cm4gdmFsdWUgPiAtMSAvIDAgJiYgdmFsdWUgPCAxIC8gMCA/IFwiXCIgKyB2YWx1ZSA6IFwibnVsbFwiO1xuXHQgICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MpIHtcblx0ICAgICAgICAgICAgLy8gU3RyaW5ncyBhcmUgZG91YmxlLXF1b3RlZCBhbmQgZXNjYXBlZC5cblx0ICAgICAgICAgICAgcmV0dXJuIHF1b3RlKFwiXCIgKyB2YWx1ZSk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgb2JqZWN0cyBhbmQgYXJyYXlzLlxuXHQgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiKSB7XG5cdCAgICAgICAgICAgIC8vIENoZWNrIGZvciBjeWNsaWMgc3RydWN0dXJlcy4gVGhpcyBpcyBhIGxpbmVhciBzZWFyY2g7IHBlcmZvcm1hbmNlXG5cdCAgICAgICAgICAgIC8vIGlzIGludmVyc2VseSBwcm9wb3J0aW9uYWwgdG8gdGhlIG51bWJlciBvZiB1bmlxdWUgbmVzdGVkIG9iamVjdHMuXG5cdCAgICAgICAgICAgIGZvciAobGVuZ3RoID0gc3RhY2subGVuZ3RoOyBsZW5ndGgtLTspIHtcblx0ICAgICAgICAgICAgICBpZiAoc3RhY2tbbGVuZ3RoXSA9PT0gdmFsdWUpIHtcblx0ICAgICAgICAgICAgICAgIC8vIEN5Y2xpYyBzdHJ1Y3R1cmVzIGNhbm5vdCBiZSBzZXJpYWxpemVkIGJ5IGBKU09OLnN0cmluZ2lmeWAuXG5cdCAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoKTtcblx0ICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgLy8gQWRkIHRoZSBvYmplY3QgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuXHQgICAgICAgICAgICBzdGFjay5wdXNoKHZhbHVlKTtcblx0ICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuXHQgICAgICAgICAgICAvLyBTYXZlIHRoZSBjdXJyZW50IGluZGVudGF0aW9uIGxldmVsIGFuZCBpbmRlbnQgb25lIGFkZGl0aW9uYWwgbGV2ZWwuXG5cdCAgICAgICAgICAgIHByZWZpeCA9IGluZGVudGF0aW9uO1xuXHQgICAgICAgICAgICBpbmRlbnRhdGlvbiArPSB3aGl0ZXNwYWNlO1xuXHQgICAgICAgICAgICBpZiAoY2xhc3NOYW1lID09IGFycmF5Q2xhc3MpIHtcblx0ICAgICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgYXJyYXkgZWxlbWVudHMuXG5cdCAgICAgICAgICAgICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcblx0ICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBzZXJpYWxpemUoaW5kZXgsIHZhbHVlLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKTtcblx0ICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChlbGVtZW50ID09PSB1bmRlZiA/IFwibnVsbFwiIDogZWxlbWVudCk7XG5cdCAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdHMubGVuZ3RoID8gKHdoaXRlc3BhY2UgPyBcIltcXG5cIiArIGluZGVudGF0aW9uICsgcmVzdWx0cy5qb2luKFwiLFxcblwiICsgaW5kZW50YXRpb24pICsgXCJcXG5cIiArIHByZWZpeCArIFwiXVwiIDogKFwiW1wiICsgcmVzdWx0cy5qb2luKFwiLFwiKSArIFwiXVwiKSkgOiBcIltdXCI7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgc2VyaWFsaXplIG9iamVjdCBtZW1iZXJzLiBNZW1iZXJzIGFyZSBzZWxlY3RlZCBmcm9tXG5cdCAgICAgICAgICAgICAgLy8gZWl0aGVyIGEgdXNlci1zcGVjaWZpZWQgbGlzdCBvZiBwcm9wZXJ0eSBuYW1lcywgb3IgdGhlIG9iamVjdFxuXHQgICAgICAgICAgICAgIC8vIGl0c2VsZi5cblx0ICAgICAgICAgICAgICBmb3JFYWNoKHByb3BlcnRpZXMgfHwgdmFsdWUsIGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBzZXJpYWxpemUocHJvcGVydHksIHZhbHVlLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKTtcblx0ICAgICAgICAgICAgICAgIGlmIChlbGVtZW50ICE9PSB1bmRlZikge1xuXHQgICAgICAgICAgICAgICAgICAvLyBBY2NvcmRpbmcgdG8gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMzogXCJJZiBgZ2FwYCB7d2hpdGVzcGFjZX1cblx0ICAgICAgICAgICAgICAgICAgLy8gaXMgbm90IHRoZSBlbXB0eSBzdHJpbmcsIGxldCBgbWVtYmVyYCB7cXVvdGUocHJvcGVydHkpICsgXCI6XCJ9XG5cdCAgICAgICAgICAgICAgICAgIC8vIGJlIHRoZSBjb25jYXRlbmF0aW9uIG9mIGBtZW1iZXJgIGFuZCB0aGUgYHNwYWNlYCBjaGFyYWN0ZXIuXCJcblx0ICAgICAgICAgICAgICAgICAgLy8gVGhlIFwiYHNwYWNlYCBjaGFyYWN0ZXJcIiByZWZlcnMgdG8gdGhlIGxpdGVyYWwgc3BhY2Vcblx0ICAgICAgICAgICAgICAgICAgLy8gY2hhcmFjdGVyLCBub3QgdGhlIGBzcGFjZWAge3dpZHRofSBhcmd1bWVudCBwcm92aWRlZCB0b1xuXHQgICAgICAgICAgICAgICAgICAvLyBgSlNPTi5zdHJpbmdpZnlgLlxuXHQgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocXVvdGUocHJvcGVydHkpICsgXCI6XCIgKyAod2hpdGVzcGFjZSA/IFwiIFwiIDogXCJcIikgKyBlbGVtZW50KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHRzLmxlbmd0aCA/ICh3aGl0ZXNwYWNlID8gXCJ7XFxuXCIgKyBpbmRlbnRhdGlvbiArIHJlc3VsdHMuam9pbihcIixcXG5cIiArIGluZGVudGF0aW9uKSArIFwiXFxuXCIgKyBwcmVmaXggKyBcIn1cIiA6IChcIntcIiArIHJlc3VsdHMuam9pbihcIixcIikgKyBcIn1cIikpIDogXCJ7fVwiO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgb2JqZWN0IGZyb20gdGhlIHRyYXZlcnNlZCBvYmplY3Qgc3RhY2suXG5cdCAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuXHQgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH07XG5cblx0ICAgICAgICAvLyBQdWJsaWM6IGBKU09OLnN0cmluZ2lmeWAuIFNlZSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLlxuXHQgICAgICAgIGV4cG9ydHMuc3RyaW5naWZ5ID0gZnVuY3Rpb24gKHNvdXJjZSwgZmlsdGVyLCB3aWR0aCkge1xuXHQgICAgICAgICAgdmFyIHdoaXRlc3BhY2UsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCBjbGFzc05hbWU7XG5cdCAgICAgICAgICBpZiAob2JqZWN0VHlwZXNbdHlwZW9mIGZpbHRlcl0gJiYgZmlsdGVyKSB7XG5cdCAgICAgICAgICAgIGlmICgoY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbChmaWx0ZXIpKSA9PSBmdW5jdGlvbkNsYXNzKSB7XG5cdCAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmaWx0ZXI7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IGFycmF5Q2xhc3MpIHtcblx0ICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBwcm9wZXJ0eSBuYW1lcyBhcnJheSBpbnRvIGEgbWFrZXNoaWZ0IHNldC5cblx0ICAgICAgICAgICAgICBwcm9wZXJ0aWVzID0ge307XG5cdCAgICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwLCBsZW5ndGggPSBmaWx0ZXIubGVuZ3RoLCB2YWx1ZTsgaW5kZXggPCBsZW5ndGg7IHZhbHVlID0gZmlsdGVyW2luZGV4KytdLCAoKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpKSwgY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzIHx8IGNsYXNzTmFtZSA9PSBudW1iZXJDbGFzcykgJiYgKHByb3BlcnRpZXNbdmFsdWVdID0gMSkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgICBpZiAod2lkdGgpIHtcblx0ICAgICAgICAgICAgaWYgKChjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHdpZHRoKSkgPT0gbnVtYmVyQ2xhc3MpIHtcblx0ICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBgd2lkdGhgIHRvIGFuIGludGVnZXIgYW5kIGNyZWF0ZSBhIHN0cmluZyBjb250YWluaW5nXG5cdCAgICAgICAgICAgICAgLy8gYHdpZHRoYCBudW1iZXIgb2Ygc3BhY2UgY2hhcmFjdGVycy5cblx0ICAgICAgICAgICAgICBpZiAoKHdpZHRoIC09IHdpZHRoICUgMSkgPiAwKSB7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHdoaXRlc3BhY2UgPSBcIlwiLCB3aWR0aCA+IDEwICYmICh3aWR0aCA9IDEwKTsgd2hpdGVzcGFjZS5sZW5ndGggPCB3aWR0aDsgd2hpdGVzcGFjZSArPSBcIiBcIik7XG5cdCAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcykge1xuXHQgICAgICAgICAgICAgIHdoaXRlc3BhY2UgPSB3aWR0aC5sZW5ndGggPD0gMTAgPyB3aWR0aCA6IHdpZHRoLnNsaWNlKDAsIDEwKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgLy8gT3BlcmEgPD0gNy41NHUyIGRpc2NhcmRzIHRoZSB2YWx1ZXMgYXNzb2NpYXRlZCB3aXRoIGVtcHR5IHN0cmluZyBrZXlzXG5cdCAgICAgICAgICAvLyAoYFwiXCJgKSBvbmx5IGlmIHRoZXkgYXJlIHVzZWQgZGlyZWN0bHkgd2l0aGluIGFuIG9iamVjdCBtZW1iZXIgbGlzdFxuXHQgICAgICAgICAgLy8gKGUuZy4sIGAhKFwiXCIgaW4geyBcIlwiOiAxfSlgKS5cblx0ICAgICAgICAgIHJldHVybiBzZXJpYWxpemUoXCJcIiwgKHZhbHVlID0ge30sIHZhbHVlW1wiXCJdID0gc291cmNlLCB2YWx1ZSksIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBcIlwiLCBbXSk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgfVxuXG5cdCAgICAgIC8vIFB1YmxpYzogUGFyc2VzIGEgSlNPTiBzb3VyY2Ugc3RyaW5nLlxuXHQgICAgICBpZiAoIWhhcyhcImpzb24tcGFyc2VcIikpIHtcblx0ICAgICAgICB2YXIgZnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcblxuXHQgICAgICAgIC8vIEludGVybmFsOiBBIG1hcCBvZiBlc2NhcGVkIGNvbnRyb2wgY2hhcmFjdGVycyBhbmQgdGhlaXIgdW5lc2NhcGVkXG5cdCAgICAgICAgLy8gZXF1aXZhbGVudHMuXG5cdCAgICAgICAgdmFyIFVuZXNjYXBlcyA9IHtcblx0ICAgICAgICAgIDkyOiBcIlxcXFxcIixcblx0ICAgICAgICAgIDM0OiAnXCInLFxuXHQgICAgICAgICAgNDc6IFwiL1wiLFxuXHQgICAgICAgICAgOTg6IFwiXFxiXCIsXG5cdCAgICAgICAgICAxMTY6IFwiXFx0XCIsXG5cdCAgICAgICAgICAxMTA6IFwiXFxuXCIsXG5cdCAgICAgICAgICAxMDI6IFwiXFxmXCIsXG5cdCAgICAgICAgICAxMTQ6IFwiXFxyXCJcblx0ICAgICAgICB9O1xuXG5cdCAgICAgICAgLy8gSW50ZXJuYWw6IFN0b3JlcyB0aGUgcGFyc2VyIHN0YXRlLlxuXHQgICAgICAgIHZhciBJbmRleCwgU291cmNlO1xuXG5cdCAgICAgICAgLy8gSW50ZXJuYWw6IFJlc2V0cyB0aGUgcGFyc2VyIHN0YXRlIGFuZCB0aHJvd3MgYSBgU3ludGF4RXJyb3JgLlxuXHQgICAgICAgIHZhciBhYm9ydCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgIEluZGV4ID0gU291cmNlID0gbnVsbDtcblx0ICAgICAgICAgIHRocm93IFN5bnRheEVycm9yKCk7XG5cdCAgICAgICAgfTtcblxuXHQgICAgICAgIC8vIEludGVybmFsOiBSZXR1cm5zIHRoZSBuZXh0IHRva2VuLCBvciBgXCIkXCJgIGlmIHRoZSBwYXJzZXIgaGFzIHJlYWNoZWRcblx0ICAgICAgICAvLyB0aGUgZW5kIG9mIHRoZSBzb3VyY2Ugc3RyaW5nLiBBIHRva2VuIG1heSBiZSBhIHN0cmluZywgbnVtYmVyLCBgbnVsbGBcblx0ICAgICAgICAvLyBsaXRlcmFsLCBvciBCb29sZWFuIGxpdGVyYWwuXG5cdCAgICAgICAgdmFyIGxleCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgIHZhciBzb3VyY2UgPSBTb3VyY2UsIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGgsIHZhbHVlLCBiZWdpbiwgcG9zaXRpb24sIGlzU2lnbmVkLCBjaGFyQ29kZTtcblx0ICAgICAgICAgIHdoaWxlIChJbmRleCA8IGxlbmd0aCkge1xuXHQgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcblx0ICAgICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xuXHQgICAgICAgICAgICAgIGNhc2UgOTogY2FzZSAxMDogY2FzZSAxMzogY2FzZSAzMjpcblx0ICAgICAgICAgICAgICAgIC8vIFNraXAgd2hpdGVzcGFjZSB0b2tlbnMsIGluY2x1ZGluZyB0YWJzLCBjYXJyaWFnZSByZXR1cm5zLCBsaW5lXG5cdCAgICAgICAgICAgICAgICAvLyBmZWVkcywgYW5kIHNwYWNlIGNoYXJhY3RlcnMuXG5cdCAgICAgICAgICAgICAgICBJbmRleCsrO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgY2FzZSAxMjM6IGNhc2UgMTI1OiBjYXNlIDkxOiBjYXNlIDkzOiBjYXNlIDU4OiBjYXNlIDQ0OlxuXHQgICAgICAgICAgICAgICAgLy8gUGFyc2UgYSBwdW5jdHVhdG9yIHRva2VuIChge2AsIGB9YCwgYFtgLCBgXWAsIGA6YCwgb3IgYCxgKSBhdFxuXHQgICAgICAgICAgICAgICAgLy8gdGhlIGN1cnJlbnQgcG9zaXRpb24uXG5cdCAgICAgICAgICAgICAgICB2YWx1ZSA9IGNoYXJJbmRleEJ1Z2d5ID8gc291cmNlLmNoYXJBdChJbmRleCkgOiBzb3VyY2VbSW5kZXhdO1xuXHQgICAgICAgICAgICAgICAgSW5kZXgrKztcblx0ICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgICAgICAgICAgICBjYXNlIDM0OlxuXHQgICAgICAgICAgICAgICAgLy8gYFwiYCBkZWxpbWl0cyBhIEpTT04gc3RyaW5nOyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNoYXJhY3RlciBhbmRcblx0ICAgICAgICAgICAgICAgIC8vIGJlZ2luIHBhcnNpbmcgdGhlIHN0cmluZy4gU3RyaW5nIHRva2VucyBhcmUgcHJlZml4ZWQgd2l0aCB0aGVcblx0ICAgICAgICAgICAgICAgIC8vIHNlbnRpbmVsIGBAYCBjaGFyYWN0ZXIgdG8gZGlzdGluZ3Vpc2ggdGhlbSBmcm9tIHB1bmN0dWF0b3JzIGFuZFxuXHQgICAgICAgICAgICAgICAgLy8gZW5kLW9mLXN0cmluZyB0b2tlbnMuXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhbHVlID0gXCJAXCIsIEluZGV4Kys7IEluZGV4IDwgbGVuZ3RoOykge1xuXHQgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcblx0ICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlIDwgMzIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAvLyBVbmVzY2FwZWQgQVNDSUkgY29udHJvbCBjaGFyYWN0ZXJzICh0aG9zZSB3aXRoIGEgY29kZSB1bml0XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gbGVzcyB0aGFuIHRoZSBzcGFjZSBjaGFyYWN0ZXIpIGFyZSBub3QgcGVybWl0dGVkLlxuXHQgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG5cdCAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hhckNvZGUgPT0gOTIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAvLyBBIHJldmVyc2Ugc29saWR1cyAoYFxcYCkgbWFya3MgdGhlIGJlZ2lubmluZyBvZiBhbiBlc2NhcGVkXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gY29udHJvbCBjaGFyYWN0ZXIgKGluY2x1ZGluZyBgXCJgLCBgXFxgLCBhbmQgYC9gKSBvciBVbmljb2RlXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gZXNjYXBlIHNlcXVlbmNlLlxuXHQgICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG5cdCAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgY2FzZSA5MjogY2FzZSAzNDogY2FzZSA0NzogY2FzZSA5ODogY2FzZSAxMTY6IGNhc2UgMTEwOiBjYXNlIDEwMjogY2FzZSAxMTQ6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldml2ZSBlc2NhcGVkIGNvbnRyb2wgY2hhcmFjdGVycy5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gVW5lc2NhcGVzW2NoYXJDb2RlXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgSW5kZXgrKztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICAgICAgICBjYXNlIDExNzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gYFxcdWAgbWFya3MgdGhlIGJlZ2lubmluZyBvZiBhIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlLlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHRvIHRoZSBmaXJzdCBjaGFyYWN0ZXIgYW5kIHZhbGlkYXRlIHRoZVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3VyLWRpZ2l0IGNvZGUgcG9pbnQuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJlZ2luID0gKytJbmRleDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChwb3NpdGlvbiA9IEluZGV4ICsgNDsgSW5kZXggPCBwb3NpdGlvbjsgSW5kZXgrKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEEgdmFsaWQgc2VxdWVuY2UgY29tcHJpc2VzIGZvdXIgaGV4ZGlnaXRzIChjYXNlLVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluc2Vuc2l0aXZlKSB0aGF0IGZvcm0gYSBzaW5nbGUgaGV4YWRlY2ltYWwgdmFsdWUuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcgfHwgY2hhckNvZGUgPj0gOTcgJiYgY2hhckNvZGUgPD0gMTAyIHx8IGNoYXJDb2RlID49IDY1ICYmIGNoYXJDb2RlIDw9IDcwKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW52YWxpZCBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZS5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldml2ZSB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IGZyb21DaGFyQ29kZShcIjB4XCIgKyBzb3VyY2Uuc2xpY2UoYmVnaW4sIEluZGV4KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW52YWxpZCBlc2NhcGUgc2VxdWVuY2UuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSAzNCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgLy8gQW4gdW5lc2NhcGVkIGRvdWJsZS1xdW90ZSBjaGFyYWN0ZXIgbWFya3MgdGhlIGVuZCBvZiB0aGVcblx0ICAgICAgICAgICAgICAgICAgICAgIC8vIHN0cmluZy5cblx0ICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcblx0ICAgICAgICAgICAgICAgICAgICBiZWdpbiA9IEluZGV4O1xuXHQgICAgICAgICAgICAgICAgICAgIC8vIE9wdGltaXplIGZvciB0aGUgY29tbW9uIGNhc2Ugd2hlcmUgYSBzdHJpbmcgaXMgdmFsaWQuXG5cdCAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGNoYXJDb2RlID49IDMyICYmIGNoYXJDb2RlICE9IDkyICYmIGNoYXJDb2RlICE9IDM0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAvLyBBcHBlbmQgdGhlIHN0cmluZyBhcy1pcy5cblx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBzb3VyY2Uuc2xpY2UoYmVnaW4sIEluZGV4KTtcblx0ICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KSA9PSAzNCkge1xuXHQgICAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHRvIHRoZSBuZXh0IGNoYXJhY3RlciBhbmQgcmV0dXJuIHRoZSByZXZpdmVkIHN0cmluZy5cblx0ICAgICAgICAgICAgICAgICAgSW5kZXgrKztcblx0ICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgLy8gVW50ZXJtaW5hdGVkIHN0cmluZy5cblx0ICAgICAgICAgICAgICAgIGFib3J0KCk7XG5cdCAgICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgIC8vIFBhcnNlIG51bWJlcnMgYW5kIGxpdGVyYWxzLlxuXHQgICAgICAgICAgICAgICAgYmVnaW4gPSBJbmRleDtcblx0ICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgcGFzdCB0aGUgbmVnYXRpdmUgc2lnbiwgaWYgb25lIGlzIHNwZWNpZmllZC5cblx0ICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSA0NSkge1xuXHQgICAgICAgICAgICAgICAgICBpc1NpZ25lZCA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAvLyBQYXJzZSBhbiBpbnRlZ2VyIG9yIGZsb2F0aW5nLXBvaW50IHZhbHVlLlxuXHQgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KSB7XG5cdCAgICAgICAgICAgICAgICAgIC8vIExlYWRpbmcgemVyb2VzIGFyZSBpbnRlcnByZXRlZCBhcyBvY3RhbCBsaXRlcmFscy5cblx0ICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDQ4ICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCArIDEpKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbCBvY3RhbCBsaXRlcmFsLlxuXHQgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG5cdCAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgaXNTaWduZWQgPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGludGVnZXIgY29tcG9uZW50LlxuXHQgICAgICAgICAgICAgICAgICBmb3IgKDsgSW5kZXggPCBsZW5ndGggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KTsgSW5kZXgrKyk7XG5cdCAgICAgICAgICAgICAgICAgIC8vIEZsb2F0cyBjYW5ub3QgY29udGFpbiBhIGxlYWRpbmcgZGVjaW1hbCBwb2ludDsgaG93ZXZlciwgdGhpc1xuXHQgICAgICAgICAgICAgICAgICAvLyBjYXNlIGlzIGFscmVhZHkgYWNjb3VudGVkIGZvciBieSB0aGUgcGFyc2VyLlxuXHQgICAgICAgICAgICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpID09IDQ2KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSArK0luZGV4O1xuXHQgICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBkZWNpbWFsIGNvbXBvbmVudC5cblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKDsgcG9zaXRpb24gPCBsZW5ndGggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KHBvc2l0aW9uKSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KTsgcG9zaXRpb24rKyk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09IEluZGV4KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsIHRyYWlsaW5nIGRlY2ltYWwuXG5cdCAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBJbmRleCA9IHBvc2l0aW9uO1xuXHQgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIGV4cG9uZW50cy4gVGhlIGBlYCBkZW5vdGluZyB0aGUgZXhwb25lbnQgaXNcblx0ICAgICAgICAgICAgICAgICAgLy8gY2FzZS1pbnNlbnNpdGl2ZS5cblx0ICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG5cdCAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSAxMDEgfHwgY2hhckNvZGUgPT0gNjkpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuXHQgICAgICAgICAgICAgICAgICAgIC8vIFNraXAgcGFzdCB0aGUgc2lnbiBmb2xsb3dpbmcgdGhlIGV4cG9uZW50LCBpZiBvbmUgaXNcblx0ICAgICAgICAgICAgICAgICAgICAvLyBzcGVjaWZpZWQuXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDQzIHx8IGNoYXJDb2RlID09IDQ1KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICBJbmRleCsrO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgZXhwb25lbnRpYWwgY29tcG9uZW50LlxuXHQgICAgICAgICAgICAgICAgICAgIGZvciAocG9zaXRpb24gPSBJbmRleDsgcG9zaXRpb24gPCBsZW5ndGggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KHBvc2l0aW9uKSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KTsgcG9zaXRpb24rKyk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09IEluZGV4KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsIGVtcHR5IGV4cG9uZW50LlxuXHQgICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgSW5kZXggPSBwb3NpdGlvbjtcblx0ICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAvLyBDb2VyY2UgdGhlIHBhcnNlZCB2YWx1ZSB0byBhIEphdmFTY3JpcHQgbnVtYmVyLlxuXHQgICAgICAgICAgICAgICAgICByZXR1cm4gK3NvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgLy8gQSBuZWdhdGl2ZSBzaWduIG1heSBvbmx5IHByZWNlZGUgbnVtYmVycy5cblx0ICAgICAgICAgICAgICAgIGlmIChpc1NpZ25lZCkge1xuXHQgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgLy8gYHRydWVgLCBgZmFsc2VgLCBhbmQgYG51bGxgIGxpdGVyYWxzLlxuXHQgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5zbGljZShJbmRleCwgSW5kZXggKyA0KSA9PSBcInRydWVcIikge1xuXHQgICAgICAgICAgICAgICAgICBJbmRleCArPSA0O1xuXHQgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDUpID09IFwiZmFsc2VcIikge1xuXHQgICAgICAgICAgICAgICAgICBJbmRleCArPSA1O1xuXHQgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZS5zbGljZShJbmRleCwgSW5kZXggKyA0KSA9PSBcIm51bGxcIikge1xuXHQgICAgICAgICAgICAgICAgICBJbmRleCArPSA0O1xuXHQgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIC8vIFVucmVjb2duaXplZCB0b2tlbi5cblx0ICAgICAgICAgICAgICAgIGFib3J0KCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIH1cblx0ICAgICAgICAgIC8vIFJldHVybiB0aGUgc2VudGluZWwgYCRgIGNoYXJhY3RlciBpZiB0aGUgcGFyc2VyIGhhcyByZWFjaGVkIHRoZSBlbmRcblx0ICAgICAgICAgIC8vIG9mIHRoZSBzb3VyY2Ugc3RyaW5nLlxuXHQgICAgICAgICAgcmV0dXJuIFwiJFwiO1xuXHQgICAgICAgIH07XG5cblx0ICAgICAgICAvLyBJbnRlcm5hbDogUGFyc2VzIGEgSlNPTiBgdmFsdWVgIHRva2VuLlxuXHQgICAgICAgIHZhciBnZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICAgIHZhciByZXN1bHRzLCBoYXNNZW1iZXJzO1xuXHQgICAgICAgICAgaWYgKHZhbHVlID09IFwiJFwiKSB7XG5cdCAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgZW5kIG9mIGlucHV0LlxuXHQgICAgICAgICAgICBhYm9ydCgpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgIGlmICgoY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5jaGFyQXQoMCkgOiB2YWx1ZVswXSkgPT0gXCJAXCIpIHtcblx0ICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHNlbnRpbmVsIGBAYCBjaGFyYWN0ZXIuXG5cdCAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnNsaWNlKDEpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIC8vIFBhcnNlIG9iamVjdCBhbmQgYXJyYXkgbGl0ZXJhbHMuXG5cdCAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIltcIikge1xuXHQgICAgICAgICAgICAgIC8vIFBhcnNlcyBhIEpTT04gYXJyYXksIHJldHVybmluZyBhIG5ldyBKYXZhU2NyaXB0IGFycmF5LlxuXHQgICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcblx0ICAgICAgICAgICAgICBmb3IgKDs7IGhhc01lbWJlcnMgfHwgKGhhc01lbWJlcnMgPSB0cnVlKSkge1xuXHQgICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcblx0ICAgICAgICAgICAgICAgIC8vIEEgY2xvc2luZyBzcXVhcmUgYnJhY2tldCBtYXJrcyB0aGUgZW5kIG9mIHRoZSBhcnJheSBsaXRlcmFsLlxuXHQgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiXVwiKSB7XG5cdCAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGFycmF5IGxpdGVyYWwgY29udGFpbnMgZWxlbWVudHMsIHRoZSBjdXJyZW50IHRva2VuXG5cdCAgICAgICAgICAgICAgICAvLyBzaG91bGQgYmUgYSBjb21tYSBzZXBhcmF0aW5nIHRoZSBwcmV2aW91cyBlbGVtZW50IGZyb20gdGhlXG5cdCAgICAgICAgICAgICAgICAvLyBuZXh0LlxuXHQgICAgICAgICAgICAgICAgaWYgKGhhc01lbWJlcnMpIHtcblx0ICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJdXCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgdHJhaWxpbmcgYCxgIGluIGFycmF5IGxpdGVyYWwuXG5cdCAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAvLyBBIGAsYCBtdXN0IHNlcGFyYXRlIGVhY2ggYXJyYXkgZWxlbWVudC5cblx0ICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuXHQgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAvLyBFbGlzaW9ucyBhbmQgbGVhZGluZyBjb21tYXMgYXJlIG5vdCBwZXJtaXR0ZWQuXG5cdCAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIpIHtcblx0ICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChnZXQodmFsdWUpKTtcblx0ICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT0gXCJ7XCIpIHtcblx0ICAgICAgICAgICAgICAvLyBQYXJzZXMgYSBKU09OIG9iamVjdCwgcmV0dXJuaW5nIGEgbmV3IEphdmFTY3JpcHQgb2JqZWN0LlxuXHQgICAgICAgICAgICAgIHJlc3VsdHMgPSB7fTtcblx0ICAgICAgICAgICAgICBmb3IgKDs7IGhhc01lbWJlcnMgfHwgKGhhc01lbWJlcnMgPSB0cnVlKSkge1xuXHQgICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcblx0ICAgICAgICAgICAgICAgIC8vIEEgY2xvc2luZyBjdXJseSBicmFjZSBtYXJrcyB0aGUgZW5kIG9mIHRoZSBvYmplY3QgbGl0ZXJhbC5cblx0ICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIn1cIikge1xuXHQgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIC8vIElmIHRoZSBvYmplY3QgbGl0ZXJhbCBjb250YWlucyBtZW1iZXJzLCB0aGUgY3VycmVudCB0b2tlblxuXHQgICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGEgY29tbWEgc2VwYXJhdG9yLlxuXHQgICAgICAgICAgICAgICAgaWYgKGhhc01lbWJlcnMpIHtcblx0ICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJ9XCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgdHJhaWxpbmcgYCxgIGluIG9iamVjdCBsaXRlcmFsLlxuXHQgICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gQSBgLGAgbXVzdCBzZXBhcmF0ZSBlYWNoIG9iamVjdCBtZW1iZXIuXG5cdCAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcblx0ICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgLy8gTGVhZGluZyBjb21tYXMgYXJlIG5vdCBwZXJtaXR0ZWQsIG9iamVjdCBwcm9wZXJ0eSBuYW1lcyBtdXN0IGJlXG5cdCAgICAgICAgICAgICAgICAvLyBkb3VibGUtcXVvdGVkIHN0cmluZ3MsIGFuZCBhIGA6YCBtdXN0IHNlcGFyYXRlIGVhY2ggcHJvcGVydHlcblx0ICAgICAgICAgICAgICAgIC8vIG5hbWUgYW5kIHZhbHVlLlxuXHQgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiIHx8IHR5cGVvZiB2YWx1ZSAhPSBcInN0cmluZ1wiIHx8IChjaGFySW5kZXhCdWdneSA/IHZhbHVlLmNoYXJBdCgwKSA6IHZhbHVlWzBdKSAhPSBcIkBcIiB8fCBsZXgoKSAhPSBcIjpcIikge1xuXHQgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmVzdWx0c1t2YWx1ZS5zbGljZSgxKV0gPSBnZXQobGV4KCkpO1xuXHQgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRva2VuIGVuY291bnRlcmVkLlxuXHQgICAgICAgICAgICBhYm9ydCgpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuXHQgICAgICAgIH07XG5cblx0ICAgICAgICAvLyBJbnRlcm5hbDogVXBkYXRlcyBhIHRyYXZlcnNlZCBvYmplY3QgbWVtYmVyLlxuXHQgICAgICAgIHZhciB1cGRhdGUgPSBmdW5jdGlvbiAoc291cmNlLCBwcm9wZXJ0eSwgY2FsbGJhY2spIHtcblx0ICAgICAgICAgIHZhciBlbGVtZW50ID0gd2Fsayhzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjayk7XG5cdCAgICAgICAgICBpZiAoZWxlbWVudCA9PT0gdW5kZWYpIHtcblx0ICAgICAgICAgICAgZGVsZXRlIHNvdXJjZVtwcm9wZXJ0eV07XG5cdCAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBzb3VyY2VbcHJvcGVydHldID0gZWxlbWVudDtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9O1xuXG5cdCAgICAgICAgLy8gSW50ZXJuYWw6IFJlY3Vyc2l2ZWx5IHRyYXZlcnNlcyBhIHBhcnNlZCBKU09OIG9iamVjdCwgaW52b2tpbmcgdGhlXG5cdCAgICAgICAgLy8gYGNhbGxiYWNrYCBmdW5jdGlvbiBmb3IgZWFjaCB2YWx1ZS4gVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGVcblx0ICAgICAgICAvLyBgV2Fsayhob2xkZXIsIG5hbWUpYCBvcGVyYXRpb24gZGVmaW5lZCBpbiBFUyA1LjEgc2VjdGlvbiAxNS4xMi4yLlxuXHQgICAgICAgIHZhciB3YWxrID0gZnVuY3Rpb24gKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKSB7XG5cdCAgICAgICAgICB2YXIgdmFsdWUgPSBzb3VyY2VbcHJvcGVydHldLCBsZW5ndGg7XG5cdCAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIgJiYgdmFsdWUpIHtcblx0ICAgICAgICAgICAgLy8gYGZvckVhY2hgIGNhbid0IGJlIHVzZWQgdG8gdHJhdmVyc2UgYW4gYXJyYXkgaW4gT3BlcmEgPD0gOC41NFxuXHQgICAgICAgICAgICAvLyBiZWNhdXNlIGl0cyBgT2JqZWN0I2hhc093blByb3BlcnR5YCBpbXBsZW1lbnRhdGlvbiByZXR1cm5zIGBmYWxzZWBcblx0ICAgICAgICAgICAgLy8gZm9yIGFycmF5IGluZGljZXMgKGUuZy4sIGAhWzEsIDIsIDNdLmhhc093blByb3BlcnR5KFwiMFwiKWApLlxuXHQgICAgICAgICAgICBpZiAoZ2V0Q2xhc3MuY2FsbCh2YWx1ZSkgPT0gYXJyYXlDbGFzcykge1xuXHQgICAgICAgICAgICAgIGZvciAobGVuZ3RoID0gdmFsdWUubGVuZ3RoOyBsZW5ndGgtLTspIHtcblx0ICAgICAgICAgICAgICAgIHVwZGF0ZSh2YWx1ZSwgbGVuZ3RoLCBjYWxsYmFjayk7XG5cdCAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgIGZvckVhY2godmFsdWUsIGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuXHQgICAgICAgICAgICAgICAgdXBkYXRlKHZhbHVlLCBwcm9wZXJ0eSwgY2FsbGJhY2spO1xuXHQgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChzb3VyY2UsIHByb3BlcnR5LCB2YWx1ZSk7XG5cdCAgICAgICAgfTtcblxuXHQgICAgICAgIC8vIFB1YmxpYzogYEpTT04ucGFyc2VgLiBTZWUgRVMgNS4xIHNlY3Rpb24gMTUuMTIuMi5cblx0ICAgICAgICBleHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKHNvdXJjZSwgY2FsbGJhY2spIHtcblx0ICAgICAgICAgIHZhciByZXN1bHQsIHZhbHVlO1xuXHQgICAgICAgICAgSW5kZXggPSAwO1xuXHQgICAgICAgICAgU291cmNlID0gXCJcIiArIHNvdXJjZTtcblx0ICAgICAgICAgIHJlc3VsdCA9IGdldChsZXgoKSk7XG5cdCAgICAgICAgICAvLyBJZiBhIEpTT04gc3RyaW5nIGNvbnRhaW5zIG11bHRpcGxlIHRva2VucywgaXQgaXMgaW52YWxpZC5cblx0ICAgICAgICAgIGlmIChsZXgoKSAhPSBcIiRcIikge1xuXHQgICAgICAgICAgICBhYm9ydCgpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgLy8gUmVzZXQgdGhlIHBhcnNlciBzdGF0ZS5cblx0ICAgICAgICAgIEluZGV4ID0gU291cmNlID0gbnVsbDtcblx0ICAgICAgICAgIHJldHVybiBjYWxsYmFjayAmJiBnZXRDbGFzcy5jYWxsKGNhbGxiYWNrKSA9PSBmdW5jdGlvbkNsYXNzID8gd2FsaygodmFsdWUgPSB7fSwgdmFsdWVbXCJcIl0gPSByZXN1bHQsIHZhbHVlKSwgXCJcIiwgY2FsbGJhY2spIDogcmVzdWx0O1xuXHQgICAgICAgIH07XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgZXhwb3J0c1tcInJ1bkluQ29udGV4dFwiXSA9IHJ1bkluQ29udGV4dDtcblx0ICAgIHJldHVybiBleHBvcnRzO1xuXHQgIH1cblxuXHQgIGlmIChmcmVlRXhwb3J0cyAmJiAhaXNMb2FkZXIpIHtcblx0ICAgIC8vIEV4cG9ydCBmb3IgQ29tbW9uSlMgZW52aXJvbm1lbnRzLlxuXHQgICAgcnVuSW5Db250ZXh0KHJvb3QsIGZyZWVFeHBvcnRzKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgLy8gRXhwb3J0IGZvciB3ZWIgYnJvd3NlcnMgYW5kIEphdmFTY3JpcHQgZW5naW5lcy5cblx0ICAgIHZhciBuYXRpdmVKU09OID0gcm9vdC5KU09OLFxuXHQgICAgICAgIHByZXZpb3VzSlNPTiA9IHJvb3RbXCJKU09OM1wiXSxcblx0ICAgICAgICBpc1Jlc3RvcmVkID0gZmFsc2U7XG5cblx0ICAgIHZhciBKU09OMyA9IHJ1bkluQ29udGV4dChyb290LCAocm9vdFtcIkpTT04zXCJdID0ge1xuXHQgICAgICAvLyBQdWJsaWM6IFJlc3RvcmVzIHRoZSBvcmlnaW5hbCB2YWx1ZSBvZiB0aGUgZ2xvYmFsIGBKU09OYCBvYmplY3QgYW5kXG5cdCAgICAgIC8vIHJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIGBKU09OM2Agb2JqZWN0LlxuXHQgICAgICBcIm5vQ29uZmxpY3RcIjogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGlmICghaXNSZXN0b3JlZCkge1xuXHQgICAgICAgICAgaXNSZXN0b3JlZCA9IHRydWU7XG5cdCAgICAgICAgICByb290LkpTT04gPSBuYXRpdmVKU09OO1xuXHQgICAgICAgICAgcm9vdFtcIkpTT04zXCJdID0gcHJldmlvdXNKU09OO1xuXHQgICAgICAgICAgbmF0aXZlSlNPTiA9IHByZXZpb3VzSlNPTiA9IG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBKU09OMztcblx0ICAgICAgfVxuXHQgICAgfSkpO1xuXG5cdCAgICByb290LkpTT04gPSB7XG5cdCAgICAgIFwicGFyc2VcIjogSlNPTjMucGFyc2UsXG5cdCAgICAgIFwic3RyaW5naWZ5XCI6IEpTT04zLnN0cmluZ2lmeVxuXHQgICAgfTtcblx0ICB9XG5cblx0ICAvLyBFeHBvcnQgZm9yIGFzeW5jaHJvbm91cyBtb2R1bGUgbG9hZGVycy5cblx0ICBpZiAoaXNMb2FkZXIpIHtcblx0ICAgICEoX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHJldHVybiBKU09OMztcblx0ICAgIH0uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fLCBleHBvcnRzLCBtb2R1bGUpLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cdCAgfVxuXHR9KS5jYWxsKHRoaXMpO1xuXG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpKG1vZHVsZSksIChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0oKSkpKVxuXG4vKioqLyB9LFxuLyogOCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRcdGlmKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XHJcblx0XHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xyXG5cdFx0XHRtb2R1bGUucGF0aHMgPSBbXTtcclxuXHRcdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XHJcblx0XHRcdG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBtb2R1bGU7XHJcblx0fVxyXG5cblxuLyoqKi8gfSxcbi8qIDkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihfX3dlYnBhY2tfYW1kX29wdGlvbnNfXykge21vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX2FtZF9vcHRpb25zX187XHJcblxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywge30pKVxuXG4vKioqLyB9LFxuLyogMTAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdG1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG5cdCAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG5cdH07XG5cblxuLyoqKi8gfSxcbi8qIDExICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRcblx0LyoqXG5cdCAqIEV4cG9zZSBgRW1pdHRlcmAuXG5cdCAqL1xuXG5cdG1vZHVsZS5leHBvcnRzID0gRW1pdHRlcjtcblxuXHQvKipcblx0ICogSW5pdGlhbGl6ZSBhIG5ldyBgRW1pdHRlcmAuXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIEVtaXR0ZXIob2JqKSB7XG5cdCAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XG5cdH07XG5cblx0LyoqXG5cdCAqIE1peGluIHRoZSBlbWl0dGVyIHByb3BlcnRpZXMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcblx0ICogQHJldHVybiB7T2JqZWN0fVxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0ZnVuY3Rpb24gbWl4aW4ob2JqKSB7XG5cdCAgZm9yICh2YXIga2V5IGluIEVtaXR0ZXIucHJvdG90eXBlKSB7XG5cdCAgICBvYmpba2V5XSA9IEVtaXR0ZXIucHJvdG90eXBlW2tleV07XG5cdCAgfVxuXHQgIHJldHVybiBvYmo7XG5cdH1cblxuXHQvKipcblx0ICogTGlzdGVuIG9uIHRoZSBnaXZlbiBgZXZlbnRgIHdpdGggYGZuYC5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG5cdCAqIEByZXR1cm4ge0VtaXR0ZXJ9XG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdEVtaXR0ZXIucHJvdG90eXBlLm9uID1cblx0RW1pdHRlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG5cdCAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuXHQgICh0aGlzLl9jYWxsYmFja3NbZXZlbnRdID0gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XSB8fCBbXSlcblx0ICAgIC5wdXNoKGZuKTtcblx0ICByZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogQWRkcyBhbiBgZXZlbnRgIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBpbnZva2VkIGEgc2luZ2xlXG5cdCAqIHRpbWUgdGhlbiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuXHQgKiBAcmV0dXJuIHtFbWl0dGVyfVxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcblx0ICB2YXIgc2VsZiA9IHRoaXM7XG5cdCAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuXG5cdCAgZnVuY3Rpb24gb24oKSB7XG5cdCAgICBzZWxmLm9mZihldmVudCwgb24pO1xuXHQgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICB9XG5cblx0ICBvbi5mbiA9IGZuO1xuXHQgIHRoaXMub24oZXZlbnQsIG9uKTtcblx0ICByZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogUmVtb3ZlIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgYGV2ZW50YCBvciBhbGxcblx0ICogcmVnaXN0ZXJlZCBjYWxsYmFja3MuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuXHQgKiBAcmV0dXJuIHtFbWl0dGVyfVxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPVxuXHRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG5cdEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG5cdEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuXHQgIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcblxuXHQgIC8vIGFsbFxuXHQgIGlmICgwID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcblx0ICAgIHRoaXMuX2NhbGxiYWNrcyA9IHt9O1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfVxuXG5cdCAgLy8gc3BlY2lmaWMgZXZlbnRcblx0ICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XTtcblx0ICBpZiAoIWNhbGxiYWNrcykgcmV0dXJuIHRoaXM7XG5cblx0ICAvLyByZW1vdmUgYWxsIGhhbmRsZXJzXG5cdCAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuXHQgICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1tldmVudF07XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9XG5cblx0ICAvLyByZW1vdmUgc3BlY2lmaWMgaGFuZGxlclxuXHQgIHZhciBjYjtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuXHQgICAgY2IgPSBjYWxsYmFja3NbaV07XG5cdCAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xuXHQgICAgICBjYWxsYmFja3Muc3BsaWNlKGksIDEpO1xuXHQgICAgICBicmVhaztcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEVtaXQgYGV2ZW50YCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcblx0ICogQHBhcmFtIHtNaXhlZH0gLi4uXG5cdCAqIEByZXR1cm4ge0VtaXR0ZXJ9XG5cdCAqL1xuXG5cdEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldmVudCl7XG5cdCAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuXHQgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXG5cdCAgICAsIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1tldmVudF07XG5cblx0ICBpZiAoY2FsbGJhY2tzKSB7XG5cdCAgICBjYWxsYmFja3MgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG5cdCAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG5cdCAgICAgIGNhbGxiYWNrc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICByZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJuIGFycmF5IG9mIGNhbGxiYWNrcyBmb3IgYGV2ZW50YC5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG5cdCAqIEByZXR1cm4ge0FycmF5fVxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XG5cdCAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuXHQgIHJldHVybiB0aGlzLl9jYWxsYmFja3NbZXZlbnRdIHx8IFtdO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDaGVjayBpZiB0aGlzIGVtaXR0ZXIgaGFzIGBldmVudGAgaGFuZGxlcnMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRFbWl0dGVyLnByb3RvdHlwZS5oYXNMaXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XG5cdCAgcmV0dXJuICEhIHRoaXMubGlzdGVuZXJzKGV2ZW50KS5sZW5ndGg7XG5cdH07XG5cblxuLyoqKi8gfSxcbi8qIDEyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7LypnbG9iYWwgQmxvYixGaWxlKi9cblxuXHQvKipcblx0ICogTW9kdWxlIHJlcXVpcmVtZW50c1xuXHQgKi9cblxuXHR2YXIgaXNBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xuXHR2YXIgaXNCdWYgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcblxuXHQvKipcblx0ICogUmVwbGFjZXMgZXZlcnkgQnVmZmVyIHwgQXJyYXlCdWZmZXIgaW4gcGFja2V0IHdpdGggYSBudW1iZXJlZCBwbGFjZWhvbGRlci5cblx0ICogQW55dGhpbmcgd2l0aCBibG9icyBvciBmaWxlcyBzaG91bGQgYmUgZmVkIHRocm91Z2ggcmVtb3ZlQmxvYnMgYmVmb3JlIGNvbWluZ1xuXHQgKiBoZXJlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcGFja2V0IC0gc29ja2V0LmlvIGV2ZW50IHBhY2tldFxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IHdpdGggZGVjb25zdHJ1Y3RlZCBwYWNrZXQgYW5kIGxpc3Qgb2YgYnVmZmVyc1xuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRleHBvcnRzLmRlY29uc3RydWN0UGFja2V0ID0gZnVuY3Rpb24ocGFja2V0KXtcblx0ICB2YXIgYnVmZmVycyA9IFtdO1xuXHQgIHZhciBwYWNrZXREYXRhID0gcGFja2V0LmRhdGE7XG5cblx0ICBmdW5jdGlvbiBfZGVjb25zdHJ1Y3RQYWNrZXQoZGF0YSkge1xuXHQgICAgaWYgKCFkYXRhKSByZXR1cm4gZGF0YTtcblxuXHQgICAgaWYgKGlzQnVmKGRhdGEpKSB7XG5cdCAgICAgIHZhciBwbGFjZWhvbGRlciA9IHsgX3BsYWNlaG9sZGVyOiB0cnVlLCBudW06IGJ1ZmZlcnMubGVuZ3RoIH07XG5cdCAgICAgIGJ1ZmZlcnMucHVzaChkYXRhKTtcblx0ICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyO1xuXHQgICAgfSBlbHNlIGlmIChpc0FycmF5KGRhdGEpKSB7XG5cdCAgICAgIHZhciBuZXdEYXRhID0gbmV3IEFycmF5KGRhdGEubGVuZ3RoKTtcblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgbmV3RGF0YVtpXSA9IF9kZWNvbnN0cnVjdFBhY2tldChkYXRhW2ldKTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gbmV3RGF0YTtcblx0ICAgIH0gZWxzZSBpZiAoJ29iamVjdCcgPT0gdHlwZW9mIGRhdGEgJiYgIShkYXRhIGluc3RhbmNlb2YgRGF0ZSkpIHtcblx0ICAgICAgdmFyIG5ld0RhdGEgPSB7fTtcblx0ICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcblx0ICAgICAgICBuZXdEYXRhW2tleV0gPSBfZGVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtrZXldKTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gbmV3RGF0YTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBkYXRhO1xuXHQgIH1cblxuXHQgIHZhciBwYWNrID0gcGFja2V0O1xuXHQgIHBhY2suZGF0YSA9IF9kZWNvbnN0cnVjdFBhY2tldChwYWNrZXREYXRhKTtcblx0ICBwYWNrLmF0dGFjaG1lbnRzID0gYnVmZmVycy5sZW5ndGg7IC8vIG51bWJlciBvZiBiaW5hcnkgJ2F0dGFjaG1lbnRzJ1xuXHQgIHJldHVybiB7cGFja2V0OiBwYWNrLCBidWZmZXJzOiBidWZmZXJzfTtcblx0fTtcblxuXHQvKipcblx0ICogUmVjb25zdHJ1Y3RzIGEgYmluYXJ5IHBhY2tldCBmcm9tIGl0cyBwbGFjZWhvbGRlciBwYWNrZXQgYW5kIGJ1ZmZlcnNcblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCAtIGV2ZW50IHBhY2tldCB3aXRoIHBsYWNlaG9sZGVyc1xuXHQgKiBAcGFyYW0ge0FycmF5fSBidWZmZXJzIC0gYmluYXJ5IGJ1ZmZlcnMgdG8gcHV0IGluIHBsYWNlaG9sZGVyIHBvc2l0aW9uc1xuXHQgKiBAcmV0dXJuIHtPYmplY3R9IHJlY29uc3RydWN0ZWQgcGFja2V0XG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGV4cG9ydHMucmVjb25zdHJ1Y3RQYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQsIGJ1ZmZlcnMpIHtcblx0ICB2YXIgY3VyUGxhY2VIb2xkZXIgPSAwO1xuXG5cdCAgZnVuY3Rpb24gX3JlY29uc3RydWN0UGFja2V0KGRhdGEpIHtcblx0ICAgIGlmIChkYXRhICYmIGRhdGEuX3BsYWNlaG9sZGVyKSB7XG5cdCAgICAgIHZhciBidWYgPSBidWZmZXJzW2RhdGEubnVtXTsgLy8gYXBwcm9wcmlhdGUgYnVmZmVyIChzaG91bGQgYmUgbmF0dXJhbCBvcmRlciBhbnl3YXkpXG5cdCAgICAgIHJldHVybiBidWY7XG5cdCAgICB9IGVsc2UgaWYgKGlzQXJyYXkoZGF0YSkpIHtcblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgZGF0YVtpXSA9IF9yZWNvbnN0cnVjdFBhY2tldChkYXRhW2ldKTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gZGF0YTtcblx0ICAgIH0gZWxzZSBpZiAoZGF0YSAmJiAnb2JqZWN0JyA9PSB0eXBlb2YgZGF0YSkge1xuXHQgICAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuXHQgICAgICAgIGRhdGFba2V5XSA9IF9yZWNvbnN0cnVjdFBhY2tldChkYXRhW2tleV0pO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBkYXRhO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGRhdGE7XG5cdCAgfVxuXG5cdCAgcGFja2V0LmRhdGEgPSBfcmVjb25zdHJ1Y3RQYWNrZXQocGFja2V0LmRhdGEpO1xuXHQgIHBhY2tldC5hdHRhY2htZW50cyA9IHVuZGVmaW5lZDsgLy8gbm8gbG9uZ2VyIHVzZWZ1bFxuXHQgIHJldHVybiBwYWNrZXQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFzeW5jaHJvbm91c2x5IHJlbW92ZXMgQmxvYnMgb3IgRmlsZXMgZnJvbSBkYXRhIHZpYVxuXHQgKiBGaWxlUmVhZGVyJ3MgcmVhZEFzQXJyYXlCdWZmZXIgbWV0aG9kLiBVc2VkIGJlZm9yZSBlbmNvZGluZ1xuXHQgKiBkYXRhIGFzIG1zZ3BhY2suIENhbGxzIGNhbGxiYWNrIHdpdGggdGhlIGJsb2JsZXNzIGRhdGEuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRleHBvcnRzLnJlbW92ZUJsb2JzID0gZnVuY3Rpb24oZGF0YSwgY2FsbGJhY2spIHtcblx0ICBmdW5jdGlvbiBfcmVtb3ZlQmxvYnMob2JqLCBjdXJLZXksIGNvbnRhaW5pbmdPYmplY3QpIHtcblx0ICAgIGlmICghb2JqKSByZXR1cm4gb2JqO1xuXG5cdCAgICAvLyBjb252ZXJ0IGFueSBibG9iXG5cdCAgICBpZiAoKGdsb2JhbC5CbG9iICYmIG9iaiBpbnN0YW5jZW9mIEJsb2IpIHx8XG5cdCAgICAgICAgKGdsb2JhbC5GaWxlICYmIG9iaiBpbnN0YW5jZW9mIEZpbGUpKSB7XG5cdCAgICAgIHBlbmRpbmdCbG9icysrO1xuXG5cdCAgICAgIC8vIGFzeW5jIGZpbGVyZWFkZXJcblx0ICAgICAgdmFyIGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXHQgICAgICBmaWxlUmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkgeyAvLyB0aGlzLnJlc3VsdCA9PSBhcnJheWJ1ZmZlclxuXHQgICAgICAgIGlmIChjb250YWluaW5nT2JqZWN0KSB7XG5cdCAgICAgICAgICBjb250YWluaW5nT2JqZWN0W2N1cktleV0gPSB0aGlzLnJlc3VsdDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICBibG9ibGVzc0RhdGEgPSB0aGlzLnJlc3VsdDtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBpZiBub3RoaW5nIHBlbmRpbmcgaXRzIGNhbGxiYWNrIHRpbWVcblx0ICAgICAgICBpZighIC0tcGVuZGluZ0Jsb2JzKSB7XG5cdCAgICAgICAgICBjYWxsYmFjayhibG9ibGVzc0RhdGEpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfTtcblxuXHQgICAgICBmaWxlUmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKG9iaik7IC8vIGJsb2IgLT4gYXJyYXlidWZmZXJcblx0ICAgIH0gZWxzZSBpZiAoaXNBcnJheShvYmopKSB7IC8vIGhhbmRsZSBhcnJheVxuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIF9yZW1vdmVCbG9icyhvYmpbaV0sIGksIG9iaik7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSBpZiAob2JqICYmICdvYmplY3QnID09IHR5cGVvZiBvYmogJiYgIWlzQnVmKG9iaikpIHsgLy8gYW5kIG9iamVjdFxuXHQgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG5cdCAgICAgICAgX3JlbW92ZUJsb2JzKG9ialtrZXldLCBrZXksIG9iaik7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cblx0ICB2YXIgcGVuZGluZ0Jsb2JzID0gMDtcblx0ICB2YXIgYmxvYmxlc3NEYXRhID0gZGF0YTtcblx0ICBfcmVtb3ZlQmxvYnMoYmxvYmxlc3NEYXRhKTtcblx0ICBpZiAoIXBlbmRpbmdCbG9icykge1xuXHQgICAgY2FsbGJhY2soYmxvYmxlc3NEYXRhKTtcblx0ICB9XG5cdH07XG5cblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0oKSkpKVxuXG4vKioqLyB9LFxuLyogMTMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHtcblx0bW9kdWxlLmV4cG9ydHMgPSBpc0J1ZjtcblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIG9iaiBpcyBhIGJ1ZmZlciBvciBhbiBhcnJheWJ1ZmZlci5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIGlzQnVmKG9iaikge1xuXHQgIHJldHVybiAoZ2xvYmFsLkJ1ZmZlciAmJiBnbG9iYWwuQnVmZmVyLmlzQnVmZmVyKG9iaikpIHx8XG5cdCAgICAgICAgIChnbG9iYWwuQXJyYXlCdWZmZXIgJiYgb2JqIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpO1xuXHR9XG5cblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0oKSkpKVxuXG4vKioqLyB9LFxuLyogMTQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cblx0LyoqXG5cdCAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG5cdCAqL1xuXG5cdHZhciBlaW8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcblx0dmFyIFNvY2tldCA9IF9fd2VicGFja19yZXF1aXJlX18oNDIpO1xuXHR2YXIgRW1pdHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oNDMpO1xuXHR2YXIgcGFyc2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblx0dmFyIG9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NSk7XG5cdHZhciBiaW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Nik7XG5cdHZhciBkZWJ1ZyA9IF9fd2VicGFja19yZXF1aXJlX18oMykoJ3NvY2tldC5pby1jbGllbnQ6bWFuYWdlcicpO1xuXHR2YXIgaW5kZXhPZiA9IF9fd2VicGFja19yZXF1aXJlX18oNDApO1xuXHR2YXIgQmFja29mZiA9IF9fd2VicGFja19yZXF1aXJlX18oNDkpO1xuXG5cdC8qKlxuXHQgKiBJRTYrIGhhc093blByb3BlcnR5XG5cdCAqL1xuXG5cdHZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5cdC8qKlxuXHQgKiBNb2R1bGUgZXhwb3J0c1xuXHQgKi9cblxuXHRtb2R1bGUuZXhwb3J0cyA9IE1hbmFnZXI7XG5cblx0LyoqXG5cdCAqIGBNYW5hZ2VyYCBjb25zdHJ1Y3Rvci5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IGVuZ2luZSBpbnN0YW5jZSBvciBlbmdpbmUgdXJpL29wdHNcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZnVuY3Rpb24gTWFuYWdlcih1cmksIG9wdHMpIHtcblx0ICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTWFuYWdlcikpIHJldHVybiBuZXcgTWFuYWdlcih1cmksIG9wdHMpO1xuXHQgIGlmICh1cmkgJiYgJ29iamVjdCcgPT09ICh0eXBlb2YgdXJpID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih1cmkpKSkge1xuXHQgICAgb3B0cyA9IHVyaTtcblx0ICAgIHVyaSA9IHVuZGVmaW5lZDtcblx0ICB9XG5cdCAgb3B0cyA9IG9wdHMgfHwge307XG5cblx0ICBvcHRzLnBhdGggPSBvcHRzLnBhdGggfHwgJy9zb2NrZXQuaW8nO1xuXHQgIHRoaXMubnNwcyA9IHt9O1xuXHQgIHRoaXMuc3VicyA9IFtdO1xuXHQgIHRoaXMub3B0cyA9IG9wdHM7XG5cdCAgdGhpcy5yZWNvbm5lY3Rpb24ob3B0cy5yZWNvbm5lY3Rpb24gIT09IGZhbHNlKTtcblx0ICB0aGlzLnJlY29ubmVjdGlvbkF0dGVtcHRzKG9wdHMucmVjb25uZWN0aW9uQXR0ZW1wdHMgfHwgSW5maW5pdHkpO1xuXHQgIHRoaXMucmVjb25uZWN0aW9uRGVsYXkob3B0cy5yZWNvbm5lY3Rpb25EZWxheSB8fCAxMDAwKTtcblx0ICB0aGlzLnJlY29ubmVjdGlvbkRlbGF5TWF4KG9wdHMucmVjb25uZWN0aW9uRGVsYXlNYXggfHwgNTAwMCk7XG5cdCAgdGhpcy5yYW5kb21pemF0aW9uRmFjdG9yKG9wdHMucmFuZG9taXphdGlvbkZhY3RvciB8fCAwLjUpO1xuXHQgIHRoaXMuYmFja29mZiA9IG5ldyBCYWNrb2ZmKHtcblx0ICAgIG1pbjogdGhpcy5yZWNvbm5lY3Rpb25EZWxheSgpLFxuXHQgICAgbWF4OiB0aGlzLnJlY29ubmVjdGlvbkRlbGF5TWF4KCksXG5cdCAgICBqaXR0ZXI6IHRoaXMucmFuZG9taXphdGlvbkZhY3RvcigpXG5cdCAgfSk7XG5cdCAgdGhpcy50aW1lb3V0KG51bGwgPT0gb3B0cy50aW1lb3V0ID8gMjAwMDAgOiBvcHRzLnRpbWVvdXQpO1xuXHQgIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuXHQgIHRoaXMudXJpID0gdXJpO1xuXHQgIHRoaXMuY29ubmVjdGluZyA9IFtdO1xuXHQgIHRoaXMubGFzdFBpbmcgPSBudWxsO1xuXHQgIHRoaXMuZW5jb2RpbmcgPSBmYWxzZTtcblx0ICB0aGlzLnBhY2tldEJ1ZmZlciA9IFtdO1xuXHQgIHRoaXMuZW5jb2RlciA9IG5ldyBwYXJzZXIuRW5jb2RlcigpO1xuXHQgIHRoaXMuZGVjb2RlciA9IG5ldyBwYXJzZXIuRGVjb2RlcigpO1xuXHQgIHRoaXMuYXV0b0Nvbm5lY3QgPSBvcHRzLmF1dG9Db25uZWN0ICE9PSBmYWxzZTtcblx0ICBpZiAodGhpcy5hdXRvQ29ubmVjdCkgdGhpcy5vcGVuKCk7XG5cdH1cblxuXHQvKipcblx0ICogUHJvcGFnYXRlIGdpdmVuIGV2ZW50IHRvIHNvY2tldHMgYW5kIGVtaXQgb24gYHRoaXNgXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRNYW5hZ2VyLnByb3RvdHlwZS5lbWl0QWxsID0gZnVuY3Rpb24gKCkge1xuXHQgIHRoaXMuZW1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgIGZvciAodmFyIG5zcCBpbiB0aGlzLm5zcHMpIHtcblx0ICAgIGlmIChoYXMuY2FsbCh0aGlzLm5zcHMsIG5zcCkpIHtcblx0ICAgICAgdGhpcy5uc3BzW25zcF0uZW1pdC5hcHBseSh0aGlzLm5zcHNbbnNwXSwgYXJndW1lbnRzKTtcblx0ICAgIH1cblx0ICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIFVwZGF0ZSBgc29ja2V0LmlkYCBvZiBhbGwgc29ja2V0c1xuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0TWFuYWdlci5wcm90b3R5cGUudXBkYXRlU29ja2V0SWRzID0gZnVuY3Rpb24gKCkge1xuXHQgIGZvciAodmFyIG5zcCBpbiB0aGlzLm5zcHMpIHtcblx0ICAgIGlmIChoYXMuY2FsbCh0aGlzLm5zcHMsIG5zcCkpIHtcblx0ICAgICAgdGhpcy5uc3BzW25zcF0uaWQgPSB0aGlzLmVuZ2luZS5pZDtcblx0ICAgIH1cblx0ICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIE1peCBpbiBgRW1pdHRlcmAuXG5cdCAqL1xuXG5cdEVtaXR0ZXIoTWFuYWdlci5wcm90b3R5cGUpO1xuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBgcmVjb25uZWN0aW9uYCBjb25maWcuXG5cdCAqXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gdHJ1ZS9mYWxzZSBpZiBpdCBzaG91bGQgYXV0b21hdGljYWxseSByZWNvbm5lY3Rcblx0ICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRNYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb24gPSBmdW5jdGlvbiAodikge1xuXHQgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbjtcblx0ICB0aGlzLl9yZWNvbm5lY3Rpb24gPSAhIXY7XG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHJlY29ubmVjdGlvbiBhdHRlbXB0cyBjb25maWcuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBtYXggcmVjb25uZWN0aW9uIGF0dGVtcHRzIGJlZm9yZSBnaXZpbmcgdXBcblx0ICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRNYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb25BdHRlbXB0cyA9IGZ1bmN0aW9uICh2KSB7XG5cdCAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmVjb25uZWN0aW9uQXR0ZW1wdHM7XG5cdCAgdGhpcy5fcmVjb25uZWN0aW9uQXR0ZW1wdHMgPSB2O1xuXHQgIHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBkZWxheSBiZXR3ZWVuIHJlY29ubmVjdGlvbnMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheVxuXHQgKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdE1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbkRlbGF5ID0gZnVuY3Rpb24gKHYpIHtcblx0ICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheTtcblx0ICB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheSA9IHY7XG5cdCAgdGhpcy5iYWNrb2ZmICYmIHRoaXMuYmFja29mZi5zZXRNaW4odik7XG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cblx0TWFuYWdlci5wcm90b3R5cGUucmFuZG9taXphdGlvbkZhY3RvciA9IGZ1bmN0aW9uICh2KSB7XG5cdCAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmFuZG9taXphdGlvbkZhY3Rvcjtcblx0ICB0aGlzLl9yYW5kb21pemF0aW9uRmFjdG9yID0gdjtcblx0ICB0aGlzLmJhY2tvZmYgJiYgdGhpcy5iYWNrb2ZmLnNldEppdHRlcih2KTtcblx0ICByZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogU2V0cyB0aGUgbWF4aW11bSBkZWxheSBiZXR3ZWVuIHJlY29ubmVjdGlvbnMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheVxuXHQgKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdE1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbkRlbGF5TWF4ID0gZnVuY3Rpb24gKHYpIHtcblx0ICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheU1heDtcblx0ICB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheU1heCA9IHY7XG5cdCAgdGhpcy5iYWNrb2ZmICYmIHRoaXMuYmFja29mZi5zZXRNYXgodik7XG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGNvbm5lY3Rpb24gdGltZW91dC4gYGZhbHNlYCB0byBkaXNhYmxlXG5cdCAqXG5cdCAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0TWFuYWdlci5wcm90b3R5cGUudGltZW91dCA9IGZ1bmN0aW9uICh2KSB7XG5cdCAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fdGltZW91dDtcblx0ICB0aGlzLl90aW1lb3V0ID0gdjtcblx0ICByZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogU3RhcnRzIHRyeWluZyB0byByZWNvbm5lY3QgaWYgcmVjb25uZWN0aW9uIGlzIGVuYWJsZWQgYW5kIHdlIGhhdmUgbm90XG5cdCAqIHN0YXJ0ZWQgcmVjb25uZWN0aW5nIHlldFxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0TWFuYWdlci5wcm90b3R5cGUubWF5YmVSZWNvbm5lY3RPbk9wZW4gPSBmdW5jdGlvbiAoKSB7XG5cdCAgLy8gT25seSB0cnkgdG8gcmVjb25uZWN0IGlmIGl0J3MgdGhlIGZpcnN0IHRpbWUgd2UncmUgY29ubmVjdGluZ1xuXHQgIGlmICghdGhpcy5yZWNvbm5lY3RpbmcgJiYgdGhpcy5fcmVjb25uZWN0aW9uICYmIHRoaXMuYmFja29mZi5hdHRlbXB0cyA9PT0gMCkge1xuXHQgICAgLy8ga2VlcHMgcmVjb25uZWN0aW9uIGZyb20gZmlyaW5nIHR3aWNlIGZvciB0aGUgc2FtZSByZWNvbm5lY3Rpb24gbG9vcFxuXHQgICAgdGhpcy5yZWNvbm5lY3QoKTtcblx0ICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGN1cnJlbnQgdHJhbnNwb3J0IGBzb2NrZXRgLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25hbCwgY2FsbGJhY2tcblx0ICogQHJldHVybiB7TWFuYWdlcn0gc2VsZlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRNYW5hZ2VyLnByb3RvdHlwZS5vcGVuID0gTWFuYWdlci5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uIChmbiwgb3B0cykge1xuXHQgIGRlYnVnKCdyZWFkeVN0YXRlICVzJywgdGhpcy5yZWFkeVN0YXRlKTtcblx0ICBpZiAofnRoaXMucmVhZHlTdGF0ZS5pbmRleE9mKCdvcGVuJykpIHJldHVybiB0aGlzO1xuXG5cdCAgZGVidWcoJ29wZW5pbmcgJXMnLCB0aGlzLnVyaSk7XG5cdCAgdGhpcy5lbmdpbmUgPSBlaW8odGhpcy51cmksIHRoaXMub3B0cyk7XG5cdCAgdmFyIHNvY2tldCA9IHRoaXMuZW5naW5lO1xuXHQgIHZhciBzZWxmID0gdGhpcztcblx0ICB0aGlzLnJlYWR5U3RhdGUgPSAnb3BlbmluZyc7XG5cdCAgdGhpcy5za2lwUmVjb25uZWN0ID0gZmFsc2U7XG5cblx0ICAvLyBlbWl0IGBvcGVuYFxuXHQgIHZhciBvcGVuU3ViID0gb24oc29ja2V0LCAnb3BlbicsIGZ1bmN0aW9uICgpIHtcblx0ICAgIHNlbGYub25vcGVuKCk7XG5cdCAgICBmbiAmJiBmbigpO1xuXHQgIH0pO1xuXG5cdCAgLy8gZW1pdCBgY29ubmVjdF9lcnJvcmBcblx0ICB2YXIgZXJyb3JTdWIgPSBvbihzb2NrZXQsICdlcnJvcicsIGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgICBkZWJ1ZygnY29ubmVjdF9lcnJvcicpO1xuXHQgICAgc2VsZi5jbGVhbnVwKCk7XG5cdCAgICBzZWxmLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcblx0ICAgIHNlbGYuZW1pdEFsbCgnY29ubmVjdF9lcnJvcicsIGRhdGEpO1xuXHQgICAgaWYgKGZuKSB7XG5cdCAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ0Nvbm5lY3Rpb24gZXJyb3InKTtcblx0ICAgICAgZXJyLmRhdGEgPSBkYXRhO1xuXHQgICAgICBmbihlcnIpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgLy8gT25seSBkbyB0aGlzIGlmIHRoZXJlIGlzIG5vIGZuIHRvIGhhbmRsZSB0aGUgZXJyb3Jcblx0ICAgICAgc2VsZi5tYXliZVJlY29ubmVjdE9uT3BlbigpO1xuXHQgICAgfVxuXHQgIH0pO1xuXG5cdCAgLy8gZW1pdCBgY29ubmVjdF90aW1lb3V0YFxuXHQgIGlmIChmYWxzZSAhPT0gdGhpcy5fdGltZW91dCkge1xuXHQgICAgdmFyIHRpbWVvdXQgPSB0aGlzLl90aW1lb3V0O1xuXHQgICAgZGVidWcoJ2Nvbm5lY3QgYXR0ZW1wdCB3aWxsIHRpbWVvdXQgYWZ0ZXIgJWQnLCB0aW1lb3V0KTtcblxuXHQgICAgLy8gc2V0IHRpbWVyXG5cdCAgICB2YXIgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgZGVidWcoJ2Nvbm5lY3QgYXR0ZW1wdCB0aW1lZCBvdXQgYWZ0ZXIgJWQnLCB0aW1lb3V0KTtcblx0ICAgICAgb3BlblN1Yi5kZXN0cm95KCk7XG5cdCAgICAgIHNvY2tldC5jbG9zZSgpO1xuXHQgICAgICBzb2NrZXQuZW1pdCgnZXJyb3InLCAndGltZW91dCcpO1xuXHQgICAgICBzZWxmLmVtaXRBbGwoJ2Nvbm5lY3RfdGltZW91dCcsIHRpbWVvdXQpO1xuXHQgICAgfSwgdGltZW91dCk7XG5cblx0ICAgIHRoaXMuc3Vicy5wdXNoKHtcblx0ICAgICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcblx0ICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuXHQgICAgICB9XG5cdCAgICB9KTtcblx0ICB9XG5cblx0ICB0aGlzLnN1YnMucHVzaChvcGVuU3ViKTtcblx0ICB0aGlzLnN1YnMucHVzaChlcnJvclN1Yik7XG5cblx0ICByZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IG9wZW4uXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRNYW5hZ2VyLnByb3RvdHlwZS5vbm9wZW4gPSBmdW5jdGlvbiAoKSB7XG5cdCAgZGVidWcoJ29wZW4nKTtcblxuXHQgIC8vIGNsZWFyIG9sZCBzdWJzXG5cdCAgdGhpcy5jbGVhbnVwKCk7XG5cblx0ICAvLyBtYXJrIGFzIG9wZW5cblx0ICB0aGlzLnJlYWR5U3RhdGUgPSAnb3Blbic7XG5cdCAgdGhpcy5lbWl0KCdvcGVuJyk7XG5cblx0ICAvLyBhZGQgbmV3IHN1YnNcblx0ICB2YXIgc29ja2V0ID0gdGhpcy5lbmdpbmU7XG5cdCAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAnZGF0YScsIGJpbmQodGhpcywgJ29uZGF0YScpKSk7XG5cdCAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAncGluZycsIGJpbmQodGhpcywgJ29ucGluZycpKSk7XG5cdCAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAncG9uZycsIGJpbmQodGhpcywgJ29ucG9uZycpKSk7XG5cdCAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAnZXJyb3InLCBiaW5kKHRoaXMsICdvbmVycm9yJykpKTtcblx0ICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdjbG9zZScsIGJpbmQodGhpcywgJ29uY2xvc2UnKSkpO1xuXHQgIHRoaXMuc3Vicy5wdXNoKG9uKHRoaXMuZGVjb2RlciwgJ2RlY29kZWQnLCBiaW5kKHRoaXMsICdvbmRlY29kZWQnKSkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgdXBvbiBhIHBpbmcuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRNYW5hZ2VyLnByb3RvdHlwZS5vbnBpbmcgPSBmdW5jdGlvbiAoKSB7XG5cdCAgdGhpcy5sYXN0UGluZyA9IG5ldyBEYXRlKCk7XG5cdCAgdGhpcy5lbWl0QWxsKCdwaW5nJyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxlZCB1cG9uIGEgcGFja2V0LlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0TWFuYWdlci5wcm90b3R5cGUub25wb25nID0gZnVuY3Rpb24gKCkge1xuXHQgIHRoaXMuZW1pdEFsbCgncG9uZycsIG5ldyBEYXRlKCkgLSB0aGlzLmxhc3RQaW5nKTtcblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIHdpdGggZGF0YS5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdE1hbmFnZXIucHJvdG90eXBlLm9uZGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgdGhpcy5kZWNvZGVyLmFkZChkYXRhKTtcblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIHdoZW4gcGFyc2VyIGZ1bGx5IGRlY29kZXMgYSBwYWNrZXQuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRNYW5hZ2VyLnByb3RvdHlwZS5vbmRlY29kZWQgPSBmdW5jdGlvbiAocGFja2V0KSB7XG5cdCAgdGhpcy5lbWl0KCdwYWNrZXQnLCBwYWNrZXQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgdXBvbiBzb2NrZXQgZXJyb3IuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRNYW5hZ2VyLnByb3RvdHlwZS5vbmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuXHQgIGRlYnVnKCdlcnJvcicsIGVycik7XG5cdCAgdGhpcy5lbWl0QWxsKCdlcnJvcicsIGVycik7XG5cdH07XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBuZXcgc29ja2V0IGZvciB0aGUgZ2l2ZW4gYG5zcGAuXG5cdCAqXG5cdCAqIEByZXR1cm4ge1NvY2tldH1cblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0TWFuYWdlci5wcm90b3R5cGUuc29ja2V0ID0gZnVuY3Rpb24gKG5zcCwgb3B0cykge1xuXHQgIHZhciBzb2NrZXQgPSB0aGlzLm5zcHNbbnNwXTtcblx0ICBpZiAoIXNvY2tldCkge1xuXHQgICAgc29ja2V0ID0gbmV3IFNvY2tldCh0aGlzLCBuc3AsIG9wdHMpO1xuXHQgICAgdGhpcy5uc3BzW25zcF0gPSBzb2NrZXQ7XG5cdCAgICB2YXIgc2VsZiA9IHRoaXM7XG5cdCAgICBzb2NrZXQub24oJ2Nvbm5lY3RpbmcnLCBvbkNvbm5lY3RpbmcpO1xuXHQgICAgc29ja2V0Lm9uKCdjb25uZWN0JywgZnVuY3Rpb24gKCkge1xuXHQgICAgICBzb2NrZXQuaWQgPSBzZWxmLmVuZ2luZS5pZDtcblx0ICAgIH0pO1xuXG5cdCAgICBpZiAodGhpcy5hdXRvQ29ubmVjdCkge1xuXHQgICAgICAvLyBtYW51YWxseSBjYWxsIGhlcmUgc2luY2UgY29ubmVjdGluZyBldm5ldCBpcyBmaXJlZCBiZWZvcmUgbGlzdGVuaW5nXG5cdCAgICAgIG9uQ29ubmVjdGluZygpO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIG9uQ29ubmVjdGluZygpIHtcblx0ICAgIGlmICghfmluZGV4T2Yoc2VsZi5jb25uZWN0aW5nLCBzb2NrZXQpKSB7XG5cdCAgICAgIHNlbGYuY29ubmVjdGluZy5wdXNoKHNvY2tldCk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHNvY2tldDtcblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIHVwb24gYSBzb2NrZXQgY2xvc2UuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U29ja2V0fSBzb2NrZXRcblx0ICovXG5cblx0TWFuYWdlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChzb2NrZXQpIHtcblx0ICB2YXIgaW5kZXggPSBpbmRleE9mKHRoaXMuY29ubmVjdGluZywgc29ja2V0KTtcblx0ICBpZiAofmluZGV4KSB0aGlzLmNvbm5lY3Rpbmcuc3BsaWNlKGluZGV4LCAxKTtcblx0ICBpZiAodGhpcy5jb25uZWN0aW5nLmxlbmd0aCkgcmV0dXJuO1xuXG5cdCAgdGhpcy5jbG9zZSgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBXcml0ZXMgYSBwYWNrZXQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdE1hbmFnZXIucHJvdG90eXBlLnBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcblx0ICBkZWJ1Zygnd3JpdGluZyBwYWNrZXQgJWonLCBwYWNrZXQpO1xuXHQgIHZhciBzZWxmID0gdGhpcztcblx0ICBpZiAocGFja2V0LnF1ZXJ5ICYmIHBhY2tldC50eXBlID09PSAwKSBwYWNrZXQubnNwICs9ICc/JyArIHBhY2tldC5xdWVyeTtcblxuXHQgIGlmICghc2VsZi5lbmNvZGluZykge1xuXHQgICAgLy8gZW5jb2RlLCB0aGVuIHdyaXRlIHRvIGVuZ2luZSB3aXRoIHJlc3VsdFxuXHQgICAgc2VsZi5lbmNvZGluZyA9IHRydWU7XG5cdCAgICB0aGlzLmVuY29kZXIuZW5jb2RlKHBhY2tldCwgZnVuY3Rpb24gKGVuY29kZWRQYWNrZXRzKSB7XG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5jb2RlZFBhY2tldHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICBzZWxmLmVuZ2luZS53cml0ZShlbmNvZGVkUGFja2V0c1tpXSwgcGFja2V0Lm9wdGlvbnMpO1xuXHQgICAgICB9XG5cdCAgICAgIHNlbGYuZW5jb2RpbmcgPSBmYWxzZTtcblx0ICAgICAgc2VsZi5wcm9jZXNzUGFja2V0UXVldWUoKTtcblx0ICAgIH0pO1xuXHQgIH0gZWxzZSB7XG5cdCAgICAvLyBhZGQgcGFja2V0IHRvIHRoZSBxdWV1ZVxuXHQgICAgc2VsZi5wYWNrZXRCdWZmZXIucHVzaChwYWNrZXQpO1xuXHQgIH1cblx0fTtcblxuXHQvKipcblx0ICogSWYgcGFja2V0IGJ1ZmZlciBpcyBub24tZW1wdHksIGJlZ2lucyBlbmNvZGluZyB0aGVcblx0ICogbmV4dCBwYWNrZXQgaW4gbGluZS5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdE1hbmFnZXIucHJvdG90eXBlLnByb2Nlc3NQYWNrZXRRdWV1ZSA9IGZ1bmN0aW9uICgpIHtcblx0ICBpZiAodGhpcy5wYWNrZXRCdWZmZXIubGVuZ3RoID4gMCAmJiAhdGhpcy5lbmNvZGluZykge1xuXHQgICAgdmFyIHBhY2sgPSB0aGlzLnBhY2tldEJ1ZmZlci5zaGlmdCgpO1xuXHQgICAgdGhpcy5wYWNrZXQocGFjayk7XG5cdCAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDbGVhbiB1cCB0cmFuc3BvcnQgc3Vic2NyaXB0aW9ucyBhbmQgcGFja2V0IGJ1ZmZlci5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdE1hbmFnZXIucHJvdG90eXBlLmNsZWFudXAgPSBmdW5jdGlvbiAoKSB7XG5cdCAgZGVidWcoJ2NsZWFudXAnKTtcblxuXHQgIHZhciBzdWJzTGVuZ3RoID0gdGhpcy5zdWJzLmxlbmd0aDtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YnNMZW5ndGg7IGkrKykge1xuXHQgICAgdmFyIHN1YiA9IHRoaXMuc3Vicy5zaGlmdCgpO1xuXHQgICAgc3ViLmRlc3Ryb3koKTtcblx0ICB9XG5cblx0ICB0aGlzLnBhY2tldEJ1ZmZlciA9IFtdO1xuXHQgIHRoaXMuZW5jb2RpbmcgPSBmYWxzZTtcblx0ICB0aGlzLmxhc3RQaW5nID0gbnVsbDtcblxuXHQgIHRoaXMuZGVjb2Rlci5kZXN0cm95KCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENsb3NlIHRoZSBjdXJyZW50IHNvY2tldC5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdE1hbmFnZXIucHJvdG90eXBlLmNsb3NlID0gTWFuYWdlci5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcblx0ICBkZWJ1ZygnZGlzY29ubmVjdCcpO1xuXHQgIHRoaXMuc2tpcFJlY29ubmVjdCA9IHRydWU7XG5cdCAgdGhpcy5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcblx0ICBpZiAoJ29wZW5pbmcnID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcblx0ICAgIC8vIGBvbmNsb3NlYCB3aWxsIG5vdCBmaXJlIGJlY2F1c2Vcblx0ICAgIC8vIGFuIG9wZW4gZXZlbnQgbmV2ZXIgaGFwcGVuZWRcblx0ICAgIHRoaXMuY2xlYW51cCgpO1xuXHQgIH1cblx0ICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcblx0ICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcblx0ICBpZiAodGhpcy5lbmdpbmUpIHRoaXMuZW5naW5lLmNsb3NlKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxlZCB1cG9uIGVuZ2luZSBjbG9zZS5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdE1hbmFnZXIucHJvdG90eXBlLm9uY2xvc2UgPSBmdW5jdGlvbiAocmVhc29uKSB7XG5cdCAgZGVidWcoJ29uY2xvc2UnKTtcblxuXHQgIHRoaXMuY2xlYW51cCgpO1xuXHQgIHRoaXMuYmFja29mZi5yZXNldCgpO1xuXHQgIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuXHQgIHRoaXMuZW1pdCgnY2xvc2UnLCByZWFzb24pO1xuXG5cdCAgaWYgKHRoaXMuX3JlY29ubmVjdGlvbiAmJiAhdGhpcy5za2lwUmVjb25uZWN0KSB7XG5cdCAgICB0aGlzLnJlY29ubmVjdCgpO1xuXHQgIH1cblx0fTtcblxuXHQvKipcblx0ICogQXR0ZW1wdCBhIHJlY29ubmVjdGlvbi5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdE1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcblx0ICBpZiAodGhpcy5yZWNvbm5lY3RpbmcgfHwgdGhpcy5za2lwUmVjb25uZWN0KSByZXR1cm4gdGhpcztcblxuXHQgIHZhciBzZWxmID0gdGhpcztcblxuXHQgIGlmICh0aGlzLmJhY2tvZmYuYXR0ZW1wdHMgPj0gdGhpcy5fcmVjb25uZWN0aW9uQXR0ZW1wdHMpIHtcblx0ICAgIGRlYnVnKCdyZWNvbm5lY3QgZmFpbGVkJyk7XG5cdCAgICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcblx0ICAgIHRoaXMuZW1pdEFsbCgncmVjb25uZWN0X2ZhaWxlZCcpO1xuXHQgICAgdGhpcy5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcblx0ICB9IGVsc2Uge1xuXHQgICAgdmFyIGRlbGF5ID0gdGhpcy5iYWNrb2ZmLmR1cmF0aW9uKCk7XG5cdCAgICBkZWJ1Zygnd2lsbCB3YWl0ICVkbXMgYmVmb3JlIHJlY29ubmVjdCBhdHRlbXB0JywgZGVsYXkpO1xuXG5cdCAgICB0aGlzLnJlY29ubmVjdGluZyA9IHRydWU7XG5cdCAgICB2YXIgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgaWYgKHNlbGYuc2tpcFJlY29ubmVjdCkgcmV0dXJuO1xuXG5cdCAgICAgIGRlYnVnKCdhdHRlbXB0aW5nIHJlY29ubmVjdCcpO1xuXHQgICAgICBzZWxmLmVtaXRBbGwoJ3JlY29ubmVjdF9hdHRlbXB0Jywgc2VsZi5iYWNrb2ZmLmF0dGVtcHRzKTtcblx0ICAgICAgc2VsZi5lbWl0QWxsKCdyZWNvbm5lY3RpbmcnLCBzZWxmLmJhY2tvZmYuYXR0ZW1wdHMpO1xuXG5cdCAgICAgIC8vIGNoZWNrIGFnYWluIGZvciB0aGUgY2FzZSBzb2NrZXQgY2xvc2VkIGluIGFib3ZlIGV2ZW50c1xuXHQgICAgICBpZiAoc2VsZi5za2lwUmVjb25uZWN0KSByZXR1cm47XG5cblx0ICAgICAgc2VsZi5vcGVuKGZ1bmN0aW9uIChlcnIpIHtcblx0ICAgICAgICBpZiAoZXJyKSB7XG5cdCAgICAgICAgICBkZWJ1ZygncmVjb25uZWN0IGF0dGVtcHQgZXJyb3InKTtcblx0ICAgICAgICAgIHNlbGYucmVjb25uZWN0aW5nID0gZmFsc2U7XG5cdCAgICAgICAgICBzZWxmLnJlY29ubmVjdCgpO1xuXHQgICAgICAgICAgc2VsZi5lbWl0QWxsKCdyZWNvbm5lY3RfZXJyb3InLCBlcnIuZGF0YSk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIGRlYnVnKCdyZWNvbm5lY3Qgc3VjY2VzcycpO1xuXHQgICAgICAgICAgc2VsZi5vbnJlY29ubmVjdCgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSk7XG5cdCAgICB9LCBkZWxheSk7XG5cblx0ICAgIHRoaXMuc3Vicy5wdXNoKHtcblx0ICAgICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcblx0ICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuXHQgICAgICB9XG5cdCAgICB9KTtcblx0ICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxlZCB1cG9uIHN1Y2Nlc3NmdWwgcmVjb25uZWN0LlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0TWFuYWdlci5wcm90b3R5cGUub25yZWNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG5cdCAgdmFyIGF0dGVtcHQgPSB0aGlzLmJhY2tvZmYuYXR0ZW1wdHM7XG5cdCAgdGhpcy5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcblx0ICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcblx0ICB0aGlzLnVwZGF0ZVNvY2tldElkcygpO1xuXHQgIHRoaXMuZW1pdEFsbCgncmVjb25uZWN0JywgYXR0ZW1wdCk7XG5cdH07XG5cbi8qKiovIH0sXG4vKiAxNSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XG5cdG1vZHVsZS5leHBvcnRzID0gIF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xuXG5cbi8qKiovIH0sXG4vKiAxNiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XG5cdG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XG5cblx0LyoqXG5cdCAqIEV4cG9ydHMgcGFyc2VyXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqXG5cdCAqL1xuXHRtb2R1bGUuZXhwb3J0cy5wYXJzZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KTtcblxuXG4vKioqLyB9LFxuLyogMTcgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHsvKipcblx0ICogTW9kdWxlIGRlcGVuZGVuY2llcy5cblx0ICovXG5cblx0dmFyIHRyYW5zcG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcblx0dmFyIEVtaXR0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcblx0dmFyIGRlYnVnID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKSgnZW5naW5lLmlvLWNsaWVudDpzb2NrZXQnKTtcblx0dmFyIGluZGV4ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MCk7XG5cdHZhciBwYXJzZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KTtcblx0dmFyIHBhcnNldXJpID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblx0dmFyIHBhcnNlanNvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNDEpO1xuXHR2YXIgcGFyc2VxcyA9IF9fd2VicGFja19yZXF1aXJlX18oMzQpO1xuXG5cdC8qKlxuXHQgKiBNb2R1bGUgZXhwb3J0cy5cblx0ICovXG5cblx0bW9kdWxlLmV4cG9ydHMgPSBTb2NrZXQ7XG5cblx0LyoqXG5cdCAqIE5vb3AgZnVuY3Rpb24uXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRmdW5jdGlvbiBub29wKCl7fVxuXG5cdC8qKlxuXHQgKiBTb2NrZXQgY29uc3RydWN0b3IuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gdXJpIG9yIG9wdGlvbnNcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZnVuY3Rpb24gU29ja2V0KHVyaSwgb3B0cyl7XG5cdCAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNvY2tldCkpIHJldHVybiBuZXcgU29ja2V0KHVyaSwgb3B0cyk7XG5cblx0ICBvcHRzID0gb3B0cyB8fCB7fTtcblxuXHQgIGlmICh1cmkgJiYgJ29iamVjdCcgPT0gdHlwZW9mIHVyaSkge1xuXHQgICAgb3B0cyA9IHVyaTtcblx0ICAgIHVyaSA9IG51bGw7XG5cdCAgfVxuXG5cdCAgaWYgKHVyaSkge1xuXHQgICAgdXJpID0gcGFyc2V1cmkodXJpKTtcblx0ICAgIG9wdHMuaG9zdG5hbWUgPSB1cmkuaG9zdDtcblx0ICAgIG9wdHMuc2VjdXJlID0gdXJpLnByb3RvY29sID09ICdodHRwcycgfHwgdXJpLnByb3RvY29sID09ICd3c3MnO1xuXHQgICAgb3B0cy5wb3J0ID0gdXJpLnBvcnQ7XG5cdCAgICBpZiAodXJpLnF1ZXJ5KSBvcHRzLnF1ZXJ5ID0gdXJpLnF1ZXJ5O1xuXHQgIH0gZWxzZSBpZiAob3B0cy5ob3N0KSB7XG5cdCAgICBvcHRzLmhvc3RuYW1lID0gcGFyc2V1cmkob3B0cy5ob3N0KS5ob3N0O1xuXHQgIH1cblxuXHQgIHRoaXMuc2VjdXJlID0gbnVsbCAhPSBvcHRzLnNlY3VyZSA/IG9wdHMuc2VjdXJlIDpcblx0ICAgIChnbG9iYWwubG9jYXRpb24gJiYgJ2h0dHBzOicgPT0gbG9jYXRpb24ucHJvdG9jb2wpO1xuXG5cdCAgaWYgKG9wdHMuaG9zdG5hbWUgJiYgIW9wdHMucG9ydCkge1xuXHQgICAgLy8gaWYgbm8gcG9ydCBpcyBzcGVjaWZpZWQgbWFudWFsbHksIHVzZSB0aGUgcHJvdG9jb2wgZGVmYXVsdFxuXHQgICAgb3B0cy5wb3J0ID0gdGhpcy5zZWN1cmUgPyAnNDQzJyA6ICc4MCc7XG5cdCAgfVxuXG5cdCAgdGhpcy5hZ2VudCA9IG9wdHMuYWdlbnQgfHwgZmFsc2U7XG5cdCAgdGhpcy5ob3N0bmFtZSA9IG9wdHMuaG9zdG5hbWUgfHxcblx0ICAgIChnbG9iYWwubG9jYXRpb24gPyBsb2NhdGlvbi5ob3N0bmFtZSA6ICdsb2NhbGhvc3QnKTtcblx0ICB0aGlzLnBvcnQgPSBvcHRzLnBvcnQgfHwgKGdsb2JhbC5sb2NhdGlvbiAmJiBsb2NhdGlvbi5wb3J0ID9cblx0ICAgICAgIGxvY2F0aW9uLnBvcnQgOlxuXHQgICAgICAgKHRoaXMuc2VjdXJlID8gNDQzIDogODApKTtcblx0ICB0aGlzLnF1ZXJ5ID0gb3B0cy5xdWVyeSB8fCB7fTtcblx0ICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIHRoaXMucXVlcnkpIHRoaXMucXVlcnkgPSBwYXJzZXFzLmRlY29kZSh0aGlzLnF1ZXJ5KTtcblx0ICB0aGlzLnVwZ3JhZGUgPSBmYWxzZSAhPT0gb3B0cy51cGdyYWRlO1xuXHQgIHRoaXMucGF0aCA9IChvcHRzLnBhdGggfHwgJy9lbmdpbmUuaW8nKS5yZXBsYWNlKC9cXC8kLywgJycpICsgJy8nO1xuXHQgIHRoaXMuZm9yY2VKU09OUCA9ICEhb3B0cy5mb3JjZUpTT05QO1xuXHQgIHRoaXMuanNvbnAgPSBmYWxzZSAhPT0gb3B0cy5qc29ucDtcblx0ICB0aGlzLmZvcmNlQmFzZTY0ID0gISFvcHRzLmZvcmNlQmFzZTY0O1xuXHQgIHRoaXMuZW5hYmxlc1hEUiA9ICEhb3B0cy5lbmFibGVzWERSO1xuXHQgIHRoaXMudGltZXN0YW1wUGFyYW0gPSBvcHRzLnRpbWVzdGFtcFBhcmFtIHx8ICd0Jztcblx0ICB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzID0gb3B0cy50aW1lc3RhbXBSZXF1ZXN0cztcblx0ICB0aGlzLnRyYW5zcG9ydHMgPSBvcHRzLnRyYW5zcG9ydHMgfHwgWydwb2xsaW5nJywgJ3dlYnNvY2tldCddO1xuXHQgIHRoaXMucmVhZHlTdGF0ZSA9ICcnO1xuXHQgIHRoaXMud3JpdGVCdWZmZXIgPSBbXTtcblx0ICB0aGlzLnBvbGljeVBvcnQgPSBvcHRzLnBvbGljeVBvcnQgfHwgODQzO1xuXHQgIHRoaXMucmVtZW1iZXJVcGdyYWRlID0gb3B0cy5yZW1lbWJlclVwZ3JhZGUgfHwgZmFsc2U7XG5cdCAgdGhpcy5iaW5hcnlUeXBlID0gbnVsbDtcblx0ICB0aGlzLm9ubHlCaW5hcnlVcGdyYWRlcyA9IG9wdHMub25seUJpbmFyeVVwZ3JhZGVzO1xuXHQgIHRoaXMucGVyTWVzc2FnZURlZmxhdGUgPSBmYWxzZSAhPT0gb3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSA/IChvcHRzLnBlck1lc3NhZ2VEZWZsYXRlIHx8IHt9KSA6IGZhbHNlO1xuXG5cdCAgaWYgKHRydWUgPT09IHRoaXMucGVyTWVzc2FnZURlZmxhdGUpIHRoaXMucGVyTWVzc2FnZURlZmxhdGUgPSB7fTtcblx0ICBpZiAodGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSAmJiBudWxsID09IHRoaXMucGVyTWVzc2FnZURlZmxhdGUudGhyZXNob2xkKSB7XG5cdCAgICB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlLnRocmVzaG9sZCA9IDEwMjQ7XG5cdCAgfVxuXG5cdCAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG5cdCAgdGhpcy5wZnggPSBvcHRzLnBmeCB8fCBudWxsO1xuXHQgIHRoaXMua2V5ID0gb3B0cy5rZXkgfHwgbnVsbDtcblx0ICB0aGlzLnBhc3NwaHJhc2UgPSBvcHRzLnBhc3NwaHJhc2UgfHwgbnVsbDtcblx0ICB0aGlzLmNlcnQgPSBvcHRzLmNlcnQgfHwgbnVsbDtcblx0ICB0aGlzLmNhID0gb3B0cy5jYSB8fCBudWxsO1xuXHQgIHRoaXMuY2lwaGVycyA9IG9wdHMuY2lwaGVycyB8fCBudWxsO1xuXHQgIHRoaXMucmVqZWN0VW5hdXRob3JpemVkID0gb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBvcHRzLnJlamVjdFVuYXV0aG9yaXplZDtcblxuXHQgIC8vIG90aGVyIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG5cdCAgdmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0ICBpZiAoZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwpIHtcblx0ICAgIGlmIChvcHRzLmV4dHJhSGVhZGVycyAmJiBPYmplY3Qua2V5cyhvcHRzLmV4dHJhSGVhZGVycykubGVuZ3RoID4gMCkge1xuXHQgICAgICB0aGlzLmV4dHJhSGVhZGVycyA9IG9wdHMuZXh0cmFIZWFkZXJzO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHRoaXMub3BlbigpO1xuXHR9XG5cblx0U29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IGZhbHNlO1xuXG5cdC8qKlxuXHQgKiBNaXggaW4gYEVtaXR0ZXJgLlxuXHQgKi9cblxuXHRFbWl0dGVyKFNvY2tldC5wcm90b3R5cGUpO1xuXG5cdC8qKlxuXHQgKiBQcm90b2NvbCB2ZXJzaW9uLlxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRTb2NrZXQucHJvdG9jb2wgPSBwYXJzZXIucHJvdG9jb2w7IC8vIHRoaXMgaXMgYW4gaW50XG5cblx0LyoqXG5cdCAqIEV4cG9zZSBkZXBzIGZvciBsZWdhY3kgY29tcGF0aWJpbGl0eVxuXHQgKiBhbmQgc3RhbmRhbG9uZSBicm93c2VyIGFjY2Vzcy5cblx0ICovXG5cblx0U29ja2V0LlNvY2tldCA9IFNvY2tldDtcblx0U29ja2V0LlRyYW5zcG9ydCA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpO1xuXHRTb2NrZXQudHJhbnNwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xuXHRTb2NrZXQucGFyc2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCk7XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgdHJhbnNwb3J0IG9mIHRoZSBnaXZlbiB0eXBlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHJhbnNwb3J0IG5hbWVcblx0ICogQHJldHVybiB7VHJhbnNwb3J0fVxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0U29ja2V0LnByb3RvdHlwZS5jcmVhdGVUcmFuc3BvcnQgPSBmdW5jdGlvbiAobmFtZSkge1xuXHQgIGRlYnVnKCdjcmVhdGluZyB0cmFuc3BvcnQgXCIlc1wiJywgbmFtZSk7XG5cdCAgdmFyIHF1ZXJ5ID0gY2xvbmUodGhpcy5xdWVyeSk7XG5cblx0ICAvLyBhcHBlbmQgZW5naW5lLmlvIHByb3RvY29sIGlkZW50aWZpZXJcblx0ICBxdWVyeS5FSU8gPSBwYXJzZXIucHJvdG9jb2w7XG5cblx0ICAvLyB0cmFuc3BvcnQgbmFtZVxuXHQgIHF1ZXJ5LnRyYW5zcG9ydCA9IG5hbWU7XG5cblx0ICAvLyBzZXNzaW9uIGlkIGlmIHdlIGFscmVhZHkgaGF2ZSBvbmVcblx0ICBpZiAodGhpcy5pZCkgcXVlcnkuc2lkID0gdGhpcy5pZDtcblxuXHQgIHZhciB0cmFuc3BvcnQgPSBuZXcgdHJhbnNwb3J0c1tuYW1lXSh7XG5cdCAgICBhZ2VudDogdGhpcy5hZ2VudCxcblx0ICAgIGhvc3RuYW1lOiB0aGlzLmhvc3RuYW1lLFxuXHQgICAgcG9ydDogdGhpcy5wb3J0LFxuXHQgICAgc2VjdXJlOiB0aGlzLnNlY3VyZSxcblx0ICAgIHBhdGg6IHRoaXMucGF0aCxcblx0ICAgIHF1ZXJ5OiBxdWVyeSxcblx0ICAgIGZvcmNlSlNPTlA6IHRoaXMuZm9yY2VKU09OUCxcblx0ICAgIGpzb25wOiB0aGlzLmpzb25wLFxuXHQgICAgZm9yY2VCYXNlNjQ6IHRoaXMuZm9yY2VCYXNlNjQsXG5cdCAgICBlbmFibGVzWERSOiB0aGlzLmVuYWJsZXNYRFIsXG5cdCAgICB0aW1lc3RhbXBSZXF1ZXN0czogdGhpcy50aW1lc3RhbXBSZXF1ZXN0cyxcblx0ICAgIHRpbWVzdGFtcFBhcmFtOiB0aGlzLnRpbWVzdGFtcFBhcmFtLFxuXHQgICAgcG9saWN5UG9ydDogdGhpcy5wb2xpY3lQb3J0LFxuXHQgICAgc29ja2V0OiB0aGlzLFxuXHQgICAgcGZ4OiB0aGlzLnBmeCxcblx0ICAgIGtleTogdGhpcy5rZXksXG5cdCAgICBwYXNzcGhyYXNlOiB0aGlzLnBhc3NwaHJhc2UsXG5cdCAgICBjZXJ0OiB0aGlzLmNlcnQsXG5cdCAgICBjYTogdGhpcy5jYSxcblx0ICAgIGNpcGhlcnM6IHRoaXMuY2lwaGVycyxcblx0ICAgIHJlamVjdFVuYXV0aG9yaXplZDogdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQsXG5cdCAgICBwZXJNZXNzYWdlRGVmbGF0ZTogdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSxcblx0ICAgIGV4dHJhSGVhZGVyczogdGhpcy5leHRyYUhlYWRlcnNcblx0ICB9KTtcblxuXHQgIHJldHVybiB0cmFuc3BvcnQ7XG5cdH07XG5cblx0ZnVuY3Rpb24gY2xvbmUgKG9iaikge1xuXHQgIHZhciBvID0ge307XG5cdCAgZm9yICh2YXIgaSBpbiBvYmopIHtcblx0ICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcblx0ICAgICAgb1tpXSA9IG9ialtpXTtcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIG87XG5cdH1cblxuXHQvKipcblx0ICogSW5pdGlhbGl6ZXMgdHJhbnNwb3J0IHRvIHVzZSBhbmQgc3RhcnRzIHByb2JlLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFNvY2tldC5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uICgpIHtcblx0ICB2YXIgdHJhbnNwb3J0O1xuXHQgIGlmICh0aGlzLnJlbWVtYmVyVXBncmFkZSAmJiBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzICYmIHRoaXMudHJhbnNwb3J0cy5pbmRleE9mKCd3ZWJzb2NrZXQnKSAhPSAtMSkge1xuXHQgICAgdHJhbnNwb3J0ID0gJ3dlYnNvY2tldCc7XG5cdCAgfSBlbHNlIGlmICgwID09PSB0aGlzLnRyYW5zcG9ydHMubGVuZ3RoKSB7XG5cdCAgICAvLyBFbWl0IGVycm9yIG9uIG5leHQgdGljayBzbyBpdCBjYW4gYmUgbGlzdGVuZWQgdG9cblx0ICAgIHZhciBzZWxmID0gdGhpcztcblx0ICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdCAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCAnTm8gdHJhbnNwb3J0cyBhdmFpbGFibGUnKTtcblx0ICAgIH0sIDApO1xuXHQgICAgcmV0dXJuO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB0cmFuc3BvcnQgPSB0aGlzLnRyYW5zcG9ydHNbMF07XG5cdCAgfVxuXHQgIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuaW5nJztcblxuXHQgIC8vIFJldHJ5IHdpdGggdGhlIG5leHQgdHJhbnNwb3J0IGlmIHRoZSB0cmFuc3BvcnQgaXMgZGlzYWJsZWQgKGpzb25wOiBmYWxzZSlcblx0ICB0cnkge1xuXHQgICAgdHJhbnNwb3J0ID0gdGhpcy5jcmVhdGVUcmFuc3BvcnQodHJhbnNwb3J0KTtcblx0ICB9IGNhdGNoIChlKSB7XG5cdCAgICB0aGlzLnRyYW5zcG9ydHMuc2hpZnQoKTtcblx0ICAgIHRoaXMub3BlbigpO1xuXHQgICAgcmV0dXJuO1xuXHQgIH1cblxuXHQgIHRyYW5zcG9ydC5vcGVuKCk7XG5cdCAgdGhpcy5zZXRUcmFuc3BvcnQodHJhbnNwb3J0KTtcblx0fTtcblxuXHQvKipcblx0ICogU2V0cyB0aGUgY3VycmVudCB0cmFuc3BvcnQuIERpc2FibGVzIHRoZSBleGlzdGluZyBvbmUgKGlmIGFueSkuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRTb2NrZXQucHJvdG90eXBlLnNldFRyYW5zcG9ydCA9IGZ1bmN0aW9uKHRyYW5zcG9ydCl7XG5cdCAgZGVidWcoJ3NldHRpbmcgdHJhbnNwb3J0ICVzJywgdHJhbnNwb3J0Lm5hbWUpO1xuXHQgIHZhciBzZWxmID0gdGhpcztcblxuXHQgIGlmICh0aGlzLnRyYW5zcG9ydCkge1xuXHQgICAgZGVidWcoJ2NsZWFyaW5nIGV4aXN0aW5nIHRyYW5zcG9ydCAlcycsIHRoaXMudHJhbnNwb3J0Lm5hbWUpO1xuXHQgICAgdGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG5cdCAgfVxuXG5cdCAgLy8gc2V0IHVwIHRyYW5zcG9ydFxuXHQgIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuXG5cdCAgLy8gc2V0IHVwIHRyYW5zcG9ydCBsaXN0ZW5lcnNcblx0ICB0cmFuc3BvcnRcblx0ICAub24oJ2RyYWluJywgZnVuY3Rpb24oKXtcblx0ICAgIHNlbGYub25EcmFpbigpO1xuXHQgIH0pXG5cdCAgLm9uKCdwYWNrZXQnLCBmdW5jdGlvbihwYWNrZXQpe1xuXHQgICAgc2VsZi5vblBhY2tldChwYWNrZXQpO1xuXHQgIH0pXG5cdCAgLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGUpe1xuXHQgICAgc2VsZi5vbkVycm9yKGUpO1xuXHQgIH0pXG5cdCAgLm9uKCdjbG9zZScsIGZ1bmN0aW9uKCl7XG5cdCAgICBzZWxmLm9uQ2xvc2UoJ3RyYW5zcG9ydCBjbG9zZScpO1xuXHQgIH0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBQcm9iZXMgYSB0cmFuc3BvcnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0cmFuc3BvcnQgbmFtZVxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0U29ja2V0LnByb3RvdHlwZS5wcm9iZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG5cdCAgZGVidWcoJ3Byb2JpbmcgdHJhbnNwb3J0IFwiJXNcIicsIG5hbWUpO1xuXHQgIHZhciB0cmFuc3BvcnQgPSB0aGlzLmNyZWF0ZVRyYW5zcG9ydChuYW1lLCB7IHByb2JlOiAxIH0pXG5cdCAgICAsIGZhaWxlZCA9IGZhbHNlXG5cdCAgICAsIHNlbGYgPSB0aGlzO1xuXG5cdCAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IGZhbHNlO1xuXG5cdCAgZnVuY3Rpb24gb25UcmFuc3BvcnRPcGVuKCl7XG5cdCAgICBpZiAoc2VsZi5vbmx5QmluYXJ5VXBncmFkZXMpIHtcblx0ICAgICAgdmFyIHVwZ3JhZGVMb3Nlc0JpbmFyeSA9ICF0aGlzLnN1cHBvcnRzQmluYXJ5ICYmIHNlbGYudHJhbnNwb3J0LnN1cHBvcnRzQmluYXJ5O1xuXHQgICAgICBmYWlsZWQgPSBmYWlsZWQgfHwgdXBncmFkZUxvc2VzQmluYXJ5O1xuXHQgICAgfVxuXHQgICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuXG5cdCAgICBkZWJ1ZygncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBvcGVuZWQnLCBuYW1lKTtcblx0ICAgIHRyYW5zcG9ydC5zZW5kKFt7IHR5cGU6ICdwaW5nJywgZGF0YTogJ3Byb2JlJyB9XSk7XG5cdCAgICB0cmFuc3BvcnQub25jZSgncGFja2V0JywgZnVuY3Rpb24gKG1zZykge1xuXHQgICAgICBpZiAoZmFpbGVkKSByZXR1cm47XG5cdCAgICAgIGlmICgncG9uZycgPT0gbXNnLnR5cGUgJiYgJ3Byb2JlJyA9PSBtc2cuZGF0YSkge1xuXHQgICAgICAgIGRlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIHBvbmcnLCBuYW1lKTtcblx0ICAgICAgICBzZWxmLnVwZ3JhZGluZyA9IHRydWU7XG5cdCAgICAgICAgc2VsZi5lbWl0KCd1cGdyYWRpbmcnLCB0cmFuc3BvcnQpO1xuXHQgICAgICAgIGlmICghdHJhbnNwb3J0KSByZXR1cm47XG5cdCAgICAgICAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9ICd3ZWJzb2NrZXQnID09IHRyYW5zcG9ydC5uYW1lO1xuXG5cdCAgICAgICAgZGVidWcoJ3BhdXNpbmcgY3VycmVudCB0cmFuc3BvcnQgXCIlc1wiJywgc2VsZi50cmFuc3BvcnQubmFtZSk7XG5cdCAgICAgICAgc2VsZi50cmFuc3BvcnQucGF1c2UoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuXHQgICAgICAgICAgaWYgKCdjbG9zZWQnID09IHNlbGYucmVhZHlTdGF0ZSkgcmV0dXJuO1xuXHQgICAgICAgICAgZGVidWcoJ2NoYW5naW5nIHRyYW5zcG9ydCBhbmQgc2VuZGluZyB1cGdyYWRlIHBhY2tldCcpO1xuXG5cdCAgICAgICAgICBjbGVhbnVwKCk7XG5cblx0ICAgICAgICAgIHNlbGYuc2V0VHJhbnNwb3J0KHRyYW5zcG9ydCk7XG5cdCAgICAgICAgICB0cmFuc3BvcnQuc2VuZChbeyB0eXBlOiAndXBncmFkZScgfV0pO1xuXHQgICAgICAgICAgc2VsZi5lbWl0KCd1cGdyYWRlJywgdHJhbnNwb3J0KTtcblx0ICAgICAgICAgIHRyYW5zcG9ydCA9IG51bGw7XG5cdCAgICAgICAgICBzZWxmLnVwZ3JhZGluZyA9IGZhbHNlO1xuXHQgICAgICAgICAgc2VsZi5mbHVzaCgpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGRlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIGZhaWxlZCcsIG5hbWUpO1xuXHQgICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ3Byb2JlIGVycm9yJyk7XG5cdCAgICAgICAgZXJyLnRyYW5zcG9ydCA9IHRyYW5zcG9ydC5uYW1lO1xuXHQgICAgICAgIHNlbGYuZW1pdCgndXBncmFkZUVycm9yJywgZXJyKTtcblx0ICAgICAgfVxuXHQgICAgfSk7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gZnJlZXplVHJhbnNwb3J0KCkge1xuXHQgICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuXG5cdCAgICAvLyBBbnkgY2FsbGJhY2sgY2FsbGVkIGJ5IHRyYW5zcG9ydCBzaG91bGQgYmUgaWdub3JlZCBzaW5jZSBub3dcblx0ICAgIGZhaWxlZCA9IHRydWU7XG5cblx0ICAgIGNsZWFudXAoKTtcblxuXHQgICAgdHJhbnNwb3J0LmNsb3NlKCk7XG5cdCAgICB0cmFuc3BvcnQgPSBudWxsO1xuXHQgIH1cblxuXHQgIC8vSGFuZGxlIGFueSBlcnJvciB0aGF0IGhhcHBlbnMgd2hpbGUgcHJvYmluZ1xuXHQgIGZ1bmN0aW9uIG9uZXJyb3IoZXJyKSB7XG5cdCAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ3Byb2JlIGVycm9yOiAnICsgZXJyKTtcblx0ICAgIGVycm9yLnRyYW5zcG9ydCA9IHRyYW5zcG9ydC5uYW1lO1xuXG5cdCAgICBmcmVlemVUcmFuc3BvcnQoKTtcblxuXHQgICAgZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgZmFpbGVkIGJlY2F1c2Ugb2YgZXJyb3I6ICVzJywgbmFtZSwgZXJyKTtcblxuXHQgICAgc2VsZi5lbWl0KCd1cGdyYWRlRXJyb3InLCBlcnJvcik7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gb25UcmFuc3BvcnRDbG9zZSgpe1xuXHQgICAgb25lcnJvcihcInRyYW5zcG9ydCBjbG9zZWRcIik7XG5cdCAgfVxuXG5cdCAgLy9XaGVuIHRoZSBzb2NrZXQgaXMgY2xvc2VkIHdoaWxlIHdlJ3JlIHByb2Jpbmdcblx0ICBmdW5jdGlvbiBvbmNsb3NlKCl7XG5cdCAgICBvbmVycm9yKFwic29ja2V0IGNsb3NlZFwiKTtcblx0ICB9XG5cblx0ICAvL1doZW4gdGhlIHNvY2tldCBpcyB1cGdyYWRlZCB3aGlsZSB3ZSdyZSBwcm9iaW5nXG5cdCAgZnVuY3Rpb24gb251cGdyYWRlKHRvKXtcblx0ICAgIGlmICh0cmFuc3BvcnQgJiYgdG8ubmFtZSAhPSB0cmFuc3BvcnQubmFtZSkge1xuXHQgICAgICBkZWJ1ZygnXCIlc1wiIHdvcmtzIC0gYWJvcnRpbmcgXCIlc1wiJywgdG8ubmFtZSwgdHJhbnNwb3J0Lm5hbWUpO1xuXHQgICAgICBmcmVlemVUcmFuc3BvcnQoKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICAvL1JlbW92ZSBhbGwgbGlzdGVuZXJzIG9uIHRoZSB0cmFuc3BvcnQgYW5kIG9uIHNlbGZcblx0ICBmdW5jdGlvbiBjbGVhbnVwKCl7XG5cdCAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoJ29wZW4nLCBvblRyYW5zcG9ydE9wZW4pO1xuXHQgICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuXHQgICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uVHJhbnNwb3J0Q2xvc2UpO1xuXHQgICAgc2VsZi5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcblx0ICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ3VwZ3JhZGluZycsIG9udXBncmFkZSk7XG5cdCAgfVxuXG5cdCAgdHJhbnNwb3J0Lm9uY2UoJ29wZW4nLCBvblRyYW5zcG9ydE9wZW4pO1xuXHQgIHRyYW5zcG9ydC5vbmNlKCdlcnJvcicsIG9uZXJyb3IpO1xuXHQgIHRyYW5zcG9ydC5vbmNlKCdjbG9zZScsIG9uVHJhbnNwb3J0Q2xvc2UpO1xuXG5cdCAgdGhpcy5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuXHQgIHRoaXMub25jZSgndXBncmFkaW5nJywgb251cGdyYWRlKTtcblxuXHQgIHRyYW5zcG9ydC5vcGVuKCk7XG5cblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIHdoZW4gY29ubmVjdGlvbiBpcyBkZWVtZWQgb3Blbi5cblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0U29ja2V0LnByb3RvdHlwZS5vbk9wZW4gPSBmdW5jdGlvbiAoKSB7XG5cdCAgZGVidWcoJ3NvY2tldCBvcGVuJyk7XG5cdCAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW4nO1xuXHQgIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSAnd2Vic29ja2V0JyA9PSB0aGlzLnRyYW5zcG9ydC5uYW1lO1xuXHQgIHRoaXMuZW1pdCgnb3BlbicpO1xuXHQgIHRoaXMuZmx1c2goKTtcblxuXHQgIC8vIHdlIGNoZWNrIGZvciBgcmVhZHlTdGF0ZWAgaW4gY2FzZSBhbiBgb3BlbmBcblx0ICAvLyBsaXN0ZW5lciBhbHJlYWR5IGNsb3NlZCB0aGUgc29ja2V0XG5cdCAgaWYgKCdvcGVuJyA9PSB0aGlzLnJlYWR5U3RhdGUgJiYgdGhpcy51cGdyYWRlICYmIHRoaXMudHJhbnNwb3J0LnBhdXNlKSB7XG5cdCAgICBkZWJ1Zygnc3RhcnRpbmcgdXBncmFkZSBwcm9iZXMnKTtcblx0ICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy51cGdyYWRlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0ICAgICAgdGhpcy5wcm9iZSh0aGlzLnVwZ3JhZGVzW2ldKTtcblx0ICAgIH1cblx0ICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIEhhbmRsZXMgYSBwYWNrZXQuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRTb2NrZXQucHJvdG90eXBlLm9uUGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuXHQgIGlmICgnb3BlbmluZycgPT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdvcGVuJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcblx0ICAgIGRlYnVnKCdzb2NrZXQgcmVjZWl2ZTogdHlwZSBcIiVzXCIsIGRhdGEgXCIlc1wiJywgcGFja2V0LnR5cGUsIHBhY2tldC5kYXRhKTtcblxuXHQgICAgdGhpcy5lbWl0KCdwYWNrZXQnLCBwYWNrZXQpO1xuXG5cdCAgICAvLyBTb2NrZXQgaXMgbGl2ZSAtIGFueSBwYWNrZXQgY291bnRzXG5cdCAgICB0aGlzLmVtaXQoJ2hlYXJ0YmVhdCcpO1xuXG5cdCAgICBzd2l0Y2ggKHBhY2tldC50eXBlKSB7XG5cdCAgICAgIGNhc2UgJ29wZW4nOlxuXHQgICAgICAgIHRoaXMub25IYW5kc2hha2UocGFyc2Vqc29uKHBhY2tldC5kYXRhKSk7XG5cdCAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgY2FzZSAncG9uZyc6XG5cdCAgICAgICAgdGhpcy5zZXRQaW5nKCk7XG5cdCAgICAgICAgdGhpcy5lbWl0KCdwb25nJyk7XG5cdCAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgY2FzZSAnZXJyb3InOlxuXHQgICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ3NlcnZlciBlcnJvcicpO1xuXHQgICAgICAgIGVyci5jb2RlID0gcGFja2V0LmRhdGE7XG5cdCAgICAgICAgdGhpcy5vbkVycm9yKGVycik7XG5cdCAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgY2FzZSAnbWVzc2FnZSc6XG5cdCAgICAgICAgdGhpcy5lbWl0KCdkYXRhJywgcGFja2V0LmRhdGEpO1xuXHQgICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIHBhY2tldC5kYXRhKTtcblx0ICAgICAgICBicmVhaztcblx0ICAgIH1cblx0ICB9IGVsc2Uge1xuXHQgICAgZGVidWcoJ3BhY2tldCByZWNlaXZlZCB3aXRoIHNvY2tldCByZWFkeVN0YXRlIFwiJXNcIicsIHRoaXMucmVhZHlTdGF0ZSk7XG5cdCAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgdXBvbiBoYW5kc2hha2UgY29tcGxldGlvbi5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IGhhbmRzaGFrZSBvYmpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFNvY2tldC5wcm90b3R5cGUub25IYW5kc2hha2UgPSBmdW5jdGlvbiAoZGF0YSkge1xuXHQgIHRoaXMuZW1pdCgnaGFuZHNoYWtlJywgZGF0YSk7XG5cdCAgdGhpcy5pZCA9IGRhdGEuc2lkO1xuXHQgIHRoaXMudHJhbnNwb3J0LnF1ZXJ5LnNpZCA9IGRhdGEuc2lkO1xuXHQgIHRoaXMudXBncmFkZXMgPSB0aGlzLmZpbHRlclVwZ3JhZGVzKGRhdGEudXBncmFkZXMpO1xuXHQgIHRoaXMucGluZ0ludGVydmFsID0gZGF0YS5waW5nSW50ZXJ2YWw7XG5cdCAgdGhpcy5waW5nVGltZW91dCA9IGRhdGEucGluZ1RpbWVvdXQ7XG5cdCAgdGhpcy5vbk9wZW4oKTtcblx0ICAvLyBJbiBjYXNlIG9wZW4gaGFuZGxlciBjbG9zZXMgc29ja2V0XG5cdCAgaWYgICgnY2xvc2VkJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHJldHVybjtcblx0ICB0aGlzLnNldFBpbmcoKTtcblxuXHQgIC8vIFByb2xvbmcgbGl2ZW5lc3Mgb2Ygc29ja2V0IG9uIGhlYXJ0YmVhdFxuXHQgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2hlYXJ0YmVhdCcsIHRoaXMub25IZWFydGJlYXQpO1xuXHQgIHRoaXMub24oJ2hlYXJ0YmVhdCcsIHRoaXMub25IZWFydGJlYXQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXNldHMgcGluZyB0aW1lb3V0LlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0U29ja2V0LnByb3RvdHlwZS5vbkhlYXJ0YmVhdCA9IGZ1bmN0aW9uICh0aW1lb3V0KSB7XG5cdCAgY2xlYXJUaW1lb3V0KHRoaXMucGluZ1RpbWVvdXRUaW1lcik7XG5cdCAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgIHNlbGYucGluZ1RpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHQgICAgaWYgKCdjbG9zZWQnID09IHNlbGYucmVhZHlTdGF0ZSkgcmV0dXJuO1xuXHQgICAgc2VsZi5vbkNsb3NlKCdwaW5nIHRpbWVvdXQnKTtcblx0ICB9LCB0aW1lb3V0IHx8IChzZWxmLnBpbmdJbnRlcnZhbCArIHNlbGYucGluZ1RpbWVvdXQpKTtcblx0fTtcblxuXHQvKipcblx0ICogUGluZ3Mgc2VydmVyIGV2ZXJ5IGB0aGlzLnBpbmdJbnRlcnZhbGAgYW5kIGV4cGVjdHMgcmVzcG9uc2Vcblx0ICogd2l0aGluIGB0aGlzLnBpbmdUaW1lb3V0YCBvciBjbG9zZXMgY29ubmVjdGlvbi5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFNvY2tldC5wcm90b3R5cGUuc2V0UGluZyA9IGZ1bmN0aW9uICgpIHtcblx0ICB2YXIgc2VsZiA9IHRoaXM7XG5cdCAgY2xlYXJUaW1lb3V0KHNlbGYucGluZ0ludGVydmFsVGltZXIpO1xuXHQgIHNlbGYucGluZ0ludGVydmFsVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0ICAgIGRlYnVnKCd3cml0aW5nIHBpbmcgcGFja2V0IC0gZXhwZWN0aW5nIHBvbmcgd2l0aGluICVzbXMnLCBzZWxmLnBpbmdUaW1lb3V0KTtcblx0ICAgIHNlbGYucGluZygpO1xuXHQgICAgc2VsZi5vbkhlYXJ0YmVhdChzZWxmLnBpbmdUaW1lb3V0KTtcblx0ICB9LCBzZWxmLnBpbmdJbnRlcnZhbCk7XG5cdH07XG5cblx0LyoqXG5cdCogU2VuZHMgYSBwaW5nIHBhY2tldC5cblx0KlxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXG5cdFNvY2tldC5wcm90b3R5cGUucGluZyA9IGZ1bmN0aW9uICgpIHtcblx0ICB2YXIgc2VsZiA9IHRoaXM7XG5cdCAgdGhpcy5zZW5kUGFja2V0KCdwaW5nJywgZnVuY3Rpb24oKXtcblx0ICAgIHNlbGYuZW1pdCgncGluZycpO1xuXHQgIH0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgb24gYGRyYWluYCBldmVudFxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0U29ja2V0LnByb3RvdHlwZS5vbkRyYWluID0gZnVuY3Rpb24oKSB7XG5cdCAgdGhpcy53cml0ZUJ1ZmZlci5zcGxpY2UoMCwgdGhpcy5wcmV2QnVmZmVyTGVuKTtcblxuXHQgIC8vIHNldHRpbmcgcHJldkJ1ZmZlckxlbiA9IDAgaXMgdmVyeSBpbXBvcnRhbnRcblx0ICAvLyBmb3IgZXhhbXBsZSwgd2hlbiB1cGdyYWRpbmcsIHVwZ3JhZGUgcGFja2V0IGlzIHNlbnQgb3Zlcixcblx0ICAvLyBhbmQgYSBub256ZXJvIHByZXZCdWZmZXJMZW4gY291bGQgY2F1c2UgcHJvYmxlbXMgb24gYGRyYWluYFxuXHQgIHRoaXMucHJldkJ1ZmZlckxlbiA9IDA7XG5cblx0ICBpZiAoMCA9PT0gdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpIHtcblx0ICAgIHRoaXMuZW1pdCgnZHJhaW4nKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgdGhpcy5mbHVzaCgpO1xuXHQgIH1cblx0fTtcblxuXHQvKipcblx0ICogRmx1c2ggd3JpdGUgYnVmZmVycy5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFNvY2tldC5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG5cdCAgaWYgKCdjbG9zZWQnICE9IHRoaXMucmVhZHlTdGF0ZSAmJiB0aGlzLnRyYW5zcG9ydC53cml0YWJsZSAmJlxuXHQgICAgIXRoaXMudXBncmFkaW5nICYmIHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKSB7XG5cdCAgICBkZWJ1ZygnZmx1c2hpbmcgJWQgcGFja2V0cyBpbiBzb2NrZXQnLCB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCk7XG5cdCAgICB0aGlzLnRyYW5zcG9ydC5zZW5kKHRoaXMud3JpdGVCdWZmZXIpO1xuXHQgICAgLy8ga2VlcCB0cmFjayBvZiBjdXJyZW50IGxlbmd0aCBvZiB3cml0ZUJ1ZmZlclxuXHQgICAgLy8gc3BsaWNlIHdyaXRlQnVmZmVyIGFuZCBjYWxsYmFja0J1ZmZlciBvbiBgZHJhaW5gXG5cdCAgICB0aGlzLnByZXZCdWZmZXJMZW4gPSB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aDtcblx0ICAgIHRoaXMuZW1pdCgnZmx1c2gnKTtcblx0ICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIFNlbmRzIGEgbWVzc2FnZS5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5cblx0ICogQHJldHVybiB7U29ja2V0fSBmb3IgY2hhaW5pbmcuXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdFNvY2tldC5wcm90b3R5cGUud3JpdGUgPVxuXHRTb2NrZXQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAobXNnLCBvcHRpb25zLCBmbikge1xuXHQgIHRoaXMuc2VuZFBhY2tldCgnbWVzc2FnZScsIG1zZywgb3B0aW9ucywgZm4pO1xuXHQgIHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZW5kcyBhIHBhY2tldC5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IHBhY2tldCB0eXBlLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5cblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0U29ja2V0LnByb3RvdHlwZS5zZW5kUGFja2V0ID0gZnVuY3Rpb24gKHR5cGUsIGRhdGEsIG9wdGlvbnMsIGZuKSB7XG5cdCAgaWYoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSkge1xuXHQgICAgZm4gPSBkYXRhO1xuXHQgICAgZGF0YSA9IHVuZGVmaW5lZDtcblx0ICB9XG5cblx0ICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2Ygb3B0aW9ucykge1xuXHQgICAgZm4gPSBvcHRpb25zO1xuXHQgICAgb3B0aW9ucyA9IG51bGw7XG5cdCAgfVxuXG5cdCAgaWYgKCdjbG9zaW5nJyA9PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ2Nsb3NlZCcgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG5cdCAgICByZXR1cm47XG5cdCAgfVxuXG5cdCAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdCAgb3B0aW9ucy5jb21wcmVzcyA9IGZhbHNlICE9PSBvcHRpb25zLmNvbXByZXNzO1xuXG5cdCAgdmFyIHBhY2tldCA9IHtcblx0ICAgIHR5cGU6IHR5cGUsXG5cdCAgICBkYXRhOiBkYXRhLFxuXHQgICAgb3B0aW9uczogb3B0aW9uc1xuXHQgIH07XG5cdCAgdGhpcy5lbWl0KCdwYWNrZXRDcmVhdGUnLCBwYWNrZXQpO1xuXHQgIHRoaXMud3JpdGVCdWZmZXIucHVzaChwYWNrZXQpO1xuXHQgIGlmIChmbikgdGhpcy5vbmNlKCdmbHVzaCcsIGZuKTtcblx0ICB0aGlzLmZsdXNoKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENsb3NlcyB0aGUgY29ubmVjdGlvbi5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFNvY2tldC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgaWYgKCdvcGVuaW5nJyA9PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09IHRoaXMucmVhZHlTdGF0ZSkge1xuXHQgICAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NpbmcnO1xuXG5cdCAgICB2YXIgc2VsZiA9IHRoaXM7XG5cblx0ICAgIGlmICh0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCkge1xuXHQgICAgICB0aGlzLm9uY2UoJ2RyYWluJywgZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgaWYgKHRoaXMudXBncmFkaW5nKSB7XG5cdCAgICAgICAgICB3YWl0Rm9yVXBncmFkZSgpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICBjbG9zZSgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSk7XG5cdCAgICB9IGVsc2UgaWYgKHRoaXMudXBncmFkaW5nKSB7XG5cdCAgICAgIHdhaXRGb3JVcGdyYWRlKCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBjbG9zZSgpO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGNsb3NlKCkge1xuXHQgICAgc2VsZi5vbkNsb3NlKCdmb3JjZWQgY2xvc2UnKTtcblx0ICAgIGRlYnVnKCdzb2NrZXQgY2xvc2luZyAtIHRlbGxpbmcgdHJhbnNwb3J0IHRvIGNsb3NlJyk7XG5cdCAgICBzZWxmLnRyYW5zcG9ydC5jbG9zZSgpO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGNsZWFudXBBbmRDbG9zZSgpIHtcblx0ICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ3VwZ3JhZGUnLCBjbGVhbnVwQW5kQ2xvc2UpO1xuXHQgICAgc2VsZi5yZW1vdmVMaXN0ZW5lcigndXBncmFkZUVycm9yJywgY2xlYW51cEFuZENsb3NlKTtcblx0ICAgIGNsb3NlKCk7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gd2FpdEZvclVwZ3JhZGUoKSB7XG5cdCAgICAvLyB3YWl0IGZvciB1cGdyYWRlIHRvIGZpbmlzaCBzaW5jZSB3ZSBjYW4ndCBzZW5kIHBhY2tldHMgd2hpbGUgcGF1c2luZyBhIHRyYW5zcG9ydFxuXHQgICAgc2VsZi5vbmNlKCd1cGdyYWRlJywgY2xlYW51cEFuZENsb3NlKTtcblx0ICAgIHNlbGYub25jZSgndXBncmFkZUVycm9yJywgY2xlYW51cEFuZENsb3NlKTtcblx0ICB9XG5cblx0ICByZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IGVycm9yXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRTb2NrZXQucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG5cdCAgZGVidWcoJ3NvY2tldCBlcnJvciAlaicsIGVycik7XG5cdCAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IGZhbHNlO1xuXHQgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuXHQgIHRoaXMub25DbG9zZSgndHJhbnNwb3J0IGVycm9yJywgZXJyKTtcblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IGNsb3NlLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0U29ja2V0LnByb3RvdHlwZS5vbkNsb3NlID0gZnVuY3Rpb24gKHJlYXNvbiwgZGVzYykge1xuXHQgIGlmICgnb3BlbmluZycgPT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdvcGVuJyA9PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ2Nsb3NpbmcnID09IHRoaXMucmVhZHlTdGF0ZSkge1xuXHQgICAgZGVidWcoJ3NvY2tldCBjbG9zZSB3aXRoIHJlYXNvbjogXCIlc1wiJywgcmVhc29uKTtcblx0ICAgIHZhciBzZWxmID0gdGhpcztcblxuXHQgICAgLy8gY2xlYXIgdGltZXJzXG5cdCAgICBjbGVhclRpbWVvdXQodGhpcy5waW5nSW50ZXJ2YWxUaW1lcik7XG5cdCAgICBjbGVhclRpbWVvdXQodGhpcy5waW5nVGltZW91dFRpbWVyKTtcblxuXHQgICAgLy8gc3RvcCBldmVudCBmcm9tIGZpcmluZyBhZ2FpbiBmb3IgdHJhbnNwb3J0XG5cdCAgICB0aGlzLnRyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2Nsb3NlJyk7XG5cblx0ICAgIC8vIGVuc3VyZSB0cmFuc3BvcnQgd29uJ3Qgc3RheSBvcGVuXG5cdCAgICB0aGlzLnRyYW5zcG9ydC5jbG9zZSgpO1xuXG5cdCAgICAvLyBpZ25vcmUgZnVydGhlciB0cmFuc3BvcnQgY29tbXVuaWNhdGlvblxuXHQgICAgdGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG5cblx0ICAgIC8vIHNldCByZWFkeSBzdGF0ZVxuXHQgICAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG5cblx0ICAgIC8vIGNsZWFyIHNlc3Npb24gaWRcblx0ICAgIHRoaXMuaWQgPSBudWxsO1xuXG5cdCAgICAvLyBlbWl0IGNsb3NlIGV2ZW50XG5cdCAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgcmVhc29uLCBkZXNjKTtcblxuXHQgICAgLy8gY2xlYW4gYnVmZmVycyBhZnRlciwgc28gdXNlcnMgY2FuIHN0aWxsXG5cdCAgICAvLyBncmFiIHRoZSBidWZmZXJzIG9uIGBjbG9zZWAgZXZlbnRcblx0ICAgIHNlbGYud3JpdGVCdWZmZXIgPSBbXTtcblx0ICAgIHNlbGYucHJldkJ1ZmZlckxlbiA9IDA7XG5cdCAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBGaWx0ZXJzIHVwZ3JhZGVzLCByZXR1cm5pbmcgb25seSB0aG9zZSBtYXRjaGluZyBjbGllbnQgdHJhbnNwb3J0cy5cblx0ICpcblx0ICogQHBhcmFtIHtBcnJheX0gc2VydmVyIHVwZ3JhZGVzXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKlxuXHQgKi9cblxuXHRTb2NrZXQucHJvdG90eXBlLmZpbHRlclVwZ3JhZGVzID0gZnVuY3Rpb24gKHVwZ3JhZGVzKSB7XG5cdCAgdmFyIGZpbHRlcmVkVXBncmFkZXMgPSBbXTtcblx0ICBmb3IgKHZhciBpID0gMCwgaiA9IHVwZ3JhZGVzLmxlbmd0aDsgaTxqOyBpKyspIHtcblx0ICAgIGlmICh+aW5kZXgodGhpcy50cmFuc3BvcnRzLCB1cGdyYWRlc1tpXSkpIGZpbHRlcmVkVXBncmFkZXMucHVzaCh1cGdyYWRlc1tpXSk7XG5cdCAgfVxuXHQgIHJldHVybiBmaWx0ZXJlZFVwZ3JhZGVzO1xuXHR9O1xuXG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KCkpKSlcblxuLyoqKi8gfSxcbi8qIDE4ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7LyoqXG5cdCAqIE1vZHVsZSBkZXBlbmRlbmNpZXNcblx0ICovXG5cblx0dmFyIFhNTEh0dHBSZXF1ZXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XG5cdHZhciBYSFIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKTtcblx0dmFyIEpTT05QID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNyk7XG5cdHZhciB3ZWJzb2NrZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4KTtcblxuXHQvKipcblx0ICogRXhwb3J0IHRyYW5zcG9ydHMuXG5cdCAqL1xuXG5cdGV4cG9ydHMucG9sbGluZyA9IHBvbGxpbmc7XG5cdGV4cG9ydHMud2Vic29ja2V0ID0gd2Vic29ja2V0O1xuXG5cdC8qKlxuXHQgKiBQb2xsaW5nIHRyYW5zcG9ydCBwb2x5bW9ycGhpYyBjb25zdHJ1Y3Rvci5cblx0ICogRGVjaWRlcyBvbiB4aHIgdnMganNvbnAgYmFzZWQgb24gZmVhdHVyZSBkZXRlY3Rpb24uXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRmdW5jdGlvbiBwb2xsaW5nKG9wdHMpe1xuXHQgIHZhciB4aHI7XG5cdCAgdmFyIHhkID0gZmFsc2U7XG5cdCAgdmFyIHhzID0gZmFsc2U7XG5cdCAgdmFyIGpzb25wID0gZmFsc2UgIT09IG9wdHMuanNvbnA7XG5cblx0ICBpZiAoZ2xvYmFsLmxvY2F0aW9uKSB7XG5cdCAgICB2YXIgaXNTU0wgPSAnaHR0cHM6JyA9PSBsb2NhdGlvbi5wcm90b2NvbDtcblx0ICAgIHZhciBwb3J0ID0gbG9jYXRpb24ucG9ydDtcblxuXHQgICAgLy8gc29tZSB1c2VyIGFnZW50cyBoYXZlIGVtcHR5IGBsb2NhdGlvbi5wb3J0YFxuXHQgICAgaWYgKCFwb3J0KSB7XG5cdCAgICAgIHBvcnQgPSBpc1NTTCA/IDQ0MyA6IDgwO1xuXHQgICAgfVxuXG5cdCAgICB4ZCA9IG9wdHMuaG9zdG5hbWUgIT0gbG9jYXRpb24uaG9zdG5hbWUgfHwgcG9ydCAhPSBvcHRzLnBvcnQ7XG5cdCAgICB4cyA9IG9wdHMuc2VjdXJlICE9IGlzU1NMO1xuXHQgIH1cblxuXHQgIG9wdHMueGRvbWFpbiA9IHhkO1xuXHQgIG9wdHMueHNjaGVtZSA9IHhzO1xuXHQgIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdChvcHRzKTtcblxuXHQgIGlmICgnb3BlbicgaW4geGhyICYmICFvcHRzLmZvcmNlSlNPTlApIHtcblx0ICAgIHJldHVybiBuZXcgWEhSKG9wdHMpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBpZiAoIWpzb25wKSB0aHJvdyBuZXcgRXJyb3IoJ0pTT05QIGRpc2FibGVkJyk7XG5cdCAgICByZXR1cm4gbmV3IEpTT05QKG9wdHMpO1xuXHQgIH1cblx0fVxuXG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KCkpKSlcblxuLyoqKi8gfSxcbi8qIDE5ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvLyBicm93c2VyIHNoaW0gZm9yIHhtbGh0dHByZXF1ZXN0IG1vZHVsZVxuXHR2YXIgaGFzQ09SUyA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xuXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3B0cykge1xuXHQgIHZhciB4ZG9tYWluID0gb3B0cy54ZG9tYWluO1xuXG5cdCAgLy8gc2NoZW1lIG11c3QgYmUgc2FtZSB3aGVuIHVzaWduIFhEb21haW5SZXF1ZXN0XG5cdCAgLy8gaHR0cDovL2Jsb2dzLm1zZG4uY29tL2IvaWVpbnRlcm5hbHMvYXJjaGl2ZS8yMDEwLzA1LzEzL3hkb21haW5yZXF1ZXN0LXJlc3RyaWN0aW9ucy1saW1pdGF0aW9ucy1hbmQtd29ya2Fyb3VuZHMuYXNweFxuXHQgIHZhciB4c2NoZW1lID0gb3B0cy54c2NoZW1lO1xuXG5cdCAgLy8gWERvbWFpblJlcXVlc3QgaGFzIGEgZmxvdyBvZiBub3Qgc2VuZGluZyBjb29raWUsIHRoZXJlZm9yZSBpdCBzaG91bGQgYmUgZGlzYWJsZWQgYXMgYSBkZWZhdWx0LlxuXHQgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9BdXRvbWF0dGljL2VuZ2luZS5pby1jbGllbnQvcHVsbC8yMTdcblx0ICB2YXIgZW5hYmxlc1hEUiA9IG9wdHMuZW5hYmxlc1hEUjtcblxuXHQgIC8vIFhNTEh0dHBSZXF1ZXN0IGNhbiBiZSBkaXNhYmxlZCBvbiBJRVxuXHQgIHRyeSB7XG5cdCAgICBpZiAoJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICYmICgheGRvbWFpbiB8fCBoYXNDT1JTKSkge1xuXHQgICAgICByZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cdCAgICB9XG5cdCAgfSBjYXRjaCAoZSkgeyB9XG5cblx0ICAvLyBVc2UgWERvbWFpblJlcXVlc3QgZm9yIElFOCBpZiBlbmFibGVzWERSIGlzIHRydWVcblx0ICAvLyBiZWNhdXNlIGxvYWRpbmcgYmFyIGtlZXBzIGZsYXNoaW5nIHdoZW4gdXNpbmcganNvbnAtcG9sbGluZ1xuXHQgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS95dWppb3Nha2Evc29ja2UuaW8taWU4LWxvYWRpbmctZXhhbXBsZVxuXHQgIHRyeSB7XG5cdCAgICBpZiAoJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIFhEb21haW5SZXF1ZXN0ICYmICF4c2NoZW1lICYmIGVuYWJsZXNYRFIpIHtcblx0ICAgICAgcmV0dXJuIG5ldyBYRG9tYWluUmVxdWVzdCgpO1xuXHQgICAgfVxuXHQgIH0gY2F0Y2ggKGUpIHsgfVxuXG5cdCAgaWYgKCF4ZG9tYWluKSB7XG5cdCAgICB0cnkge1xuXHQgICAgICByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01pY3Jvc29mdC5YTUxIVFRQJyk7XG5cdCAgICB9IGNhdGNoKGUpIHsgfVxuXHQgIH1cblx0fVxuXG5cbi8qKiovIH0sXG4vKiAyMCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0XG5cdC8qKlxuXHQgKiBNb2R1bGUgZXhwb3J0cy5cblx0ICpcblx0ICogTG9naWMgYm9ycm93ZWQgZnJvbSBNb2Rlcm5penI6XG5cdCAqXG5cdCAqICAgLSBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9mZWF0dXJlLWRldGVjdHMvY29ycy5qc1xuXHQgKi9cblxuXHR0cnkge1xuXHQgIG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJyAmJlxuXHQgICAgJ3dpdGhDcmVkZW50aWFscycgaW4gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cdH0gY2F0Y2ggKGVycikge1xuXHQgIC8vIGlmIFhNTEh0dHAgc3VwcG9ydCBpcyBkaXNhYmxlZCBpbiBJRSB0aGVuIGl0IHdpbGwgdGhyb3dcblx0ICAvLyB3aGVuIHRyeWluZyB0byBjcmVhdGVcblx0ICBtb2R1bGUuZXhwb3J0cyA9IGZhbHNlO1xuXHR9XG5cblxuLyoqKi8gfSxcbi8qIDIxICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7LyoqXG5cdCAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG5cdCAqL1xuXG5cdHZhciBYTUxIdHRwUmVxdWVzdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xuXHR2YXIgUG9sbGluZyA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xuXHR2YXIgRW1pdHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xuXHR2YXIgaW5oZXJpdCA9IF9fd2VicGFja19yZXF1aXJlX18oMzUpO1xuXHR2YXIgZGVidWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKCdlbmdpbmUuaW8tY2xpZW50OnBvbGxpbmcteGhyJyk7XG5cblx0LyoqXG5cdCAqIE1vZHVsZSBleHBvcnRzLlxuXHQgKi9cblxuXHRtb2R1bGUuZXhwb3J0cyA9IFhIUjtcblx0bW9kdWxlLmV4cG9ydHMuUmVxdWVzdCA9IFJlcXVlc3Q7XG5cblx0LyoqXG5cdCAqIEVtcHR5IGZ1bmN0aW9uXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIGVtcHR5KCl7fVxuXG5cdC8qKlxuXHQgKiBYSFIgUG9sbGluZyBjb25zdHJ1Y3Rvci5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdHNcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZnVuY3Rpb24gWEhSKG9wdHMpe1xuXHQgIFBvbGxpbmcuY2FsbCh0aGlzLCBvcHRzKTtcblxuXHQgIGlmIChnbG9iYWwubG9jYXRpb24pIHtcblx0ICAgIHZhciBpc1NTTCA9ICdodHRwczonID09IGxvY2F0aW9uLnByb3RvY29sO1xuXHQgICAgdmFyIHBvcnQgPSBsb2NhdGlvbi5wb3J0O1xuXG5cdCAgICAvLyBzb21lIHVzZXIgYWdlbnRzIGhhdmUgZW1wdHkgYGxvY2F0aW9uLnBvcnRgXG5cdCAgICBpZiAoIXBvcnQpIHtcblx0ICAgICAgcG9ydCA9IGlzU1NMID8gNDQzIDogODA7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMueGQgPSBvcHRzLmhvc3RuYW1lICE9IGdsb2JhbC5sb2NhdGlvbi5ob3N0bmFtZSB8fFxuXHQgICAgICBwb3J0ICE9IG9wdHMucG9ydDtcblx0ICAgIHRoaXMueHMgPSBvcHRzLnNlY3VyZSAhPSBpc1NTTDtcblx0ICB9IGVsc2Uge1xuXHQgICAgdGhpcy5leHRyYUhlYWRlcnMgPSBvcHRzLmV4dHJhSGVhZGVycztcblx0ICB9XG5cdH1cblxuXHQvKipcblx0ICogSW5oZXJpdHMgZnJvbSBQb2xsaW5nLlxuXHQgKi9cblxuXHRpbmhlcml0KFhIUiwgUG9sbGluZyk7XG5cblx0LyoqXG5cdCAqIFhIUiBzdXBwb3J0cyBiaW5hcnlcblx0ICovXG5cblx0WEhSLnByb3RvdHlwZS5zdXBwb3J0c0JpbmFyeSA9IHRydWU7XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSByZXF1ZXN0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRYSFIucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbihvcHRzKXtcblx0ICBvcHRzID0gb3B0cyB8fCB7fTtcblx0ICBvcHRzLnVyaSA9IHRoaXMudXJpKCk7XG5cdCAgb3B0cy54ZCA9IHRoaXMueGQ7XG5cdCAgb3B0cy54cyA9IHRoaXMueHM7XG5cdCAgb3B0cy5hZ2VudCA9IHRoaXMuYWdlbnQgfHwgZmFsc2U7XG5cdCAgb3B0cy5zdXBwb3J0c0JpbmFyeSA9IHRoaXMuc3VwcG9ydHNCaW5hcnk7XG5cdCAgb3B0cy5lbmFibGVzWERSID0gdGhpcy5lbmFibGVzWERSO1xuXG5cdCAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG5cdCAgb3B0cy5wZnggPSB0aGlzLnBmeDtcblx0ICBvcHRzLmtleSA9IHRoaXMua2V5O1xuXHQgIG9wdHMucGFzc3BocmFzZSA9IHRoaXMucGFzc3BocmFzZTtcblx0ICBvcHRzLmNlcnQgPSB0aGlzLmNlcnQ7XG5cdCAgb3B0cy5jYSA9IHRoaXMuY2E7XG5cdCAgb3B0cy5jaXBoZXJzID0gdGhpcy5jaXBoZXJzO1xuXHQgIG9wdHMucmVqZWN0VW5hdXRob3JpemVkID0gdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQ7XG5cblx0ICAvLyBvdGhlciBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuXHQgIG9wdHMuZXh0cmFIZWFkZXJzID0gdGhpcy5leHRyYUhlYWRlcnM7XG5cblx0ICByZXR1cm4gbmV3IFJlcXVlc3Qob3B0cyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNlbmRzIGRhdGEuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhIHRvIHNlbmQuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxlZCB1cG9uIGZsdXNoLlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0WEhSLnByb3RvdHlwZS5kb1dyaXRlID0gZnVuY3Rpb24oZGF0YSwgZm4pe1xuXHQgIHZhciBpc0JpbmFyeSA9IHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJyAmJiBkYXRhICE9PSB1bmRlZmluZWQ7XG5cdCAgdmFyIHJlcSA9IHRoaXMucmVxdWVzdCh7IG1ldGhvZDogJ1BPU1QnLCBkYXRhOiBkYXRhLCBpc0JpbmFyeTogaXNCaW5hcnkgfSk7XG5cdCAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgIHJlcS5vbignc3VjY2VzcycsIGZuKTtcblx0ICByZXEub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyKXtcblx0ICAgIHNlbGYub25FcnJvcigneGhyIHBvc3QgZXJyb3InLCBlcnIpO1xuXHQgIH0pO1xuXHQgIHRoaXMuc2VuZFhociA9IHJlcTtcblx0fTtcblxuXHQvKipcblx0ICogU3RhcnRzIGEgcG9sbCBjeWNsZS5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFhIUi5wcm90b3R5cGUuZG9Qb2xsID0gZnVuY3Rpb24oKXtcblx0ICBkZWJ1ZygneGhyIHBvbGwnKTtcblx0ICB2YXIgcmVxID0gdGhpcy5yZXF1ZXN0KCk7XG5cdCAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgIHJlcS5vbignZGF0YScsIGZ1bmN0aW9uKGRhdGEpe1xuXHQgICAgc2VsZi5vbkRhdGEoZGF0YSk7XG5cdCAgfSk7XG5cdCAgcmVxLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycil7XG5cdCAgICBzZWxmLm9uRXJyb3IoJ3hociBwb2xsIGVycm9yJywgZXJyKTtcblx0ICB9KTtcblx0ICB0aGlzLnBvbGxYaHIgPSByZXE7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlcXVlc3QgY29uc3RydWN0b3Jcblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZnVuY3Rpb24gUmVxdWVzdChvcHRzKXtcblx0ICB0aGlzLm1ldGhvZCA9IG9wdHMubWV0aG9kIHx8ICdHRVQnO1xuXHQgIHRoaXMudXJpID0gb3B0cy51cmk7XG5cdCAgdGhpcy54ZCA9ICEhb3B0cy54ZDtcblx0ICB0aGlzLnhzID0gISFvcHRzLnhzO1xuXHQgIHRoaXMuYXN5bmMgPSBmYWxzZSAhPT0gb3B0cy5hc3luYztcblx0ICB0aGlzLmRhdGEgPSB1bmRlZmluZWQgIT0gb3B0cy5kYXRhID8gb3B0cy5kYXRhIDogbnVsbDtcblx0ICB0aGlzLmFnZW50ID0gb3B0cy5hZ2VudDtcblx0ICB0aGlzLmlzQmluYXJ5ID0gb3B0cy5pc0JpbmFyeTtcblx0ICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gb3B0cy5zdXBwb3J0c0JpbmFyeTtcblx0ICB0aGlzLmVuYWJsZXNYRFIgPSBvcHRzLmVuYWJsZXNYRFI7XG5cblx0ICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcblx0ICB0aGlzLnBmeCA9IG9wdHMucGZ4O1xuXHQgIHRoaXMua2V5ID0gb3B0cy5rZXk7XG5cdCAgdGhpcy5wYXNzcGhyYXNlID0gb3B0cy5wYXNzcGhyYXNlO1xuXHQgIHRoaXMuY2VydCA9IG9wdHMuY2VydDtcblx0ICB0aGlzLmNhID0gb3B0cy5jYTtcblx0ICB0aGlzLmNpcGhlcnMgPSBvcHRzLmNpcGhlcnM7XG5cdCAgdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQgPSBvcHRzLnJlamVjdFVuYXV0aG9yaXplZDtcblxuXHQgIC8vIG90aGVyIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG5cdCAgdGhpcy5leHRyYUhlYWRlcnMgPSBvcHRzLmV4dHJhSGVhZGVycztcblxuXHQgIHRoaXMuY3JlYXRlKCk7XG5cdH1cblxuXHQvKipcblx0ICogTWl4IGluIGBFbWl0dGVyYC5cblx0ICovXG5cblx0RW1pdHRlcihSZXF1ZXN0LnByb3RvdHlwZSk7XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgdGhlIFhIUiBvYmplY3QgYW5kIHNlbmRzIHRoZSByZXF1ZXN0LlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0UmVxdWVzdC5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24oKXtcblx0ICB2YXIgb3B0cyA9IHsgYWdlbnQ6IHRoaXMuYWdlbnQsIHhkb21haW46IHRoaXMueGQsIHhzY2hlbWU6IHRoaXMueHMsIGVuYWJsZXNYRFI6IHRoaXMuZW5hYmxlc1hEUiB9O1xuXG5cdCAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG5cdCAgb3B0cy5wZnggPSB0aGlzLnBmeDtcblx0ICBvcHRzLmtleSA9IHRoaXMua2V5O1xuXHQgIG9wdHMucGFzc3BocmFzZSA9IHRoaXMucGFzc3BocmFzZTtcblx0ICBvcHRzLmNlcnQgPSB0aGlzLmNlcnQ7XG5cdCAgb3B0cy5jYSA9IHRoaXMuY2E7XG5cdCAgb3B0cy5jaXBoZXJzID0gdGhpcy5jaXBoZXJzO1xuXHQgIG9wdHMucmVqZWN0VW5hdXRob3JpemVkID0gdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQ7XG5cblx0ICB2YXIgeGhyID0gdGhpcy54aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3Qob3B0cyk7XG5cdCAgdmFyIHNlbGYgPSB0aGlzO1xuXG5cdCAgdHJ5IHtcblx0ICAgIGRlYnVnKCd4aHIgb3BlbiAlczogJXMnLCB0aGlzLm1ldGhvZCwgdGhpcy51cmkpO1xuXHQgICAgeGhyLm9wZW4odGhpcy5tZXRob2QsIHRoaXMudXJpLCB0aGlzLmFzeW5jKTtcblx0ICAgIHRyeSB7XG5cdCAgICAgIGlmICh0aGlzLmV4dHJhSGVhZGVycykge1xuXHQgICAgICAgIHhoci5zZXREaXNhYmxlSGVhZGVyQ2hlY2sodHJ1ZSk7XG5cdCAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLmV4dHJhSGVhZGVycykge1xuXHQgICAgICAgICAgaWYgKHRoaXMuZXh0cmFIZWFkZXJzLmhhc093blByb3BlcnR5KGkpKSB7XG5cdCAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGksIHRoaXMuZXh0cmFIZWFkZXJzW2ldKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH0gY2F0Y2ggKGUpIHt9XG5cdCAgICBpZiAodGhpcy5zdXBwb3J0c0JpbmFyeSkge1xuXHQgICAgICAvLyBUaGlzIGhhcyB0byBiZSBkb25lIGFmdGVyIG9wZW4gYmVjYXVzZSBGaXJlZm94IGlzIHN0dXBpZFxuXHQgICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEzMjE2OTAzL2dldC1iaW5hcnktZGF0YS13aXRoLXhtbGh0dHByZXF1ZXN0LWluLWEtZmlyZWZveC1leHRlbnNpb25cblx0ICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG5cdCAgICB9XG5cblx0ICAgIGlmICgnUE9TVCcgPT0gdGhpcy5tZXRob2QpIHtcblx0ICAgICAgdHJ5IHtcblx0ICAgICAgICBpZiAodGhpcy5pc0JpbmFyeSkge1xuXHQgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtdHlwZScsICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0gY2F0Y2ggKGUpIHt9XG5cdCAgICB9XG5cblx0ICAgIC8vIGllNiBjaGVja1xuXHQgICAgaWYgKCd3aXRoQ3JlZGVudGlhbHMnIGluIHhocikge1xuXHQgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcblx0ICAgIH1cblxuXHQgICAgaWYgKHRoaXMuaGFzWERSKCkpIHtcblx0ICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCl7XG5cdCAgICAgICAgc2VsZi5vbkxvYWQoKTtcblx0ICAgICAgfTtcblx0ICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbigpe1xuXHQgICAgICAgIHNlbGYub25FcnJvcih4aHIucmVzcG9uc2VUZXh0KTtcblx0ICAgICAgfTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpe1xuXHQgICAgICAgIGlmICg0ICE9IHhoci5yZWFkeVN0YXRlKSByZXR1cm47XG5cdCAgICAgICAgaWYgKDIwMCA9PSB4aHIuc3RhdHVzIHx8IDEyMjMgPT0geGhyLnN0YXR1cykge1xuXHQgICAgICAgICAgc2VsZi5vbkxvYWQoKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgLy8gbWFrZSBzdXJlIHRoZSBgZXJyb3JgIGV2ZW50IGhhbmRsZXIgdGhhdCdzIHVzZXItc2V0XG5cdCAgICAgICAgICAvLyBkb2VzIG5vdCB0aHJvdyBpbiB0aGUgc2FtZSB0aWNrIGFuZCBnZXRzIGNhdWdodCBoZXJlXG5cdCAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG5cdCAgICAgICAgICAgIHNlbGYub25FcnJvcih4aHIuc3RhdHVzKTtcblx0ICAgICAgICAgIH0sIDApO1xuXHQgICAgICAgIH1cblx0ICAgICAgfTtcblx0ICAgIH1cblxuXHQgICAgZGVidWcoJ3hociBkYXRhICVzJywgdGhpcy5kYXRhKTtcblx0ICAgIHhoci5zZW5kKHRoaXMuZGF0YSk7XG5cdCAgfSBjYXRjaCAoZSkge1xuXHQgICAgLy8gTmVlZCB0byBkZWZlciBzaW5jZSAuY3JlYXRlKCkgaXMgY2FsbGVkIGRpcmVjdGx5IGZocm9tIHRoZSBjb25zdHJ1Y3RvclxuXHQgICAgLy8gYW5kIHRodXMgdGhlICdlcnJvcicgZXZlbnQgY2FuIG9ubHkgYmUgb25seSBib3VuZCAqYWZ0ZXIqIHRoaXMgZXhjZXB0aW9uXG5cdCAgICAvLyBvY2N1cnMuICBUaGVyZWZvcmUsIGFsc28sIHdlIGNhbm5vdCB0aHJvdyBoZXJlIGF0IGFsbC5cblx0ICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdCAgICAgIHNlbGYub25FcnJvcihlKTtcblx0ICAgIH0sIDApO1xuXHQgICAgcmV0dXJuO1xuXHQgIH1cblxuXHQgIGlmIChnbG9iYWwuZG9jdW1lbnQpIHtcblx0ICAgIHRoaXMuaW5kZXggPSBSZXF1ZXN0LnJlcXVlc3RzQ291bnQrKztcblx0ICAgIFJlcXVlc3QucmVxdWVzdHNbdGhpcy5pbmRleF0gPSB0aGlzO1xuXHQgIH1cblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIHVwb24gc3VjY2Vzc2Z1bCByZXNwb25zZS5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFJlcXVlc3QucHJvdG90eXBlLm9uU3VjY2VzcyA9IGZ1bmN0aW9uKCl7XG5cdCAgdGhpcy5lbWl0KCdzdWNjZXNzJyk7XG5cdCAgdGhpcy5jbGVhbnVwKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxlZCBpZiB3ZSBoYXZlIGRhdGEuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRSZXF1ZXN0LnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbihkYXRhKXtcblx0ICB0aGlzLmVtaXQoJ2RhdGEnLCBkYXRhKTtcblx0ICB0aGlzLm9uU3VjY2VzcygpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgdXBvbiBlcnJvci5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFJlcXVlc3QucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbihlcnIpe1xuXHQgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuXHQgIHRoaXMuY2xlYW51cCh0cnVlKTtcblx0fTtcblxuXHQvKipcblx0ICogQ2xlYW5zIHVwIGhvdXNlLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0UmVxdWVzdC5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uKGZyb21FcnJvcil7XG5cdCAgaWYgKCd1bmRlZmluZWQnID09IHR5cGVvZiB0aGlzLnhociB8fCBudWxsID09PSB0aGlzLnhocikge1xuXHQgICAgcmV0dXJuO1xuXHQgIH1cblx0ICAvLyB4bWxodHRwcmVxdWVzdFxuXHQgIGlmICh0aGlzLmhhc1hEUigpKSB7XG5cdCAgICB0aGlzLnhoci5vbmxvYWQgPSB0aGlzLnhoci5vbmVycm9yID0gZW1wdHk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHRoaXMueGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGVtcHR5O1xuXHQgIH1cblxuXHQgIGlmIChmcm9tRXJyb3IpIHtcblx0ICAgIHRyeSB7XG5cdCAgICAgIHRoaXMueGhyLmFib3J0KCk7XG5cdCAgICB9IGNhdGNoKGUpIHt9XG5cdCAgfVxuXG5cdCAgaWYgKGdsb2JhbC5kb2N1bWVudCkge1xuXHQgICAgZGVsZXRlIFJlcXVlc3QucmVxdWVzdHNbdGhpcy5pbmRleF07XG5cdCAgfVxuXG5cdCAgdGhpcy54aHIgPSBudWxsO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgdXBvbiBsb2FkLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0UmVxdWVzdC5wcm90b3R5cGUub25Mb2FkID0gZnVuY3Rpb24oKXtcblx0ICB2YXIgZGF0YTtcblx0ICB0cnkge1xuXHQgICAgdmFyIGNvbnRlbnRUeXBlO1xuXHQgICAgdHJ5IHtcblx0ICAgICAgY29udGVudFR5cGUgPSB0aGlzLnhoci5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1UeXBlJykuc3BsaXQoJzsnKVswXTtcblx0ICAgIH0gY2F0Y2ggKGUpIHt9XG5cdCAgICBpZiAoY29udGVudFR5cGUgPT09ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nKSB7XG5cdCAgICAgIGRhdGEgPSB0aGlzLnhoci5yZXNwb25zZTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGlmICghdGhpcy5zdXBwb3J0c0JpbmFyeSkge1xuXHQgICAgICAgIGRhdGEgPSB0aGlzLnhoci5yZXNwb25zZVRleHQ7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgIGRhdGEgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KHRoaXMueGhyLnJlc3BvbnNlKSk7XG5cdCAgICAgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICAgICAgdmFyIHVpOEFyciA9IG5ldyBVaW50OEFycmF5KHRoaXMueGhyLnJlc3BvbnNlKTtcblx0ICAgICAgICAgIHZhciBkYXRhQXJyYXkgPSBbXTtcblx0ICAgICAgICAgIGZvciAodmFyIGlkeCA9IDAsIGxlbmd0aCA9IHVpOEFyci5sZW5ndGg7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcblx0ICAgICAgICAgICAgZGF0YUFycmF5LnB1c2godWk4QXJyW2lkeF0pO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICBkYXRhID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBkYXRhQXJyYXkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0gY2F0Y2ggKGUpIHtcblx0ICAgIHRoaXMub25FcnJvcihlKTtcblx0ICB9XG5cdCAgaWYgKG51bGwgIT0gZGF0YSkge1xuXHQgICAgdGhpcy5vbkRhdGEoZGF0YSk7XG5cdCAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDaGVjayBpZiBpdCBoYXMgWERvbWFpblJlcXVlc3QuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRSZXF1ZXN0LnByb3RvdHlwZS5oYXNYRFIgPSBmdW5jdGlvbigpe1xuXHQgIHJldHVybiAndW5kZWZpbmVkJyAhPT0gdHlwZW9mIGdsb2JhbC5YRG9tYWluUmVxdWVzdCAmJiAhdGhpcy54cyAmJiB0aGlzLmVuYWJsZXNYRFI7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFib3J0cyB0aGUgcmVxdWVzdC5cblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0UmVxdWVzdC5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpe1xuXHQgIHRoaXMuY2xlYW51cCgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBYm9ydHMgcGVuZGluZyByZXF1ZXN0cyB3aGVuIHVubG9hZGluZyB0aGUgd2luZG93LiBUaGlzIGlzIG5lZWRlZCB0byBwcmV2ZW50XG5cdCAqIG1lbW9yeSBsZWFrcyAoZS5nLiB3aGVuIHVzaW5nIElFKSBhbmQgdG8gZW5zdXJlIHRoYXQgbm8gc3B1cmlvdXMgZXJyb3IgaXNcblx0ICogZW1pdHRlZC5cblx0ICovXG5cblx0aWYgKGdsb2JhbC5kb2N1bWVudCkge1xuXHQgIFJlcXVlc3QucmVxdWVzdHNDb3VudCA9IDA7XG5cdCAgUmVxdWVzdC5yZXF1ZXN0cyA9IHt9O1xuXHQgIGlmIChnbG9iYWwuYXR0YWNoRXZlbnQpIHtcblx0ICAgIGdsb2JhbC5hdHRhY2hFdmVudCgnb251bmxvYWQnLCB1bmxvYWRIYW5kbGVyKTtcblx0ICB9IGVsc2UgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG5cdCAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgdW5sb2FkSGFuZGxlciwgZmFsc2UpO1xuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIHVubG9hZEhhbmRsZXIoKSB7XG5cdCAgZm9yICh2YXIgaSBpbiBSZXF1ZXN0LnJlcXVlc3RzKSB7XG5cdCAgICBpZiAoUmVxdWVzdC5yZXF1ZXN0cy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuXHQgICAgICBSZXF1ZXN0LnJlcXVlc3RzW2ldLmFib3J0KCk7XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0oKSkpKVxuXG4vKioqLyB9LFxuLyogMjIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8qKlxuXHQgKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuXHQgKi9cblxuXHR2YXIgVHJhbnNwb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XG5cdHZhciBwYXJzZXFzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNCk7XG5cdHZhciBwYXJzZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KTtcblx0dmFyIGluaGVyaXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM1KTtcblx0dmFyIHllYXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNik7XG5cdHZhciBkZWJ1ZyA9IF9fd2VicGFja19yZXF1aXJlX18oMykoJ2VuZ2luZS5pby1jbGllbnQ6cG9sbGluZycpO1xuXG5cdC8qKlxuXHQgKiBNb2R1bGUgZXhwb3J0cy5cblx0ICovXG5cblx0bW9kdWxlLmV4cG9ydHMgPSBQb2xsaW5nO1xuXG5cdC8qKlxuXHQgKiBJcyBYSFIyIHN1cHBvcnRlZD9cblx0ICovXG5cblx0dmFyIGhhc1hIUjIgPSAoZnVuY3Rpb24oKSB7XG5cdCAgdmFyIFhNTEh0dHBSZXF1ZXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XG5cdCAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCh7IHhkb21haW46IGZhbHNlIH0pO1xuXHQgIHJldHVybiBudWxsICE9IHhoci5yZXNwb25zZVR5cGU7XG5cdH0pKCk7XG5cblx0LyoqXG5cdCAqIFBvbGxpbmcgaW50ZXJmYWNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0ZnVuY3Rpb24gUG9sbGluZyhvcHRzKXtcblx0ICB2YXIgZm9yY2VCYXNlNjQgPSAob3B0cyAmJiBvcHRzLmZvcmNlQmFzZTY0KTtcblx0ICBpZiAoIWhhc1hIUjIgfHwgZm9yY2VCYXNlNjQpIHtcblx0ICAgIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcblx0ICB9XG5cdCAgVHJhbnNwb3J0LmNhbGwodGhpcywgb3B0cyk7XG5cdH1cblxuXHQvKipcblx0ICogSW5oZXJpdHMgZnJvbSBUcmFuc3BvcnQuXG5cdCAqL1xuXG5cdGluaGVyaXQoUG9sbGluZywgVHJhbnNwb3J0KTtcblxuXHQvKipcblx0ICogVHJhbnNwb3J0IG5hbWUuXG5cdCAqL1xuXG5cdFBvbGxpbmcucHJvdG90eXBlLm5hbWUgPSAncG9sbGluZyc7XG5cblx0LyoqXG5cdCAqIE9wZW5zIHRoZSBzb2NrZXQgKHRyaWdnZXJzIHBvbGxpbmcpLiBXZSB3cml0ZSBhIFBJTkcgbWVzc2FnZSB0byBkZXRlcm1pbmVcblx0ICogd2hlbiB0aGUgdHJhbnNwb3J0IGlzIG9wZW4uXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRQb2xsaW5nLnByb3RvdHlwZS5kb09wZW4gPSBmdW5jdGlvbigpe1xuXHQgIHRoaXMucG9sbCgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBQYXVzZXMgcG9sbGluZy5cblx0ICpcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgdXBvbiBidWZmZXJzIGFyZSBmbHVzaGVkIGFuZCB0cmFuc3BvcnQgaXMgcGF1c2VkXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRQb2xsaW5nLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uKG9uUGF1c2Upe1xuXHQgIHZhciBwZW5kaW5nID0gMDtcblx0ICB2YXIgc2VsZiA9IHRoaXM7XG5cblx0ICB0aGlzLnJlYWR5U3RhdGUgPSAncGF1c2luZyc7XG5cblx0ICBmdW5jdGlvbiBwYXVzZSgpe1xuXHQgICAgZGVidWcoJ3BhdXNlZCcpO1xuXHQgICAgc2VsZi5yZWFkeVN0YXRlID0gJ3BhdXNlZCc7XG5cdCAgICBvblBhdXNlKCk7XG5cdCAgfVxuXG5cdCAgaWYgKHRoaXMucG9sbGluZyB8fCAhdGhpcy53cml0YWJsZSkge1xuXHQgICAgdmFyIHRvdGFsID0gMDtcblxuXHQgICAgaWYgKHRoaXMucG9sbGluZykge1xuXHQgICAgICBkZWJ1Zygnd2UgYXJlIGN1cnJlbnRseSBwb2xsaW5nIC0gd2FpdGluZyB0byBwYXVzZScpO1xuXHQgICAgICB0b3RhbCsrO1xuXHQgICAgICB0aGlzLm9uY2UoJ3BvbGxDb21wbGV0ZScsIGZ1bmN0aW9uKCl7XG5cdCAgICAgICAgZGVidWcoJ3ByZS1wYXVzZSBwb2xsaW5nIGNvbXBsZXRlJyk7XG5cdCAgICAgICAgLS10b3RhbCB8fCBwYXVzZSgpO1xuXHQgICAgICB9KTtcblx0ICAgIH1cblxuXHQgICAgaWYgKCF0aGlzLndyaXRhYmxlKSB7XG5cdCAgICAgIGRlYnVnKCd3ZSBhcmUgY3VycmVudGx5IHdyaXRpbmcgLSB3YWl0aW5nIHRvIHBhdXNlJyk7XG5cdCAgICAgIHRvdGFsKys7XG5cdCAgICAgIHRoaXMub25jZSgnZHJhaW4nLCBmdW5jdGlvbigpe1xuXHQgICAgICAgIGRlYnVnKCdwcmUtcGF1c2Ugd3JpdGluZyBjb21wbGV0ZScpO1xuXHQgICAgICAgIC0tdG90YWwgfHwgcGF1c2UoKTtcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cdCAgfSBlbHNlIHtcblx0ICAgIHBhdXNlKCk7XG5cdCAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBTdGFydHMgcG9sbGluZyBjeWNsZS5cblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0UG9sbGluZy5wcm90b3R5cGUucG9sbCA9IGZ1bmN0aW9uKCl7XG5cdCAgZGVidWcoJ3BvbGxpbmcnKTtcblx0ICB0aGlzLnBvbGxpbmcgPSB0cnVlO1xuXHQgIHRoaXMuZG9Qb2xsKCk7XG5cdCAgdGhpcy5lbWl0KCdwb2xsJyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIE92ZXJsb2FkcyBvbkRhdGEgdG8gZGV0ZWN0IHBheWxvYWRzLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0UG9sbGluZy5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24oZGF0YSl7XG5cdCAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgIGRlYnVnKCdwb2xsaW5nIGdvdCBkYXRhICVzJywgZGF0YSk7XG5cdCAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24ocGFja2V0LCBpbmRleCwgdG90YWwpIHtcblx0ICAgIC8vIGlmIGl0cyB0aGUgZmlyc3QgbWVzc2FnZSB3ZSBjb25zaWRlciB0aGUgdHJhbnNwb3J0IG9wZW5cblx0ICAgIGlmICgnb3BlbmluZycgPT0gc2VsZi5yZWFkeVN0YXRlKSB7XG5cdCAgICAgIHNlbGYub25PcGVuKCk7XG5cdCAgICB9XG5cblx0ICAgIC8vIGlmIGl0cyBhIGNsb3NlIHBhY2tldCwgd2UgY2xvc2UgdGhlIG9uZ29pbmcgcmVxdWVzdHNcblx0ICAgIGlmICgnY2xvc2UnID09IHBhY2tldC50eXBlKSB7XG5cdCAgICAgIHNlbGYub25DbG9zZSgpO1xuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cblx0ICAgIC8vIG90aGVyd2lzZSBieXBhc3Mgb25EYXRhIGFuZCBoYW5kbGUgdGhlIG1lc3NhZ2Vcblx0ICAgIHNlbGYub25QYWNrZXQocGFja2V0KTtcblx0ICB9O1xuXG5cdCAgLy8gZGVjb2RlIHBheWxvYWRcblx0ICBwYXJzZXIuZGVjb2RlUGF5bG9hZChkYXRhLCB0aGlzLnNvY2tldC5iaW5hcnlUeXBlLCBjYWxsYmFjayk7XG5cblx0ICAvLyBpZiBhbiBldmVudCBkaWQgbm90IHRyaWdnZXIgY2xvc2luZ1xuXHQgIGlmICgnY2xvc2VkJyAhPSB0aGlzLnJlYWR5U3RhdGUpIHtcblx0ICAgIC8vIGlmIHdlIGdvdCBkYXRhIHdlJ3JlIG5vdCBwb2xsaW5nXG5cdCAgICB0aGlzLnBvbGxpbmcgPSBmYWxzZTtcblx0ICAgIHRoaXMuZW1pdCgncG9sbENvbXBsZXRlJyk7XG5cblx0ICAgIGlmICgnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG5cdCAgICAgIHRoaXMucG9sbCgpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgZGVidWcoJ2lnbm9yaW5nIHBvbGwgLSB0cmFuc3BvcnQgc3RhdGUgXCIlc1wiJywgdGhpcy5yZWFkeVN0YXRlKTtcblx0ICAgIH1cblx0ICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIEZvciBwb2xsaW5nLCBzZW5kIGEgY2xvc2UgcGFja2V0LlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0UG9sbGluZy5wcm90b3R5cGUuZG9DbG9zZSA9IGZ1bmN0aW9uKCl7XG5cdCAgdmFyIHNlbGYgPSB0aGlzO1xuXG5cdCAgZnVuY3Rpb24gY2xvc2UoKXtcblx0ICAgIGRlYnVnKCd3cml0aW5nIGNsb3NlIHBhY2tldCcpO1xuXHQgICAgc2VsZi53cml0ZShbeyB0eXBlOiAnY2xvc2UnIH1dKTtcblx0ICB9XG5cblx0ICBpZiAoJ29wZW4nID09IHRoaXMucmVhZHlTdGF0ZSkge1xuXHQgICAgZGVidWcoJ3RyYW5zcG9ydCBvcGVuIC0gY2xvc2luZycpO1xuXHQgICAgY2xvc2UoKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgLy8gaW4gY2FzZSB3ZSdyZSB0cnlpbmcgdG8gY2xvc2Ugd2hpbGVcblx0ICAgIC8vIGhhbmRzaGFraW5nIGlzIGluIHByb2dyZXNzIChHSC0xNjQpXG5cdCAgICBkZWJ1ZygndHJhbnNwb3J0IG5vdCBvcGVuIC0gZGVmZXJyaW5nIGNsb3NlJyk7XG5cdCAgICB0aGlzLm9uY2UoJ29wZW4nLCBjbG9zZSk7XG5cdCAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBXcml0ZXMgYSBwYWNrZXRzIHBheWxvYWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgcGFja2V0c1xuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkcmFpbiBjYWxsYmFja1xuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0UG9sbGluZy5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihwYWNrZXRzKXtcblx0ICB2YXIgc2VsZiA9IHRoaXM7XG5cdCAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXHQgIHZhciBjYWxsYmFja2ZuID0gZnVuY3Rpb24oKSB7XG5cdCAgICBzZWxmLndyaXRhYmxlID0gdHJ1ZTtcblx0ICAgIHNlbGYuZW1pdCgnZHJhaW4nKTtcblx0ICB9O1xuXG5cdCAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgIHBhcnNlci5lbmNvZGVQYXlsb2FkKHBhY2tldHMsIHRoaXMuc3VwcG9ydHNCaW5hcnksIGZ1bmN0aW9uKGRhdGEpIHtcblx0ICAgIHNlbGYuZG9Xcml0ZShkYXRhLCBjYWxsYmFja2ZuKTtcblx0ICB9KTtcblx0fTtcblxuXHQvKipcblx0ICogR2VuZXJhdGVzIHVyaSBmb3IgY29ubmVjdGlvbi5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFBvbGxpbmcucHJvdG90eXBlLnVyaSA9IGZ1bmN0aW9uKCl7XG5cdCAgdmFyIHF1ZXJ5ID0gdGhpcy5xdWVyeSB8fCB7fTtcblx0ICB2YXIgc2NoZW1hID0gdGhpcy5zZWN1cmUgPyAnaHR0cHMnIDogJ2h0dHAnO1xuXHQgIHZhciBwb3J0ID0gJyc7XG5cblx0ICAvLyBjYWNoZSBidXN0aW5nIGlzIGZvcmNlZFxuXHQgIGlmIChmYWxzZSAhPT0gdGhpcy50aW1lc3RhbXBSZXF1ZXN0cykge1xuXHQgICAgcXVlcnlbdGhpcy50aW1lc3RhbXBQYXJhbV0gPSB5ZWFzdCgpO1xuXHQgIH1cblxuXHQgIGlmICghdGhpcy5zdXBwb3J0c0JpbmFyeSAmJiAhcXVlcnkuc2lkKSB7XG5cdCAgICBxdWVyeS5iNjQgPSAxO1xuXHQgIH1cblxuXHQgIHF1ZXJ5ID0gcGFyc2Vxcy5lbmNvZGUocXVlcnkpO1xuXG5cdCAgLy8gYXZvaWQgcG9ydCBpZiBkZWZhdWx0IGZvciBzY2hlbWFcblx0ICBpZiAodGhpcy5wb3J0ICYmICgoJ2h0dHBzJyA9PSBzY2hlbWEgJiYgdGhpcy5wb3J0ICE9IDQ0MykgfHxcblx0ICAgICAoJ2h0dHAnID09IHNjaGVtYSAmJiB0aGlzLnBvcnQgIT0gODApKSkge1xuXHQgICAgcG9ydCA9ICc6JyArIHRoaXMucG9ydDtcblx0ICB9XG5cblx0ICAvLyBwcmVwZW5kID8gdG8gcXVlcnlcblx0ICBpZiAocXVlcnkubGVuZ3RoKSB7XG5cdCAgICBxdWVyeSA9ICc/JyArIHF1ZXJ5O1xuXHQgIH1cblxuXHQgIHZhciBpcHY2ID0gdGhpcy5ob3N0bmFtZS5pbmRleE9mKCc6JykgIT09IC0xO1xuXHQgIHJldHVybiBzY2hlbWEgKyAnOi8vJyArIChpcHY2ID8gJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyA6IHRoaXMuaG9zdG5hbWUpICsgcG9ydCArIHRoaXMucGF0aCArIHF1ZXJ5O1xuXHR9O1xuXG5cbi8qKiovIH0sXG4vKiAyMyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0LyoqXG5cdCAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG5cdCAqL1xuXG5cdHZhciBwYXJzZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KTtcblx0dmFyIEVtaXR0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcblxuXHQvKipcblx0ICogTW9kdWxlIGV4cG9ydHMuXG5cdCAqL1xuXG5cdG1vZHVsZS5leHBvcnRzID0gVHJhbnNwb3J0O1xuXG5cdC8qKlxuXHQgKiBUcmFuc3BvcnQgYWJzdHJhY3QgY29uc3RydWN0b3IuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0ZnVuY3Rpb24gVHJhbnNwb3J0IChvcHRzKSB7XG5cdCAgdGhpcy5wYXRoID0gb3B0cy5wYXRoO1xuXHQgIHRoaXMuaG9zdG5hbWUgPSBvcHRzLmhvc3RuYW1lO1xuXHQgIHRoaXMucG9ydCA9IG9wdHMucG9ydDtcblx0ICB0aGlzLnNlY3VyZSA9IG9wdHMuc2VjdXJlO1xuXHQgIHRoaXMucXVlcnkgPSBvcHRzLnF1ZXJ5O1xuXHQgIHRoaXMudGltZXN0YW1wUGFyYW0gPSBvcHRzLnRpbWVzdGFtcFBhcmFtO1xuXHQgIHRoaXMudGltZXN0YW1wUmVxdWVzdHMgPSBvcHRzLnRpbWVzdGFtcFJlcXVlc3RzO1xuXHQgIHRoaXMucmVhZHlTdGF0ZSA9ICcnO1xuXHQgIHRoaXMuYWdlbnQgPSBvcHRzLmFnZW50IHx8IGZhbHNlO1xuXHQgIHRoaXMuc29ja2V0ID0gb3B0cy5zb2NrZXQ7XG5cdCAgdGhpcy5lbmFibGVzWERSID0gb3B0cy5lbmFibGVzWERSO1xuXG5cdCAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG5cdCAgdGhpcy5wZnggPSBvcHRzLnBmeDtcblx0ICB0aGlzLmtleSA9IG9wdHMua2V5O1xuXHQgIHRoaXMucGFzc3BocmFzZSA9IG9wdHMucGFzc3BocmFzZTtcblx0ICB0aGlzLmNlcnQgPSBvcHRzLmNlcnQ7XG5cdCAgdGhpcy5jYSA9IG9wdHMuY2E7XG5cdCAgdGhpcy5jaXBoZXJzID0gb3B0cy5jaXBoZXJzO1xuXHQgIHRoaXMucmVqZWN0VW5hdXRob3JpemVkID0gb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQ7XG5cblx0ICAvLyBvdGhlciBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuXHQgIHRoaXMuZXh0cmFIZWFkZXJzID0gb3B0cy5leHRyYUhlYWRlcnM7XG5cdH1cblxuXHQvKipcblx0ICogTWl4IGluIGBFbWl0dGVyYC5cblx0ICovXG5cblx0RW1pdHRlcihUcmFuc3BvcnQucHJvdG90eXBlKTtcblxuXHQvKipcblx0ICogRW1pdHMgYW4gZXJyb3IuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcblx0ICogQHJldHVybiB7VHJhbnNwb3J0fSBmb3IgY2hhaW5pbmdcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0VHJhbnNwb3J0LnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKG1zZywgZGVzYykge1xuXHQgIHZhciBlcnIgPSBuZXcgRXJyb3IobXNnKTtcblx0ICBlcnIudHlwZSA9ICdUcmFuc3BvcnRFcnJvcic7XG5cdCAgZXJyLmRlc2NyaXB0aW9uID0gZGVzYztcblx0ICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcblx0ICByZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogT3BlbnMgdGhlIHRyYW5zcG9ydC5cblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0VHJhbnNwb3J0LnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKCkge1xuXHQgIGlmICgnY2xvc2VkJyA9PSB0aGlzLnJlYWR5U3RhdGUgfHwgJycgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG5cdCAgICB0aGlzLnJlYWR5U3RhdGUgPSAnb3BlbmluZyc7XG5cdCAgICB0aGlzLmRvT3BlbigpO1xuXHQgIH1cblxuXHQgIHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDbG9zZXMgdGhlIHRyYW5zcG9ydC5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFRyYW5zcG9ydC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgaWYgKCdvcGVuaW5nJyA9PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09IHRoaXMucmVhZHlTdGF0ZSkge1xuXHQgICAgdGhpcy5kb0Nsb3NlKCk7XG5cdCAgICB0aGlzLm9uQ2xvc2UoKTtcblx0ICB9XG5cblx0ICByZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogU2VuZHMgbXVsdGlwbGUgcGFja2V0cy5cblx0ICpcblx0ICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0VHJhbnNwb3J0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24ocGFja2V0cyl7XG5cdCAgaWYgKCdvcGVuJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcblx0ICAgIHRoaXMud3JpdGUocGFja2V0cyk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IG5vdCBvcGVuJyk7XG5cdCAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgdXBvbiBvcGVuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRUcmFuc3BvcnQucHJvdG90eXBlLm9uT3BlbiA9IGZ1bmN0aW9uICgpIHtcblx0ICB0aGlzLnJlYWR5U3RhdGUgPSAnb3Blbic7XG5cdCAgdGhpcy53cml0YWJsZSA9IHRydWU7XG5cdCAgdGhpcy5lbWl0KCdvcGVuJyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxlZCB3aXRoIGRhdGEuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRUcmFuc3BvcnQucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uKGRhdGEpe1xuXHQgIHZhciBwYWNrZXQgPSBwYXJzZXIuZGVjb2RlUGFja2V0KGRhdGEsIHRoaXMuc29ja2V0LmJpbmFyeVR5cGUpO1xuXHQgIHRoaXMub25QYWNrZXQocGFja2V0KTtcblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIHdpdGggYSBkZWNvZGVkIHBhY2tldC5cblx0ICovXG5cblx0VHJhbnNwb3J0LnByb3RvdHlwZS5vblBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcblx0ICB0aGlzLmVtaXQoJ3BhY2tldCcsIHBhY2tldCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxlZCB1cG9uIGNsb3NlLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0VHJhbnNwb3J0LnByb3RvdHlwZS5vbkNsb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuXHQgIHRoaXMuZW1pdCgnY2xvc2UnKTtcblx0fTtcblxuXG4vKioqLyB9LFxuLyogMjQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHsvKipcblx0ICogTW9kdWxlIGRlcGVuZGVuY2llcy5cblx0ICovXG5cblx0dmFyIGtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KTtcblx0dmFyIGhhc0JpbmFyeSA9IF9fd2VicGFja19yZXF1aXJlX18oMjYpO1xuXHR2YXIgc2xpY2VCdWZmZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KTtcblx0dmFyIGJhc2U2NGVuY29kZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5KTtcblx0dmFyIGFmdGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMCk7XG5cdHZhciB1dGY4ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMSk7XG5cblx0LyoqXG5cdCAqIENoZWNrIGlmIHdlIGFyZSBydW5uaW5nIGFuIGFuZHJvaWQgYnJvd3Nlci4gVGhhdCByZXF1aXJlcyB1cyB0byB1c2Vcblx0ICogQXJyYXlCdWZmZXIgd2l0aCBwb2xsaW5nIHRyYW5zcG9ydHMuLi5cblx0ICpcblx0ICogaHR0cDovL2doaW5kYS5uZXQvanBlZy1ibG9iLWFqYXgtYW5kcm9pZC9cblx0ICovXG5cblx0dmFyIGlzQW5kcm9pZCA9IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0FuZHJvaWQvaSk7XG5cblx0LyoqXG5cdCAqIENoZWNrIGlmIHdlIGFyZSBydW5uaW5nIGluIFBoYW50b21KUy5cblx0ICogVXBsb2FkaW5nIGEgQmxvYiB3aXRoIFBoYW50b21KUyBkb2VzIG5vdCB3b3JrIGNvcnJlY3RseSwgYXMgcmVwb3J0ZWQgaGVyZTpcblx0ICogaHR0cHM6Ly9naXRodWIuY29tL2FyaXlhL3BoYW50b21qcy9pc3N1ZXMvMTEzOTVcblx0ICogQHR5cGUgYm9vbGVhblxuXHQgKi9cblx0dmFyIGlzUGhhbnRvbUpTID0gL1BoYW50b21KUy9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cblx0LyoqXG5cdCAqIFdoZW4gdHJ1ZSwgYXZvaWRzIHVzaW5nIEJsb2JzIHRvIGVuY29kZSBwYXlsb2Fkcy5cblx0ICogQHR5cGUgYm9vbGVhblxuXHQgKi9cblx0dmFyIGRvbnRTZW5kQmxvYnMgPSBpc0FuZHJvaWQgfHwgaXNQaGFudG9tSlM7XG5cblx0LyoqXG5cdCAqIEN1cnJlbnQgcHJvdG9jb2wgdmVyc2lvbi5cblx0ICovXG5cblx0ZXhwb3J0cy5wcm90b2NvbCA9IDM7XG5cblx0LyoqXG5cdCAqIFBhY2tldCB0eXBlcy5cblx0ICovXG5cblx0dmFyIHBhY2tldHMgPSBleHBvcnRzLnBhY2tldHMgPSB7XG5cdCAgICBvcGVuOiAgICAgMCAgICAvLyBub24td3Ncblx0ICAsIGNsb3NlOiAgICAxICAgIC8vIG5vbi13c1xuXHQgICwgcGluZzogICAgIDJcblx0ICAsIHBvbmc6ICAgICAzXG5cdCAgLCBtZXNzYWdlOiAgNFxuXHQgICwgdXBncmFkZTogIDVcblx0ICAsIG5vb3A6ICAgICA2XG5cdH07XG5cblx0dmFyIHBhY2tldHNsaXN0ID0ga2V5cyhwYWNrZXRzKTtcblxuXHQvKipcblx0ICogUHJlbWFkZSBlcnJvciBwYWNrZXQuXG5cdCAqL1xuXG5cdHZhciBlcnIgPSB7IHR5cGU6ICdlcnJvcicsIGRhdGE6ICdwYXJzZXIgZXJyb3InIH07XG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhIGJsb2IgYXBpIGV2ZW4gZm9yIGJsb2IgYnVpbGRlciB3aGVuIHZlbmRvciBwcmVmaXhlcyBleGlzdFxuXHQgKi9cblxuXHR2YXIgQmxvYiA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xuXG5cdC8qKlxuXHQgKiBFbmNvZGVzIGEgcGFja2V0LlxuXHQgKlxuXHQgKiAgICAgPHBhY2tldCB0eXBlIGlkPiBbIDxkYXRhPiBdXG5cdCAqXG5cdCAqIEV4YW1wbGU6XG5cdCAqXG5cdCAqICAgICA1aGVsbG8gd29ybGRcblx0ICogICAgIDNcblx0ICogICAgIDRcblx0ICpcblx0ICogQmluYXJ5IGlzIGVuY29kZWQgaW4gYW4gaWRlbnRpY2FsIHByaW5jaXBsZVxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0ZXhwb3J0cy5lbmNvZGVQYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgdXRmOGVuY29kZSwgY2FsbGJhY2spIHtcblx0ICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2Ygc3VwcG9ydHNCaW5hcnkpIHtcblx0ICAgIGNhbGxiYWNrID0gc3VwcG9ydHNCaW5hcnk7XG5cdCAgICBzdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuXHQgIH1cblxuXHQgIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiB1dGY4ZW5jb2RlKSB7XG5cdCAgICBjYWxsYmFjayA9IHV0ZjhlbmNvZGU7XG5cdCAgICB1dGY4ZW5jb2RlID0gbnVsbDtcblx0ICB9XG5cblx0ICB2YXIgZGF0YSA9IChwYWNrZXQuZGF0YSA9PT0gdW5kZWZpbmVkKVxuXHQgICAgPyB1bmRlZmluZWRcblx0ICAgIDogcGFja2V0LmRhdGEuYnVmZmVyIHx8IHBhY2tldC5kYXRhO1xuXG5cdCAgaWYgKGdsb2JhbC5BcnJheUJ1ZmZlciAmJiBkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcblx0ICAgIHJldHVybiBlbmNvZGVBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjayk7XG5cdCAgfSBlbHNlIGlmIChCbG9iICYmIGRhdGEgaW5zdGFuY2VvZiBnbG9iYWwuQmxvYikge1xuXHQgICAgcmV0dXJuIGVuY29kZUJsb2IocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spO1xuXHQgIH1cblxuXHQgIC8vIG1pZ2h0IGJlIGFuIG9iamVjdCB3aXRoIHsgYmFzZTY0OiB0cnVlLCBkYXRhOiBkYXRhQXNCYXNlNjRTdHJpbmcgfVxuXHQgIGlmIChkYXRhICYmIGRhdGEuYmFzZTY0KSB7XG5cdCAgICByZXR1cm4gZW5jb2RlQmFzZTY0T2JqZWN0KHBhY2tldCwgY2FsbGJhY2spO1xuXHQgIH1cblxuXHQgIC8vIFNlbmRpbmcgZGF0YSBhcyBhIHV0Zi04IHN0cmluZ1xuXHQgIHZhciBlbmNvZGVkID0gcGFja2V0c1twYWNrZXQudHlwZV07XG5cblx0ICAvLyBkYXRhIGZyYWdtZW50IGlzIG9wdGlvbmFsXG5cdCAgaWYgKHVuZGVmaW5lZCAhPT0gcGFja2V0LmRhdGEpIHtcblx0ICAgIGVuY29kZWQgKz0gdXRmOGVuY29kZSA/IHV0ZjguZW5jb2RlKFN0cmluZyhwYWNrZXQuZGF0YSkpIDogU3RyaW5nKHBhY2tldC5kYXRhKTtcblx0ICB9XG5cblx0ICByZXR1cm4gY2FsbGJhY2soJycgKyBlbmNvZGVkKTtcblxuXHR9O1xuXG5cdGZ1bmN0aW9uIGVuY29kZUJhc2U2NE9iamVjdChwYWNrZXQsIGNhbGxiYWNrKSB7XG5cdCAgLy8gcGFja2V0IGRhdGEgaXMgYW4gb2JqZWN0IHsgYmFzZTY0OiB0cnVlLCBkYXRhOiBkYXRhQXNCYXNlNjRTdHJpbmcgfVxuXHQgIHZhciBtZXNzYWdlID0gJ2InICsgZXhwb3J0cy5wYWNrZXRzW3BhY2tldC50eXBlXSArIHBhY2tldC5kYXRhLmRhdGE7XG5cdCAgcmV0dXJuIGNhbGxiYWNrKG1lc3NhZ2UpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEVuY29kZSBwYWNrZXQgaGVscGVycyBmb3IgYmluYXJ5IHR5cGVzXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIGVuY29kZUFycmF5QnVmZmVyKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKSB7XG5cdCAgaWYgKCFzdXBwb3J0c0JpbmFyeSkge1xuXHQgICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0KHBhY2tldCwgY2FsbGJhY2spO1xuXHQgIH1cblxuXHQgIHZhciBkYXRhID0gcGFja2V0LmRhdGE7XG5cdCAgdmFyIGNvbnRlbnRBcnJheSA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuXHQgIHZhciByZXN1bHRCdWZmZXIgPSBuZXcgVWludDhBcnJheSgxICsgZGF0YS5ieXRlTGVuZ3RoKTtcblxuXHQgIHJlc3VsdEJ1ZmZlclswXSA9IHBhY2tldHNbcGFja2V0LnR5cGVdO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgY29udGVudEFycmF5Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICByZXN1bHRCdWZmZXJbaSsxXSA9IGNvbnRlbnRBcnJheVtpXTtcblx0ICB9XG5cblx0ICByZXR1cm4gY2FsbGJhY2socmVzdWx0QnVmZmVyLmJ1ZmZlcik7XG5cdH1cblxuXHRmdW5jdGlvbiBlbmNvZGVCbG9iQXNBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuXHQgIGlmICghc3VwcG9ydHNCaW5hcnkpIHtcblx0ICAgIHJldHVybiBleHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldChwYWNrZXQsIGNhbGxiYWNrKTtcblx0ICB9XG5cblx0ICB2YXIgZnIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXHQgIGZyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgcGFja2V0LmRhdGEgPSBmci5yZXN1bHQ7XG5cdCAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCB0cnVlLCBjYWxsYmFjayk7XG5cdCAgfTtcblx0ICByZXR1cm4gZnIucmVhZEFzQXJyYXlCdWZmZXIocGFja2V0LmRhdGEpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZW5jb2RlQmxvYihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuXHQgIGlmICghc3VwcG9ydHNCaW5hcnkpIHtcblx0ICAgIHJldHVybiBleHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldChwYWNrZXQsIGNhbGxiYWNrKTtcblx0ICB9XG5cblx0ICBpZiAoZG9udFNlbmRCbG9icykge1xuXHQgICAgcmV0dXJuIGVuY29kZUJsb2JBc0FycmF5QnVmZmVyKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKTtcblx0ICB9XG5cblx0ICB2YXIgbGVuZ3RoID0gbmV3IFVpbnQ4QXJyYXkoMSk7XG5cdCAgbGVuZ3RoWzBdID0gcGFja2V0c1twYWNrZXQudHlwZV07XG5cdCAgdmFyIGJsb2IgPSBuZXcgQmxvYihbbGVuZ3RoLmJ1ZmZlciwgcGFja2V0LmRhdGFdKTtcblxuXHQgIHJldHVybiBjYWxsYmFjayhibG9iKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBFbmNvZGVzIGEgcGFja2V0IHdpdGggYmluYXJ5IGRhdGEgaW4gYSBiYXNlNjQgc3RyaW5nXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQsIGhhcyBgdHlwZWAgYW5kIGBkYXRhYFxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGJhc2U2NCBlbmNvZGVkIG1lc3NhZ2Vcblx0ICovXG5cblx0ZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQsIGNhbGxiYWNrKSB7XG5cdCAgdmFyIG1lc3NhZ2UgPSAnYicgKyBleHBvcnRzLnBhY2tldHNbcGFja2V0LnR5cGVdO1xuXHQgIGlmIChCbG9iICYmIHBhY2tldC5kYXRhIGluc3RhbmNlb2YgZ2xvYmFsLkJsb2IpIHtcblx0ICAgIHZhciBmciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cdCAgICBmci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgdmFyIGI2NCA9IGZyLnJlc3VsdC5zcGxpdCgnLCcpWzFdO1xuXHQgICAgICBjYWxsYmFjayhtZXNzYWdlICsgYjY0KTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gZnIucmVhZEFzRGF0YVVSTChwYWNrZXQuZGF0YSk7XG5cdCAgfVxuXG5cdCAgdmFyIGI2NGRhdGE7XG5cdCAgdHJ5IHtcblx0ICAgIGI2NGRhdGEgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KHBhY2tldC5kYXRhKSk7XG5cdCAgfSBjYXRjaCAoZSkge1xuXHQgICAgLy8gaVBob25lIFNhZmFyaSBkb2Vzbid0IGxldCB5b3UgYXBwbHkgd2l0aCB0eXBlZCBhcnJheXNcblx0ICAgIHZhciB0eXBlZCA9IG5ldyBVaW50OEFycmF5KHBhY2tldC5kYXRhKTtcblx0ICAgIHZhciBiYXNpYyA9IG5ldyBBcnJheSh0eXBlZC5sZW5ndGgpO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlZC5sZW5ndGg7IGkrKykge1xuXHQgICAgICBiYXNpY1tpXSA9IHR5cGVkW2ldO1xuXHQgICAgfVxuXHQgICAgYjY0ZGF0YSA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYmFzaWMpO1xuXHQgIH1cblx0ICBtZXNzYWdlICs9IGdsb2JhbC5idG9hKGI2NGRhdGEpO1xuXHQgIHJldHVybiBjYWxsYmFjayhtZXNzYWdlKTtcblx0fTtcblxuXHQvKipcblx0ICogRGVjb2RlcyBhIHBhY2tldC4gQ2hhbmdlcyBmb3JtYXQgdG8gQmxvYiBpZiByZXF1ZXN0ZWQuXG5cdCAqXG5cdCAqIEByZXR1cm4ge09iamVjdH0gd2l0aCBgdHlwZWAgYW5kIGBkYXRhYCAoaWYgYW55KVxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0ZXhwb3J0cy5kZWNvZGVQYWNrZXQgPSBmdW5jdGlvbiAoZGF0YSwgYmluYXJ5VHlwZSwgdXRmOGRlY29kZSkge1xuXHQgIC8vIFN0cmluZyBkYXRhXG5cdCAgaWYgKHR5cGVvZiBkYXRhID09ICdzdHJpbmcnIHx8IGRhdGEgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgaWYgKGRhdGEuY2hhckF0KDApID09ICdiJykge1xuXHQgICAgICByZXR1cm4gZXhwb3J0cy5kZWNvZGVCYXNlNjRQYWNrZXQoZGF0YS5zdWJzdHIoMSksIGJpbmFyeVR5cGUpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAodXRmOGRlY29kZSkge1xuXHQgICAgICB0cnkge1xuXHQgICAgICAgIGRhdGEgPSB1dGY4LmRlY29kZShkYXRhKTtcblx0ICAgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICAgIHJldHVybiBlcnI7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHZhciB0eXBlID0gZGF0YS5jaGFyQXQoMCk7XG5cblx0ICAgIGlmIChOdW1iZXIodHlwZSkgIT0gdHlwZSB8fCAhcGFja2V0c2xpc3RbdHlwZV0pIHtcblx0ICAgICAgcmV0dXJuIGVycjtcblx0ICAgIH1cblxuXHQgICAgaWYgKGRhdGEubGVuZ3RoID4gMSkge1xuXHQgICAgICByZXR1cm4geyB0eXBlOiBwYWNrZXRzbGlzdFt0eXBlXSwgZGF0YTogZGF0YS5zdWJzdHJpbmcoMSkgfTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJldHVybiB7IHR5cGU6IHBhY2tldHNsaXN0W3R5cGVdIH07XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgdmFyIGFzQXJyYXkgPSBuZXcgVWludDhBcnJheShkYXRhKTtcblx0ICB2YXIgdHlwZSA9IGFzQXJyYXlbMF07XG5cdCAgdmFyIHJlc3QgPSBzbGljZUJ1ZmZlcihkYXRhLCAxKTtcblx0ICBpZiAoQmxvYiAmJiBiaW5hcnlUeXBlID09PSAnYmxvYicpIHtcblx0ICAgIHJlc3QgPSBuZXcgQmxvYihbcmVzdF0pO1xuXHQgIH1cblx0ICByZXR1cm4geyB0eXBlOiBwYWNrZXRzbGlzdFt0eXBlXSwgZGF0YTogcmVzdCB9O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEZWNvZGVzIGEgcGFja2V0IGVuY29kZWQgaW4gYSBiYXNlNjQgc3RyaW5nXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBiYXNlNjQgZW5jb2RlZCBtZXNzYWdlXG5cdCAqIEByZXR1cm4ge09iamVjdH0gd2l0aCBgdHlwZWAgYW5kIGBkYXRhYCAoaWYgYW55KVxuXHQgKi9cblxuXHRleHBvcnRzLmRlY29kZUJhc2U2NFBhY2tldCA9IGZ1bmN0aW9uKG1zZywgYmluYXJ5VHlwZSkge1xuXHQgIHZhciB0eXBlID0gcGFja2V0c2xpc3RbbXNnLmNoYXJBdCgwKV07XG5cdCAgaWYgKCFnbG9iYWwuQXJyYXlCdWZmZXIpIHtcblx0ICAgIHJldHVybiB7IHR5cGU6IHR5cGUsIGRhdGE6IHsgYmFzZTY0OiB0cnVlLCBkYXRhOiBtc2cuc3Vic3RyKDEpIH0gfTtcblx0ICB9XG5cblx0ICB2YXIgZGF0YSA9IGJhc2U2NGVuY29kZXIuZGVjb2RlKG1zZy5zdWJzdHIoMSkpO1xuXG5cdCAgaWYgKGJpbmFyeVR5cGUgPT09ICdibG9iJyAmJiBCbG9iKSB7XG5cdCAgICBkYXRhID0gbmV3IEJsb2IoW2RhdGFdKTtcblx0ICB9XG5cblx0ICByZXR1cm4geyB0eXBlOiB0eXBlLCBkYXRhOiBkYXRhIH07XG5cdH07XG5cblx0LyoqXG5cdCAqIEVuY29kZXMgbXVsdGlwbGUgbWVzc2FnZXMgKHBheWxvYWQpLlxuXHQgKlxuXHQgKiAgICAgPGxlbmd0aD46ZGF0YVxuXHQgKlxuXHQgKiBFeGFtcGxlOlxuXHQgKlxuXHQgKiAgICAgMTE6aGVsbG8gd29ybGQyOmhpXG5cdCAqXG5cdCAqIElmIGFueSBjb250ZW50cyBhcmUgYmluYXJ5LCB0aGV5IHdpbGwgYmUgZW5jb2RlZCBhcyBiYXNlNjQgc3RyaW5ncy4gQmFzZTY0XG5cdCAqIGVuY29kZWQgc3RyaW5ncyBhcmUgbWFya2VkIHdpdGggYSBiIGJlZm9yZSB0aGUgbGVuZ3RoIHNwZWNpZmllclxuXHQgKlxuXHQgKiBAcGFyYW0ge0FycmF5fSBwYWNrZXRzXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRleHBvcnRzLmVuY29kZVBheWxvYWQgPSBmdW5jdGlvbiAocGFja2V0cywgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKSB7XG5cdCAgaWYgKHR5cGVvZiBzdXBwb3J0c0JpbmFyeSA9PSAnZnVuY3Rpb24nKSB7XG5cdCAgICBjYWxsYmFjayA9IHN1cHBvcnRzQmluYXJ5O1xuXHQgICAgc3VwcG9ydHNCaW5hcnkgPSBudWxsO1xuXHQgIH1cblxuXHQgIHZhciBpc0JpbmFyeSA9IGhhc0JpbmFyeShwYWNrZXRzKTtcblxuXHQgIGlmIChzdXBwb3J0c0JpbmFyeSAmJiBpc0JpbmFyeSkge1xuXHQgICAgaWYgKEJsb2IgJiYgIWRvbnRTZW5kQmxvYnMpIHtcblx0ICAgICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlUGF5bG9hZEFzQmxvYihwYWNrZXRzLCBjYWxsYmFjayk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBleHBvcnRzLmVuY29kZVBheWxvYWRBc0FycmF5QnVmZmVyKHBhY2tldHMsIGNhbGxiYWNrKTtcblx0ICB9XG5cblx0ICBpZiAoIXBhY2tldHMubGVuZ3RoKSB7XG5cdCAgICByZXR1cm4gY2FsbGJhY2soJzA6Jyk7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gc2V0TGVuZ3RoSGVhZGVyKG1lc3NhZ2UpIHtcblx0ICAgIHJldHVybiBtZXNzYWdlLmxlbmd0aCArICc6JyArIG1lc3NhZ2U7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gZW5jb2RlT25lKHBhY2tldCwgZG9uZUNhbGxiYWNrKSB7XG5cdCAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsICFpc0JpbmFyeSA/IGZhbHNlIDogc3VwcG9ydHNCaW5hcnksIHRydWUsIGZ1bmN0aW9uKG1lc3NhZ2UpIHtcblx0ICAgICAgZG9uZUNhbGxiYWNrKG51bGwsIHNldExlbmd0aEhlYWRlcihtZXNzYWdlKSk7XG5cdCAgICB9KTtcblx0ICB9XG5cblx0ICBtYXAocGFja2V0cywgZW5jb2RlT25lLCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcblx0ICAgIHJldHVybiBjYWxsYmFjayhyZXN1bHRzLmpvaW4oJycpKTtcblx0ICB9KTtcblx0fTtcblxuXHQvKipcblx0ICogQXN5bmMgYXJyYXkgbWFwIHVzaW5nIGFmdGVyXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIG1hcChhcnksIGVhY2gsIGRvbmUpIHtcblx0ICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KGFyeS5sZW5ndGgpO1xuXHQgIHZhciBuZXh0ID0gYWZ0ZXIoYXJ5Lmxlbmd0aCwgZG9uZSk7XG5cblx0ICB2YXIgZWFjaFdpdGhJbmRleCA9IGZ1bmN0aW9uKGksIGVsLCBjYikge1xuXHQgICAgZWFjaChlbCwgZnVuY3Rpb24oZXJyb3IsIG1zZykge1xuXHQgICAgICByZXN1bHRbaV0gPSBtc2c7XG5cdCAgICAgIGNiKGVycm9yLCByZXN1bHQpO1xuXHQgICAgfSk7XG5cdCAgfTtcblxuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJ5Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICBlYWNoV2l0aEluZGV4KGksIGFyeVtpXSwgbmV4dCk7XG5cdCAgfVxuXHR9XG5cblx0Lypcblx0ICogRGVjb2RlcyBkYXRhIHdoZW4gYSBwYXlsb2FkIGlzIG1heWJlIGV4cGVjdGVkLiBQb3NzaWJsZSBiaW5hcnkgY29udGVudHMgYXJlXG5cdCAqIGRlY29kZWQgZnJvbSB0aGVpciBiYXNlNjQgcmVwcmVzZW50YXRpb25cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRhdGEsIGNhbGxiYWNrIG1ldGhvZFxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRleHBvcnRzLmRlY29kZVBheWxvYWQgPSBmdW5jdGlvbiAoZGF0YSwgYmluYXJ5VHlwZSwgY2FsbGJhY2spIHtcblx0ICBpZiAodHlwZW9mIGRhdGEgIT0gJ3N0cmluZycpIHtcblx0ICAgIHJldHVybiBleHBvcnRzLmRlY29kZVBheWxvYWRBc0JpbmFyeShkYXRhLCBiaW5hcnlUeXBlLCBjYWxsYmFjayk7XG5cdCAgfVxuXG5cdCAgaWYgKHR5cGVvZiBiaW5hcnlUeXBlID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICBjYWxsYmFjayA9IGJpbmFyeVR5cGU7XG5cdCAgICBiaW5hcnlUeXBlID0gbnVsbDtcblx0ICB9XG5cblx0ICB2YXIgcGFja2V0O1xuXHQgIGlmIChkYXRhID09ICcnKSB7XG5cdCAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG5cdCAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcblx0ICB9XG5cblx0ICB2YXIgbGVuZ3RoID0gJydcblx0ICAgICwgbiwgbXNnO1xuXG5cdCAgZm9yICh2YXIgaSA9IDAsIGwgPSBkYXRhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHQgICAgdmFyIGNociA9IGRhdGEuY2hhckF0KGkpO1xuXG5cdCAgICBpZiAoJzonICE9IGNocikge1xuXHQgICAgICBsZW5ndGggKz0gY2hyO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgaWYgKCcnID09IGxlbmd0aCB8fCAobGVuZ3RoICE9IChuID0gTnVtYmVyKGxlbmd0aCkpKSkge1xuXHQgICAgICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcblx0ICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIG1zZyA9IGRhdGEuc3Vic3RyKGkgKyAxLCBuKTtcblxuXHQgICAgICBpZiAobGVuZ3RoICE9IG1zZy5sZW5ndGgpIHtcblx0ICAgICAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG5cdCAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAobXNnLmxlbmd0aCkge1xuXHQgICAgICAgIHBhY2tldCA9IGV4cG9ydHMuZGVjb2RlUGFja2V0KG1zZywgYmluYXJ5VHlwZSwgdHJ1ZSk7XG5cblx0ICAgICAgICBpZiAoZXJyLnR5cGUgPT0gcGFja2V0LnR5cGUgJiYgZXJyLmRhdGEgPT0gcGFja2V0LmRhdGEpIHtcblx0ICAgICAgICAgIC8vIHBhcnNlciBlcnJvciBpbiBpbmRpdmlkdWFsIHBhY2tldCAtIGlnbm9yaW5nIHBheWxvYWRcblx0ICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHZhciByZXQgPSBjYWxsYmFjayhwYWNrZXQsIGkgKyBuLCBsKTtcblx0ICAgICAgICBpZiAoZmFsc2UgPT09IHJldCkgcmV0dXJuO1xuXHQgICAgICB9XG5cblx0ICAgICAgLy8gYWR2YW5jZSBjdXJzb3Jcblx0ICAgICAgaSArPSBuO1xuXHQgICAgICBsZW5ndGggPSAnJztcblx0ICAgIH1cblx0ICB9XG5cblx0ICBpZiAobGVuZ3RoICE9ICcnKSB7XG5cdCAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG5cdCAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcblx0ICB9XG5cblx0fTtcblxuXHQvKipcblx0ICogRW5jb2RlcyBtdWx0aXBsZSBtZXNzYWdlcyAocGF5bG9hZCkgYXMgYmluYXJ5LlxuXHQgKlxuXHQgKiA8MSA9IGJpbmFyeSwgMCA9IHN0cmluZz48bnVtYmVyIGZyb20gMC05PjxudW1iZXIgZnJvbSAwLTk+Wy4uLl08bnVtYmVyXG5cdCAqIDI1NT48ZGF0YT5cblx0ICpcblx0ICogRXhhbXBsZTpcblx0ICogMSAzIDI1NSAxIDIgMywgaWYgdGhlIGJpbmFyeSBjb250ZW50cyBhcmUgaW50ZXJwcmV0ZWQgYXMgOCBiaXQgaW50ZWdlcnNcblx0ICpcblx0ICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuXHQgKiBAcmV0dXJuIHtBcnJheUJ1ZmZlcn0gZW5jb2RlZCBwYXlsb2FkXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRleHBvcnRzLmVuY29kZVBheWxvYWRBc0FycmF5QnVmZmVyID0gZnVuY3Rpb24ocGFja2V0cywgY2FsbGJhY2spIHtcblx0ICBpZiAoIXBhY2tldHMubGVuZ3RoKSB7XG5cdCAgICByZXR1cm4gY2FsbGJhY2sobmV3IEFycmF5QnVmZmVyKDApKTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBlbmNvZGVPbmUocGFja2V0LCBkb25lQ2FsbGJhY2spIHtcblx0ICAgIGV4cG9ydHMuZW5jb2RlUGFja2V0KHBhY2tldCwgdHJ1ZSwgdHJ1ZSwgZnVuY3Rpb24oZGF0YSkge1xuXHQgICAgICByZXR1cm4gZG9uZUNhbGxiYWNrKG51bGwsIGRhdGEpO1xuXHQgICAgfSk7XG5cdCAgfVxuXG5cdCAgbWFwKHBhY2tldHMsIGVuY29kZU9uZSwgZnVuY3Rpb24oZXJyLCBlbmNvZGVkUGFja2V0cykge1xuXHQgICAgdmFyIHRvdGFsTGVuZ3RoID0gZW5jb2RlZFBhY2tldHMucmVkdWNlKGZ1bmN0aW9uKGFjYywgcCkge1xuXHQgICAgICB2YXIgbGVuO1xuXHQgICAgICBpZiAodHlwZW9mIHAgPT09ICdzdHJpbmcnKXtcblx0ICAgICAgICBsZW4gPSBwLmxlbmd0aDtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBsZW4gPSBwLmJ5dGVMZW5ndGg7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIGFjYyArIGxlbi50b1N0cmluZygpLmxlbmd0aCArIGxlbiArIDI7IC8vIHN0cmluZy9iaW5hcnkgaWRlbnRpZmllciArIHNlcGFyYXRvciA9IDJcblx0ICAgIH0sIDApO1xuXG5cdCAgICB2YXIgcmVzdWx0QXJyYXkgPSBuZXcgVWludDhBcnJheSh0b3RhbExlbmd0aCk7XG5cblx0ICAgIHZhciBidWZmZXJJbmRleCA9IDA7XG5cdCAgICBlbmNvZGVkUGFja2V0cy5mb3JFYWNoKGZ1bmN0aW9uKHApIHtcblx0ICAgICAgdmFyIGlzU3RyaW5nID0gdHlwZW9mIHAgPT09ICdzdHJpbmcnO1xuXHQgICAgICB2YXIgYWIgPSBwO1xuXHQgICAgICBpZiAoaXNTdHJpbmcpIHtcblx0ICAgICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KHAubGVuZ3RoKTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHAubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgIHZpZXdbaV0gPSBwLmNoYXJDb2RlQXQoaSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGFiID0gdmlldy5idWZmZXI7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoaXNTdHJpbmcpIHsgLy8gbm90IHRydWUgYmluYXJ5XG5cdCAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSAwO1xuXHQgICAgICB9IGVsc2UgeyAvLyB0cnVlIGJpbmFyeVxuXHQgICAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gMTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHZhciBsZW5TdHIgPSBhYi5ieXRlTGVuZ3RoLnRvU3RyaW5nKCk7XG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuU3RyLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSBwYXJzZUludChsZW5TdHJbaV0pO1xuXHQgICAgICB9XG5cdCAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gMjU1O1xuXG5cdCAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYWIpO1xuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXcubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IHZpZXdbaV07XG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICByZXR1cm4gY2FsbGJhY2socmVzdWx0QXJyYXkuYnVmZmVyKTtcblx0ICB9KTtcblx0fTtcblxuXHQvKipcblx0ICogRW5jb2RlIGFzIEJsb2Jcblx0ICovXG5cblx0ZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNCbG9iID0gZnVuY3Rpb24ocGFja2V0cywgY2FsbGJhY2spIHtcblx0ICBmdW5jdGlvbiBlbmNvZGVPbmUocGFja2V0LCBkb25lQ2FsbGJhY2spIHtcblx0ICAgIGV4cG9ydHMuZW5jb2RlUGFja2V0KHBhY2tldCwgdHJ1ZSwgdHJ1ZSwgZnVuY3Rpb24oZW5jb2RlZCkge1xuXHQgICAgICB2YXIgYmluYXJ5SWRlbnRpZmllciA9IG5ldyBVaW50OEFycmF5KDEpO1xuXHQgICAgICBiaW5hcnlJZGVudGlmaWVyWzBdID0gMTtcblx0ICAgICAgaWYgKHR5cGVvZiBlbmNvZGVkID09PSAnc3RyaW5nJykge1xuXHQgICAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZC5sZW5ndGgpO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5jb2RlZC5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgdmlld1tpXSA9IGVuY29kZWQuY2hhckNvZGVBdChpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZW5jb2RlZCA9IHZpZXcuYnVmZmVyO1xuXHQgICAgICAgIGJpbmFyeUlkZW50aWZpZXJbMF0gPSAwO1xuXHQgICAgICB9XG5cblx0ICAgICAgdmFyIGxlbiA9IChlbmNvZGVkIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpXG5cdCAgICAgICAgPyBlbmNvZGVkLmJ5dGVMZW5ndGhcblx0ICAgICAgICA6IGVuY29kZWQuc2l6ZTtcblxuXHQgICAgICB2YXIgbGVuU3RyID0gbGVuLnRvU3RyaW5nKCk7XG5cdCAgICAgIHZhciBsZW5ndGhBcnkgPSBuZXcgVWludDhBcnJheShsZW5TdHIubGVuZ3RoICsgMSk7XG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuU3RyLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgbGVuZ3RoQXJ5W2ldID0gcGFyc2VJbnQobGVuU3RyW2ldKTtcblx0ICAgICAgfVxuXHQgICAgICBsZW5ndGhBcnlbbGVuU3RyLmxlbmd0aF0gPSAyNTU7XG5cblx0ICAgICAgaWYgKEJsb2IpIHtcblx0ICAgICAgICB2YXIgYmxvYiA9IG5ldyBCbG9iKFtiaW5hcnlJZGVudGlmaWVyLmJ1ZmZlciwgbGVuZ3RoQXJ5LmJ1ZmZlciwgZW5jb2RlZF0pO1xuXHQgICAgICAgIGRvbmVDYWxsYmFjayhudWxsLCBibG9iKTtcblx0ICAgICAgfVxuXHQgICAgfSk7XG5cdCAgfVxuXG5cdCAgbWFwKHBhY2tldHMsIGVuY29kZU9uZSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG5cdCAgICByZXR1cm4gY2FsbGJhY2sobmV3IEJsb2IocmVzdWx0cykpO1xuXHQgIH0pO1xuXHR9O1xuXG5cdC8qXG5cdCAqIERlY29kZXMgZGF0YSB3aGVuIGEgcGF5bG9hZCBpcyBtYXliZSBleHBlY3RlZC4gU3RyaW5ncyBhcmUgZGVjb2RlZCBieVxuXHQgKiBpbnRlcnByZXRpbmcgZWFjaCBieXRlIGFzIGEga2V5IGNvZGUgZm9yIGVudHJpZXMgbWFya2VkIHRvIHN0YXJ0IHdpdGggMC4gU2VlXG5cdCAqIGRlc2NyaXB0aW9uIG9mIGVuY29kZVBheWxvYWRBc0JpbmFyeVxuXHQgKlxuXHQgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBkYXRhLCBjYWxsYmFjayBtZXRob2Rcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZXhwb3J0cy5kZWNvZGVQYXlsb2FkQXNCaW5hcnkgPSBmdW5jdGlvbiAoZGF0YSwgYmluYXJ5VHlwZSwgY2FsbGJhY2spIHtcblx0ICBpZiAodHlwZW9mIGJpbmFyeVR5cGUgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgIGNhbGxiYWNrID0gYmluYXJ5VHlwZTtcblx0ICAgIGJpbmFyeVR5cGUgPSBudWxsO1xuXHQgIH1cblxuXHQgIHZhciBidWZmZXJUYWlsID0gZGF0YTtcblx0ICB2YXIgYnVmZmVycyA9IFtdO1xuXG5cdCAgdmFyIG51bWJlclRvb0xvbmcgPSBmYWxzZTtcblx0ICB3aGlsZSAoYnVmZmVyVGFpbC5ieXRlTGVuZ3RoID4gMCkge1xuXHQgICAgdmFyIHRhaWxBcnJheSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlclRhaWwpO1xuXHQgICAgdmFyIGlzU3RyaW5nID0gdGFpbEFycmF5WzBdID09PSAwO1xuXHQgICAgdmFyIG1zZ0xlbmd0aCA9ICcnO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMTsgOyBpKyspIHtcblx0ICAgICAgaWYgKHRhaWxBcnJheVtpXSA9PSAyNTUpIGJyZWFrO1xuXG5cdCAgICAgIGlmIChtc2dMZW5ndGgubGVuZ3RoID4gMzEwKSB7XG5cdCAgICAgICAgbnVtYmVyVG9vTG9uZyA9IHRydWU7XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICAgIH1cblxuXHQgICAgICBtc2dMZW5ndGggKz0gdGFpbEFycmF5W2ldO1xuXHQgICAgfVxuXG5cdCAgICBpZihudW1iZXJUb29Mb25nKSByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcblxuXHQgICAgYnVmZmVyVGFpbCA9IHNsaWNlQnVmZmVyKGJ1ZmZlclRhaWwsIDIgKyBtc2dMZW5ndGgubGVuZ3RoKTtcblx0ICAgIG1zZ0xlbmd0aCA9IHBhcnNlSW50KG1zZ0xlbmd0aCk7XG5cblx0ICAgIHZhciBtc2cgPSBzbGljZUJ1ZmZlcihidWZmZXJUYWlsLCAwLCBtc2dMZW5ndGgpO1xuXHQgICAgaWYgKGlzU3RyaW5nKSB7XG5cdCAgICAgIHRyeSB7XG5cdCAgICAgICAgbXNnID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheShtc2cpKTtcblx0ICAgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICAgIC8vIGlQaG9uZSBTYWZhcmkgZG9lc24ndCBsZXQgeW91IGFwcGx5IHRvIHR5cGVkIGFycmF5c1xuXHQgICAgICAgIHZhciB0eXBlZCA9IG5ldyBVaW50OEFycmF5KG1zZyk7XG5cdCAgICAgICAgbXNnID0gJyc7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlZC5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgbXNnICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodHlwZWRbaV0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBidWZmZXJzLnB1c2gobXNnKTtcblx0ICAgIGJ1ZmZlclRhaWwgPSBzbGljZUJ1ZmZlcihidWZmZXJUYWlsLCBtc2dMZW5ndGgpO1xuXHQgIH1cblxuXHQgIHZhciB0b3RhbCA9IGJ1ZmZlcnMubGVuZ3RoO1xuXHQgIGJ1ZmZlcnMuZm9yRWFjaChmdW5jdGlvbihidWZmZXIsIGkpIHtcblx0ICAgIGNhbGxiYWNrKGV4cG9ydHMuZGVjb2RlUGFja2V0KGJ1ZmZlciwgYmluYXJ5VHlwZSwgdHJ1ZSksIGksIHRvdGFsKTtcblx0ICB9KTtcblx0fTtcblxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSgpKSkpXG5cbi8qKiovIH0sXG4vKiAyNSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0XG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBrZXlzIGZvciBhbiBvYmplY3QuXG5cdCAqXG5cdCAqIEByZXR1cm4ge0FycmF5fSBrZXlzXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRtb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMgKG9iail7XG5cdCAgdmFyIGFyciA9IFtdO1xuXHQgIHZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5cdCAgZm9yICh2YXIgaSBpbiBvYmopIHtcblx0ICAgIGlmIChoYXMuY2FsbChvYmosIGkpKSB7XG5cdCAgICAgIGFyci5wdXNoKGkpO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gYXJyO1xuXHR9O1xuXG5cbi8qKiovIH0sXG4vKiAyNiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkge1xuXHQvKlxuXHQgKiBNb2R1bGUgcmVxdWlyZW1lbnRzLlxuXHQgKi9cblxuXHR2YXIgaXNBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oMjcpO1xuXG5cdC8qKlxuXHQgKiBNb2R1bGUgZXhwb3J0cy5cblx0ICovXG5cblx0bW9kdWxlLmV4cG9ydHMgPSBoYXNCaW5hcnk7XG5cblx0LyoqXG5cdCAqIENoZWNrcyBmb3IgYmluYXJ5IGRhdGEuXG5cdCAqXG5cdCAqIFJpZ2h0IG5vdyBvbmx5IEJ1ZmZlciBhbmQgQXJyYXlCdWZmZXIgYXJlIHN1cHBvcnRlZC4uXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBhbnl0aGluZ1xuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRmdW5jdGlvbiBoYXNCaW5hcnkoZGF0YSkge1xuXG5cdCAgZnVuY3Rpb24gX2hhc0JpbmFyeShvYmopIHtcblx0ICAgIGlmICghb2JqKSByZXR1cm4gZmFsc2U7XG5cblx0ICAgIGlmICggKGdsb2JhbC5CdWZmZXIgJiYgZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlcihvYmopKSB8fFxuXHQgICAgICAgICAoZ2xvYmFsLkFycmF5QnVmZmVyICYmIG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fFxuXHQgICAgICAgICAoZ2xvYmFsLkJsb2IgJiYgb2JqIGluc3RhbmNlb2YgQmxvYikgfHxcblx0ICAgICAgICAgKGdsb2JhbC5GaWxlICYmIG9iaiBpbnN0YW5jZW9mIEZpbGUpXG5cdCAgICAgICAgKSB7XG5cdCAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoaXNBcnJheShvYmopKSB7XG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICBpZiAoX2hhc0JpbmFyeShvYmpbaV0pKSB7XG5cdCAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSBpZiAob2JqICYmICdvYmplY3QnID09IHR5cGVvZiBvYmopIHtcblx0ICAgICAgaWYgKG9iai50b0pTT04pIHtcblx0ICAgICAgICBvYmogPSBvYmoudG9KU09OKCk7XG5cdCAgICAgIH1cblxuXHQgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG5cdCAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkgJiYgX2hhc0JpbmFyeShvYmpba2V5XSkpIHtcblx0ICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIF9oYXNCaW5hcnkoZGF0YSk7XG5cdH1cblxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSgpKSkpXG5cbi8qKiovIH0sXG4vKiAyNyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcblx0ICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcblx0fTtcblxuXG4vKioqLyB9LFxuLyogMjggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdC8qKlxuXHQgKiBBbiBhYnN0cmFjdGlvbiBmb3Igc2xpY2luZyBhbiBhcnJheWJ1ZmZlciBldmVuIHdoZW5cblx0ICogQXJyYXlCdWZmZXIucHJvdG90eXBlLnNsaWNlIGlzIG5vdCBzdXBwb3J0ZWRcblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcnJheWJ1ZmZlciwgc3RhcnQsIGVuZCkge1xuXHQgIHZhciBieXRlcyA9IGFycmF5YnVmZmVyLmJ5dGVMZW5ndGg7XG5cdCAgc3RhcnQgPSBzdGFydCB8fCAwO1xuXHQgIGVuZCA9IGVuZCB8fCBieXRlcztcblxuXHQgIGlmIChhcnJheWJ1ZmZlci5zbGljZSkgeyByZXR1cm4gYXJyYXlidWZmZXIuc2xpY2Uoc3RhcnQsIGVuZCk7IH1cblxuXHQgIGlmIChzdGFydCA8IDApIHsgc3RhcnQgKz0gYnl0ZXM7IH1cblx0ICBpZiAoZW5kIDwgMCkgeyBlbmQgKz0gYnl0ZXM7IH1cblx0ICBpZiAoZW5kID4gYnl0ZXMpIHsgZW5kID0gYnl0ZXM7IH1cblxuXHQgIGlmIChzdGFydCA+PSBieXRlcyB8fCBzdGFydCA+PSBlbmQgfHwgYnl0ZXMgPT09IDApIHtcblx0ICAgIHJldHVybiBuZXcgQXJyYXlCdWZmZXIoMCk7XG5cdCAgfVxuXG5cdCAgdmFyIGFidiA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKTtcblx0ICB2YXIgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoZW5kIC0gc3RhcnQpO1xuXHQgIGZvciAodmFyIGkgPSBzdGFydCwgaWkgPSAwOyBpIDwgZW5kOyBpKyssIGlpKyspIHtcblx0ICAgIHJlc3VsdFtpaV0gPSBhYnZbaV07XG5cdCAgfVxuXHQgIHJldHVybiByZXN1bHQuYnVmZmVyO1xuXHR9O1xuXG5cbi8qKiovIH0sXG4vKiAyOSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0Lypcblx0ICogYmFzZTY0LWFycmF5YnVmZmVyXG5cdCAqIGh0dHBzOi8vZ2l0aHViLmNvbS9uaWtsYXN2aC9iYXNlNjQtYXJyYXlidWZmZXJcblx0ICpcblx0ICogQ29weXJpZ2h0IChjKSAyMDEyIE5pa2xhcyB2b24gSGVydHplblxuXHQgKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5cdCAqL1xuXHQoZnVuY3Rpb24oY2hhcnMpe1xuXHQgIFwidXNlIHN0cmljdFwiO1xuXG5cdCAgZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbihhcnJheWJ1ZmZlcikge1xuXHQgICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpLFxuXHQgICAgaSwgbGVuID0gYnl0ZXMubGVuZ3RoLCBiYXNlNjQgPSBcIlwiO1xuXG5cdCAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKz0zKSB7XG5cdCAgICAgIGJhc2U2NCArPSBjaGFyc1tieXRlc1tpXSA+PiAyXTtcblx0ICAgICAgYmFzZTY0ICs9IGNoYXJzWygoYnl0ZXNbaV0gJiAzKSA8PCA0KSB8IChieXRlc1tpICsgMV0gPj4gNCldO1xuXHQgICAgICBiYXNlNjQgKz0gY2hhcnNbKChieXRlc1tpICsgMV0gJiAxNSkgPDwgMikgfCAoYnl0ZXNbaSArIDJdID4+IDYpXTtcblx0ICAgICAgYmFzZTY0ICs9IGNoYXJzW2J5dGVzW2kgKyAyXSAmIDYzXTtcblx0ICAgIH1cblxuXHQgICAgaWYgKChsZW4gJSAzKSA9PT0gMikge1xuXHQgICAgICBiYXNlNjQgPSBiYXNlNjQuc3Vic3RyaW5nKDAsIGJhc2U2NC5sZW5ndGggLSAxKSArIFwiPVwiO1xuXHQgICAgfSBlbHNlIGlmIChsZW4gJSAzID09PSAxKSB7XG5cdCAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDIpICsgXCI9PVwiO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gYmFzZTY0O1xuXHQgIH07XG5cblx0ICBleHBvcnRzLmRlY29kZSA9ICBmdW5jdGlvbihiYXNlNjQpIHtcblx0ICAgIHZhciBidWZmZXJMZW5ndGggPSBiYXNlNjQubGVuZ3RoICogMC43NSxcblx0ICAgIGxlbiA9IGJhc2U2NC5sZW5ndGgsIGksIHAgPSAwLFxuXHQgICAgZW5jb2RlZDEsIGVuY29kZWQyLCBlbmNvZGVkMywgZW5jb2RlZDQ7XG5cblx0ICAgIGlmIChiYXNlNjRbYmFzZTY0Lmxlbmd0aCAtIDFdID09PSBcIj1cIikge1xuXHQgICAgICBidWZmZXJMZW5ndGgtLTtcblx0ICAgICAgaWYgKGJhc2U2NFtiYXNlNjQubGVuZ3RoIC0gMl0gPT09IFwiPVwiKSB7XG5cdCAgICAgICAgYnVmZmVyTGVuZ3RoLS07XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgdmFyIGFycmF5YnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ1ZmZlckxlbmd0aCksXG5cdCAgICBieXRlcyA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKTtcblxuXHQgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSs9NCkge1xuXHQgICAgICBlbmNvZGVkMSA9IGNoYXJzLmluZGV4T2YoYmFzZTY0W2ldKTtcblx0ICAgICAgZW5jb2RlZDIgPSBjaGFycy5pbmRleE9mKGJhc2U2NFtpKzFdKTtcblx0ICAgICAgZW5jb2RlZDMgPSBjaGFycy5pbmRleE9mKGJhc2U2NFtpKzJdKTtcblx0ICAgICAgZW5jb2RlZDQgPSBjaGFycy5pbmRleE9mKGJhc2U2NFtpKzNdKTtcblxuXHQgICAgICBieXRlc1twKytdID0gKGVuY29kZWQxIDw8IDIpIHwgKGVuY29kZWQyID4+IDQpO1xuXHQgICAgICBieXRlc1twKytdID0gKChlbmNvZGVkMiAmIDE1KSA8PCA0KSB8IChlbmNvZGVkMyA+PiAyKTtcblx0ICAgICAgYnl0ZXNbcCsrXSA9ICgoZW5jb2RlZDMgJiAzKSA8PCA2KSB8IChlbmNvZGVkNCAmIDYzKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGFycmF5YnVmZmVyO1xuXHQgIH07XG5cdH0pKFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiKTtcblxuXG4vKioqLyB9LFxuLyogMzAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdG1vZHVsZS5leHBvcnRzID0gYWZ0ZXJcblxuXHRmdW5jdGlvbiBhZnRlcihjb3VudCwgY2FsbGJhY2ssIGVycl9jYikge1xuXHQgICAgdmFyIGJhaWwgPSBmYWxzZVxuXHQgICAgZXJyX2NiID0gZXJyX2NiIHx8IG5vb3Bcblx0ICAgIHByb3h5LmNvdW50ID0gY291bnRcblxuXHQgICAgcmV0dXJuIChjb3VudCA9PT0gMCkgPyBjYWxsYmFjaygpIDogcHJveHlcblxuXHQgICAgZnVuY3Rpb24gcHJveHkoZXJyLCByZXN1bHQpIHtcblx0ICAgICAgICBpZiAocHJveHkuY291bnQgPD0gMCkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FmdGVyIGNhbGxlZCB0b28gbWFueSB0aW1lcycpXG5cdCAgICAgICAgfVxuXHQgICAgICAgIC0tcHJveHkuY291bnRcblxuXHQgICAgICAgIC8vIGFmdGVyIGZpcnN0IGVycm9yLCByZXN0IGFyZSBwYXNzZWQgdG8gZXJyX2NiXG5cdCAgICAgICAgaWYgKGVycikge1xuXHQgICAgICAgICAgICBiYWlsID0gdHJ1ZVxuXHQgICAgICAgICAgICBjYWxsYmFjayhlcnIpXG5cdCAgICAgICAgICAgIC8vIGZ1dHVyZSBlcnJvciBjYWxsYmFja3Mgd2lsbCBnbyB0byBlcnJvciBoYW5kbGVyXG5cdCAgICAgICAgICAgIGNhbGxiYWNrID0gZXJyX2NiXG5cdCAgICAgICAgfSBlbHNlIGlmIChwcm94eS5jb3VudCA9PT0gMCAmJiAhYmFpbCkge1xuXHQgICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXN1bHQpXG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gbm9vcCgpIHt9XG5cblxuLyoqKi8gfSxcbi8qIDMxICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKG1vZHVsZSwgZ2xvYmFsKSB7LyohIGh0dHBzOi8vbXRocy5iZS91dGY4anMgdjIuMC4wIGJ5IEBtYXRoaWFzICovXG5cdDsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdFx0Ly8gRGV0ZWN0IGZyZWUgdmFyaWFibGVzIGBleHBvcnRzYFxuXHRcdHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHM7XG5cblx0XHQvLyBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYFxuXHRcdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHRcdG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzICYmIG1vZHVsZTtcblxuXHRcdC8vIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgLCBmcm9tIE5vZGUuanMgb3IgQnJvd3NlcmlmaWVkIGNvZGUsXG5cdFx0Ly8gYW5kIHVzZSBpdCBhcyBgcm9vdGBcblx0XHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuXHRcdGlmIChmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCkge1xuXHRcdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdFx0fVxuXG5cdFx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0XHR2YXIgc3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcblxuXHRcdC8vIFRha2VuIGZyb20gaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlXG5cdFx0ZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0XHRcdHZhciBvdXRwdXQgPSBbXTtcblx0XHRcdHZhciBjb3VudGVyID0gMDtcblx0XHRcdHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuXHRcdFx0dmFyIHZhbHVlO1xuXHRcdFx0dmFyIGV4dHJhO1xuXHRcdFx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdFx0Ly8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG5cdFx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdFx0Ly8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHR9XG5cblx0XHQvLyBUYWtlbiBmcm9tIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZVxuXHRcdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHRcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0XHR2YXIgaW5kZXggPSAtMTtcblx0XHRcdHZhciB2YWx1ZTtcblx0XHRcdHZhciBvdXRwdXQgPSAnJztcblx0XHRcdHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdFx0XHRcdHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuXHRcdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdFx0XHR2YWx1ZSAtPSAweDEwMDAwO1xuXHRcdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHRcdFx0fVxuXHRcdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY2hlY2tTY2FsYXJWYWx1ZShjb2RlUG9pbnQpIHtcblx0XHRcdGlmIChjb2RlUG9pbnQgPj0gMHhEODAwICYmIGNvZGVQb2ludCA8PSAweERGRkYpIHtcblx0XHRcdFx0dGhyb3cgRXJyb3IoXG5cdFx0XHRcdFx0J0xvbmUgc3Vycm9nYXRlIFUrJyArIGNvZGVQb2ludC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSArXG5cdFx0XHRcdFx0JyBpcyBub3QgYSBzY2FsYXIgdmFsdWUnXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdFx0ZnVuY3Rpb24gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIHNoaWZ0KSB7XG5cdFx0XHRyZXR1cm4gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IHNoaWZ0KSAmIDB4M0YpIHwgMHg4MCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZW5jb2RlQ29kZVBvaW50KGNvZGVQb2ludCkge1xuXHRcdFx0aWYgKChjb2RlUG9pbnQgJiAweEZGRkZGRjgwKSA9PSAwKSB7IC8vIDEtYnl0ZSBzZXF1ZW5jZVxuXHRcdFx0XHRyZXR1cm4gc3RyaW5nRnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgc3ltYm9sID0gJyc7XG5cdFx0XHRpZiAoKGNvZGVQb2ludCAmIDB4RkZGRkY4MDApID09IDApIHsgLy8gMi1ieXRlIHNlcXVlbmNlXG5cdFx0XHRcdHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiA2KSAmIDB4MUYpIHwgMHhDMCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICgoY29kZVBvaW50ICYgMHhGRkZGMDAwMCkgPT0gMCkgeyAvLyAzLWJ5dGUgc2VxdWVuY2Vcblx0XHRcdFx0Y2hlY2tTY2FsYXJWYWx1ZShjb2RlUG9pbnQpO1xuXHRcdFx0XHRzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gMTIpICYgMHgwRikgfCAweEUwKTtcblx0XHRcdFx0c3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCA2KTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKChjb2RlUG9pbnQgJiAweEZGRTAwMDAwKSA9PSAwKSB7IC8vIDQtYnl0ZSBzZXF1ZW5jZVxuXHRcdFx0XHRzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gMTgpICYgMHgwNykgfCAweEYwKTtcblx0XHRcdFx0c3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCAxMik7XG5cdFx0XHRcdHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgNik7XG5cdFx0XHR9XG5cdFx0XHRzeW1ib2wgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKChjb2RlUG9pbnQgJiAweDNGKSB8IDB4ODApO1xuXHRcdFx0cmV0dXJuIHN5bWJvbDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB1dGY4ZW5jb2RlKHN0cmluZykge1xuXHRcdFx0dmFyIGNvZGVQb2ludHMgPSB1Y3MyZGVjb2RlKHN0cmluZyk7XG5cdFx0XHR2YXIgbGVuZ3RoID0gY29kZVBvaW50cy5sZW5ndGg7XG5cdFx0XHR2YXIgaW5kZXggPSAtMTtcblx0XHRcdHZhciBjb2RlUG9pbnQ7XG5cdFx0XHR2YXIgYnl0ZVN0cmluZyA9ICcnO1xuXHRcdFx0d2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0XHRcdFx0Y29kZVBvaW50ID0gY29kZVBvaW50c1tpbmRleF07XG5cdFx0XHRcdGJ5dGVTdHJpbmcgKz0gZW5jb2RlQ29kZVBvaW50KGNvZGVQb2ludCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYnl0ZVN0cmluZztcblx0XHR9XG5cblx0XHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHRcdGZ1bmN0aW9uIHJlYWRDb250aW51YXRpb25CeXRlKCkge1xuXHRcdFx0aWYgKGJ5dGVJbmRleCA+PSBieXRlQ291bnQpIHtcblx0XHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgYnl0ZSBpbmRleCcpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgY29udGludWF0aW9uQnl0ZSA9IGJ5dGVBcnJheVtieXRlSW5kZXhdICYgMHhGRjtcblx0XHRcdGJ5dGVJbmRleCsrO1xuXG5cdFx0XHRpZiAoKGNvbnRpbnVhdGlvbkJ5dGUgJiAweEMwKSA9PSAweDgwKSB7XG5cdFx0XHRcdHJldHVybiBjb250aW51YXRpb25CeXRlICYgMHgzRjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgd2UgZW5kIHVwIGhlcmUsIGl04oCZcyBub3QgYSBjb250aW51YXRpb24gYnl0ZVxuXHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBkZWNvZGVTeW1ib2woKSB7XG5cdFx0XHR2YXIgYnl0ZTE7XG5cdFx0XHR2YXIgYnl0ZTI7XG5cdFx0XHR2YXIgYnl0ZTM7XG5cdFx0XHR2YXIgYnl0ZTQ7XG5cdFx0XHR2YXIgY29kZVBvaW50O1xuXG5cdFx0XHRpZiAoYnl0ZUluZGV4ID4gYnl0ZUNvdW50KSB7XG5cdFx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGJ5dGUgaW5kZXgnKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGJ5dGVJbmRleCA9PSBieXRlQ291bnQpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZWFkIGZpcnN0IGJ5dGVcblx0XHRcdGJ5dGUxID0gYnl0ZUFycmF5W2J5dGVJbmRleF0gJiAweEZGO1xuXHRcdFx0Ynl0ZUluZGV4Kys7XG5cblx0XHRcdC8vIDEtYnl0ZSBzZXF1ZW5jZSAobm8gY29udGludWF0aW9uIGJ5dGVzKVxuXHRcdFx0aWYgKChieXRlMSAmIDB4ODApID09IDApIHtcblx0XHRcdFx0cmV0dXJuIGJ5dGUxO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyAyLWJ5dGUgc2VxdWVuY2Vcblx0XHRcdGlmICgoYnl0ZTEgJiAweEUwKSA9PSAweEMwKSB7XG5cdFx0XHRcdHZhciBieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRcdGNvZGVQb2ludCA9ICgoYnl0ZTEgJiAweDFGKSA8PCA2KSB8IGJ5dGUyO1xuXHRcdFx0XHRpZiAoY29kZVBvaW50ID49IDB4ODApIHtcblx0XHRcdFx0XHRyZXR1cm4gY29kZVBvaW50O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlJyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gMy1ieXRlIHNlcXVlbmNlIChtYXkgaW5jbHVkZSB1bnBhaXJlZCBzdXJyb2dhdGVzKVxuXHRcdFx0aWYgKChieXRlMSAmIDB4RjApID09IDB4RTApIHtcblx0XHRcdFx0Ynl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0XHRieXRlMyA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRcdGNvZGVQb2ludCA9ICgoYnl0ZTEgJiAweDBGKSA8PCAxMikgfCAoYnl0ZTIgPDwgNikgfCBieXRlMztcblx0XHRcdFx0aWYgKGNvZGVQb2ludCA+PSAweDA4MDApIHtcblx0XHRcdFx0XHRjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCk7XG5cdFx0XHRcdFx0cmV0dXJuIGNvZGVQb2ludDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBjb250aW51YXRpb24gYnl0ZScpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIDQtYnl0ZSBzZXF1ZW5jZVxuXHRcdFx0aWYgKChieXRlMSAmIDB4RjgpID09IDB4RjApIHtcblx0XHRcdFx0Ynl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0XHRieXRlMyA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRcdGJ5dGU0ID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdFx0Y29kZVBvaW50ID0gKChieXRlMSAmIDB4MEYpIDw8IDB4MTIpIHwgKGJ5dGUyIDw8IDB4MEMpIHxcblx0XHRcdFx0XHQoYnl0ZTMgPDwgMHgwNikgfCBieXRlNDtcblx0XHRcdFx0aWYgKGNvZGVQb2ludCA+PSAweDAxMDAwMCAmJiBjb2RlUG9pbnQgPD0gMHgxMEZGRkYpIHtcblx0XHRcdFx0XHRyZXR1cm4gY29kZVBvaW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIFVURi04IGRldGVjdGVkJyk7XG5cdFx0fVxuXG5cdFx0dmFyIGJ5dGVBcnJheTtcblx0XHR2YXIgYnl0ZUNvdW50O1xuXHRcdHZhciBieXRlSW5kZXg7XG5cdFx0ZnVuY3Rpb24gdXRmOGRlY29kZShieXRlU3RyaW5nKSB7XG5cdFx0XHRieXRlQXJyYXkgPSB1Y3MyZGVjb2RlKGJ5dGVTdHJpbmcpO1xuXHRcdFx0Ynl0ZUNvdW50ID0gYnl0ZUFycmF5Lmxlbmd0aDtcblx0XHRcdGJ5dGVJbmRleCA9IDA7XG5cdFx0XHR2YXIgY29kZVBvaW50cyA9IFtdO1xuXHRcdFx0dmFyIHRtcDtcblx0XHRcdHdoaWxlICgodG1wID0gZGVjb2RlU3ltYm9sKCkpICE9PSBmYWxzZSkge1xuXHRcdFx0XHRjb2RlUG9pbnRzLnB1c2godG1wKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB1Y3MyZW5jb2RlKGNvZGVQb2ludHMpO1xuXHRcdH1cblxuXHRcdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdFx0dmFyIHV0ZjggPSB7XG5cdFx0XHQndmVyc2lvbic6ICcyLjAuMCcsXG5cdFx0XHQnZW5jb2RlJzogdXRmOGVuY29kZSxcblx0XHRcdCdkZWNvZGUnOiB1dGY4ZGVjb2RlXG5cdFx0fTtcblxuXHRcdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHRcdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0XHRpZiAoXG5cdFx0XHR0cnVlXG5cdFx0KSB7XG5cdFx0XHQhKF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB1dGY4O1xuXHRcdFx0fS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18sIGV4cG9ydHMsIG1vZHVsZSksIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblx0XHR9XHRlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiAhZnJlZUV4cG9ydHMubm9kZVR5cGUpIHtcblx0XHRcdGlmIChmcmVlTW9kdWxlKSB7IC8vIGluIE5vZGUuanMgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHV0Zjg7XG5cdFx0XHR9IGVsc2UgeyAvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0XHR2YXIgb2JqZWN0ID0ge307XG5cdFx0XHRcdHZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdC5oYXNPd25Qcm9wZXJ0eTtcblx0XHRcdFx0Zm9yICh2YXIga2V5IGluIHV0ZjgpIHtcblx0XHRcdFx0XHRoYXNPd25Qcm9wZXJ0eS5jYWxsKHV0ZjgsIGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSB1dGY4W2tleV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHsgLy8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdFx0cm9vdC51dGY4ID0gdXRmODtcblx0XHR9XG5cblx0fSh0aGlzKSk7XG5cblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18oOCkobW9kdWxlKSwgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSgpKSkpXG5cbi8qKiovIH0sXG4vKiAzMiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkgey8qKlxuXHQgKiBDcmVhdGUgYSBibG9iIGJ1aWxkZXIgZXZlbiB3aGVuIHZlbmRvciBwcmVmaXhlcyBleGlzdFxuXHQgKi9cblxuXHR2YXIgQmxvYkJ1aWxkZXIgPSBnbG9iYWwuQmxvYkJ1aWxkZXJcblx0ICB8fCBnbG9iYWwuV2ViS2l0QmxvYkJ1aWxkZXJcblx0ICB8fCBnbG9iYWwuTVNCbG9iQnVpbGRlclxuXHQgIHx8IGdsb2JhbC5Nb3pCbG9iQnVpbGRlcjtcblxuXHQvKipcblx0ICogQ2hlY2sgaWYgQmxvYiBjb25zdHJ1Y3RvciBpcyBzdXBwb3J0ZWRcblx0ICovXG5cblx0dmFyIGJsb2JTdXBwb3J0ZWQgPSAoZnVuY3Rpb24oKSB7XG5cdCAgdHJ5IHtcblx0ICAgIHZhciBhID0gbmV3IEJsb2IoWydoaSddKTtcblx0ICAgIHJldHVybiBhLnNpemUgPT09IDI7XG5cdCAgfSBjYXRjaChlKSB7XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfVxuXHR9KSgpO1xuXG5cdC8qKlxuXHQgKiBDaGVjayBpZiBCbG9iIGNvbnN0cnVjdG9yIHN1cHBvcnRzIEFycmF5QnVmZmVyVmlld3Ncblx0ICogRmFpbHMgaW4gU2FmYXJpIDYsIHNvIHdlIG5lZWQgdG8gbWFwIHRvIEFycmF5QnVmZmVycyB0aGVyZS5cblx0ICovXG5cblx0dmFyIGJsb2JTdXBwb3J0c0FycmF5QnVmZmVyVmlldyA9IGJsb2JTdXBwb3J0ZWQgJiYgKGZ1bmN0aW9uKCkge1xuXHQgIHRyeSB7XG5cdCAgICB2YXIgYiA9IG5ldyBCbG9iKFtuZXcgVWludDhBcnJheShbMSwyXSldKTtcblx0ICAgIHJldHVybiBiLnNpemUgPT09IDI7XG5cdCAgfSBjYXRjaChlKSB7XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfVxuXHR9KSgpO1xuXG5cdC8qKlxuXHQgKiBDaGVjayBpZiBCbG9iQnVpbGRlciBpcyBzdXBwb3J0ZWRcblx0ICovXG5cblx0dmFyIGJsb2JCdWlsZGVyU3VwcG9ydGVkID0gQmxvYkJ1aWxkZXJcblx0ICAmJiBCbG9iQnVpbGRlci5wcm90b3R5cGUuYXBwZW5kXG5cdCAgJiYgQmxvYkJ1aWxkZXIucHJvdG90eXBlLmdldEJsb2I7XG5cblx0LyoqXG5cdCAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IG1hcHMgQXJyYXlCdWZmZXJWaWV3cyB0byBBcnJheUJ1ZmZlcnNcblx0ICogVXNlZCBieSBCbG9iQnVpbGRlciBjb25zdHJ1Y3RvciBhbmQgb2xkIGJyb3dzZXJzIHRoYXQgZGlkbid0XG5cdCAqIHN1cHBvcnQgaXQgaW4gdGhlIEJsb2IgY29uc3RydWN0b3IuXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIG1hcEFycmF5QnVmZmVyVmlld3MoYXJ5KSB7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnkubGVuZ3RoOyBpKyspIHtcblx0ICAgIHZhciBjaHVuayA9IGFyeVtpXTtcblx0ICAgIGlmIChjaHVuay5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuXHQgICAgICB2YXIgYnVmID0gY2h1bmsuYnVmZmVyO1xuXG5cdCAgICAgIC8vIGlmIHRoaXMgaXMgYSBzdWJhcnJheSwgbWFrZSBhIGNvcHkgc28gd2Ugb25seVxuXHQgICAgICAvLyBpbmNsdWRlIHRoZSBzdWJhcnJheSByZWdpb24gZnJvbSB0aGUgdW5kZXJseWluZyBidWZmZXJcblx0ICAgICAgaWYgKGNodW5rLmJ5dGVMZW5ndGggIT09IGJ1Zi5ieXRlTGVuZ3RoKSB7XG5cdCAgICAgICAgdmFyIGNvcHkgPSBuZXcgVWludDhBcnJheShjaHVuay5ieXRlTGVuZ3RoKTtcblx0ICAgICAgICBjb3B5LnNldChuZXcgVWludDhBcnJheShidWYsIGNodW5rLmJ5dGVPZmZzZXQsIGNodW5rLmJ5dGVMZW5ndGgpKTtcblx0ICAgICAgICBidWYgPSBjb3B5LmJ1ZmZlcjtcblx0ICAgICAgfVxuXG5cdCAgICAgIGFyeVtpXSA9IGJ1Zjtcblx0ICAgIH1cblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBCbG9iQnVpbGRlckNvbnN0cnVjdG9yKGFyeSwgb3B0aW9ucykge1xuXHQgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdCAgdmFyIGJiID0gbmV3IEJsb2JCdWlsZGVyKCk7XG5cdCAgbWFwQXJyYXlCdWZmZXJWaWV3cyhhcnkpO1xuXG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnkubGVuZ3RoOyBpKyspIHtcblx0ICAgIGJiLmFwcGVuZChhcnlbaV0pO1xuXHQgIH1cblxuXHQgIHJldHVybiAob3B0aW9ucy50eXBlKSA/IGJiLmdldEJsb2Iob3B0aW9ucy50eXBlKSA6IGJiLmdldEJsb2IoKTtcblx0fTtcblxuXHRmdW5jdGlvbiBCbG9iQ29uc3RydWN0b3IoYXJ5LCBvcHRpb25zKSB7XG5cdCAgbWFwQXJyYXlCdWZmZXJWaWV3cyhhcnkpO1xuXHQgIHJldHVybiBuZXcgQmxvYihhcnksIG9wdGlvbnMgfHwge30pO1xuXHR9O1xuXG5cdG1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuXHQgIGlmIChibG9iU3VwcG9ydGVkKSB7XG5cdCAgICByZXR1cm4gYmxvYlN1cHBvcnRzQXJyYXlCdWZmZXJWaWV3ID8gZ2xvYmFsLkJsb2IgOiBCbG9iQ29uc3RydWN0b3I7XG5cdCAgfSBlbHNlIGlmIChibG9iQnVpbGRlclN1cHBvcnRlZCkge1xuXHQgICAgcmV0dXJuIEJsb2JCdWlsZGVyQ29uc3RydWN0b3I7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHJldHVybiB1bmRlZmluZWQ7XG5cdCAgfVxuXHR9KSgpO1xuXG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KCkpKSlcblxuLyoqKi8gfSxcbi8qIDMzICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRcblx0LyoqXG5cdCAqIEV4cG9zZSBgRW1pdHRlcmAuXG5cdCAqL1xuXG5cdG1vZHVsZS5leHBvcnRzID0gRW1pdHRlcjtcblxuXHQvKipcblx0ICogSW5pdGlhbGl6ZSBhIG5ldyBgRW1pdHRlcmAuXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIEVtaXR0ZXIob2JqKSB7XG5cdCAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XG5cdH07XG5cblx0LyoqXG5cdCAqIE1peGluIHRoZSBlbWl0dGVyIHByb3BlcnRpZXMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcblx0ICogQHJldHVybiB7T2JqZWN0fVxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0ZnVuY3Rpb24gbWl4aW4ob2JqKSB7XG5cdCAgZm9yICh2YXIga2V5IGluIEVtaXR0ZXIucHJvdG90eXBlKSB7XG5cdCAgICBvYmpba2V5XSA9IEVtaXR0ZXIucHJvdG90eXBlW2tleV07XG5cdCAgfVxuXHQgIHJldHVybiBvYmo7XG5cdH1cblxuXHQvKipcblx0ICogTGlzdGVuIG9uIHRoZSBnaXZlbiBgZXZlbnRgIHdpdGggYGZuYC5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG5cdCAqIEByZXR1cm4ge0VtaXR0ZXJ9XG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdEVtaXR0ZXIucHJvdG90eXBlLm9uID1cblx0RW1pdHRlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG5cdCAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuXHQgICh0aGlzLl9jYWxsYmFja3NbZXZlbnRdID0gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XSB8fCBbXSlcblx0ICAgIC5wdXNoKGZuKTtcblx0ICByZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogQWRkcyBhbiBgZXZlbnRgIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBpbnZva2VkIGEgc2luZ2xlXG5cdCAqIHRpbWUgdGhlbiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuXHQgKiBAcmV0dXJuIHtFbWl0dGVyfVxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcblx0ICB2YXIgc2VsZiA9IHRoaXM7XG5cdCAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuXG5cdCAgZnVuY3Rpb24gb24oKSB7XG5cdCAgICBzZWxmLm9mZihldmVudCwgb24pO1xuXHQgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICB9XG5cblx0ICBvbi5mbiA9IGZuO1xuXHQgIHRoaXMub24oZXZlbnQsIG9uKTtcblx0ICByZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogUmVtb3ZlIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgYGV2ZW50YCBvciBhbGxcblx0ICogcmVnaXN0ZXJlZCBjYWxsYmFja3MuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuXHQgKiBAcmV0dXJuIHtFbWl0dGVyfVxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPVxuXHRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG5cdEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG5cdEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuXHQgIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcblxuXHQgIC8vIGFsbFxuXHQgIGlmICgwID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcblx0ICAgIHRoaXMuX2NhbGxiYWNrcyA9IHt9O1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfVxuXG5cdCAgLy8gc3BlY2lmaWMgZXZlbnRcblx0ICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XTtcblx0ICBpZiAoIWNhbGxiYWNrcykgcmV0dXJuIHRoaXM7XG5cblx0ICAvLyByZW1vdmUgYWxsIGhhbmRsZXJzXG5cdCAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuXHQgICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1tldmVudF07XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9XG5cblx0ICAvLyByZW1vdmUgc3BlY2lmaWMgaGFuZGxlclxuXHQgIHZhciBjYjtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuXHQgICAgY2IgPSBjYWxsYmFja3NbaV07XG5cdCAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xuXHQgICAgICBjYWxsYmFja3Muc3BsaWNlKGksIDEpO1xuXHQgICAgICBicmVhaztcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEVtaXQgYGV2ZW50YCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcblx0ICogQHBhcmFtIHtNaXhlZH0gLi4uXG5cdCAqIEByZXR1cm4ge0VtaXR0ZXJ9XG5cdCAqL1xuXG5cdEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldmVudCl7XG5cdCAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuXHQgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXG5cdCAgICAsIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1tldmVudF07XG5cblx0ICBpZiAoY2FsbGJhY2tzKSB7XG5cdCAgICBjYWxsYmFja3MgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG5cdCAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG5cdCAgICAgIGNhbGxiYWNrc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICByZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJuIGFycmF5IG9mIGNhbGxiYWNrcyBmb3IgYGV2ZW50YC5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG5cdCAqIEByZXR1cm4ge0FycmF5fVxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XG5cdCAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuXHQgIHJldHVybiB0aGlzLl9jYWxsYmFja3NbZXZlbnRdIHx8IFtdO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDaGVjayBpZiB0aGlzIGVtaXR0ZXIgaGFzIGBldmVudGAgaGFuZGxlcnMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRFbWl0dGVyLnByb3RvdHlwZS5oYXNMaXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XG5cdCAgcmV0dXJuICEhIHRoaXMubGlzdGVuZXJzKGV2ZW50KS5sZW5ndGg7XG5cdH07XG5cblxuLyoqKi8gfSxcbi8qIDM0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQvKipcblx0ICogQ29tcGlsZXMgYSBxdWVyeXN0cmluZ1xuXHQgKiBSZXR1cm5zIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgb2JqZWN0XG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fVxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0ZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiAob2JqKSB7XG5cdCAgdmFyIHN0ciA9ICcnO1xuXG5cdCAgZm9yICh2YXIgaSBpbiBvYmopIHtcblx0ICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcblx0ICAgICAgaWYgKHN0ci5sZW5ndGgpIHN0ciArPSAnJic7XG5cdCAgICAgIHN0ciArPSBlbmNvZGVVUklDb21wb25lbnQoaSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQob2JqW2ldKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICByZXR1cm4gc3RyO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBQYXJzZXMgYSBzaW1wbGUgcXVlcnlzdHJpbmcgaW50byBhbiBvYmplY3Rcblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IHFzXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRleHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uKHFzKXtcblx0ICB2YXIgcXJ5ID0ge307XG5cdCAgdmFyIHBhaXJzID0gcXMuc3BsaXQoJyYnKTtcblx0ICBmb3IgKHZhciBpID0gMCwgbCA9IHBhaXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHQgICAgdmFyIHBhaXIgPSBwYWlyc1tpXS5zcGxpdCgnPScpO1xuXHQgICAgcXJ5W2RlY29kZVVSSUNvbXBvbmVudChwYWlyWzBdKV0gPSBkZWNvZGVVUklDb21wb25lbnQocGFpclsxXSk7XG5cdCAgfVxuXHQgIHJldHVybiBxcnk7XG5cdH07XG5cblxuLyoqKi8gfSxcbi8qIDM1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhLCBiKXtcblx0ICB2YXIgZm4gPSBmdW5jdGlvbigpe307XG5cdCAgZm4ucHJvdG90eXBlID0gYi5wcm90b3R5cGU7XG5cdCAgYS5wcm90b3R5cGUgPSBuZXcgZm47XG5cdCAgYS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBhO1xuXHR9O1xuXG4vKioqLyB9LFxuLyogMzYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgYWxwaGFiZXQgPSAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXotXycuc3BsaXQoJycpXG5cdCAgLCBsZW5ndGggPSA2NFxuXHQgICwgbWFwID0ge31cblx0ICAsIHNlZWQgPSAwXG5cdCAgLCBpID0gMFxuXHQgICwgcHJldjtcblxuXHQvKipcblx0ICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgc3BlY2lmaWVkIG51bWJlci5cblx0ICpcblx0ICogQHBhcmFtIHtOdW1iZXJ9IG51bSBUaGUgbnVtYmVyIHRvIGNvbnZlcnQuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG51bWJlci5cblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cdGZ1bmN0aW9uIGVuY29kZShudW0pIHtcblx0ICB2YXIgZW5jb2RlZCA9ICcnO1xuXG5cdCAgZG8ge1xuXHQgICAgZW5jb2RlZCA9IGFscGhhYmV0W251bSAlIGxlbmd0aF0gKyBlbmNvZGVkO1xuXHQgICAgbnVtID0gTWF0aC5mbG9vcihudW0gLyBsZW5ndGgpO1xuXHQgIH0gd2hpbGUgKG51bSA+IDApO1xuXG5cdCAgcmV0dXJuIGVuY29kZWQ7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJuIHRoZSBpbnRlZ2VyIHZhbHVlIHNwZWNpZmllZCBieSB0aGUgZ2l2ZW4gc3RyaW5nLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gY29udmVydC5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIGludGVnZXIgdmFsdWUgcmVwcmVzZW50ZWQgYnkgdGhlIHN0cmluZy5cblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cdGZ1bmN0aW9uIGRlY29kZShzdHIpIHtcblx0ICB2YXIgZGVjb2RlZCA9IDA7XG5cblx0ICBmb3IgKGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG5cdCAgICBkZWNvZGVkID0gZGVjb2RlZCAqIGxlbmd0aCArIG1hcFtzdHIuY2hhckF0KGkpXTtcblx0ICB9XG5cblx0ICByZXR1cm4gZGVjb2RlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBZZWFzdDogQSB0aW55IGdyb3dpbmcgaWQgZ2VuZXJhdG9yLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBBIHVuaXF1ZSBpZC5cblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cdGZ1bmN0aW9uIHllYXN0KCkge1xuXHQgIHZhciBub3cgPSBlbmNvZGUoK25ldyBEYXRlKCkpO1xuXG5cdCAgaWYgKG5vdyAhPT0gcHJldikgcmV0dXJuIHNlZWQgPSAwLCBwcmV2ID0gbm93O1xuXHQgIHJldHVybiBub3cgKycuJysgZW5jb2RlKHNlZWQrKyk7XG5cdH1cblxuXHQvL1xuXHQvLyBNYXAgZWFjaCBjaGFyYWN0ZXIgdG8gaXRzIGluZGV4LlxuXHQvL1xuXHRmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSBtYXBbYWxwaGFiZXRbaV1dID0gaTtcblxuXHQvL1xuXHQvLyBFeHBvc2UgdGhlIGB5ZWFzdGAsIGBlbmNvZGVgIGFuZCBgZGVjb2RlYCBmdW5jdGlvbnMuXG5cdC8vXG5cdHllYXN0LmVuY29kZSA9IGVuY29kZTtcblx0eWVhc3QuZGVjb2RlID0gZGVjb2RlO1xuXHRtb2R1bGUuZXhwb3J0cyA9IHllYXN0O1xuXG5cbi8qKiovIH0sXG4vKiAzNyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkge1xuXHQvKipcblx0ICogTW9kdWxlIHJlcXVpcmVtZW50cy5cblx0ICovXG5cblx0dmFyIFBvbGxpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKTtcblx0dmFyIGluaGVyaXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM1KTtcblxuXHQvKipcblx0ICogTW9kdWxlIGV4cG9ydHMuXG5cdCAqL1xuXG5cdG1vZHVsZS5leHBvcnRzID0gSlNPTlBQb2xsaW5nO1xuXG5cdC8qKlxuXHQgKiBDYWNoZWQgcmVndWxhciBleHByZXNzaW9ucy5cblx0ICovXG5cblx0dmFyIHJOZXdsaW5lID0gL1xcbi9nO1xuXHR2YXIgckVzY2FwZWROZXdsaW5lID0gL1xcXFxuL2c7XG5cblx0LyoqXG5cdCAqIEdsb2JhbCBKU09OUCBjYWxsYmFja3MuXG5cdCAqL1xuXG5cdHZhciBjYWxsYmFja3M7XG5cblx0LyoqXG5cdCAqIENhbGxiYWNrcyBjb3VudC5cblx0ICovXG5cblx0dmFyIGluZGV4ID0gMDtcblxuXHQvKipcblx0ICogTm9vcC5cblx0ICovXG5cblx0ZnVuY3Rpb24gZW1wdHkgKCkgeyB9XG5cblx0LyoqXG5cdCAqIEpTT05QIFBvbGxpbmcgY29uc3RydWN0b3IuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRmdW5jdGlvbiBKU09OUFBvbGxpbmcgKG9wdHMpIHtcblx0ICBQb2xsaW5nLmNhbGwodGhpcywgb3B0cyk7XG5cblx0ICB0aGlzLnF1ZXJ5ID0gdGhpcy5xdWVyeSB8fCB7fTtcblxuXHQgIC8vIGRlZmluZSBnbG9iYWwgY2FsbGJhY2tzIGFycmF5IGlmIG5vdCBwcmVzZW50XG5cdCAgLy8gd2UgZG8gdGhpcyBoZXJlIChsYXppbHkpIHRvIGF2b2lkIHVubmVlZGVkIGdsb2JhbCBwb2xsdXRpb25cblx0ICBpZiAoIWNhbGxiYWNrcykge1xuXHQgICAgLy8gd2UgbmVlZCB0byBjb25zaWRlciBtdWx0aXBsZSBlbmdpbmVzIGluIHRoZSBzYW1lIHBhZ2Vcblx0ICAgIGlmICghZ2xvYmFsLl9fX2VpbykgZ2xvYmFsLl9fX2VpbyA9IFtdO1xuXHQgICAgY2FsbGJhY2tzID0gZ2xvYmFsLl9fX2Vpbztcblx0ICB9XG5cblx0ICAvLyBjYWxsYmFjayBpZGVudGlmaWVyXG5cdCAgdGhpcy5pbmRleCA9IGNhbGxiYWNrcy5sZW5ndGg7XG5cblx0ICAvLyBhZGQgY2FsbGJhY2sgdG8ganNvbnAgZ2xvYmFsXG5cdCAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgIGNhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uIChtc2cpIHtcblx0ICAgIHNlbGYub25EYXRhKG1zZyk7XG5cdCAgfSk7XG5cblx0ICAvLyBhcHBlbmQgdG8gcXVlcnkgc3RyaW5nXG5cdCAgdGhpcy5xdWVyeS5qID0gdGhpcy5pbmRleDtcblxuXHQgIC8vIHByZXZlbnQgc3B1cmlvdXMgZXJyb3JzIGZyb20gYmVpbmcgZW1pdHRlZCB3aGVuIHRoZSB3aW5kb3cgaXMgdW5sb2FkZWRcblx0ICBpZiAoZ2xvYmFsLmRvY3VtZW50ICYmIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG5cdCAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgZnVuY3Rpb24gKCkge1xuXHQgICAgICBpZiAoc2VsZi5zY3JpcHQpIHNlbGYuc2NyaXB0Lm9uZXJyb3IgPSBlbXB0eTtcblx0ICAgIH0sIGZhbHNlKTtcblx0ICB9XG5cdH1cblxuXHQvKipcblx0ICogSW5oZXJpdHMgZnJvbSBQb2xsaW5nLlxuXHQgKi9cblxuXHRpbmhlcml0KEpTT05QUG9sbGluZywgUG9sbGluZyk7XG5cblx0Lypcblx0ICogSlNPTlAgb25seSBzdXBwb3J0cyBiaW5hcnkgYXMgYmFzZTY0IGVuY29kZWQgc3RyaW5nc1xuXHQgKi9cblxuXHRKU09OUFBvbGxpbmcucHJvdG90eXBlLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG5cblx0LyoqXG5cdCAqIENsb3NlcyB0aGUgc29ja2V0LlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0SlNPTlBQb2xsaW5nLnByb3RvdHlwZS5kb0Nsb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgIGlmICh0aGlzLnNjcmlwdCkge1xuXHQgICAgdGhpcy5zY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnNjcmlwdCk7XG5cdCAgICB0aGlzLnNjcmlwdCA9IG51bGw7XG5cdCAgfVxuXG5cdCAgaWYgKHRoaXMuZm9ybSkge1xuXHQgICAgdGhpcy5mb3JtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5mb3JtKTtcblx0ICAgIHRoaXMuZm9ybSA9IG51bGw7XG5cdCAgICB0aGlzLmlmcmFtZSA9IG51bGw7XG5cdCAgfVxuXG5cdCAgUG9sbGluZy5wcm90b3R5cGUuZG9DbG9zZS5jYWxsKHRoaXMpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTdGFydHMgYSBwb2xsIGN5Y2xlLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0SlNPTlBQb2xsaW5nLnByb3RvdHlwZS5kb1BvbGwgPSBmdW5jdGlvbiAoKSB7XG5cdCAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgIHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcblxuXHQgIGlmICh0aGlzLnNjcmlwdCkge1xuXHQgICAgdGhpcy5zY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnNjcmlwdCk7XG5cdCAgICB0aGlzLnNjcmlwdCA9IG51bGw7XG5cdCAgfVxuXG5cdCAgc2NyaXB0LmFzeW5jID0gdHJ1ZTtcblx0ICBzY3JpcHQuc3JjID0gdGhpcy51cmkoKTtcblx0ICBzY3JpcHQub25lcnJvciA9IGZ1bmN0aW9uKGUpe1xuXHQgICAgc2VsZi5vbkVycm9yKCdqc29ucCBwb2xsIGVycm9yJyxlKTtcblx0ICB9O1xuXG5cdCAgdmFyIGluc2VydEF0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpWzBdO1xuXHQgIGlmIChpbnNlcnRBdCkge1xuXHQgICAgaW5zZXJ0QXQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc2NyaXB0LCBpbnNlcnRBdCk7XG5cdCAgfVxuXHQgIGVsc2Uge1xuXHQgICAgKGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuYm9keSkuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcblx0ICB9XG5cdCAgdGhpcy5zY3JpcHQgPSBzY3JpcHQ7XG5cblx0ICB2YXIgaXNVQWdlY2tvID0gJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIG5hdmlnYXRvciAmJiAvZ2Vja28vaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXHQgIFxuXHQgIGlmIChpc1VBZ2Vja28pIHtcblx0ICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHQgICAgICB2YXIgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG5cdCAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcblx0ICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChpZnJhbWUpO1xuXHQgICAgfSwgMTAwKTtcblx0ICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIFdyaXRlcyB3aXRoIGEgaGlkZGVuIGlmcmFtZS5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgdG8gc2VuZFxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsZWQgdXBvbiBmbHVzaC5cblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdEpTT05QUG9sbGluZy5wcm90b3R5cGUuZG9Xcml0ZSA9IGZ1bmN0aW9uIChkYXRhLCBmbikge1xuXHQgIHZhciBzZWxmID0gdGhpcztcblxuXHQgIGlmICghdGhpcy5mb3JtKSB7XG5cdCAgICB2YXIgZm9ybSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Zvcm0nKTtcblx0ICAgIHZhciBhcmVhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKTtcblx0ICAgIHZhciBpZCA9IHRoaXMuaWZyYW1lSWQgPSAnZWlvX2lmcmFtZV8nICsgdGhpcy5pbmRleDtcblx0ICAgIHZhciBpZnJhbWU7XG5cblx0ICAgIGZvcm0uY2xhc3NOYW1lID0gJ3NvY2tldGlvJztcblx0ICAgIGZvcm0uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuXHQgICAgZm9ybS5zdHlsZS50b3AgPSAnLTEwMDBweCc7XG5cdCAgICBmb3JtLnN0eWxlLmxlZnQgPSAnLTEwMDBweCc7XG5cdCAgICBmb3JtLnRhcmdldCA9IGlkO1xuXHQgICAgZm9ybS5tZXRob2QgPSAnUE9TVCc7XG5cdCAgICBmb3JtLnNldEF0dHJpYnV0ZSgnYWNjZXB0LWNoYXJzZXQnLCAndXRmLTgnKTtcblx0ICAgIGFyZWEubmFtZSA9ICdkJztcblx0ICAgIGZvcm0uYXBwZW5kQ2hpbGQoYXJlYSk7XG5cdCAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGZvcm0pO1xuXG5cdCAgICB0aGlzLmZvcm0gPSBmb3JtO1xuXHQgICAgdGhpcy5hcmVhID0gYXJlYTtcblx0ICB9XG5cblx0ICB0aGlzLmZvcm0uYWN0aW9uID0gdGhpcy51cmkoKTtcblxuXHQgIGZ1bmN0aW9uIGNvbXBsZXRlICgpIHtcblx0ICAgIGluaXRJZnJhbWUoKTtcblx0ICAgIGZuKCk7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gaW5pdElmcmFtZSAoKSB7XG5cdCAgICBpZiAoc2VsZi5pZnJhbWUpIHtcblx0ICAgICAgdHJ5IHtcblx0ICAgICAgICBzZWxmLmZvcm0ucmVtb3ZlQ2hpbGQoc2VsZi5pZnJhbWUpO1xuXHQgICAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgICAgc2VsZi5vbkVycm9yKCdqc29ucCBwb2xsaW5nIGlmcmFtZSByZW1vdmFsIGVycm9yJywgZSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgdHJ5IHtcblx0ICAgICAgLy8gaWU2IGR5bmFtaWMgaWZyYW1lcyB3aXRoIHRhcmdldD1cIlwiIHN1cHBvcnQgKHRoYW5rcyBDaHJpcyBMYW1iYWNoZXIpXG5cdCAgICAgIHZhciBodG1sID0gJzxpZnJhbWUgc3JjPVwiamF2YXNjcmlwdDowXCIgbmFtZT1cIicrIHNlbGYuaWZyYW1lSWQgKydcIj4nO1xuXHQgICAgICBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGh0bWwpO1xuXHQgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcblx0ICAgICAgaWZyYW1lLm5hbWUgPSBzZWxmLmlmcmFtZUlkO1xuXHQgICAgICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6MCc7XG5cdCAgICB9XG5cblx0ICAgIGlmcmFtZS5pZCA9IHNlbGYuaWZyYW1lSWQ7XG5cblx0ICAgIHNlbGYuZm9ybS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuXHQgICAgc2VsZi5pZnJhbWUgPSBpZnJhbWU7XG5cdCAgfVxuXG5cdCAgaW5pdElmcmFtZSgpO1xuXG5cdCAgLy8gZXNjYXBlIFxcbiB0byBwcmV2ZW50IGl0IGZyb20gYmVpbmcgY29udmVydGVkIGludG8gXFxyXFxuIGJ5IHNvbWUgVUFzXG5cdCAgLy8gZG91YmxlIGVzY2FwaW5nIGlzIHJlcXVpcmVkIGZvciBlc2NhcGVkIG5ldyBsaW5lcyBiZWNhdXNlIHVuZXNjYXBpbmcgb2YgbmV3IGxpbmVzIGNhbiBiZSBkb25lIHNhZmVseSBvbiBzZXJ2ZXItc2lkZVxuXHQgIGRhdGEgPSBkYXRhLnJlcGxhY2UockVzY2FwZWROZXdsaW5lLCAnXFxcXFxcbicpO1xuXHQgIHRoaXMuYXJlYS52YWx1ZSA9IGRhdGEucmVwbGFjZShyTmV3bGluZSwgJ1xcXFxuJyk7XG5cblx0ICB0cnkge1xuXHQgICAgdGhpcy5mb3JtLnN1Ym1pdCgpO1xuXHQgIH0gY2F0Y2goZSkge31cblxuXHQgIGlmICh0aGlzLmlmcmFtZS5hdHRhY2hFdmVudCkge1xuXHQgICAgdGhpcy5pZnJhbWUub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKXtcblx0ICAgICAgaWYgKHNlbGYuaWZyYW1lLnJlYWR5U3RhdGUgPT0gJ2NvbXBsZXRlJykge1xuXHQgICAgICAgIGNvbXBsZXRlKCk7XG5cdCAgICAgIH1cblx0ICAgIH07XG5cdCAgfSBlbHNlIHtcblx0ICAgIHRoaXMuaWZyYW1lLm9ubG9hZCA9IGNvbXBsZXRlO1xuXHQgIH1cblx0fTtcblxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSgpKSkpXG5cbi8qKiovIH0sXG4vKiAzOCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkgey8qKlxuXHQgKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuXHQgKi9cblxuXHR2YXIgVHJhbnNwb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XG5cdHZhciBwYXJzZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KTtcblx0dmFyIHBhcnNlcXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0KTtcblx0dmFyIGluaGVyaXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM1KTtcblx0dmFyIHllYXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNik7XG5cdHZhciBkZWJ1ZyA9IF9fd2VicGFja19yZXF1aXJlX18oMykoJ2VuZ2luZS5pby1jbGllbnQ6d2Vic29ja2V0Jyk7XG5cdHZhciBCcm93c2VyV2ViU29ja2V0ID0gZ2xvYmFsLldlYlNvY2tldCB8fCBnbG9iYWwuTW96V2ViU29ja2V0O1xuXG5cdC8qKlxuXHQgKiBHZXQgZWl0aGVyIHRoZSBgV2ViU29ja2V0YCBvciBgTW96V2ViU29ja2V0YCBnbG9iYWxzXG5cdCAqIGluIHRoZSBicm93c2VyIG9yIHRyeSB0byByZXNvbHZlIFdlYlNvY2tldC1jb21wYXRpYmxlXG5cdCAqIGludGVyZmFjZSBleHBvc2VkIGJ5IGB3c2AgZm9yIE5vZGUtbGlrZSBlbnZpcm9ubWVudC5cblx0ICovXG5cblx0dmFyIFdlYlNvY2tldCA9IEJyb3dzZXJXZWJTb2NrZXQ7XG5cdGlmICghV2ViU29ja2V0ICYmIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG5cdCAgdHJ5IHtcblx0ICAgIFdlYlNvY2tldCA9IF9fd2VicGFja19yZXF1aXJlX18oMzkpO1xuXHQgIH0gY2F0Y2ggKGUpIHsgfVxuXHR9XG5cblx0LyoqXG5cdCAqIE1vZHVsZSBleHBvcnRzLlxuXHQgKi9cblxuXHRtb2R1bGUuZXhwb3J0cyA9IFdTO1xuXG5cdC8qKlxuXHQgKiBXZWJTb2NrZXQgdHJhbnNwb3J0IGNvbnN0cnVjdG9yLlxuXHQgKlxuXHQgKiBAYXBpIHtPYmplY3R9IGNvbm5lY3Rpb24gb3B0aW9uc1xuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRmdW5jdGlvbiBXUyhvcHRzKXtcblx0ICB2YXIgZm9yY2VCYXNlNjQgPSAob3B0cyAmJiBvcHRzLmZvcmNlQmFzZTY0KTtcblx0ICBpZiAoZm9yY2VCYXNlNjQpIHtcblx0ICAgIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcblx0ICB9XG5cdCAgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSA9IG9wdHMucGVyTWVzc2FnZURlZmxhdGU7XG5cdCAgVHJhbnNwb3J0LmNhbGwodGhpcywgb3B0cyk7XG5cdH1cblxuXHQvKipcblx0ICogSW5oZXJpdHMgZnJvbSBUcmFuc3BvcnQuXG5cdCAqL1xuXG5cdGluaGVyaXQoV1MsIFRyYW5zcG9ydCk7XG5cblx0LyoqXG5cdCAqIFRyYW5zcG9ydCBuYW1lLlxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRXUy5wcm90b3R5cGUubmFtZSA9ICd3ZWJzb2NrZXQnO1xuXG5cdC8qXG5cdCAqIFdlYlNvY2tldHMgc3VwcG9ydCBiaW5hcnlcblx0ICovXG5cblx0V1MucHJvdG90eXBlLnN1cHBvcnRzQmluYXJ5ID0gdHJ1ZTtcblxuXHQvKipcblx0ICogT3BlbnMgc29ja2V0LlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0V1MucHJvdG90eXBlLmRvT3BlbiA9IGZ1bmN0aW9uKCl7XG5cdCAgaWYgKCF0aGlzLmNoZWNrKCkpIHtcblx0ICAgIC8vIGxldCBwcm9iZSB0aW1lb3V0XG5cdCAgICByZXR1cm47XG5cdCAgfVxuXG5cdCAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgIHZhciB1cmkgPSB0aGlzLnVyaSgpO1xuXHQgIHZhciBwcm90b2NvbHMgPSB2b2lkKDApO1xuXHQgIHZhciBvcHRzID0ge1xuXHQgICAgYWdlbnQ6IHRoaXMuYWdlbnQsXG5cdCAgICBwZXJNZXNzYWdlRGVmbGF0ZTogdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZVxuXHQgIH07XG5cblx0ICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcblx0ICBvcHRzLnBmeCA9IHRoaXMucGZ4O1xuXHQgIG9wdHMua2V5ID0gdGhpcy5rZXk7XG5cdCAgb3B0cy5wYXNzcGhyYXNlID0gdGhpcy5wYXNzcGhyYXNlO1xuXHQgIG9wdHMuY2VydCA9IHRoaXMuY2VydDtcblx0ICBvcHRzLmNhID0gdGhpcy5jYTtcblx0ICBvcHRzLmNpcGhlcnMgPSB0aGlzLmNpcGhlcnM7XG5cdCAgb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPSB0aGlzLnJlamVjdFVuYXV0aG9yaXplZDtcblx0ICBpZiAodGhpcy5leHRyYUhlYWRlcnMpIHtcblx0ICAgIG9wdHMuaGVhZGVycyA9IHRoaXMuZXh0cmFIZWFkZXJzO1xuXHQgIH1cblxuXHQgIHRoaXMud3MgPSBCcm93c2VyV2ViU29ja2V0ID8gbmV3IFdlYlNvY2tldCh1cmkpIDogbmV3IFdlYlNvY2tldCh1cmksIHByb3RvY29scywgb3B0cyk7XG5cblx0ICBpZiAodGhpcy53cy5iaW5hcnlUeXBlID09PSB1bmRlZmluZWQpIHtcblx0ICAgIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcblx0ICB9XG5cblx0ICBpZiAodGhpcy53cy5zdXBwb3J0cyAmJiB0aGlzLndzLnN1cHBvcnRzLmJpbmFyeSkge1xuXHQgICAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IHRydWU7XG5cdCAgICB0aGlzLndzLmJpbmFyeVR5cGUgPSAnYnVmZmVyJztcblx0ICB9IGVsc2Uge1xuXHQgICAgdGhpcy53cy5iaW5hcnlUeXBlID0gJ2FycmF5YnVmZmVyJztcblx0ICB9XG5cblx0ICB0aGlzLmFkZEV2ZW50TGlzdGVuZXJzKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFkZHMgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBzb2NrZXRcblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFdTLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uKCl7XG5cdCAgdmFyIHNlbGYgPSB0aGlzO1xuXG5cdCAgdGhpcy53cy5vbm9wZW4gPSBmdW5jdGlvbigpe1xuXHQgICAgc2VsZi5vbk9wZW4oKTtcblx0ICB9O1xuXHQgIHRoaXMud3Mub25jbG9zZSA9IGZ1bmN0aW9uKCl7XG5cdCAgICBzZWxmLm9uQ2xvc2UoKTtcblx0ICB9O1xuXHQgIHRoaXMud3Mub25tZXNzYWdlID0gZnVuY3Rpb24oZXYpe1xuXHQgICAgc2VsZi5vbkRhdGEoZXYuZGF0YSk7XG5cdCAgfTtcblx0ICB0aGlzLndzLm9uZXJyb3IgPSBmdW5jdGlvbihlKXtcblx0ICAgIHNlbGYub25FcnJvcignd2Vic29ja2V0IGVycm9yJywgZSk7XG5cdCAgfTtcblx0fTtcblxuXHQvKipcblx0ICogT3ZlcnJpZGUgYG9uRGF0YWAgdG8gdXNlIGEgdGltZXIgb24gaU9TLlxuXHQgKiBTZWU6IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL21sb3VnaHJhbi8yMDUyMDA2XG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRpZiAoJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIG5hdmlnYXRvclxuXHQgICYmIC9pUGFkfGlQaG9uZXxpUG9kL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuXHQgIFdTLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbihkYXRhKXtcblx0ICAgIHZhciBzZWxmID0gdGhpcztcblx0ICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcblx0ICAgICAgVHJhbnNwb3J0LnByb3RvdHlwZS5vbkRhdGEuY2FsbChzZWxmLCBkYXRhKTtcblx0ICAgIH0sIDApO1xuXHQgIH07XG5cdH1cblxuXHQvKipcblx0ICogV3JpdGVzIGRhdGEgdG8gc29ja2V0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBvZiBwYWNrZXRzLlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0V1MucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24ocGFja2V0cyl7XG5cdCAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuXHQgIC8vIGVuY29kZVBhY2tldCBlZmZpY2llbnQgYXMgaXQgdXNlcyBXUyBmcmFtaW5nXG5cdCAgLy8gbm8gbmVlZCBmb3IgZW5jb2RlUGF5bG9hZFxuXHQgIHZhciB0b3RhbCA9IHBhY2tldHMubGVuZ3RoO1xuXHQgIGZvciAodmFyIGkgPSAwLCBsID0gdG90YWw7IGkgPCBsOyBpKyspIHtcblx0ICAgIChmdW5jdGlvbihwYWNrZXQpIHtcblx0ICAgICAgcGFyc2VyLmVuY29kZVBhY2tldChwYWNrZXQsIHNlbGYuc3VwcG9ydHNCaW5hcnksIGZ1bmN0aW9uKGRhdGEpIHtcblx0ICAgICAgICBpZiAoIUJyb3dzZXJXZWJTb2NrZXQpIHtcblx0ICAgICAgICAgIC8vIGFsd2F5cyBjcmVhdGUgYSBuZXcgb2JqZWN0IChHSC00MzcpXG5cdCAgICAgICAgICB2YXIgb3B0cyA9IHt9O1xuXHQgICAgICAgICAgaWYgKHBhY2tldC5vcHRpb25zKSB7XG5cdCAgICAgICAgICAgIG9wdHMuY29tcHJlc3MgPSBwYWNrZXQub3B0aW9ucy5jb21wcmVzcztcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgaWYgKHNlbGYucGVyTWVzc2FnZURlZmxhdGUpIHtcblx0ICAgICAgICAgICAgdmFyIGxlbiA9ICdzdHJpbmcnID09IHR5cGVvZiBkYXRhID8gZ2xvYmFsLkJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpIDogZGF0YS5sZW5ndGg7XG5cdCAgICAgICAgICAgIGlmIChsZW4gPCBzZWxmLnBlck1lc3NhZ2VEZWZsYXRlLnRocmVzaG9sZCkge1xuXHQgICAgICAgICAgICAgIG9wdHMuY29tcHJlc3MgPSBmYWxzZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vU29tZXRpbWVzIHRoZSB3ZWJzb2NrZXQgaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQgYnV0IHRoZSBicm93c2VyIGRpZG4ndFxuXHQgICAgICAgIC8vaGF2ZSBhIGNoYW5jZSBvZiBpbmZvcm1pbmcgdXMgYWJvdXQgaXQgeWV0LCBpbiB0aGF0IGNhc2Ugc2VuZCB3aWxsXG5cdCAgICAgICAgLy90aHJvdyBhbiBlcnJvclxuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICBpZiAoQnJvd3NlcldlYlNvY2tldCkge1xuXHQgICAgICAgICAgICAvLyBUeXBlRXJyb3IgaXMgdGhyb3duIHdoZW4gcGFzc2luZyB0aGUgc2Vjb25kIGFyZ3VtZW50IG9uIFNhZmFyaVxuXHQgICAgICAgICAgICBzZWxmLndzLnNlbmQoZGF0YSk7XG5cdCAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBzZWxmLndzLnNlbmQoZGF0YSwgb3B0cyk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfSBjYXRjaCAoZSl7XG5cdCAgICAgICAgICBkZWJ1Zygnd2Vic29ja2V0IGNsb3NlZCBiZWZvcmUgb25jbG9zZSBldmVudCcpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC0tdG90YWwgfHwgZG9uZSgpO1xuXHQgICAgICB9KTtcblx0ICAgIH0pKHBhY2tldHNbaV0pO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGRvbmUoKXtcblx0ICAgIHNlbGYuZW1pdCgnZmx1c2gnKTtcblxuXHQgICAgLy8gZmFrZSBkcmFpblxuXHQgICAgLy8gZGVmZXIgdG8gbmV4dCB0aWNrIHRvIGFsbG93IFNvY2tldCB0byBjbGVhciB3cml0ZUJ1ZmZlclxuXHQgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuXHQgICAgICBzZWxmLndyaXRhYmxlID0gdHJ1ZTtcblx0ICAgICAgc2VsZi5lbWl0KCdkcmFpbicpO1xuXHQgICAgfSwgMCk7XG5cdCAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgdXBvbiBjbG9zZVxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0V1MucHJvdG90eXBlLm9uQ2xvc2UgPSBmdW5jdGlvbigpe1xuXHQgIFRyYW5zcG9ydC5wcm90b3R5cGUub25DbG9zZS5jYWxsKHRoaXMpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDbG9zZXMgc29ja2V0LlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0V1MucHJvdG90eXBlLmRvQ2xvc2UgPSBmdW5jdGlvbigpe1xuXHQgIGlmICh0eXBlb2YgdGhpcy53cyAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0ICAgIHRoaXMud3MuY2xvc2UoKTtcblx0ICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIEdlbmVyYXRlcyB1cmkgZm9yIGNvbm5lY3Rpb24uXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRXUy5wcm90b3R5cGUudXJpID0gZnVuY3Rpb24oKXtcblx0ICB2YXIgcXVlcnkgPSB0aGlzLnF1ZXJ5IHx8IHt9O1xuXHQgIHZhciBzY2hlbWEgPSB0aGlzLnNlY3VyZSA/ICd3c3MnIDogJ3dzJztcblx0ICB2YXIgcG9ydCA9ICcnO1xuXG5cdCAgLy8gYXZvaWQgcG9ydCBpZiBkZWZhdWx0IGZvciBzY2hlbWFcblx0ICBpZiAodGhpcy5wb3J0ICYmICgoJ3dzcycgPT0gc2NoZW1hICYmIHRoaXMucG9ydCAhPSA0NDMpXG5cdCAgICB8fCAoJ3dzJyA9PSBzY2hlbWEgJiYgdGhpcy5wb3J0ICE9IDgwKSkpIHtcblx0ICAgIHBvcnQgPSAnOicgKyB0aGlzLnBvcnQ7XG5cdCAgfVxuXG5cdCAgLy8gYXBwZW5kIHRpbWVzdGFtcCB0byBVUklcblx0ICBpZiAodGhpcy50aW1lc3RhbXBSZXF1ZXN0cykge1xuXHQgICAgcXVlcnlbdGhpcy50aW1lc3RhbXBQYXJhbV0gPSB5ZWFzdCgpO1xuXHQgIH1cblxuXHQgIC8vIGNvbW11bmljYXRlIGJpbmFyeSBzdXBwb3J0IGNhcGFiaWxpdGllc1xuXHQgIGlmICghdGhpcy5zdXBwb3J0c0JpbmFyeSkge1xuXHQgICAgcXVlcnkuYjY0ID0gMTtcblx0ICB9XG5cblx0ICBxdWVyeSA9IHBhcnNlcXMuZW5jb2RlKHF1ZXJ5KTtcblxuXHQgIC8vIHByZXBlbmQgPyB0byBxdWVyeVxuXHQgIGlmIChxdWVyeS5sZW5ndGgpIHtcblx0ICAgIHF1ZXJ5ID0gJz8nICsgcXVlcnk7XG5cdCAgfVxuXG5cdCAgdmFyIGlwdjYgPSB0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSAhPT0gLTE7XG5cdCAgcmV0dXJuIHNjaGVtYSArICc6Ly8nICsgKGlwdjYgPyAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nIDogdGhpcy5ob3N0bmFtZSkgKyBwb3J0ICsgdGhpcy5wYXRoICsgcXVlcnk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEZlYXR1cmUgZGV0ZWN0aW9uIGZvciBXZWJTb2NrZXQuXG5cdCAqXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IHdoZXRoZXIgdGhpcyB0cmFuc3BvcnQgaXMgYXZhaWxhYmxlLlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRXUy5wcm90b3R5cGUuY2hlY2sgPSBmdW5jdGlvbigpe1xuXHQgIHJldHVybiAhIVdlYlNvY2tldCAmJiAhKCdfX2luaXRpYWxpemUnIGluIFdlYlNvY2tldCAmJiB0aGlzLm5hbWUgPT09IFdTLnByb3RvdHlwZS5uYW1lKTtcblx0fTtcblxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSgpKSkpXG5cbi8qKiovIH0sXG4vKiAzOSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0LyogKGlnbm9yZWQpICovXG5cbi8qKiovIH0sXG4vKiA0MCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0XG5cdHZhciBpbmRleE9mID0gW10uaW5kZXhPZjtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFyciwgb2JqKXtcblx0ICBpZiAoaW5kZXhPZikgcmV0dXJuIGFyci5pbmRleE9mKG9iaik7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcblx0ICAgIGlmIChhcnJbaV0gPT09IG9iaikgcmV0dXJuIGk7XG5cdCAgfVxuXHQgIHJldHVybiAtMTtcblx0fTtcblxuLyoqKi8gfSxcbi8qIDQxICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7LyoqXG5cdCAqIEpTT04gcGFyc2UuXG5cdCAqXG5cdCAqIEBzZWUgQmFzZWQgb24galF1ZXJ5I3BhcnNlSlNPTiAoTUlUKSBhbmQgSlNPTjJcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdHZhciBydmFsaWRjaGFycyA9IC9eW1xcXSw6e31cXHNdKiQvO1xuXHR2YXIgcnZhbGlkZXNjYXBlID0gL1xcXFwoPzpbXCJcXFxcXFwvYmZucnRdfHVbMC05YS1mQS1GXXs0fSkvZztcblx0dmFyIHJ2YWxpZHRva2VucyA9IC9cIlteXCJcXFxcXFxuXFxyXSpcInx0cnVlfGZhbHNlfG51bGx8LT9cXGQrKD86XFwuXFxkKik/KD86W2VFXVsrXFwtXT9cXGQrKT8vZztcblx0dmFyIHJ2YWxpZGJyYWNlcyA9IC8oPzpefDp8LCkoPzpcXHMqXFxbKSsvZztcblx0dmFyIHJ0cmltTGVmdCA9IC9eXFxzKy87XG5cdHZhciBydHJpbVJpZ2h0ID0gL1xccyskLztcblxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlanNvbihkYXRhKSB7XG5cdCAgaWYgKCdzdHJpbmcnICE9IHR5cGVvZiBkYXRhIHx8ICFkYXRhKSB7XG5cdCAgICByZXR1cm4gbnVsbDtcblx0ICB9XG5cblx0ICBkYXRhID0gZGF0YS5yZXBsYWNlKHJ0cmltTGVmdCwgJycpLnJlcGxhY2UocnRyaW1SaWdodCwgJycpO1xuXG5cdCAgLy8gQXR0ZW1wdCB0byBwYXJzZSB1c2luZyB0aGUgbmF0aXZlIEpTT04gcGFyc2VyIGZpcnN0XG5cdCAgaWYgKGdsb2JhbC5KU09OICYmIEpTT04ucGFyc2UpIHtcblx0ICAgIHJldHVybiBKU09OLnBhcnNlKGRhdGEpO1xuXHQgIH1cblxuXHQgIGlmIChydmFsaWRjaGFycy50ZXN0KGRhdGEucmVwbGFjZShydmFsaWRlc2NhcGUsICdAJylcblx0ICAgICAgLnJlcGxhY2UocnZhbGlkdG9rZW5zLCAnXScpXG5cdCAgICAgIC5yZXBsYWNlKHJ2YWxpZGJyYWNlcywgJycpKSkge1xuXHQgICAgcmV0dXJuIChuZXcgRnVuY3Rpb24oJ3JldHVybiAnICsgZGF0YSkpKCk7XG5cdCAgfVxuXHR9O1xuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSgpKSkpXG5cbi8qKiovIH0sXG4vKiA0MiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdC8qKlxuXHQgKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuXHQgKi9cblxuXHR2YXIgcGFyc2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblx0dmFyIEVtaXR0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzKTtcblx0dmFyIHRvQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0KTtcblx0dmFyIG9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NSk7XG5cdHZhciBiaW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Nik7XG5cdHZhciBkZWJ1ZyA9IF9fd2VicGFja19yZXF1aXJlX18oMykoJ3NvY2tldC5pby1jbGllbnQ6c29ja2V0Jyk7XG5cdHZhciBoYXNCaW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3KTtcblxuXHQvKipcblx0ICogTW9kdWxlIGV4cG9ydHMuXG5cdCAqL1xuXG5cdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IFNvY2tldDtcblxuXHQvKipcblx0ICogSW50ZXJuYWwgZXZlbnRzIChibGFja2xpc3RlZCkuXG5cdCAqIFRoZXNlIGV2ZW50cyBjYW4ndCBiZSBlbWl0dGVkIGJ5IHRoZSB1c2VyLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0dmFyIGV2ZW50cyA9IHtcblx0ICBjb25uZWN0OiAxLFxuXHQgIGNvbm5lY3RfZXJyb3I6IDEsXG5cdCAgY29ubmVjdF90aW1lb3V0OiAxLFxuXHQgIGNvbm5lY3Rpbmc6IDEsXG5cdCAgZGlzY29ubmVjdDogMSxcblx0ICBlcnJvcjogMSxcblx0ICByZWNvbm5lY3Q6IDEsXG5cdCAgcmVjb25uZWN0X2F0dGVtcHQ6IDEsXG5cdCAgcmVjb25uZWN0X2ZhaWxlZDogMSxcblx0ICByZWNvbm5lY3RfZXJyb3I6IDEsXG5cdCAgcmVjb25uZWN0aW5nOiAxLFxuXHQgIHBpbmc6IDEsXG5cdCAgcG9uZzogMVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBgRW1pdHRlciNlbWl0YC5cblx0ICovXG5cblx0dmFyIGVtaXQgPSBFbWl0dGVyLnByb3RvdHlwZS5lbWl0O1xuXG5cdC8qKlxuXHQgKiBgU29ja2V0YCBjb25zdHJ1Y3Rvci5cblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZnVuY3Rpb24gU29ja2V0KGlvLCBuc3AsIG9wdHMpIHtcblx0ICB0aGlzLmlvID0gaW87XG5cdCAgdGhpcy5uc3AgPSBuc3A7XG5cdCAgdGhpcy5qc29uID0gdGhpczsgLy8gY29tcGF0XG5cdCAgdGhpcy5pZHMgPSAwO1xuXHQgIHRoaXMuYWNrcyA9IHt9O1xuXHQgIHRoaXMucmVjZWl2ZUJ1ZmZlciA9IFtdO1xuXHQgIHRoaXMuc2VuZEJ1ZmZlciA9IFtdO1xuXHQgIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG5cdCAgdGhpcy5kaXNjb25uZWN0ZWQgPSB0cnVlO1xuXHQgIGlmIChvcHRzICYmIG9wdHMucXVlcnkpIHtcblx0ICAgIHRoaXMucXVlcnkgPSBvcHRzLnF1ZXJ5O1xuXHQgIH1cblx0ICBpZiAodGhpcy5pby5hdXRvQ29ubmVjdCkgdGhpcy5vcGVuKCk7XG5cdH1cblxuXHQvKipcblx0ICogTWl4IGluIGBFbWl0dGVyYC5cblx0ICovXG5cblx0RW1pdHRlcihTb2NrZXQucHJvdG90eXBlKTtcblxuXHQvKipcblx0ICogU3Vic2NyaWJlIHRvIG9wZW4sIGNsb3NlIGFuZCBwYWNrZXQgZXZlbnRzXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRTb2NrZXQucHJvdG90eXBlLnN1YkV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcblx0ICBpZiAodGhpcy5zdWJzKSByZXR1cm47XG5cblx0ICB2YXIgaW8gPSB0aGlzLmlvO1xuXHQgIHRoaXMuc3VicyA9IFtvbihpbywgJ29wZW4nLCBiaW5kKHRoaXMsICdvbm9wZW4nKSksIG9uKGlvLCAncGFja2V0JywgYmluZCh0aGlzLCAnb25wYWNrZXQnKSksIG9uKGlvLCAnY2xvc2UnLCBiaW5kKHRoaXMsICdvbmNsb3NlJykpXTtcblx0fTtcblxuXHQvKipcblx0ICogXCJPcGVuc1wiIHRoZSBzb2NrZXQuXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdFNvY2tldC5wcm90b3R5cGUub3BlbiA9IFNvY2tldC5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcblx0ICBpZiAodGhpcy5jb25uZWN0ZWQpIHJldHVybiB0aGlzO1xuXG5cdCAgdGhpcy5zdWJFdmVudHMoKTtcblx0ICB0aGlzLmlvLm9wZW4oKTsgLy8gZW5zdXJlIG9wZW5cblx0ICBpZiAoJ29wZW4nID09PSB0aGlzLmlvLnJlYWR5U3RhdGUpIHRoaXMub25vcGVuKCk7XG5cdCAgdGhpcy5lbWl0KCdjb25uZWN0aW5nJyk7XG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNlbmRzIGEgYG1lc3NhZ2VgIGV2ZW50LlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0U29ja2V0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKCkge1xuXHQgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMpO1xuXHQgIGFyZ3MudW5zaGlmdCgnbWVzc2FnZScpO1xuXHQgIHRoaXMuZW1pdC5hcHBseSh0aGlzLCBhcmdzKTtcblx0ICByZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogT3ZlcnJpZGUgYGVtaXRgLlxuXHQgKiBJZiB0aGUgZXZlbnQgaXMgaW4gYGV2ZW50c2AsIGl0J3MgZW1pdHRlZCBub3JtYWxseS5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IG5hbWVcblx0ICogQHJldHVybiB7U29ja2V0fSBzZWxmXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdFNvY2tldC5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIChldikge1xuXHQgIGlmIChldmVudHMuaGFzT3duUHJvcGVydHkoZXYpKSB7XG5cdCAgICBlbWl0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9XG5cblx0ICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzKTtcblx0ICB2YXIgcGFyc2VyVHlwZSA9IHBhcnNlci5FVkVOVDsgLy8gZGVmYXVsdFxuXHQgIGlmIChoYXNCaW4oYXJncykpIHtcblx0ICAgIHBhcnNlclR5cGUgPSBwYXJzZXIuQklOQVJZX0VWRU5UO1xuXHQgIH0gLy8gYmluYXJ5XG5cdCAgdmFyIHBhY2tldCA9IHsgdHlwZTogcGFyc2VyVHlwZSwgZGF0YTogYXJncyB9O1xuXG5cdCAgcGFja2V0Lm9wdGlvbnMgPSB7fTtcblx0ICBwYWNrZXQub3B0aW9ucy5jb21wcmVzcyA9ICF0aGlzLmZsYWdzIHx8IGZhbHNlICE9PSB0aGlzLmZsYWdzLmNvbXByZXNzO1xuXG5cdCAgLy8gZXZlbnQgYWNrIGNhbGxiYWNrXG5cdCAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0pIHtcblx0ICAgIGRlYnVnKCdlbWl0dGluZyBwYWNrZXQgd2l0aCBhY2sgaWQgJWQnLCB0aGlzLmlkcyk7XG5cdCAgICB0aGlzLmFja3NbdGhpcy5pZHNdID0gYXJncy5wb3AoKTtcblx0ICAgIHBhY2tldC5pZCA9IHRoaXMuaWRzKys7XG5cdCAgfVxuXG5cdCAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG5cdCAgICB0aGlzLnBhY2tldChwYWNrZXQpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB0aGlzLnNlbmRCdWZmZXIucHVzaChwYWNrZXQpO1xuXHQgIH1cblxuXHQgIGRlbGV0ZSB0aGlzLmZsYWdzO1xuXG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNlbmRzIGEgcGFja2V0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRTb2NrZXQucHJvdG90eXBlLnBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcblx0ICBwYWNrZXQubnNwID0gdGhpcy5uc3A7XG5cdCAgdGhpcy5pby5wYWNrZXQocGFja2V0KTtcblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIHVwb24gZW5naW5lIGBvcGVuYC5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFNvY2tldC5wcm90b3R5cGUub25vcGVuID0gZnVuY3Rpb24gKCkge1xuXHQgIGRlYnVnKCd0cmFuc3BvcnQgaXMgb3BlbiAtIGNvbm5lY3RpbmcnKTtcblxuXHQgIC8vIHdyaXRlIGNvbm5lY3QgcGFja2V0IGlmIG5lY2Vzc2FyeVxuXHQgIGlmICgnLycgIT09IHRoaXMubnNwKSB7XG5cdCAgICBpZiAodGhpcy5xdWVyeSkge1xuXHQgICAgICB0aGlzLnBhY2tldCh7IHR5cGU6IHBhcnNlci5DT05ORUNULCBxdWVyeTogdGhpcy5xdWVyeSB9KTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHRoaXMucGFja2V0KHsgdHlwZTogcGFyc2VyLkNPTk5FQ1QgfSk7XG5cdCAgICB9XG5cdCAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgdXBvbiBlbmdpbmUgYGNsb3NlYC5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IHJlYXNvblxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0U29ja2V0LnByb3RvdHlwZS5vbmNsb3NlID0gZnVuY3Rpb24gKHJlYXNvbikge1xuXHQgIGRlYnVnKCdjbG9zZSAoJXMpJywgcmVhc29uKTtcblx0ICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuXHQgIHRoaXMuZGlzY29ubmVjdGVkID0gdHJ1ZTtcblx0ICBkZWxldGUgdGhpcy5pZDtcblx0ICB0aGlzLmVtaXQoJ2Rpc2Nvbm5lY3QnLCByZWFzb24pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgd2l0aCBzb2NrZXQgcGFja2V0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRTb2NrZXQucHJvdG90eXBlLm9ucGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuXHQgIGlmIChwYWNrZXQubnNwICE9PSB0aGlzLm5zcCkgcmV0dXJuO1xuXG5cdCAgc3dpdGNoIChwYWNrZXQudHlwZSkge1xuXHQgICAgY2FzZSBwYXJzZXIuQ09OTkVDVDpcblx0ICAgICAgdGhpcy5vbmNvbm5lY3QoKTtcblx0ICAgICAgYnJlYWs7XG5cblx0ICAgIGNhc2UgcGFyc2VyLkVWRU5UOlxuXHQgICAgICB0aGlzLm9uZXZlbnQocGFja2V0KTtcblx0ICAgICAgYnJlYWs7XG5cblx0ICAgIGNhc2UgcGFyc2VyLkJJTkFSWV9FVkVOVDpcblx0ICAgICAgdGhpcy5vbmV2ZW50KHBhY2tldCk7XG5cdCAgICAgIGJyZWFrO1xuXG5cdCAgICBjYXNlIHBhcnNlci5BQ0s6XG5cdCAgICAgIHRoaXMub25hY2socGFja2V0KTtcblx0ICAgICAgYnJlYWs7XG5cblx0ICAgIGNhc2UgcGFyc2VyLkJJTkFSWV9BQ0s6XG5cdCAgICAgIHRoaXMub25hY2socGFja2V0KTtcblx0ICAgICAgYnJlYWs7XG5cblx0ICAgIGNhc2UgcGFyc2VyLkRJU0NPTk5FQ1Q6XG5cdCAgICAgIHRoaXMub25kaXNjb25uZWN0KCk7XG5cdCAgICAgIGJyZWFrO1xuXG5cdCAgICBjYXNlIHBhcnNlci5FUlJPUjpcblx0ICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIHBhY2tldC5kYXRhKTtcblx0ICAgICAgYnJlYWs7XG5cdCAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgdXBvbiBhIHNlcnZlciBldmVudC5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0U29ja2V0LnByb3RvdHlwZS5vbmV2ZW50ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuXHQgIHZhciBhcmdzID0gcGFja2V0LmRhdGEgfHwgW107XG5cdCAgZGVidWcoJ2VtaXR0aW5nIGV2ZW50ICVqJywgYXJncyk7XG5cblx0ICBpZiAobnVsbCAhPSBwYWNrZXQuaWQpIHtcblx0ICAgIGRlYnVnKCdhdHRhY2hpbmcgYWNrIGNhbGxiYWNrIHRvIGV2ZW50Jyk7XG5cdCAgICBhcmdzLnB1c2godGhpcy5hY2socGFja2V0LmlkKSk7XG5cdCAgfVxuXG5cdCAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG5cdCAgICBlbWl0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB0aGlzLnJlY2VpdmVCdWZmZXIucHVzaChhcmdzKTtcblx0ICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIFByb2R1Y2VzIGFuIGFjayBjYWxsYmFjayB0byBlbWl0IHdpdGggYW4gZXZlbnQuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRTb2NrZXQucHJvdG90eXBlLmFjayA9IGZ1bmN0aW9uIChpZCkge1xuXHQgIHZhciBzZWxmID0gdGhpcztcblx0ICB2YXIgc2VudCA9IGZhbHNlO1xuXHQgIHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBwcmV2ZW50IGRvdWJsZSBjYWxsYmFja3Ncblx0ICAgIGlmIChzZW50KSByZXR1cm47XG5cdCAgICBzZW50ID0gdHJ1ZTtcblx0ICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMpO1xuXHQgICAgZGVidWcoJ3NlbmRpbmcgYWNrICVqJywgYXJncyk7XG5cblx0ICAgIHZhciB0eXBlID0gaGFzQmluKGFyZ3MpID8gcGFyc2VyLkJJTkFSWV9BQ0sgOiBwYXJzZXIuQUNLO1xuXHQgICAgc2VsZi5wYWNrZXQoe1xuXHQgICAgICB0eXBlOiB0eXBlLFxuXHQgICAgICBpZDogaWQsXG5cdCAgICAgIGRhdGE6IGFyZ3Ncblx0ICAgIH0pO1xuXHQgIH07XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxlZCB1cG9uIGEgc2VydmVyIGFja25vd2xlZ2VtZW50LlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRTb2NrZXQucHJvdG90eXBlLm9uYWNrID0gZnVuY3Rpb24gKHBhY2tldCkge1xuXHQgIHZhciBhY2sgPSB0aGlzLmFja3NbcGFja2V0LmlkXTtcblx0ICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGFjaykge1xuXHQgICAgZGVidWcoJ2NhbGxpbmcgYWNrICVzIHdpdGggJWonLCBwYWNrZXQuaWQsIHBhY2tldC5kYXRhKTtcblx0ICAgIGFjay5hcHBseSh0aGlzLCBwYWNrZXQuZGF0YSk7XG5cdCAgICBkZWxldGUgdGhpcy5hY2tzW3BhY2tldC5pZF07XG5cdCAgfSBlbHNlIHtcblx0ICAgIGRlYnVnKCdiYWQgYWNrICVzJywgcGFja2V0LmlkKTtcblx0ICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxlZCB1cG9uIHNlcnZlciBjb25uZWN0LlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0U29ja2V0LnByb3RvdHlwZS5vbmNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG5cdCAgdGhpcy5jb25uZWN0ZWQgPSB0cnVlO1xuXHQgIHRoaXMuZGlzY29ubmVjdGVkID0gZmFsc2U7XG5cdCAgdGhpcy5lbWl0KCdjb25uZWN0Jyk7XG5cdCAgdGhpcy5lbWl0QnVmZmVyZWQoKTtcblx0fTtcblxuXHQvKipcblx0ICogRW1pdCBidWZmZXJlZCBldmVudHMgKHJlY2VpdmVkIGFuZCBlbWl0dGVkKS5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFNvY2tldC5wcm90b3R5cGUuZW1pdEJ1ZmZlcmVkID0gZnVuY3Rpb24gKCkge1xuXHQgIHZhciBpO1xuXHQgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnJlY2VpdmVCdWZmZXIubGVuZ3RoOyBpKyspIHtcblx0ICAgIGVtaXQuYXBwbHkodGhpcywgdGhpcy5yZWNlaXZlQnVmZmVyW2ldKTtcblx0ICB9XG5cdCAgdGhpcy5yZWNlaXZlQnVmZmVyID0gW107XG5cblx0ICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5zZW5kQnVmZmVyLmxlbmd0aDsgaSsrKSB7XG5cdCAgICB0aGlzLnBhY2tldCh0aGlzLnNlbmRCdWZmZXJbaV0pO1xuXHQgIH1cblx0ICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIHVwb24gc2VydmVyIGRpc2Nvbm5lY3QuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRTb2NrZXQucHJvdG90eXBlLm9uZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcblx0ICBkZWJ1Zygnc2VydmVyIGRpc2Nvbm5lY3QgKCVzKScsIHRoaXMubnNwKTtcblx0ICB0aGlzLmRlc3Ryb3koKTtcblx0ICB0aGlzLm9uY2xvc2UoJ2lvIHNlcnZlciBkaXNjb25uZWN0Jyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxlZCB1cG9uIGZvcmNlZCBjbGllbnQvc2VydmVyIHNpZGUgZGlzY29ubmVjdGlvbnMsXG5cdCAqIHRoaXMgbWV0aG9kIGVuc3VyZXMgdGhlIG1hbmFnZXIgc3RvcHMgdHJhY2tpbmcgdXMgYW5kXG5cdCAqIHRoYXQgcmVjb25uZWN0aW9ucyBkb24ndCBnZXQgdHJpZ2dlcmVkIGZvciB0aGlzLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGUuXG5cdCAqL1xuXG5cdFNvY2tldC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcblx0ICBpZiAodGhpcy5zdWJzKSB7XG5cdCAgICAvLyBjbGVhbiBzdWJzY3JpcHRpb25zIHRvIGF2b2lkIHJlY29ubmVjdGlvbnNcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zdWJzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHRoaXMuc3Vic1tpXS5kZXN0cm95KCk7XG5cdCAgICB9XG5cdCAgICB0aGlzLnN1YnMgPSBudWxsO1xuXHQgIH1cblxuXHQgIHRoaXMuaW8uZGVzdHJveSh0aGlzKTtcblx0fTtcblxuXHQvKipcblx0ICogRGlzY29ubmVjdHMgdGhlIHNvY2tldCBtYW51YWxseS5cblx0ICpcblx0ICogQHJldHVybiB7U29ja2V0fSBzZWxmXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdFNvY2tldC5wcm90b3R5cGUuY2xvc2UgPSBTb2NrZXQucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG5cdCAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG5cdCAgICBkZWJ1ZygncGVyZm9ybWluZyBkaXNjb25uZWN0ICglcyknLCB0aGlzLm5zcCk7XG5cdCAgICB0aGlzLnBhY2tldCh7IHR5cGU6IHBhcnNlci5ESVNDT05ORUNUIH0pO1xuXHQgIH1cblxuXHQgIC8vIHJlbW92ZSBzb2NrZXQgZnJvbSBwb29sXG5cdCAgdGhpcy5kZXN0cm95KCk7XG5cblx0ICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcblx0ICAgIC8vIGZpcmUgZXZlbnRzXG5cdCAgICB0aGlzLm9uY2xvc2UoJ2lvIGNsaWVudCBkaXNjb25uZWN0Jyk7XG5cdCAgfVxuXHQgIHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBjb21wcmVzcyBmbGFnLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlmIGB0cnVlYCwgY29tcHJlc3NlcyB0aGUgc2VuZGluZyBkYXRhXG5cdCAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRTb2NrZXQucHJvdG90eXBlLmNvbXByZXNzID0gZnVuY3Rpb24gKGNvbXByZXNzKSB7XG5cdCAgdGhpcy5mbGFncyA9IHRoaXMuZmxhZ3MgfHwge307XG5cdCAgdGhpcy5mbGFncy5jb21wcmVzcyA9IGNvbXByZXNzO1xuXHQgIHJldHVybiB0aGlzO1xuXHR9O1xuXG4vKioqLyB9LFxuLyogNDMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdFxuXHQvKipcblx0ICogRXhwb3NlIGBFbWl0dGVyYC5cblx0ICovXG5cblx0bW9kdWxlLmV4cG9ydHMgPSBFbWl0dGVyO1xuXG5cdC8qKlxuXHQgKiBJbml0aWFsaXplIGEgbmV3IGBFbWl0dGVyYC5cblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZnVuY3Rpb24gRW1pdHRlcihvYmopIHtcblx0ICBpZiAob2JqKSByZXR1cm4gbWl4aW4ob2JqKTtcblx0fTtcblxuXHQvKipcblx0ICogTWl4aW4gdGhlIGVtaXR0ZXIgcHJvcGVydGllcy5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IG9ialxuXHQgKiBAcmV0dXJuIHtPYmplY3R9XG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRmdW5jdGlvbiBtaXhpbihvYmopIHtcblx0ICBmb3IgKHZhciBrZXkgaW4gRW1pdHRlci5wcm90b3R5cGUpIHtcblx0ICAgIG9ialtrZXldID0gRW1pdHRlci5wcm90b3R5cGVba2V5XTtcblx0ICB9XG5cdCAgcmV0dXJuIG9iajtcblx0fVxuXG5cdC8qKlxuXHQgKiBMaXN0ZW4gb24gdGhlIGdpdmVuIGBldmVudGAgd2l0aCBgZm5gLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cblx0ICogQHJldHVybiB7RW1pdHRlcn1cblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0RW1pdHRlci5wcm90b3R5cGUub24gPVxuXHRFbWl0dGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcblx0ICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG5cdCAgKHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdIHx8IFtdKVxuXHQgICAgLnB1c2goZm4pO1xuXHQgIHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBZGRzIGFuIGBldmVudGAgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGludm9rZWQgYSBzaW5nbGVcblx0ICogdGltZSB0aGVuIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG5cdCAqIEByZXR1cm4ge0VtaXR0ZXJ9XG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuXHQgIGZ1bmN0aW9uIG9uKCkge1xuXHQgICAgdGhpcy5vZmYoZXZlbnQsIG9uKTtcblx0ICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgfVxuXG5cdCAgb24uZm4gPSBmbjtcblx0ICB0aGlzLm9uKGV2ZW50LCBvbik7XG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlbW92ZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGBldmVudGAgb3IgYWxsXG5cdCAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cblx0ICogQHJldHVybiB7RW1pdHRlcn1cblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0RW1pdHRlci5wcm90b3R5cGUub2ZmID1cblx0RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuXHRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuXHRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcblx0ICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG5cblx0ICAvLyBhbGxcblx0ICBpZiAoMCA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG5cdCAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH1cblxuXHQgIC8vIHNwZWNpZmljIGV2ZW50XG5cdCAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XG5cdCAgaWYgKCFjYWxsYmFja3MpIHJldHVybiB0aGlzO1xuXG5cdCAgLy8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xuXHQgIGlmICgxID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcblx0ICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfVxuXG5cdCAgLy8gcmVtb3ZlIHNwZWNpZmljIGhhbmRsZXJcblx0ICB2YXIgY2I7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcblx0ICAgIGNiID0gY2FsbGJhY2tzW2ldO1xuXHQgICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcblx0ICAgICAgY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcblx0ICAgICAgYnJlYWs7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBFbWl0IGBldmVudGAgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG5cdCAqIEBwYXJhbSB7TWl4ZWR9IC4uLlxuXHQgKiBAcmV0dXJuIHtFbWl0dGVyfVxuXHQgKi9cblxuXHRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oZXZlbnQpe1xuXHQgIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcblx0ICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxuXHQgICAgLCBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xuXG5cdCAgaWYgKGNhbGxiYWNrcykge1xuXHQgICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuXHQgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuXHQgICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybiBhcnJheSBvZiBjYWxsYmFja3MgZm9yIGBldmVudGAuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuXHQgKiBAcmV0dXJuIHtBcnJheX1cblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xuXHQgIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcblx0ICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXTtcblx0fTtcblxuXHQvKipcblx0ICogQ2hlY2sgaWYgdGhpcyBlbWl0dGVyIGhhcyBgZXZlbnRgIGhhbmRsZXJzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0RW1pdHRlci5wcm90b3R5cGUuaGFzTGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xuXHQgIHJldHVybiAhISB0aGlzLmxpc3RlbmVycyhldmVudCkubGVuZ3RoO1xuXHR9O1xuXG5cbi8qKiovIH0sXG4vKiA0NCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSB0b0FycmF5XG5cblx0ZnVuY3Rpb24gdG9BcnJheShsaXN0LCBpbmRleCkge1xuXHQgICAgdmFyIGFycmF5ID0gW11cblxuXHQgICAgaW5kZXggPSBpbmRleCB8fCAwXG5cblx0ICAgIGZvciAodmFyIGkgPSBpbmRleCB8fCAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIGFycmF5W2kgLSBpbmRleF0gPSBsaXN0W2ldXG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBhcnJheVxuXHR9XG5cblxuLyoqKi8gfSxcbi8qIDQ1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvKipcblx0ICogTW9kdWxlIGV4cG9ydHMuXG5cdCAqL1xuXG5cdG1vZHVsZS5leHBvcnRzID0gb247XG5cblx0LyoqXG5cdCAqIEhlbHBlciBmb3Igc3Vic2NyaXB0aW9ucy5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R8RXZlbnRFbWl0dGVyfSBvYmogd2l0aCBgRW1pdHRlcmAgbWl4aW4gb3IgYEV2ZW50RW1pdHRlcmBcblx0ICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IG5hbWVcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZnVuY3Rpb24gb24ob2JqLCBldiwgZm4pIHtcblx0ICBvYmoub24oZXYsIGZuKTtcblx0ICByZXR1cm4ge1xuXHQgICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcblx0ICAgICAgb2JqLnJlbW92ZUxpc3RlbmVyKGV2LCBmbik7XG5cdCAgICB9XG5cdCAgfTtcblx0fVxuXG4vKioqLyB9LFxuLyogNDYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdC8qKlxuXHQgKiBTbGljZSByZWZlcmVuY2UuXG5cdCAqL1xuXG5cdHZhciBzbGljZSA9IFtdLnNsaWNlO1xuXG5cdC8qKlxuXHQgKiBCaW5kIGBvYmpgIHRvIGBmbmAuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcblx0ICogQHBhcmFtIHtGdW5jdGlvbnxTdHJpbmd9IGZuIG9yIHN0cmluZ1xuXHQgKiBAcmV0dXJuIHtGdW5jdGlvbn1cblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIGZuKXtcblx0ICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIGZuKSBmbiA9IG9ialtmbl07XG5cdCAgaWYgKCdmdW5jdGlvbicgIT0gdHlwZW9mIGZuKSB0aHJvdyBuZXcgRXJyb3IoJ2JpbmQoKSByZXF1aXJlcyBhIGZ1bmN0aW9uJyk7XG5cdCAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG5cdCAgcmV0dXJuIGZ1bmN0aW9uKCl7XG5cdCAgICByZXR1cm4gZm4uYXBwbHkob2JqLCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcblx0ICB9XG5cdH07XG5cblxuLyoqKi8gfSxcbi8qIDQ3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cdC8qXG5cdCAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG5cdCAqL1xuXG5cdHZhciBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OCk7XG5cblx0LyoqXG5cdCAqIE1vZHVsZSBleHBvcnRzLlxuXHQgKi9cblxuXHRtb2R1bGUuZXhwb3J0cyA9IGhhc0JpbmFyeTtcblxuXHQvKipcblx0ICogQ2hlY2tzIGZvciBiaW5hcnkgZGF0YS5cblx0ICpcblx0ICogUmlnaHQgbm93IG9ubHkgQnVmZmVyIGFuZCBBcnJheUJ1ZmZlciBhcmUgc3VwcG9ydGVkLi5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IGFueXRoaW5nXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIGhhc0JpbmFyeShkYXRhKSB7XG5cblx0ICBmdW5jdGlvbiBfaGFzQmluYXJ5KG9iaikge1xuXHQgICAgaWYgKCFvYmopIHJldHVybiBmYWxzZTtcblxuXHQgICAgaWYgKCAoZ2xvYmFsLkJ1ZmZlciAmJiBnbG9iYWwuQnVmZmVyLmlzQnVmZmVyICYmIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIob2JqKSkgfHxcblx0ICAgICAgICAgKGdsb2JhbC5BcnJheUJ1ZmZlciAmJiBvYmogaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHxcblx0ICAgICAgICAgKGdsb2JhbC5CbG9iICYmIG9iaiBpbnN0YW5jZW9mIEJsb2IpIHx8XG5cdCAgICAgICAgIChnbG9iYWwuRmlsZSAmJiBvYmogaW5zdGFuY2VvZiBGaWxlKVxuXHQgICAgICAgICkge1xuXHQgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblxuXHQgICAgaWYgKGlzQXJyYXkob2JqKSkge1xuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgaWYgKF9oYXNCaW5hcnkob2JqW2ldKSkge1xuXHQgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9IGVsc2UgaWYgKG9iaiAmJiAnb2JqZWN0JyA9PSB0eXBlb2Ygb2JqKSB7XG5cdCAgICAgIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL0F1dG9tYXR0aWMvaGFzLWJpbmFyeS9wdWxsLzRcblx0ICAgICAgaWYgKG9iai50b0pTT04gJiYgJ2Z1bmN0aW9uJyA9PSB0eXBlb2Ygb2JqLnRvSlNPTikge1xuXHQgICAgICAgIG9iaiA9IG9iai50b0pTT04oKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcblx0ICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSAmJiBfaGFzQmluYXJ5KG9ialtrZXldKSkge1xuXHQgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICB9XG5cblx0ICByZXR1cm4gX2hhc0JpbmFyeShkYXRhKTtcblx0fVxuXG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KCkpKSlcblxuLyoqKi8gfSxcbi8qIDQ4ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuXHQgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xuXHR9O1xuXG5cbi8qKiovIH0sXG4vKiA0OSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0XG5cdC8qKlxuXHQgKiBFeHBvc2UgYEJhY2tvZmZgLlxuXHQgKi9cblxuXHRtb2R1bGUuZXhwb3J0cyA9IEJhY2tvZmY7XG5cblx0LyoqXG5cdCAqIEluaXRpYWxpemUgYmFja29mZiB0aW1lciB3aXRoIGBvcHRzYC5cblx0ICpcblx0ICogLSBgbWluYCBpbml0aWFsIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIFsxMDBdXG5cdCAqIC0gYG1heGAgbWF4IHRpbWVvdXQgWzEwMDAwXVxuXHQgKiAtIGBqaXR0ZXJgIFswXVxuXHQgKiAtIGBmYWN0b3JgIFsyXVxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRmdW5jdGlvbiBCYWNrb2ZmKG9wdHMpIHtcblx0ICBvcHRzID0gb3B0cyB8fCB7fTtcblx0ICB0aGlzLm1zID0gb3B0cy5taW4gfHwgMTAwO1xuXHQgIHRoaXMubWF4ID0gb3B0cy5tYXggfHwgMTAwMDA7XG5cdCAgdGhpcy5mYWN0b3IgPSBvcHRzLmZhY3RvciB8fCAyO1xuXHQgIHRoaXMuaml0dGVyID0gb3B0cy5qaXR0ZXIgPiAwICYmIG9wdHMuaml0dGVyIDw9IDEgPyBvcHRzLmppdHRlciA6IDA7XG5cdCAgdGhpcy5hdHRlbXB0cyA9IDA7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJuIHRoZSBiYWNrb2ZmIGR1cmF0aW9uLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdEJhY2tvZmYucHJvdG90eXBlLmR1cmF0aW9uID0gZnVuY3Rpb24oKXtcblx0ICB2YXIgbXMgPSB0aGlzLm1zICogTWF0aC5wb3codGhpcy5mYWN0b3IsIHRoaXMuYXR0ZW1wdHMrKyk7XG5cdCAgaWYgKHRoaXMuaml0dGVyKSB7XG5cdCAgICB2YXIgcmFuZCA9ICBNYXRoLnJhbmRvbSgpO1xuXHQgICAgdmFyIGRldmlhdGlvbiA9IE1hdGguZmxvb3IocmFuZCAqIHRoaXMuaml0dGVyICogbXMpO1xuXHQgICAgbXMgPSAoTWF0aC5mbG9vcihyYW5kICogMTApICYgMSkgPT0gMCAgPyBtcyAtIGRldmlhdGlvbiA6IG1zICsgZGV2aWF0aW9uO1xuXHQgIH1cblx0ICByZXR1cm4gTWF0aC5taW4obXMsIHRoaXMubWF4KSB8IDA7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlc2V0IHRoZSBudW1iZXIgb2YgYXR0ZW1wdHMuXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdEJhY2tvZmYucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKXtcblx0ICB0aGlzLmF0dGVtcHRzID0gMDtcblx0fTtcblxuXHQvKipcblx0ICogU2V0IHRoZSBtaW5pbXVtIGR1cmF0aW9uXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdEJhY2tvZmYucHJvdG90eXBlLnNldE1pbiA9IGZ1bmN0aW9uKG1pbil7XG5cdCAgdGhpcy5tcyA9IG1pbjtcblx0fTtcblxuXHQvKipcblx0ICogU2V0IHRoZSBtYXhpbXVtIGR1cmF0aW9uXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdEJhY2tvZmYucHJvdG90eXBlLnNldE1heCA9IGZ1bmN0aW9uKG1heCl7XG5cdCAgdGhpcy5tYXggPSBtYXg7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNldCB0aGUgaml0dGVyXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdEJhY2tvZmYucHJvdG90eXBlLnNldEppdHRlciA9IGZ1bmN0aW9uKGppdHRlcil7XG5cdCAgdGhpcy5qaXR0ZXIgPSBqaXR0ZXI7XG5cdH07XG5cblxuXG4vKioqLyB9XG4vKioqKioqLyBdKVxufSk7XG47IiwidmFyIGdsb2JhbHMgPSB7fTtcblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG5cdGdsb2JhbHMud2luZG93ID0gd2luZG93O1xufVxuXG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuXHRnbG9iYWxzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdsb2JhbHM7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIGNvcmUgdXRpbGl0eSBmdW5jdGlvbnMuXG4gKiBAY29uc3RcbiAqL1xuXG5sZXQgY29tcGF0aWJpbGl0eU1vZGVEYXRhXztcblxuLyoqXG4gKiBDb3VudGVyIGZvciB1bmlxdWUgaWQuXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQHByaXZhdGVcbiAqL1xubGV0IHVuaXF1ZUlkQ291bnRlcl8gPSAxO1xuXG4vKipcbiAqIFVuaXF1ZSBpZCBwcm9wZXJ0eSBwcmVmaXguXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQHByb3RlY3RlZFxuICovXG5leHBvcnQgY29uc3QgVUlEX1BST1BFUlRZID0gJ2NvcmVfJyArICgoTWF0aC5yYW5kb20oKSAqIDFlOSkgPj4+IDApO1xuXG4vKipcbiAqIFdoZW4gZGVmaW5pbmcgYSBjbGFzcyBGb28gd2l0aCBhbiBhYnN0cmFjdCBtZXRob2QgYmFyKCksIHlvdSBjYW4gZG86XG4gKiBGb28ucHJvdG90eXBlLmJhciA9IGFic3RyYWN0TWV0aG9kXG4gKlxuICogTm93IGlmIGEgc3ViY2xhc3Mgb2YgRm9vIGZhaWxzIHRvIG92ZXJyaWRlIGJhcigpLCBhbiBlcnJvciB3aWxsIGJlIHRocm93blxuICogd2hlbiBiYXIoKSBpcyBpbnZva2VkLlxuICpcbiAqIEB0eXBlIHshRnVuY3Rpb259XG4gKiBAdGhyb3dzIHtFcnJvcn0gd2hlbiBpbnZva2VkIHRvIGluZGljYXRlIHRoZSBtZXRob2Qgc2hvdWxkIGJlIG92ZXJyaWRkZW4uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhYnN0cmFjdE1ldGhvZCgpIHtcblx0dGhyb3cgRXJyb3IoJ1VuaW1wbGVtZW50ZWQgYWJzdHJhY3QgbWV0aG9kJyk7XG59XG5cbi8qKlxuICogTG9vcHMgY29uc3RydWN0b3Igc3VwZXIgY2xhc3NlcyBjb2xsZWN0aW5nIGl0cyBwcm9wZXJ0aWVzIHZhbHVlcy4gSWZcbiAqIHByb3BlcnR5IGlzIG5vdCBhdmFpbGFibGUgb24gdGhlIHN1cGVyIGNsYXNzIGB1bmRlZmluZWRgIHdpbGwgYmVcbiAqIGNvbGxlY3RlZCBhcyB2YWx1ZSBmb3IgdGhlIGNsYXNzIGhpZXJhcmNoeSBwb3NpdGlvbi5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9uKCl9IGNvbnN0cnVjdG9yIENsYXNzIGNvbnN0cnVjdG9yLlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5TmFtZSBQcm9wZXJ0eSBuYW1lIHRvIGJlIGNvbGxlY3RlZC5cbiAqIEByZXR1cm4ge0FycmF5LjwqPn0gQXJyYXkgb2YgY29sbGVjdGVkIHZhbHVlcy5cbiAqIFRPRE8oKik6IFJldGhpbmsgc3VwZXJjbGFzcyBsb29wLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29sbGVjdFN1cGVyQ2xhc3Nlc1Byb3BlcnR5KGNvbnN0cnVjdG9yLCBwcm9wZXJ0eU5hbWUpIHtcblx0dmFyIHByb3BlcnR5VmFsdWVzID0gW2NvbnN0cnVjdG9yW3Byb3BlcnR5TmFtZV1dO1xuXHR3aGlsZSAoY29uc3RydWN0b3IuX19wcm90b19fICYmICFjb25zdHJ1Y3Rvci5fX3Byb3RvX18uaXNQcm90b3R5cGVPZihGdW5jdGlvbikpIHtcblx0XHRjb25zdHJ1Y3RvciA9IGNvbnN0cnVjdG9yLl9fcHJvdG9fXztcblx0XHRwcm9wZXJ0eVZhbHVlcy5wdXNoKGNvbnN0cnVjdG9yW3Byb3BlcnR5TmFtZV0pO1xuXHR9XG5cdHJldHVybiBwcm9wZXJ0eVZhbHVlcztcbn1cblxuLyoqXG4gKiBEaXNhYmxlcyBNZXRhbC5qcydzIGNvbXBhdGliaWxpdHkgbW9kZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpc2FibGVDb21wYXRpYmlsaXR5TW9kZSgpIHtcblx0Y29tcGF0aWJpbGl0eU1vZGVEYXRhXyA9IG51bGw7XG59XG5cbi8qKlxuICogRW5hYmxlcyBNZXRhbC5qcydzIGNvbXBhdGliaWxpdHkgbW9kZSB3aXRoIHRoZSBmb2xsb3dpbmcgZmVhdHVyZXMgZnJvbSByY1xuICogYW5kIDEueCB2ZXJzaW9uczpcbiAqICAgICAtIFVzaW5nIFwia2V5XCIgdG8gcmVmZXJlbmNlIGNvbXBvbmVudCBpbnN0YW5jZXMuIEluIHRoZSBjdXJyZW50IHZlcnNpb25cbiAqICAgICAgIHRoaXMgc2hvdWxkIGJlIGRvbmUgdmlhIFwicmVmXCIgaW5zdGVhZC4gVGhpcyBhbGxvd3Mgb2xkIGNvZGUgc3RpbGxcbiAqICAgICAgIHVzaW5nIFwia2V5XCIgdG8ga2VlcCB3b3JraW5nIGxpa2UgYmVmb3JlLiBOT1RFOiB0aGlzIG1heSBjYXVzZVxuICogICAgICAgcHJvYmxlbXMsIHNpbmNlIFwia2V5XCIgaXMgbWVhbnQgdG8gYmUgdXNlZCBkaWZmZXJlbnRseS4gT25seSB1c2UgdGhpc1xuICogICAgICAgaWYgaXQncyBub3QgcG9zc2libGUgdG8gdXBncmFkZSB0aGUgY29kZSB0byB1c2UgXCJyZWZcIiBpbnN0ZWFkLlxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRfZGF0YSBPcHRpb25hbCBvYmplY3Qgd2l0aCBkYXRhIHRvIHNwZWNpZnkgbW9yZVxuICogICAgIGRldGFpbHMsIHN1Y2ggYXM6XG4gKiAgICAgICAgIC0gcmVuZGVyZXJzIHtBcnJheX0gdGhlIHRlbXBsYXRlIHJlbmRlcmVycyB0aGF0IHNob3VsZCBiZSBpblxuICogICAgICAgICAgIGNvbXBhdGliaWxpdHkgbW9kZSwgZWl0aGVyIHRoZWlyIGNvbnN0cnVjdG9ycyBvciBzdHJpbmdzXG4gKiAgICAgICAgICAgcmVwcmVzZW50aW5nIHRoZW0gKGUuZy4gJ3NveScgb3IgJ2pzeCcpLiBCeSBkZWZhdWx0LCBhbGwgdGhlIG9uZXNcbiAqICAgICAgICAgICB0aGF0IGV4dGVuZCBmcm9tIEluY3JlbWVudGFsRG9tUmVuZGVyZXIuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5hYmxlQ29tcGF0aWJpbGl0eU1vZGUob3B0X2RhdGEgPSB7fSkge1xuXHRjb21wYXRpYmlsaXR5TW9kZURhdGFfID0gb3B0X2RhdGE7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZGF0YSB1c2VkIGZvciBjb21wYXRpYmlsaXR5IG1vZGUsIG9yIG5vdGhpbmcgaWYgaXQgaGFzbid0IGJlZW5cbiAqIGVuYWJsZWQuXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb21wYXRpYmlsaXR5TW9kZURhdGEoKSB7XG5cdC8vIENvbXBhdGliaWxpdHkgbW9kZSBjYW4gYmUgc2V0IHZpYSB0aGUgX19NRVRBTF9DT01QQVRJQklMSVRZX18gZ2xvYmFsIHZhci5cblx0aWYgKCFjb21wYXRpYmlsaXR5TW9kZURhdGFfKSB7XG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5fX01FVEFMX0NPTVBBVElCSUxJVFlfXykge1xuXHRcdFx0ZW5hYmxlQ29tcGF0aWJpbGl0eU1vZGUod2luZG93Ll9fTUVUQUxfQ09NUEFUSUJJTElUWV9fKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGNvbXBhdGliaWxpdHlNb2RlRGF0YV87XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbmFtZSBvZiB0aGUgZ2l2ZW4gZnVuY3Rpb24uIElmIHRoZSBjdXJyZW50IGJyb3dzZXIgZG9lc24ndFxuICogc3VwcG9ydCB0aGUgYG5hbWVgIHByb3BlcnR5LCB0aGlzIHdpbGwgY2FsY3VsYXRlIGl0IGZyb20gdGhlIGZ1bmN0aW9uJ3NcbiAqIGNvbnRlbnQgc3RyaW5nLlxuICogQHBhcmFtIHshZnVuY3Rpb24oKX0gZm5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEZ1bmN0aW9uTmFtZShmbikge1xuXHRpZiAoIWZuLm5hbWUpIHtcblx0XHR2YXIgc3RyID0gZm4udG9TdHJpbmcoKTtcblx0XHRmbi5uYW1lID0gc3RyLnN1YnN0cmluZyg5LCBzdHIuaW5kZXhPZignKCcpKTtcblx0fVxuXHRyZXR1cm4gZm4ubmFtZTtcbn1cblxuLyoqXG4gKiBHZXRzIGFuIHVuaXF1ZSBpZC4gSWYgYG9wdF9vYmplY3RgIGFyZ3VtZW50IGlzIHBhc3NlZCwgdGhlIG9iamVjdCBpc1xuICogbXV0YXRlZCB3aXRoIGFuIHVuaXF1ZSBpZC4gQ29uc2VjdXRpdmUgY2FsbHMgd2l0aCB0aGUgc2FtZSBvYmplY3RcbiAqIHJlZmVyZW5jZSB3b24ndCBtdXRhdGUgdGhlIG9iamVjdCBhZ2FpbiwgaW5zdGVhZCB0aGUgY3VycmVudCBvYmplY3QgdWlkXG4gKiByZXR1cm5zLiBTZWUge0BsaW5rIFVJRF9QUk9QRVJUWX0uXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdF9vYmplY3QgT3B0aW9uYWwgb2JqZWN0IHRvIGJlIG11dGF0ZWQgd2l0aCB0aGUgdWlkLiBJZlxuICogICAgIG5vdCBzcGVjaWZpZWQgdGhpcyBtZXRob2Qgb25seSByZXR1cm5zIHRoZSB1aWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfbm9Jbmhlcml0YW5jZSBPcHRpb25hbCBmbGFnIGluZGljYXRpbmcgaWYgdGhpc1xuICogICAgIG9iamVjdCdzIHVpZCBwcm9wZXJ0eSBjYW4gYmUgaW5oZXJpdGVkIGZyb20gcGFyZW50cyBvciBub3QuXG4gKiBAdGhyb3dzIHtFcnJvcn0gd2hlbiBpbnZva2VkIHRvIGluZGljYXRlIHRoZSBtZXRob2Qgc2hvdWxkIGJlIG92ZXJyaWRkZW4uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRVaWQob3B0X29iamVjdCwgb3B0X25vSW5oZXJpdGFuY2UpIHtcblx0aWYgKG9wdF9vYmplY3QpIHtcblx0XHR2YXIgaWQgPSBvcHRfb2JqZWN0W1VJRF9QUk9QRVJUWV07XG5cdFx0aWYgKG9wdF9ub0luaGVyaXRhbmNlICYmICFvcHRfb2JqZWN0Lmhhc093blByb3BlcnR5KFVJRF9QUk9QRVJUWSkpIHtcblx0XHRcdGlkID0gbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIGlkIHx8IChvcHRfb2JqZWN0W1VJRF9QUk9QRVJUWV0gPSB1bmlxdWVJZENvdW50ZXJfKyspO1xuXHR9XG5cdHJldHVybiB1bmlxdWVJZENvdW50ZXJfKys7XG59XG5cbi8qKlxuICogVGhlIGlkZW50aXR5IGZ1bmN0aW9uLiBSZXR1cm5zIGl0cyBmaXJzdCBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kj19IG9wdF9yZXR1cm5WYWx1ZSBUaGUgc2luZ2xlIHZhbHVlIHRoYXQgd2lsbCBiZSByZXR1cm5lZC5cbiAqIEByZXR1cm4gez99IFRoZSBmaXJzdCBhcmd1bWVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlkZW50aXR5RnVuY3Rpb24ob3B0X3JldHVyblZhbHVlKSB7XG5cdHJldHVybiBvcHRfcmV0dXJuVmFsdWU7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYSBib29sZWFuLlxuICogQHBhcmFtIHs/fSB2YWwgVmFyaWFibGUgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdmFyaWFibGUgaXMgYm9vbGVhbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQm9vbGVhbih2YWwpIHtcblx0cmV0dXJuIHR5cGVvZiB2YWwgPT09ICdib29sZWFuJztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBub3QgdW5kZWZpbmVkLlxuICogQHBhcmFtIHs/fSB2YWwgVmFyaWFibGUgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdmFyaWFibGUgaXMgZGVmaW5lZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRGVmKHZhbCkge1xuXHRyZXR1cm4gdmFsICE9PSB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIG5vdCB1bmRlZmluZWQgb3IgbnVsbC5cbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNEZWZBbmROb3ROdWxsKHZhbCkge1xuXHRyZXR1cm4gaXNEZWYodmFsKSAmJiAhaXNOdWxsKHZhbCk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIGEgZG9jdW1lbnQuXG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRG9jdW1lbnQodmFsKSB7XG5cdHJldHVybiB2YWwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgdmFsLm5vZGVUeXBlID09PSA5O1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBhIGRvbSBlbGVtZW50LlxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0VsZW1lbnQodmFsKSB7XG5cdHJldHVybiB2YWwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgdmFsLm5vZGVUeXBlID09PSAxO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGEgZnVuY3Rpb24uXG4gKiBAcGFyYW0gez99IHZhbCBWYXJpYWJsZSB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB2YXJpYWJsZSBpcyBhIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNGdW5jdGlvbih2YWwpIHtcblx0cmV0dXJuIHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIG51bGwuXG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTnVsbCh2YWwpIHtcblx0cmV0dXJuIHZhbCA9PT0gbnVsbDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEBwYXJhbSB7P30gdmFsIFZhcmlhYmxlIHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHZhcmlhYmxlIGlzIGEgbnVtYmVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNOdW1iZXIodmFsKSB7XG5cdHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgYSB3aW5kb3cuXG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzV2luZG93KHZhbCkge1xuXHRyZXR1cm4gdmFsICE9PSBudWxsICYmIHZhbCA9PT0gdmFsLndpbmRvdztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhbiBvYmplY3QuIFRoaXMgaW5jbHVkZXMgYXJyYXlzXG4gKiBhbmQgZnVuY3Rpb25zLlxuICogQHBhcmFtIHs/fSB2YWwgVmFyaWFibGUgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdmFyaWFibGUgaXMgYW4gb2JqZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNPYmplY3QodmFsKSB7XG5cdHZhciB0eXBlID0gdHlwZW9mIHZhbDtcblx0cmV0dXJuIHR5cGUgPT09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbCB8fCB0eXBlID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBhIFByb21pc2UuXG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzUHJvbWlzZSh2YWwpIHtcblx0cmV0dXJuIHZhbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsLnRoZW4gPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIGEgc3RyaW5nLlxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1N0cmluZyh2YWwpIHtcblx0cmV0dXJuIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnIHx8IHZhbCBpbnN0YW5jZW9mIFN0cmluZztcbn1cblxuLyoqXG4gKiBNZXJnZXMgdGhlIHZhbHVlcyBvZiBhIGV4cG9ydCBmdW5jdGlvbiBwcm9wZXJ0eSBhIGNsYXNzIHdpdGggdGhlIHZhbHVlcyBvZiB0aGF0XG4gKiBwcm9wZXJ0eSBmb3IgYWxsIGl0cyBzdXBlciBjbGFzc2VzLCBhbmQgc3RvcmVzIGl0IGFzIGEgbmV3IHN0YXRpY1xuICogcHJvcGVydHkgb2YgdGhhdCBjbGFzcy4gSWYgdGhlIGV4cG9ydCBmdW5jdGlvbiBwcm9wZXJ0eSBhbHJlYWR5IGV4aXN0ZWQsIGl0IHdvbid0XG4gKiBiZSByZWNhbGN1bGF0ZWQuXG4gKiBAcGFyYW0geyFmdW5jdGlvbigpfSBjb25zdHJ1Y3RvciBDbGFzcyBjb25zdHJ1Y3Rvci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eU5hbWUgUHJvcGVydHkgbmFtZSB0byBiZSBjb2xsZWN0ZWQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosICopOio9fSBvcHRfbWVyZ2VGbiBGdW5jdGlvbiB0aGF0IHJlY2VpdmVzIGFuIGFycmF5IGZpbGxlZFxuICogICB3aXRoIHRoZSB2YWx1ZXMgb2YgdGhlIHByb3BlcnR5IGZvciB0aGUgY3VycmVudCBjbGFzcyBhbmQgYWxsIGl0cyBzdXBlciBjbGFzc2VzLlxuICogICBTaG91bGQgcmV0dXJuIHRoZSBtZXJnZWQgdmFsdWUgdG8gYmUgc3RvcmVkIG9uIHRoZSBjdXJyZW50IGNsYXNzLlxuICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIG1lcmdlIGhhcHBlbnMsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlU3VwZXJDbGFzc2VzUHJvcGVydHkoY29uc3RydWN0b3IsIHByb3BlcnR5TmFtZSwgb3B0X21lcmdlRm4pIHtcblx0dmFyIG1lcmdlZE5hbWUgPSBwcm9wZXJ0eU5hbWUgKyAnX01FUkdFRCc7XG5cdGlmIChjb25zdHJ1Y3Rvci5oYXNPd25Qcm9wZXJ0eShtZXJnZWROYW1lKSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHZhciBtZXJnZWQgPSBjb2xsZWN0U3VwZXJDbGFzc2VzUHJvcGVydHkoY29uc3RydWN0b3IsIHByb3BlcnR5TmFtZSk7XG5cdGlmIChvcHRfbWVyZ2VGbikge1xuXHRcdG1lcmdlZCA9IG9wdF9tZXJnZUZuKG1lcmdlZCk7XG5cdH1cblx0Y29uc3RydWN0b3JbbWVyZ2VkTmFtZV0gPSBtZXJnZWQ7XG5cdHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIE51bGwgZnVuY3Rpb24gdXNlZCBmb3IgZGVmYXVsdCB2YWx1ZXMgb2YgY2FsbGJhY2tzLCBldGMuXG4gKiBAcmV0dXJuIHt2b2lkfSBOb3RoaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbnVsbEZ1bmN0aW9uKCkge31cbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gVGhpcyBmaWxlIGV4aXN0cyBqdXN0IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgbWFraW5nIHN1cmUgdGhhdCBvbGRcbi8vIGRlZmF1bHQgaW1wb3J0cyBmb3IgdGhpcyBmaWxlIHN0aWxsIHdvcmsuIEl0J3MgYmVzdCB0byB1c2UgdGhlIG5hbWVkIGV4cG9ydHNcbi8vIGZvciBlYWNoIGZ1bmN0aW9uIGluc3RlYWQgdGhvdWdoLCBzaW5jZSB0aGF0IGFsbG93cyBidW5kbGVycyBsaWtlIFJvbGx1cCB0b1xuLy8gcmVkdWNlIHRoZSBidW5kbGUgc2l6ZSBieSByZW1vdmluZyB1bnVzZWQgY29kZS5cbmltcG9ydCAqIGFzIGNvcmUgZnJvbSAnLi9jb3JlTmFtZWQnO1xuXG5leHBvcnQgZGVmYXVsdCBjb3JlO1xuZXhwb3J0IHsgY29yZSB9O1xuZXhwb3J0ICogZnJvbSAnLi9jb3JlTmFtZWQnO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgeyBpc0RlZiB9IGZyb20gJy4uL2NvcmUnO1xuXG5jbGFzcyBhcnJheSB7XG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgdGhlIGdpdmVuIGFycmF5cyBoYXZlIHRoZSBzYW1lIGNvbnRlbnQuXG5cdCAqIEBwYXJhbSB7IUFycmF5PCo+fSBhcnIxXG5cdCAqIEBwYXJhbSB7IUFycmF5PCo+fSBhcnIyXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqL1xuXHRzdGF0aWMgZXF1YWwoYXJyMSwgYXJyMikge1xuXHRcdGlmIChhcnIxLmxlbmd0aCAhPT0gYXJyMi5sZW5ndGgpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnIxLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAoYXJyMVtpXSAhPT0gYXJyMltpXSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGZpcnN0IHZhbHVlIGluIHRoZSBnaXZlbiBhcnJheSB0aGF0IGlzbid0IHVuZGVmaW5lZC5cblx0ICogQHBhcmFtIHshQXJyYXl9IGFyclxuXHQgKiBAcmV0dXJuIHsqfVxuXHQgKi9cblx0c3RhdGljIGZpcnN0RGVmaW5lZFZhbHVlKGFycikge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAoYXJyW2ldICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0cmV0dXJuIGFycltpXTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogVHJhbnNmb3JtcyB0aGUgaW5wdXQgbmVzdGVkIGFycmF5IHRvIGJlY29tZSBmbGF0LlxuXHQgKiBAcGFyYW0ge0FycmF5LjwqfEFycmF5LjwqPj59IGFyciBOZXN0ZWQgYXJyYXkgdG8gZmxhdHRlbi5cblx0ICogQHBhcmFtIHtBcnJheS48Kj59IG9wdF9vdXRwdXQgT3B0aW9uYWwgb3V0cHV0IGFycmF5LlxuXHQgKiBAcmV0dXJuIHtBcnJheS48Kj59IEZsYXQgYXJyYXkuXG5cdCAqL1xuXHRzdGF0aWMgZmxhdHRlbihhcnIsIG9wdF9vdXRwdXQpIHtcblx0XHR2YXIgb3V0cHV0ID0gb3B0X291dHB1dCB8fCBbXTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoYXJyW2ldKSkge1xuXHRcdFx0XHRhcnJheS5mbGF0dGVuKGFycltpXSwgb3V0cHV0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKGFycltpXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlcyB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBhIHBhcnRpY3VsYXIgdmFsdWUgZnJvbSBhbiBhcnJheS5cblx0ICogQHBhcmFtIHtBcnJheS48VD59IGFyciBBcnJheSBmcm9tIHdoaWNoIHRvIHJlbW92ZSB2YWx1ZS5cblx0ICogQHBhcmFtIHtUfSBvYmogT2JqZWN0IHRvIHJlbW92ZS5cblx0ICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhbiBlbGVtZW50IHdhcyByZW1vdmVkLlxuXHQgKiBAdGVtcGxhdGUgVFxuXHQgKi9cblx0c3RhdGljIHJlbW92ZShhcnIsIG9iaikge1xuXHRcdHZhciBpID0gYXJyLmluZGV4T2Yob2JqKTtcblx0XHR2YXIgcnY7XG5cdFx0aWYgKCAocnYgPSBpID49IDApICkge1xuXHRcdFx0YXJyYXkucmVtb3ZlQXQoYXJyLCBpKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJ2O1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgZnJvbSBhbiBhcnJheSB0aGUgZWxlbWVudCBhdCBpbmRleCBpXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFyciBBcnJheSBvciBhcnJheSBsaWtlIG9iamVjdCBmcm9tIHdoaWNoIHRvIHJlbW92ZSB2YWx1ZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIGluZGV4IHRvIHJlbW92ZS5cblx0ICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhbiBlbGVtZW50IHdhcyByZW1vdmVkLlxuXHQgKi9cblx0c3RhdGljIHJlbW92ZUF0KGFyciwgaSkge1xuXHRcdHJldHVybiBBcnJheS5wcm90b3R5cGUuc3BsaWNlLmNhbGwoYXJyLCBpLCAxKS5sZW5ndGggPT09IDE7XG5cdH1cblxuXHQvKipcblx0ICogU2xpY2VzIHRoZSBnaXZlbiBhcnJheSwganVzdCBsaWtlIEFycmF5LnByb3RvdHlwZS5zbGljZSwgYnV0IHRoaXNcblx0ICogaXMgZmFzdGVyIGFuZCB3b3JraW5nIG9uIGFsbCBhcnJheS1saWtlIG9iamVjdHMgKGxpa2UgYXJndW1lbnRzKS5cblx0ICogQHBhcmFtIHshT2JqZWN0fSBhcnIgQXJyYXktbGlrZSBvYmplY3QgdG8gc2xpY2UuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgaW5kZXggdGhhdCBzaG91bGQgc3RhcnQgdGhlIHNsaWNlLlxuXHQgKiBAcGFyYW0ge251bWJlcj19IG9wdF9lbmQgVGhlIGluZGV4IHdoZXJlIHRoZSBzbGljZSBzaG91bGQgZW5kLCBub3Rcblx0ICogICBpbmNsdWRlZCBpbiB0aGUgZmluYWwgYXJyYXkuIElmIG5vdCBnaXZlbiwgYWxsIGVsZW1lbnRzIGFmdGVyIHRoZVxuXHQgKiAgIHN0YXJ0IGluZGV4IHdpbGwgYmUgaW5jbHVkZWQuXG5cdCAqIEByZXR1cm4geyFBcnJheX1cblx0ICovXG5cdHN0YXRpYyBzbGljZShhcnIsIHN0YXJ0LCBvcHRfZW5kKSB7XG5cdFx0dmFyIHNsaWNlZCA9IFtdO1xuXHRcdHZhciBlbmQgPSBpc0RlZihvcHRfZW5kKSA/IG9wdF9lbmQgOiBhcnIubGVuZ3RoO1xuXHRcdGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG5cdFx0XHRzbGljZWQucHVzaChhcnJbaV0pO1xuXHRcdH1cblx0XHRyZXR1cm4gc2xpY2VkO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFycmF5O1xuIiwiLyohXG4gKiBQb2x5ZmlsbCBmcm9tIEdvb2dsZSdzIENsb3N1cmUgTGlicmFyeS5cbiAqIENvcHlyaWdodCAyMDEzIFRoZSBDbG9zdXJlIExpYnJhcnkgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBhc3luYyA9IHt9O1xuXG5cbi8qKlxuICogVGhyb3cgYW4gaXRlbSB3aXRob3V0IGludGVycnVwdGluZyB0aGUgY3VycmVudCBleGVjdXRpb24gY29udGV4dC4gIEZvclxuICogZXhhbXBsZSwgaWYgcHJvY2Vzc2luZyBhIGdyb3VwIG9mIGl0ZW1zIGluIGEgbG9vcCwgc29tZXRpbWVzIGl0IGlzIHVzZWZ1bFxuICogdG8gcmVwb3J0IGFuIGVycm9yIHdoaWxlIHN0aWxsIGFsbG93aW5nIHRoZSByZXN0IG9mIHRoZSBiYXRjaCB0byBiZVxuICogcHJvY2Vzc2VkLlxuICogQHBhcmFtIHsqfSBleGNlcHRpb25cbiAqL1xuYXN5bmMudGhyb3dFeGNlcHRpb24gPSBmdW5jdGlvbihleGNlcHRpb24pIHtcblx0Ly8gRWFjaCB0aHJvdyBuZWVkcyB0byBiZSBpbiBpdHMgb3duIGNvbnRleHQuXG5cdGFzeW5jLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuXHRcdHRocm93IGV4Y2VwdGlvbjtcblx0fSk7XG59O1xuXG5cbi8qKlxuICogRmlyZXMgdGhlIHByb3ZpZGVkIGNhbGxiYWNrIGp1c3QgYmVmb3JlIHRoZSBjdXJyZW50IGNhbGxzdGFjayB1bndpbmRzLCBvciBhc1xuICogc29vbiBhcyBwb3NzaWJsZSBhZnRlciB0aGUgY3VycmVudCBKUyBleGVjdXRpb24gY29udGV4dC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24odGhpczpUSElTKX0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7VEhJUz19IG9wdF9jb250ZXh0IE9iamVjdCB0byB1c2UgYXMgdGhlIFwidGhpcyB2YWx1ZVwiIHdoZW4gY2FsbGluZ1xuICogICAgIHRoZSBwcm92aWRlZCBmdW5jdGlvbi5cbiAqIEB0ZW1wbGF0ZSBUSElTXG4gKi9cbmFzeW5jLnJ1biA9IGZ1bmN0aW9uKGNhbGxiYWNrLCBvcHRfY29udGV4dCkge1xuXHRpZiAoIWFzeW5jLnJ1bi53b3JrUXVldWVTY2hlZHVsZWRfKSB7XG5cdFx0Ly8gTm90aGluZyBpcyBjdXJyZW50bHkgc2NoZWR1bGVkLCBzY2hlZHVsZSBpdCBub3cuXG5cdFx0YXN5bmMubmV4dFRpY2soYXN5bmMucnVuLnByb2Nlc3NXb3JrUXVldWUpO1xuXHRcdGFzeW5jLnJ1bi53b3JrUXVldWVTY2hlZHVsZWRfID0gdHJ1ZTtcblx0fVxuXG5cdGFzeW5jLnJ1bi53b3JrUXVldWVfLnB1c2goXG5cdFx0bmV3IGFzeW5jLnJ1bi5Xb3JrSXRlbV8oY2FsbGJhY2ssIG9wdF9jb250ZXh0KSk7XG59O1xuXG5cbi8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gKi9cbmFzeW5jLnJ1bi53b3JrUXVldWVTY2hlZHVsZWRfID0gZmFsc2U7XG5cblxuLyoqIEBwcml2YXRlIHshQXJyYXkuPCFhc3luYy5ydW4uV29ya0l0ZW1fPn0gKi9cbmFzeW5jLnJ1bi53b3JrUXVldWVfID0gW107XG5cbi8qKlxuICogUnVuIGFueSBwZW5kaW5nIGFzeW5jLnJ1biB3b3JrIGl0ZW1zLiBUaGlzIGZ1bmN0aW9uIGlzIG5vdCBpbnRlbmRlZFxuICogZm9yIGdlbmVyYWwgdXNlLCBidXQgZm9yIHVzZSBieSBlbnRyeSBwb2ludCBoYW5kbGVycyB0byBydW4gaXRlbXMgYWhlYWQgb2ZcbiAqIGFzeW5jLm5leHRUaWNrLlxuICovXG5hc3luYy5ydW4ucHJvY2Vzc1dvcmtRdWV1ZSA9IGZ1bmN0aW9uKCkge1xuXHQvLyBOT1RFOiBhZGRpdGlvbmFsIHdvcmsgcXVldWUgaXRlbXMgbWF5IGJlIHB1c2hlZCB3aGlsZSBwcm9jZXNzaW5nLlxuXHR3aGlsZSAoYXN5bmMucnVuLndvcmtRdWV1ZV8ubGVuZ3RoKSB7XG5cdFx0Ly8gRG9uJ3QgbGV0IHRoZSB3b3JrIHF1ZXVlIGdyb3cgaW5kZWZpbml0ZWx5LlxuXHRcdHZhciB3b3JrSXRlbXMgPSBhc3luYy5ydW4ud29ya1F1ZXVlXztcblx0XHRhc3luYy5ydW4ud29ya1F1ZXVlXyA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgd29ya0l0ZW1zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgd29ya0l0ZW0gPSB3b3JrSXRlbXNbaV07XG5cdFx0XHR0cnkge1xuXHRcdFx0XHR3b3JrSXRlbS5mbi5jYWxsKHdvcmtJdGVtLnNjb3BlKTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0YXN5bmMudGhyb3dFeGNlcHRpb24oZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gVGhlcmUgYXJlIG5vIG1vcmUgd29yayBpdGVtcywgcmVzZXQgdGhlIHdvcmsgcXVldWUuXG5cdGFzeW5jLnJ1bi53b3JrUXVldWVTY2hlZHVsZWRfID0gZmFsc2U7XG59O1xuXG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZmluYWxcbiAqIEBzdHJ1Y3RcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbigpfSBmblxuICogQHBhcmFtIHtPYmplY3R8bnVsbHx1bmRlZmluZWR9IHNjb3BlXG4gKi9cbmFzeW5jLnJ1bi5Xb3JrSXRlbV8gPSBmdW5jdGlvbihmbiwgc2NvcGUpIHtcblx0LyoqIEBjb25zdCAqL1xuXHR0aGlzLmZuID0gZm47XG5cdC8qKiBAY29uc3QgKi9cblx0dGhpcy5zY29wZSA9IHNjb3BlO1xufTtcblxuXG4vKipcbiAqIEZpcmVzIHRoZSBwcm92aWRlZCBjYWxsYmFja3MgYXMgc29vbiBhcyBwb3NzaWJsZSBhZnRlciB0aGUgY3VycmVudCBKU1xuICogZXhlY3V0aW9uIGNvbnRleHQuIHNldFRpbWVvdXQo4oCmLCAwKSBhbHdheXMgdGFrZXMgYXQgbGVhc3QgNW1zIGZvciBsZWdhY3lcbiAqIHJlYXNvbnMuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6U0NPUEUpfSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvbiB0byBmaXJlIGFzIHNvb24gYXNcbiAqICAgICBwb3NzaWJsZS5cbiAqIEBwYXJhbSB7U0NPUEU9fSBvcHRfY29udGV4dCBPYmplY3QgaW4gd2hvc2Ugc2NvcGUgdG8gY2FsbCB0aGUgbGlzdGVuZXIuXG4gKiBAdGVtcGxhdGUgU0NPUEVcbiAqL1xuYXN5bmMubmV4dFRpY2sgPSBmdW5jdGlvbihjYWxsYmFjaywgb3B0X2NvbnRleHQpIHtcblx0dmFyIGNiID0gY2FsbGJhY2s7XG5cdGlmIChvcHRfY29udGV4dCkge1xuXHRcdGNiID0gY2FsbGJhY2suYmluZChvcHRfY29udGV4dCk7XG5cdH1cblx0Y2IgPSBhc3luYy5uZXh0VGljay53cmFwQ2FsbGJhY2tfKGNiKTtcblx0Ly8gSW50cm9kdWNlZCBhbmQgY3VycmVudGx5IG9ubHkgc3VwcG9ydGVkIGJ5IElFMTAuXG5cdC8vIFZlcmlmeSBpZiB2YXJpYWJsZSBpcyBkZWZpbmVkIG9uIHRoZSBjdXJyZW50IHJ1bnRpbWUgKGkuZS4sIG5vZGUsIGJyb3dzZXIpLlxuXHQvLyBDYW4ndCB1c2UgdHlwZW9mIGVuY2xvc2VkIGluIGEgZnVuY3Rpb24gKHN1Y2ggYXMgY29yZS5pc0Z1bmN0aW9uKSBvciBhblxuXHQvLyBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24gd2hlbiB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGFuIGVudmlyb25tZW50XG5cdC8vIHdoZXJlIHRoZSB2YXJpYWJsZSBpcyB1bmRlZmluZWQuXG5cdGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0c2V0SW1tZWRpYXRlKGNiKTtcblx0XHRyZXR1cm47XG5cdH1cblx0Ly8gTG9vayBmb3IgYW5kIGNhY2hlIHRoZSBjdXN0b20gZmFsbGJhY2sgdmVyc2lvbiBvZiBzZXRJbW1lZGlhdGUuXG5cdGlmICghYXN5bmMubmV4dFRpY2suc2V0SW1tZWRpYXRlXykge1xuXHRcdGFzeW5jLm5leHRUaWNrLnNldEltbWVkaWF0ZV8gPSBhc3luYy5uZXh0VGljay5nZXRTZXRJbW1lZGlhdGVFbXVsYXRvcl8oKTtcblx0fVxuXHRhc3luYy5uZXh0VGljay5zZXRJbW1lZGlhdGVfKGNiKTtcbn07XG5cblxuLyoqXG4gKiBDYWNoZSBmb3IgdGhlIHNldEltbWVkaWF0ZSBpbXBsZW1lbnRhdGlvbi5cbiAqIEB0eXBlIHtmdW5jdGlvbihmdW5jdGlvbigpKX1cbiAqIEBwcml2YXRlXG4gKi9cbmFzeW5jLm5leHRUaWNrLnNldEltbWVkaWF0ZV8gPSBudWxsO1xuXG5cbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgYmVzdCBwb3NzaWJsZSBpbXBsZW1lbnRhdGlvbiB0byBydW4gYSBmdW5jdGlvbiBhcyBzb29uIGFzXG4gKiB0aGUgSlMgZXZlbnQgbG9vcCBpcyBpZGxlLlxuICogQHJldHVybiB7ZnVuY3Rpb24oZnVuY3Rpb24oKSl9IFRoZSBcInNldEltbWVkaWF0ZVwiIGltcGxlbWVudGF0aW9uLlxuICogQHByaXZhdGVcbiAqL1xuYXN5bmMubmV4dFRpY2suZ2V0U2V0SW1tZWRpYXRlRW11bGF0b3JfID0gZnVuY3Rpb24oKSB7XG5cdC8vIENyZWF0ZSBhIHByaXZhdGUgbWVzc2FnZSBjaGFubmVsIGFuZCB1c2UgaXQgdG8gcG9zdE1lc3NhZ2UgZW1wdHkgbWVzc2FnZXNcblx0Ly8gdG8gb3Vyc2VsdmVzLlxuXHR2YXIgQ2hhbm5lbDtcblxuXHQvLyBWZXJpZnkgaWYgdmFyaWFibGUgaXMgZGVmaW5lZCBvbiB0aGUgY3VycmVudCBydW50aW1lIChpLmUuLCBub2RlLCBicm93c2VyKS5cblx0Ly8gQ2FuJ3QgdXNlIHR5cGVvZiBlbmNsb3NlZCBpbiBhIGZ1bmN0aW9uIChzdWNoIGFzIGNvcmUuaXNGdW5jdGlvbikgb3IgYW5cblx0Ly8gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duIHdoZW4gdGhlIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBhbiBlbnZpcm9ubWVudFxuXHQvLyB3aGVyZSB0aGUgdmFyaWFibGUgaXMgdW5kZWZpbmVkLlxuXHRpZiAodHlwZW9mIE1lc3NhZ2VDaGFubmVsID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0Q2hhbm5lbCA9IE1lc3NhZ2VDaGFubmVsO1xuXHR9XG5cblx0Ly8gSWYgTWVzc2FnZUNoYW5uZWwgaXMgbm90IGF2YWlsYWJsZSBhbmQgd2UgYXJlIGluIGEgYnJvd3NlciwgaW1wbGVtZW50XG5cdC8vIGFuIGlmcmFtZSBiYXNlZCBwb2x5ZmlsbCBpbiBicm93c2VycyB0aGF0IGhhdmUgcG9zdE1lc3NhZ2UgYW5kXG5cdC8vIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIuIFRoZSBsYXR0ZXIgZXhjbHVkZXMgSUU4IGJlY2F1c2UgaXQgaGFzIGFcblx0Ly8gc3luY2hyb25vdXMgcG9zdE1lc3NhZ2UgaW1wbGVtZW50YXRpb24uXG5cdGlmICh0eXBlb2YgQ2hhbm5lbCA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcblx0XHR3aW5kb3cucG9zdE1lc3NhZ2UgJiYgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIpIHtcblx0XHQvKiogQGNvbnN0cnVjdG9yICovXG5cdFx0Q2hhbm5lbCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gTWFrZSBhbiBlbXB0eSwgaW52aXNpYmxlIGlmcmFtZS5cblx0XHRcdHZhciBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcblx0XHRcdGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXHRcdFx0aWZyYW1lLnNyYyA9ICcnO1xuXHRcdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKGlmcmFtZSk7XG5cdFx0XHR2YXIgd2luID0gaWZyYW1lLmNvbnRlbnRXaW5kb3c7XG5cdFx0XHR2YXIgZG9jID0gd2luLmRvY3VtZW50O1xuXHRcdFx0ZG9jLm9wZW4oKTtcblx0XHRcdGRvYy53cml0ZSgnJyk7XG5cdFx0XHRkb2MuY2xvc2UoKTtcblx0XHRcdHZhciBtZXNzYWdlID0gJ2NhbGxJbW1lZGlhdGUnICsgTWF0aC5yYW5kb20oKTtcblx0XHRcdHZhciBvcmlnaW4gPSB3aW4ubG9jYXRpb24ucHJvdG9jb2wgKyAnLy8nICsgd2luLmxvY2F0aW9uLmhvc3Q7XG5cdFx0XHR2YXIgb25tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuXHRcdFx0XHQvLyBWYWxpZGF0ZSBvcmlnaW4gYW5kIG1lc3NhZ2UgdG8gbWFrZSBzdXJlIHRoYXQgdGhpcyBtZXNzYWdlIHdhc1xuXHRcdFx0XHQvLyBpbnRlbmRlZCBmb3IgdXMuXG5cdFx0XHRcdGlmIChlLm9yaWdpbiAhPT0gb3JpZ2luICYmIGUuZGF0YSAhPT0gbWVzc2FnZSkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnBvcnQxLm9ubWVzc2FnZSgpO1xuXHRcdFx0fS5iaW5kKHRoaXMpO1xuXHRcdFx0d2luLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBvbm1lc3NhZ2UsIGZhbHNlKTtcblx0XHRcdHRoaXMucG9ydDEgPSB7fTtcblx0XHRcdHRoaXMucG9ydDIgPSB7XG5cdFx0XHRcdHBvc3RNZXNzYWdlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR3aW4ucG9zdE1lc3NhZ2UobWVzc2FnZSwgb3JpZ2luKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9O1xuXHR9XG5cdGlmICh0eXBlb2YgQ2hhbm5lbCAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHR2YXIgY2hhbm5lbCA9IG5ldyBDaGFubmVsKCk7XG5cdFx0Ly8gVXNlIGEgZmlmbyBsaW5rZWQgbGlzdCB0byBjYWxsIGNhbGxiYWNrcyBpbiB0aGUgcmlnaHQgb3JkZXIuXG5cdFx0dmFyIGhlYWQgPSB7fTtcblx0XHR2YXIgdGFpbCA9IGhlYWQ7XG5cdFx0Y2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcblx0XHRcdGhlYWQgPSBoZWFkLm5leHQ7XG5cdFx0XHR2YXIgY2IgPSBoZWFkLmNiO1xuXHRcdFx0aGVhZC5jYiA9IG51bGw7XG5cdFx0XHRjYigpO1xuXHRcdH07XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKGNiKSB7XG5cdFx0XHR0YWlsLm5leHQgPSB7XG5cdFx0XHRcdGNiOiBjYlxuXHRcdFx0fTtcblx0XHRcdHRhaWwgPSB0YWlsLm5leHQ7XG5cdFx0XHRjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKDApO1xuXHRcdH07XG5cdH1cblx0Ly8gSW1wbGVtZW50YXRpb24gZm9yIElFNi04OiBTY3JpcHQgZWxlbWVudHMgZmlyZSBhbiBhc3luY2hyb25vdXNcblx0Ly8gb25yZWFkeXN0YXRlY2hhbmdlIGV2ZW50IHdoZW4gaW5zZXJ0ZWQgaW50byB0aGUgRE9NLlxuXHRpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiAnb25yZWFkeXN0YXRlY2hhbmdlJyBpblxuXHRcdGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKGNiKSB7XG5cdFx0XHR2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG5cdFx0XHRzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdC8vIENsZWFuIHVwIGFuZCBjYWxsIHRoZSBjYWxsYmFjay5cblx0XHRcdFx0c2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG5cdFx0XHRcdHNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG5cdFx0XHRcdHNjcmlwdCA9IG51bGw7XG5cdFx0XHRcdGNiKCk7XG5cdFx0XHRcdGNiID0gbnVsbDtcblx0XHRcdH07XG5cdFx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcblx0XHR9O1xuXHR9XG5cdC8vIEZhbGwgYmFjayB0byBzZXRUaW1lb3V0IHdpdGggMC4gSW4gYnJvd3NlcnMgdGhpcyBjcmVhdGVzIGEgZGVsYXkgb2YgNW1zXG5cdC8vIG9yIG1vcmUuXG5cdHJldHVybiBmdW5jdGlvbihjYikge1xuXHRcdHNldFRpbWVvdXQoY2IsIDApO1xuXHR9O1xufTtcblxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGlzIG92ZXJyaWRlZCB0byBwcm90ZWN0IGNhbGxiYWNrcyB3aXRoIGVudHJ5IHBvaW50XG4gKiBtb25pdG9yIGlmIHRoZSBhcHBsaWNhdGlvbiBtb25pdG9ycyBlbnRyeSBwb2ludHMuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGZpcmUgYXMgc29vbiBhcyBwb3NzaWJsZS5cbiAqIEByZXR1cm4ge2Z1bmN0aW9uKCl9IFRoZSB3cmFwcGVkIGNhbGxiYWNrLlxuICogQHByaXZhdGVcbiAqL1xuYXN5bmMubmV4dFRpY2sud3JhcENhbGxiYWNrXyA9IGZ1bmN0aW9uKG9wdF9yZXR1cm5WYWx1ZSkge1xuXHRyZXR1cm4gb3B0X3JldHVyblZhbHVlO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmM7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRGlzcG9zYWJsZSB1dGlsaXR5LiBXaGVuIGluaGVyaXRlZCBwcm92aWRlcyB0aGUgYGRpc3Bvc2VgIGZ1bmN0aW9uIHRvIGl0c1xuICogc3ViY2xhc3MsIHdoaWNoIGlzIHJlc3BvbnNpYmxlIGZvciBkaXNwb3Npbmcgb2YgYW55IG9iamVjdCByZWZlcmVuY2VzXG4gKiB3aGVuIGFuIGluc3RhbmNlIHdvbid0IGJlIHVzZWQgYW55bW9yZS4gU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGVcbiAqIGBkaXNwb3NlSW50ZXJuYWxgIHRvIGltcGxlbWVudCBhbnkgc3BlY2lmaWMgZGlzcG9zaW5nIGxvZ2ljLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIERpc3Bvc2FibGUge1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHQvKipcblx0XHQgKiBGbGFnIGluZGljYXRpbmcgaWYgdGhpcyBpbnN0YW5jZSBoYXMgYWxyZWFkeSBiZWVuIGRpc3Bvc2VkLlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLmRpc3Bvc2VkXyA9IGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIERpc3Bvc2VzIG9mIHRoaXMgaW5zdGFuY2UncyBvYmplY3QgcmVmZXJlbmNlcy4gQ2FsbHMgYGRpc3Bvc2VJbnRlcm5hbGAuXG5cdCAqL1xuXHRkaXNwb3NlKCkge1xuXHRcdGlmICghdGhpcy5kaXNwb3NlZF8pIHtcblx0XHRcdHRoaXMuZGlzcG9zZUludGVybmFsKCk7XG5cdFx0XHR0aGlzLmRpc3Bvc2VkXyA9IHRydWU7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGltcGxlbWVudCBhbnkgc3BlY2lmaWNcblx0ICogZGlzcG9zaW5nIGxvZ2ljIChsaWtlIGNsZWFyaW5nIHJlZmVyZW5jZXMgYW5kIGNhbGxpbmcgYGRpc3Bvc2VgIG9uIG90aGVyXG5cdCAqIGRpc3Bvc2FibGVzKS5cblx0ICovXG5cdGRpc3Bvc2VJbnRlcm5hbCgpIHt9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiB0aGlzIGluc3RhbmNlIGhhcyBhbHJlYWR5IGJlZW4gZGlzcG9zZWQuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqL1xuXHRpc0Rpc3Bvc2VkKCkge1xuXHRcdHJldHVybiB0aGlzLmRpc3Bvc2VkXztcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBEaXNwb3NhYmxlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jbGFzcyBvYmplY3Qge1xuXHQvKipcblx0ICogQ29waWVzIGFsbCB0aGUgbWVtYmVycyBvZiBhIHNvdXJjZSBvYmplY3QgdG8gYSB0YXJnZXQgb2JqZWN0LlxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRhcmdldCBvYmplY3QuXG5cdCAqIEBwYXJhbSB7Li4uT2JqZWN0fSB2YXJfYXJncyBUaGUgb2JqZWN0cyBmcm9tIHdoaWNoIHZhbHVlcyB3aWxsIGJlIGNvcGllZC5cblx0ICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIHRoZSB0YXJnZXQgb2JqZWN0IHJlZmVyZW5jZS5cblx0ICovXG5cdHN0YXRpYyBtaXhpbih0YXJnZXQpIHtcblx0XHR2YXIga2V5LCBzb3VyY2U7XG5cdFx0Zm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdGZvciAoa2V5IGluIHNvdXJjZSkge1xuXHRcdFx0XHR0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGFyZ2V0O1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYW4gb2JqZWN0IGJhc2VkIG9uIGl0cyBmdWxseSBxdWFsaWZpZWQgZXh0ZXJuYWwgbmFtZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIGZ1bGx5IHF1YWxpZmllZCBuYW1lLlxuXHQgKiBAcGFyYW0ge29iamVjdD19IG9wdF9vYmogVGhlIG9iamVjdCB3aXRoaW4gd2hpY2ggdG8gbG9vazsgZGVmYXVsdCBpc1xuXHQgKiAgICAgPGNvZGU+d2luZG93PC9jb2RlPi5cblx0ICogQHJldHVybiB7P30gVGhlIHZhbHVlIChvYmplY3Qgb3IgcHJpbWl0aXZlKSBvciwgaWYgbm90IGZvdW5kLCB1bmRlZmluZWQuXG5cdCAqL1xuXHRzdGF0aWMgZ2V0T2JqZWN0QnlOYW1lKG5hbWUsIG9wdF9vYmopIHtcblx0XHR2YXIgc2NvcGUgPSBvcHRfb2JqIHx8IHdpbmRvdztcblx0XHR2YXIgcGFydHMgPSBuYW1lLnNwbGl0KCcuJyk7XG5cdFx0cmV0dXJuIHBhcnRzLnJlZHVjZSgocGFydCwga2V5KSA9PiBwYXJ0W2tleV0sIHNjb3BlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgbmV3IG9iamVjdCB3aXRoIHRoZSBzYW1lIGtleXMgYXMgdGhlIGdpdmVuIG9uZSwgYnV0IHdpdGhcblx0ICogdGhlaXIgdmFsdWVzIHNldCB0byB0aGUgcmV0dXJuIHZhbHVlcyBvZiB0aGUgc3BlY2lmaWVkIGZ1bmN0aW9uLlxuXHQgKiBAcGFyYW0geyFPYmplY3R9IG9ialxuXHQgKiBAcGFyYW0geyFmdW5jdGlvbihzdHJpbmcsICopfSBmblxuXHQgKiBAcmV0dXJuIHshT2JqZWN0fVxuXHQgKi9cblx0c3RhdGljIG1hcChvYmosIGZuKSB7XG5cdFx0dmFyIG1hcHBlZE9iaiA9IHt9O1xuXHRcdHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdG1hcHBlZE9ialtrZXlzW2ldXSA9IGZuKGtleXNbaV0sIG9ialtrZXlzW2ldXSk7XG5cdFx0fVxuXHRcdHJldHVybiBtYXBwZWRPYmo7XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIHRoZSB0d28gZ2l2ZW4gb2JqZWN0cyBhcmUgZXF1YWwuIFRoaXMgaXMgZG9uZSB2aWEgYSBzaGFsbG93XG5cdCAqIGNoZWNrLCBpbmNsdWRpbmcgb25seSB0aGUga2V5cyBkaXJlY3RseSBjb250YWluZWQgYnkgdGhlIDIgb2JqZWN0cy5cblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICovXG5cdHN0YXRpYyBzaGFsbG93RXF1YWwob2JqMSwgb2JqMikge1xuXHRcdGlmIChvYmoxID09PSBvYmoyKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHR2YXIga2V5czEgPSBPYmplY3Qua2V5cyhvYmoxKTtcblx0XHR2YXIga2V5czIgPSBPYmplY3Qua2V5cyhvYmoyKTtcblx0XHRpZiAoa2V5czEubGVuZ3RoICE9PSBrZXlzMi5sZW5ndGgpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGtleXMxLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAob2JqMVtrZXlzMVtpXV0gIT09IG9iajJba2V5czFbaV1dKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgb2JqZWN0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jbGFzcyBzdHJpbmcge1xuXHQvKipcblx0ICogUmVtb3ZlcyB0aGUgYnJlYWtpbmcgc3BhY2VzIGZyb20gdGhlIGxlZnQgYW5kIHJpZ2h0IG9mIHRoZSBzdHJpbmcgYW5kXG5cdCAqIGNvbGxhcHNlcyB0aGUgc2VxdWVuY2VzIG9mIGJyZWFraW5nIHNwYWNlcyBpbiB0aGUgbWlkZGxlIGludG8gc2luZ2xlIHNwYWNlcy5cblx0ICogVGhlIG9yaWdpbmFsIGFuZCB0aGUgcmVzdWx0IHN0cmluZ3MgcmVuZGVyIHRoZSBzYW1lIHdheSBpbiBIVE1MLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc3RyIEEgc3RyaW5nIGluIHdoaWNoIHRvIGNvbGxhcHNlIHNwYWNlcy5cblx0ICogQHJldHVybiB7c3RyaW5nfSBDb3B5IG9mIHRoZSBzdHJpbmcgd2l0aCBub3JtYWxpemVkIGJyZWFraW5nIHNwYWNlcy5cblx0ICovXG5cdHN0YXRpYyBjb2xsYXBzZUJyZWFraW5nU3BhY2VzKHN0cikge1xuXHRcdHJldHVybiBzdHIucmVwbGFjZSgvW1xcdFxcclxcbiBdKy9nLCAnICcpLnJlcGxhY2UoL15bXFx0XFxyXFxuIF0rfFtcXHRcXHJcXG4gXSskL2csICcnKTtcblx0fVxuXG5cdC8qKlxuXHQqIEVzY2FwZXMgY2hhcmFjdGVycyBpbiB0aGUgc3RyaW5nIHRoYXQgYXJlIG5vdCBzYWZlIHRvIHVzZSBpbiBhIFJlZ0V4cC5cblx0KiBAcGFyYW0geyp9IHN0ciBUaGUgc3RyaW5nIHRvIGVzY2FwZS4gSWYgbm90IGEgc3RyaW5nLCBpdCB3aWxsIGJlIGNhc3RlZFxuXHQqICAgICB0byBvbmUuXG5cdCogQHJldHVybiB7c3RyaW5nfSBBIFJlZ0V4cCBzYWZlLCBlc2NhcGVkIGNvcHkgb2Yge0Bjb2RlIHN9LlxuXHQqL1xuXHRzdGF0aWMgZXNjYXBlUmVnZXgoc3RyKSB7XG5cdFx0cmV0dXJuIFN0cmluZyhzdHIpXG5cdFx0XHQucmVwbGFjZSgvKFstKClcXFtcXF17fSs/Ki4kXFxefCw6IzwhXFxcXF0pL2csICdcXFxcJDEnKVxuXHRcdFx0LnJlcGxhY2UoL1xceDA4L2csICdcXFxceDA4Jyk7XG5cdH1cblxuXHQvKipcblx0KiBSZXR1cm5zIGEgc3RyaW5nIHdpdGggYXQgbGVhc3QgNjQtYml0cyBvZiByYW5kb21uZXNzLlxuXHQqIEByZXR1cm4ge3N0cmluZ30gQSByYW5kb20gc3RyaW5nLCBlLmcuIHNuMXM3dmI0Z2NpYy5cblx0Ki9cblx0c3RhdGljIGdldFJhbmRvbVN0cmluZygpIHtcblx0XHR2YXIgeCA9IDIxNDc0ODM2NDg7XG5cdFx0cmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHgpLnRvU3RyaW5nKDM2KSArXG5cdFx0XHRNYXRoLmFicyhNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB4KSBeIERhdGUubm93KCkpLnRvU3RyaW5nKDM2KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDYWxjdWxhdGVzIHRoZSBoYXNoY29kZSBmb3IgYSBzdHJpbmcuIFRoZSBoYXNoY29kZSB2YWx1ZSBpcyBjb21wdXRlZCBieVxuXHQgKiB0aGUgc3VtIGFsZ29yaXRobTogc1swXSozMV4obi0xKSArIHNbMV0qMzFeKG4tMikgKyAuLi4gKyBzW24tMV0uIEEgbmljZVxuXHQgKiBwcm9wZXJ0eSBvZiB1c2luZyAzMSBwcmltZSBpcyB0aGF0IHRoZSBtdWx0aXBsaWNhdGlvbiBjYW4gYmUgcmVwbGFjZWQgYnlcblx0ICogYSBzaGlmdCBhbmQgYSBzdWJ0cmFjdGlvbiBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlOiAzMSppID09IChpPDw1KS1pLlxuXHQgKiBNb2Rlcm4gVk1zIGRvIHRoaXMgc29ydCBvZiBvcHRpbWl6YXRpb24gYXV0b21hdGljYWxseS5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHZhbCBUYXJnZXQgc3RyaW5nLlxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IFJldHVybnMgdGhlIHN0cmluZyBoYXNoY29kZS5cblx0ICovXG5cdHN0YXRpYyBoYXNoQ29kZSh2YWwpIHtcblx0XHR2YXIgaGFzaCA9IDA7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHZhbC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aGFzaCA9IDMxICogaGFzaCArIHZhbC5jaGFyQ29kZUF0KGkpO1xuXHRcdFx0aGFzaCAlPSAweDEwMDAwMDAwMDtcblx0XHR9XG5cdFx0cmV0dXJuIGhhc2g7XG5cdH1cblxuXHQvKipcblx0ICogUmVwbGFjZXMgaW50ZXJ2YWwgaW50byB0aGUgc3RyaW5nIHdpdGggc3BlY2lmaWVkIHZhbHVlLCBlLmcuXG5cdCAqIGByZXBsYWNlSW50ZXJ2YWwoXCJhYmNkZVwiLCAxLCA0LCBcIlwiKWAgcmV0dXJucyBcImFlXCIuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIGlucHV0IHN0cmluZy5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0IFN0YXJ0IGludGVydmFsIHBvc2l0aW9uIHRvIGJlIHJlcGxhY2VkLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gZW5kIEVuZCBpbnRlcnZhbCBwb3NpdGlvbiB0byBiZSByZXBsYWNlZC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFRoZSB2YWx1ZSB0aGF0IHJlcGxhY2VzIHRoZSBzcGVjaWZpZWQgaW50ZXJ2YWwuXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdHN0YXRpYyByZXBsYWNlSW50ZXJ2YWwoc3RyLCBzdGFydCwgZW5kLCB2YWx1ZSkge1xuXHRcdHJldHVybiBzdHIuc3Vic3RyaW5nKDAsIHN0YXJ0KSArIHZhbHVlICsgc3RyLnN1YnN0cmluZyhlbmQpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0cmluZztcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDbGFzcyByZXNwb25zaWJsZSBmb3Igc3RvcmluZyBhbiBvYmplY3QgdGhhdCB3aWxsIGJlIHByaW50ZWQgYXMgSlNPTlxuICogd2hlbiB0aGUgYHRvU3RyaW5nYCBtZXRob2QgaXMgY2FsbGVkLlxuICovXG5jbGFzcyBFbWJvZGllZCB7XG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgRW1ib2RpZWQgaW5zdGFuY2UuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0dGhpcy5ib2R5XyA9IHt9O1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGpzb24gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGlzIGluc3RhbmNlLlxuXHQgKiBAcmV0dXJuIHshT2JqZWN0fVxuXHQgKi9cblx0Ym9keSgpIHtcblx0XHRyZXR1cm4gdGhpcy5ib2R5Xztcblx0fVxuXG5cdC8qKlxuXHQgKiBJZiB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGFuIGluc3RhbmNlIG9mIEVtYm9kaWVkLCB0aGlzIHdpbGxcblx0ICogcmV0dXJuIGl0cyBib2R5IGNvbnRlbnQuIE90aGVyd2lzZSB0aGlzIHdpbGwgcmV0dXJuIHRoZVxuXHQgKiBvcmlnaW5hbCBvYmplY3QuXG5cdCAqIEBwYXJhbSB7Kn0gb2JqXG5cdCAqIEByZXR1cm4geyp9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyB0b0JvZHkob2JqKSB7XG5cdFx0cmV0dXJuIChvYmogaW5zdGFuY2VvZiBFbWJvZGllZCkgPyBvYmouYm9keSgpIDogb2JqO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGpzb24gc3RyaW5nIHRoYXQgcmVwcmVzZW50cyB0aGlzIGluc3RhbmNlLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy5ib2R5KCkpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEVtYm9kaWVkO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgeyBjb3JlIH0gZnJvbSAnbWV0YWwnO1xuaW1wb3J0IEVtYm9kaWVkIGZyb20gJy4vRW1ib2RpZWQnO1xuXG4vKipcbiAqIENsYXNzIHJlc3BvbnNpYmxlIGZvciBzdG9yaW5nIGFuZCBoYW5kbGluZyB0aGUgYm9keSBjb250ZW50c1xuICogb2YgYSBGaWx0ZXIgaW5zdGFuY2UuXG4gKi9cbmNsYXNzIEZpbHRlckJvZHkge1xuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIHtAbGluayBGaWx0ZXJCb2R5fSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7Kn0gb3BlcmF0b3JPclZhbHVlIElmIGEgdGhpcmQgcGFyYW0gaXMgZ2l2ZW4sIHRoaXMgc2hvdWxkXG5cdCAqICAgYmUgdGhlIGZpbHRlcidzIG9wZXJhdG9yIChsaWtlIFwiPj1cIikuIE90aGVyd2lzZSwgdGhpcyB3aWxsIGJlXG5cdCAqICAgdXNlZCBhcyB0aGUgZmlsdGVyJ3MgdmFsdWUsIGFuZCB0aGUgZmlsdGVyJ3Mgb3BlcmF0b3Igd2lsbCBiZSBcIj1cIi5cblx0ICogQHBhcmFtIHsqPX0gb3B0X3ZhbHVlIFRoZSBmaWx0ZXIncyB2YWx1ZS5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihmaWVsZCwgb3BlcmF0b3JPclZhbHVlLCBvcHRfdmFsdWUpIHtcblx0XHR2YXIgb2JqID0ge1xuXHRcdFx0b3BlcmF0b3I6IGNvcmUuaXNEZWYob3B0X3ZhbHVlKSA/IG9wZXJhdG9yT3JWYWx1ZSA6ICc9J1xuXHRcdH07XG5cblx0XHR2YXIgdmFsdWUgPSBjb3JlLmlzRGVmKG9wdF92YWx1ZSkgPyBvcHRfdmFsdWUgOiBvcGVyYXRvck9yVmFsdWU7XG5cblx0XHRpZiAoY29yZS5pc0RlZkFuZE5vdE51bGwodmFsdWUpKSB7XG5cdFx0XHRpZiAodmFsdWUgaW5zdGFuY2VvZiBFbWJvZGllZCkge1xuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlLmJvZHkoKTtcblx0XHRcdH1cblx0XHRcdG9iai52YWx1ZSA9IHZhbHVlO1xuXHRcdH1cblxuXHRcdGlmIChjb3JlLmlzRGVmQW5kTm90TnVsbChmaWVsZCkpIHtcblx0XHRcdHRoaXMuY3JlYXRlQm9keV8oZmllbGQsIG9iaik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuY3JlYXRlQm9keV8oJ2FuZCcsIFtdKTtcblx0XHR9XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDb21wb3NlcyB0aGUgY3VycmVudCBmaWx0ZXIgd2l0aCB0aGUgZ2l2ZW4gb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBvcGVyYXRvclxuXHQgKiBAcGFyYW0ge0ZpbHRlcj19IG9wdF9maWx0ZXIgQW5vdGhlciBmaWx0ZXIgdG8gY29tcG9zZSB0aGlzIGZpbHRlciB3aXRoLFxuXHQgKiAgIGlmIHRoZSBvcGVyYXRvciBpcyBub3QgdW5hcnkuXG5cdCAqL1xuXHRhZGQob3BlcmF0b3IsIG9wdF9maWx0ZXIpIHtcblx0XHRpZiAob3B0X2ZpbHRlcikge1xuXHRcdFx0dGhpcy5hZGRBcnJheU9wZXJhdG9yXyhvcGVyYXRvciwgb3B0X2ZpbHRlcik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuY3JlYXRlQm9keV8ob3BlcmF0b3IsIHRoaXMuYm9keV8pO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBDb21wb3NlcyB0aGUgY3VycmVudCBmaWx0ZXIgd2l0aCBhbiBvcGVyYXRvciB0aGF0IHN0b3JlcyBpdHMgdmFsdWVzIGluIGFuIGFycmF5LlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3Jcblx0ICogQHBhcmFtIHshRmlsdGVyfSBmaWx0ZXJcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0YWRkQXJyYXlPcGVyYXRvcl8ob3BlcmF0b3IsIGZpbHRlcikge1xuXHRcdGlmICghKHRoaXMuYm9keV9bb3BlcmF0b3JdIGluc3RhbmNlb2YgQXJyYXkpKSB7XG5cdFx0XHR0aGlzLmNyZWF0ZUJvZHlfKG9wZXJhdG9yLCBbdGhpcy5ib2R5X10pO1xuXHRcdH1cblx0XHR0aGlzLmJvZHlfW29wZXJhdG9yXS5wdXNoKGZpbHRlci5ib2R5KCkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgZmlsdGVycyB0byBiZSBjb21wb3NlZCB3aXRoIHRoaXMgZmlsdGVyIGJvZHkgdXNpbmcgdGhlIGdpdmVuIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3Jcblx0ICogQHBhcmFtIHsuLi4qfSBmaWx0ZXJzIEEgdmFyaWFibGUgYW1vdW50IG9mIGZpbHRlcnMgdG8gYmUgY29tcG9zZWQuXG5cdCAqL1xuXHRhZGRNYW55KG9wZXJhdG9yLCAuLi5maWx0ZXJzKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBmaWx0ZXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR0aGlzLmFkZChvcGVyYXRvciwgZmlsdGVyc1tpXSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBuZXcgYm9keSBvYmplY3QsIHNldHRpbmcgdGhlIHJlcXVlc3RkIGtleSB0byB0aGUgZ2l2ZW4gdmFsdWUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSB0byBzZXQgaW4gdGhlIG5ldyBib2R5IG9iamVjdFxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0aGUgcmVxdWVzdGVkIGtleSBzaG91bGQgaGF2ZSBpbiB0aGUgbmV3IGJvZHkgb2JqZWN0LlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRjcmVhdGVCb2R5XyhrZXksIHZhbHVlKSB7XG5cdFx0dGhpcy5ib2R5XyA9IHt9O1xuXHRcdHRoaXMuYm9keV9ba2V5XSA9IHZhbHVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGpzb24gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGlzIGZpbHRlcidzIGJvZHkuXG5cdCAqIEByZXR1cm4geyFPYmplY3R9XG5cdCAqL1xuXHRnZXRPYmplY3QoKSB7XG5cdFx0cmV0dXJuIHRoaXMuYm9keV87XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRmlsdGVyQm9keTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEVtYm9kaWVkIGZyb20gJy4vRW1ib2RpZWQnO1xuXG4vKipcbiAqIENsYXNzIHJlc3BvbnNpYmxlIGZvciBidWlsZGluZyBkaWZmZXJlbnQgdHlwZXMgb2YgZ2VvbWV0cmljXG4gKiBzaGFwZXMuXG4gKi9cbmNsYXNzIEdlbyB7XG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgbmV3IHtAbGluayBCb3VuZGluZ0JveH0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7Kn0gdXBwZXJMZWZ0IFRoZSB1cHBlciBsZWZ0IHBvaW50LlxuXHQgKiBAcGFyYW0geyp9IGxvd2VyUmlnaHQgVGhlIGxvd2VyIHJpZ2h0IHBvaW50LlxuXHQgKiBAcmV0dXJuIHshQm91bmRpbmdCb3h9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBib3VuZGluZ0JveCh1cHBlckxlZnQsIGxvd2VyUmlnaHQpIHtcblx0XHRyZXR1cm4gbmV3IEdlby5Cb3VuZGluZ0JveCh1cHBlckxlZnQsIGxvd2VyUmlnaHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBuZXcge0BsaW5rIENpcmNsZX0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7Kn0gY2VudGVyIFRoZSBjaXJjbGUncyBjZW50ZXIgY29vcmRpbmF0ZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHJhZGl1cyBUaGUgY2lyY2xlJ3MgcmFkaXVzLlxuXHQgKiBAcmV0dXJuIHshQ2lyY2xlfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgY2lyY2xlKGNlbnRlciwgcmFkaXVzKSB7XG5cdFx0cmV0dXJuIG5ldyBHZW8uQ2lyY2xlKGNlbnRlciwgcmFkaXVzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgbmV3IHtAbGluayBMaW5lfSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHsuLi4qfSBwb2ludHMgVGhpcyBsaW5lJ3MgcG9pbnRzLlxuXHQgKiBAcmV0dXJuIHshTGluZX1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGxpbmUoLi4ucG9pbnRzKSB7XG5cdFx0cmV0dXJuIG5ldyBHZW8uTGluZSguLi5wb2ludHMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBuZXcge0BsaW5rIFBvaW50fSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGxhdCBUaGUgbGF0aXR1ZGUgY29vcmRpbmF0ZVxuXHQgKiBAcGFyYW0ge251bWJlcn0gbG9uIFRoZSBsb25naXR1ZGUgY29vcmRpbmF0ZVxuXHQgKiBAcmV0dXJuIHshUG9pbnR9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBwb2ludChsYXQsIGxvbikge1xuXHRcdHJldHVybiBuZXcgR2VvLlBvaW50KGxhdCwgbG9uKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgbmV3IHtAbGluayBQb2x5Z29ufSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHsuLi4qfSBwb2ludHMgVGhpcyBwb2x5Z29uJ3MgcG9pbnRzLlxuXHQgKiBAcmV0dXJuIHshUG9seWdvbn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIHBvbHlnb24oLi4ucG9pbnRzKSB7XG5cdFx0cmV0dXJuIG5ldyBHZW8uUG9seWdvbiguLi5wb2ludHMpO1xuXHR9XG59XG5cbi8qKlxuICogQ2xhc3MgdGhhdCByZXByZXNlbnRzIGEgcG9pbnQgY29vcmRpbmF0ZS5cbiAqIEBleHRlbmRzIHtFbWJvZGllZH1cbiAqL1xuY2xhc3MgUG9pbnQgZXh0ZW5kcyBFbWJvZGllZCB7XG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEge0BsaW5rIFBvaW50fSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGxhdCBUaGUgbGF0aXR1ZGUgY29vcmRpbmF0ZVxuXHQgKiBAcGFyYW0ge251bWJlcn0gbG9uIFRoZSBsb25naXR1ZGUgY29vcmRpbmF0ZVxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGNvbnN0cnVjdG9yKGxhdCwgbG9uKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLmJvZHlfID0gW2xhdCwgbG9uXTtcblx0fVxufVxuR2VvLlBvaW50ID0gUG9pbnQ7XG5cbi8qKlxuICogQ2xhc3MgdGhhdCByZXByZXNlbnRzIGEgbGluZS5cbiAqIEBleHRlbmRzIHtFbWJvZGllZH1cbiAqL1xuY2xhc3MgTGluZSBleHRlbmRzIEVtYm9kaWVkIHtcblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSB7QGxpbmsgTGluZX0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7Li4uKn0gcG9pbnRzIFRoaXMgbGluZSdzIHBvaW50cy5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciguLi5wb2ludHMpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuYm9keV8gPSB7XG5cdFx0XHR0eXBlOiAnbGluZXN0cmluZycsXG5cdFx0XHRjb29yZGluYXRlczogcG9pbnRzLm1hcChwb2ludCA9PiBFbWJvZGllZC50b0JvZHkocG9pbnQpKVxuXHRcdH07XG5cdH1cbn1cbkdlby5MaW5lID0gTGluZTtcblxuLyoqXG4gKiBDbGFzcyB0aGF0IHJlcHJlc2VudHMgYSBib3VuZGluZyBib3guXG4gKiBAZXh0ZW5kcyB7RW1ib2RpZWR9XG4gKi9cbmNsYXNzIEJvdW5kaW5nQm94IGV4dGVuZHMgRW1ib2RpZWQge1xuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIHtAbGluayBCb3VuZGluZ0JveH0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7Kn0gdXBwZXJMZWZ0IFRoZSB1cHBlciBsZWZ0IHBvaW50LlxuXHQgKiBAcGFyYW0geyp9IGxvd2VyUmlnaHQgVGhlIGxvd2VyIHJpZ2h0IHBvaW50LlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGNvbnN0cnVjdG9yKHVwcGVyTGVmdCwgbG93ZXJSaWdodCkge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy5ib2R5XyA9IHtcblx0XHRcdHR5cGU6ICdlbnZlbG9wZScsXG5cdFx0XHRjb29yZGluYXRlczogW0VtYm9kaWVkLnRvQm9keSh1cHBlckxlZnQpLCBFbWJvZGllZC50b0JvZHkobG93ZXJSaWdodCldXG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoaXMgYm91bmRpbmcgYm94J3MgcG9pbnRzLlxuXHQgKiBAcmV0dXJuIHshQXJyYXl9XG5cdCAqL1xuXHRnZXRQb2ludHMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuYm9keV8uY29vcmRpbmF0ZXM7XG5cdH1cbn1cbkdlby5Cb3VuZGluZ0JveCA9IEJvdW5kaW5nQm94O1xuXG4vKipcbiAqIENsYXNzIHRoYXQgcmVwcmVzZW50cyBhIGNpcmNsZS5cbiAqIEBleHRlbmRzIHtFbWJvZGllZH1cbiAqL1xuY2xhc3MgQ2lyY2xlIGV4dGVuZHMgRW1ib2RpZWQge1xuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIHtAbGluayBDaXJjbGV9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0geyp9IGNlbnRlciBUaGUgY2lyY2xlJ3MgY2VudGVyIGNvb3JkaW5hdGUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSByYWRpdXMgVGhlIGNpcmNsZSdzIHJhZGl1cy5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihjZW50ZXIsIHJhZGl1cykge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy5ib2R5XyA9IHtcblx0XHRcdHR5cGU6ICdjaXJjbGUnLFxuXHRcdFx0Y29vcmRpbmF0ZXM6IEVtYm9kaWVkLnRvQm9keShjZW50ZXIpLFxuXHRcdFx0cmFkaXVzOiByYWRpdXNcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhpcyBjaXJjbGUncyBjZW50ZXIgY29vcmRpbmF0ZS5cblx0ICogQHJldHVybiB7Kn1cblx0ICovXG5cdGdldENlbnRlcigpIHtcblx0XHRyZXR1cm4gdGhpcy5ib2R5Xy5jb29yZGluYXRlcztcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoaXMgY2lyY2xlJ3MgcmFkaXVzLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuXHRnZXRSYWRpdXMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuYm9keV8ucmFkaXVzO1xuXHR9XG59XG5HZW8uQ2lyY2xlID0gQ2lyY2xlO1xuXG4vKipcbiAqIENsYXNzIHRoYXQgcmVwcmVzZW50cyBhIHBvbHlnb24uXG4gKiBAZXh0ZW5kcyB7RW1ib2RpZWR9XG4gKi9cbmNsYXNzIFBvbHlnb24gZXh0ZW5kcyBFbWJvZGllZCB7XG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEge0BsaW5rIFBvbHlnb259IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0gey4uLip9IHBvaW50cyBUaGlzIHBvbHlnb24ncyBwb2ludHMuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0Y29uc3RydWN0b3IoLi4ucG9pbnRzKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLmJvZHlfID0ge1xuXHRcdFx0dHlwZTogJ3BvbHlnb24nLFxuXHRcdFx0Y29vcmRpbmF0ZXM6IFtdXG5cdFx0fTtcblx0XHR0aGlzLmFkZENvb3JkaW5hdGVzXyguLi5wb2ludHMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgdGhlIGdpdmVuIHBvaW50cyBhcyBjb29yZGluYXRlcyBmb3IgdGhpcyBwb2x5Z29uLlxuXHQgKiBAcGFyYW0gey4uLip9IHBvaW50c1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRhZGRDb29yZGluYXRlc18oLi4ucG9pbnRzKSB7XG5cdFx0dGhpcy5ib2R5Xy5jb29yZGluYXRlcy5wdXNoKHBvaW50cy5tYXAocG9pbnQgPT4gRW1ib2RpZWQudG9Cb2R5KHBvaW50KSkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgdGhlIGdpdmVuIHBvaW50cyBhcyBhIGhvbGUgaW5zaWRlIHRoaXMgcG9seWdvbi5cblx0ICogQHBhcmFtICB7Li4uKn0gcG9pbnRzXG5cdCAqIEBjaGFpbm5hYmxlXG5cdCAqL1xuXHRob2xlKC4uLnBvaW50cykge1xuXHRcdHRoaXMuYWRkQ29vcmRpbmF0ZXNfKC4uLnBvaW50cyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn1cbkdlby5Qb2x5Z29uID0gUG9seWdvbjtcblxuZXhwb3J0IGRlZmF1bHQgR2VvO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgeyBjb3JlIH0gZnJvbSAnbWV0YWwnO1xuaW1wb3J0IEVtYm9kaWVkIGZyb20gJy4vRW1ib2RpZWQnO1xuXG4vKipcbiAqIENsYXNzIHJlc3BvbnNpYmxlIGZvciBidWlsZGluZyByYW5nZSBvYmplY3RzIHRvIGJlIHVzZWQgYnkgYEZpbHRlcmAuXG4gKiBAZXh0ZW5kcyB7RW1ib2RpZWR9XG4gKi9cbmNsYXNzIFJhbmdlIGV4dGVuZHMgRW1ib2RpZWQge1xuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIHtAbGluayBSYW5nZX0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7Kn0gZnJvbVxuXHQgKiBAcGFyYW0geyp9IG9wdF90b1xuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGNvbnN0cnVjdG9yKGZyb20sIG9wdF90bykge1xuXHRcdHN1cGVyKCk7XG5cdFx0aWYgKGNvcmUuaXNEZWZBbmROb3ROdWxsKGZyb20pKSB7XG5cdFx0XHR0aGlzLmJvZHlfLmZyb20gPSBmcm9tO1xuXHRcdH1cblx0XHRpZiAoY29yZS5pc0RlZkFuZE5vdE51bGwob3B0X3RvKSkge1xuXHRcdFx0dGhpcy5ib2R5Xy50byA9IG9wdF90bztcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIHtAbGluayBSYW5nZX0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7Kn0gZnJvbVxuXHQgKiBAcmV0dXJuIHshUmFuZ2V9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBmcm9tKGZyb20pIHtcblx0XHRyZXR1cm4gbmV3IFJhbmdlKGZyb20pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSB7QGxpbmsgUmFuZ2V9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0geyp9IGZyb21cblx0ICogQHBhcmFtIHsqfSB0b1xuXHQgKiBAcmV0dXJuIHshUmFuZ2V9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyByYW5nZShmcm9tLCB0bykge1xuXHRcdHJldHVybiBuZXcgUmFuZ2UoZnJvbSwgdG8pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSB7QGxpbmsgUmFuZ2V9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0geyp9IHRvXG5cdCAqIEByZXR1cm4geyFSYW5nZX1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIHRvKHRvKSB7XG5cdFx0cmV0dXJuIG5ldyBSYW5nZShudWxsLCB0byk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUmFuZ2U7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7IGNvcmUgfSBmcm9tICdtZXRhbCc7XG5pbXBvcnQgRW1ib2RpZWQgZnJvbSAnLi9FbWJvZGllZCc7XG5pbXBvcnQgRmlsdGVyQm9keSBmcm9tICcuL0ZpbHRlckJvZHknO1xuaW1wb3J0IEdlbyBmcm9tICcuL0dlbyc7XG5pbXBvcnQgUmFuZ2UgZnJvbSAnLi9SYW5nZSc7XG5cbi8qKlxuICogQ2xhc3MgcmVzcG9uc2libGUgZm9yIGJ1aWxkaW5nIGZpbHRlcnMuXG4gKiBAZXh0ZW5kcyB7RW1ib2RpZWR9XG4gKi9cbmNsYXNzIEZpbHRlciBleHRlbmRzIEVtYm9kaWVkIHtcblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7Kn0gb3BlcmF0b3JPclZhbHVlIElmIGEgdGhpcmQgcGFyYW0gaXMgZ2l2ZW4sIHRoaXMgc2hvdWxkXG5cdCAqICAgYmUgdGhlIGZpbHRlcidzIG9wZXJhdG9yIChsaWtlIFwiPj1cIikuIE90aGVyd2lzZSwgdGhpcyB3aWxsIGJlXG5cdCAqICAgdXNlZCBhcyB0aGUgZmlsdGVyJ3MgdmFsdWUsIGFuZCB0aGUgZmlsdGVyJ3Mgb3BlcmF0b3Igd2lsbCBiZSBcIj1cIi5cblx0ICogQHBhcmFtIHsqPX0gb3B0X3ZhbHVlIFRoZSBmaWx0ZXIncyB2YWx1ZS5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihmaWVsZCwgb3BlcmF0b3JPclZhbHVlLCBvcHRfdmFsdWUpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuYm9keV8gPSBuZXcgRmlsdGVyQm9keShmaWVsZCwgb3BlcmF0b3JPclZhbHVlLCBvcHRfdmFsdWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBmaWx0ZXIgdG8gYmUgY29tcG9zZWQgd2l0aCB0aGlzIGZpbHRlciB1c2luZyB0aGUgZ2l2ZW4gb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBvcGVyYXRvclxuXHQgKiBAcGFyYW0geyFGaWx0ZXJ8c3RyaW5nfSBmaWVsZE9yRmlsdGVyIEVpdGhlciBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIG9yIHRoZVxuXHQgKiAgIG5hbWUgb2YgdGhlIGZpZWxkIHRvIGZpbHRlciBieS5cblx0ICogQHBhcmFtIHsqPX0gb3B0X29wZXJhdG9yT3JWYWx1ZSBFaXRoZXIgdGhlIGZpZWxkJ3Mgb3BlcmF0b3Igb3IgaXRzIHZhbHVlLlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfdmFsdWUgVGhlIGZpbHRlcidzIHZhbHVlLlxuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cblx0YWRkKG9wZXJhdG9yLCBmaWVsZE9yRmlsdGVyLCBvcHRfb3BlcmF0b3JPclZhbHVlLCBvcHRfdmFsdWUpIHtcblx0XHR2YXIgZmlsdGVyID0gZmllbGRPckZpbHRlciA/IEZpbHRlci50b0ZpbHRlcihmaWVsZE9yRmlsdGVyLCBvcHRfb3BlcmF0b3JPclZhbHVlLCBvcHRfdmFsdWUpIDogbnVsbDtcblx0XHR0aGlzLmJvZHlfLmFkZChvcGVyYXRvciwgZmlsdGVyKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGZpbHRlcnMgdG8gYmUgY29tcG9zZWQgd2l0aCB0aGlzIGZpbHRlciB1c2luZyB0aGUgZ2l2ZW4gb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBvcGVyYXRvclxuXHQgKiBAcGFyYW0gey4uLip9IGZpbHRlcnMgQSB2YXJpYWJsZSBhbW91bnQgb2YgZmlsdGVycyB0byBiZSBjb21wb3NlZC5cblx0ICogQGNoYWlubmFibGVcblx0ICovXG5cdGFkZE1hbnkob3BlcmF0b3IsIC4uLmZpbHRlcnMpIHtcblx0XHR0aGlzLmJvZHlfLmFkZE1hbnkob3BlcmF0b3IsIC4uLmZpbHRlcnMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBmaWx0ZXIgdG8gYmUgY29tcG9zZWQgd2l0aCB0aGlzIGZpbHRlciB1c2luZyB0aGUgXCJhbmRcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHshRmlsdGVyfHN0cmluZ30gZmllbGRPckZpbHRlciBFaXRoZXIgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSBvciB0aGVcblx0ICogICBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF9vcGVyYXRvck9yVmFsdWUgRWl0aGVyIHRoZSBmaWVsZCdzIG9wZXJhdG9yIG9yIGl0cyB2YWx1ZS5cblx0ICogQHBhcmFtIHsqPX0gb3B0X3ZhbHVlIFRoZSBmaWx0ZXIncyB2YWx1ZS5cblx0ICogQGNoYWlubmFibGVcblx0ICovXG5cdGFuZChmaWVsZE9yRmlsdGVyLCBvcHRfb3BlcmF0b3JPclZhbHVlLCBvcHRfdmFsdWUpIHtcblx0XHRyZXR1cm4gdGhpcy5hZGQoJ2FuZCcsIGZpZWxkT3JGaWx0ZXIsIG9wdF9vcGVyYXRvck9yVmFsdWUsIG9wdF92YWx1ZSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIHRoYXQgdXNlcyB0aGUgXCJhbnlcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7IShBcnJheXwuLi4qKX0gdmFsdWVzIEEgdmFyaWFibGUgYW1vdW50IG9mIHZhbHVlcyB0byBiZSB1c2VkIHdpdGhcblx0ICogICB0aGUgXCJub25lXCIgb3BlcmF0b3IuIENhbiBiZSBwYXNzZWQgZWl0aGVyIGFzIGEgc2luZ2xlIGFycmF5IG9yIGFzXG5cdCAqICAgc2VwYXJhdGUgcGFyYW1zLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgYW55KGZpZWxkKSB7XG5cdFx0dmFyIHZhbHVlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cdFx0aWYgKHZhbHVlcy5sZW5ndGggPT09IDEgJiYgdmFsdWVzWzBdIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdHZhbHVlcyA9IHZhbHVlc1swXTtcblx0XHR9XG5cdFx0cmV0dXJuIG5ldyBGaWx0ZXIoZmllbGQsICdhbnknLCB2YWx1ZXMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSB0aGF0IHVzZXMgdGhlIFwiZ3BcIiBvcGVyYXRvci5cblx0ICogVGhpcyBpcyBhIHNwZWNpYWwgdXNlIGNhc2Ugb2YgYEZpbHRlci5wb2x5Z29uYCBmb3IgYm91bmRpbmdcblx0ICogYm94ZXMuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQncyBuYW1lLlxuXHQgKiBAcGFyYW0geyp9IGJveE9yVXBwZXJMZWZ0IEVpdGhlciBhIGBHZW8uQm91bmRpbmdCb3hgIGluc3RhbmNlLCBvclxuXHQgKiAgIGEgYm91bmRpbmcgYm94J3MgdXBwZXIgbGVmdCBjb29yZGluYXRlLlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfbG93ZXJSaWdodCBBIGJvdW5kaW5nIGJveCdzIGxvd2VyIHJpZ2h0IGNvb3JkaW5hdGUuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBib3VuZGluZ0JveChmaWVsZCwgYm94T3JVcHBlckxlZnQsIG9wdF9sb3dlclJpZ2h0KSB7XG5cdFx0aWYgKGJveE9yVXBwZXJMZWZ0IGluc3RhbmNlb2YgR2VvLkJvdW5kaW5nQm94KSB7XG5cdFx0XHRyZXR1cm4gRmlsdGVyLnBvbHlnb24oZmllbGQsIC4uLmJveE9yVXBwZXJMZWZ0LmdldFBvaW50cygpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIEZpbHRlci5wb2x5Z29uKGZpZWxkLCBib3hPclVwcGVyTGVmdCwgb3B0X2xvd2VyUmlnaHQpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBqc29uIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhpcyBmaWx0ZXIuXG5cdCAqIEByZXR1cm4geyFPYmplY3R9XG5cdCAqL1xuXHRib2R5KCkge1xuXHRcdHJldHVybiB0aGlzLmJvZHlfLmdldE9iamVjdCgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSB0aGF0IHVzZXMgdGhlIFwiZ2RcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBmaWVsZCdzIG5hbWUuXG5cdCAqIEBwYXJhbSB7Kn0gbG9jYXRpb25PckNpcmNsZSBFaXRoZXIgYSBgR2VvLkNpcmNsZWAgaW5zdGFuY2Ugb3IgYSBjb29yZGluYXRlLlxuXHQgKiBAcGFyYW0ge1JhbmdlfHN0cmluZz19IG9wdF9yYW5nZU9yRGlzdGFuY2UgRWl0aGVyIGEgYFJhbmdlYCBpbnN0YW5jZSBvclxuXHQgKiAgIHRoZSBkaXN0YW5jZSB2YWx1ZS5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGRpc3RhbmNlKGZpZWxkLCBsb2NhdGlvbk9yQ2lyY2xlLCBvcHRfcmFuZ2VPckRpc3RhbmNlKSB7XG5cdFx0dmFyIGxvY2F0aW9uID0gbG9jYXRpb25PckNpcmNsZTtcblx0XHR2YXIgcmFuZ2UgPSBvcHRfcmFuZ2VPckRpc3RhbmNlO1xuXHRcdGlmIChsb2NhdGlvbk9yQ2lyY2xlIGluc3RhbmNlb2YgR2VvLkNpcmNsZSkge1xuXHRcdFx0bG9jYXRpb24gPSBsb2NhdGlvbk9yQ2lyY2xlLmdldENlbnRlcigpO1xuXHRcdFx0cmFuZ2UgPSBSYW5nZS50byhsb2NhdGlvbk9yQ2lyY2xlLmdldFJhZGl1cygpKTtcblx0XHR9IGVsc2UgaWYgKCEob3B0X3JhbmdlT3JEaXN0YW5jZSBpbnN0YW5jZW9mIFJhbmdlKSkge1xuXHRcdFx0cmFuZ2UgPSBSYW5nZS50byhvcHRfcmFuZ2VPckRpc3RhbmNlKTtcblx0XHR9XG5cdFx0cmV0dXJuIEZpbHRlci5kaXN0YW5jZUludGVybmFsXyhmaWVsZCwgbG9jYXRpb24sIHJhbmdlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcImdkXCIgb3BlcmF0b3IuIFRoaXNcblx0ICogaXMganVzdCBhbiBpbnRlcm5hbCBoZWxwZXIgdXNlZCBieSBgRmlsdGVyLmRpc3RhbmNlYC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBmaWVsZCdzIG5hbWUuXG5cdCAqIEBwYXJhbSB7Kn0gbG9jYXRpb24gQSBsb2NhdGlvbiBjb29yZGluYXRlLlxuXHQgKiBAcGFyYW0ge1JhbmdlfSByYW5nZSBBIGBSYW5nZWAgaW5zdGFuY2UuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGRpc3RhbmNlSW50ZXJuYWxfKGZpZWxkLCBsb2NhdGlvbiwgcmFuZ2UpIHtcblx0XHR2YXIgdmFsdWUgPSB7XG5cdFx0XHRsb2NhdGlvbjogRW1ib2RpZWQudG9Cb2R5KGxvY2F0aW9uKVxuXHRcdH07XG5cdFx0cmFuZ2UgPSByYW5nZS5ib2R5KCk7XG5cdFx0aWYgKHJhbmdlLmZyb20pIHtcblx0XHRcdHZhbHVlLm1pbiA9IHJhbmdlLmZyb207XG5cdFx0fVxuXHRcdGlmIChyYW5nZS50bykge1xuXHRcdFx0dmFsdWUubWF4ID0gcmFuZ2UudG87XG5cdFx0fVxuXHRcdHJldHVybiBGaWx0ZXIuZmllbGQoZmllbGQsICdnZCcsIHZhbHVlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcIj1cIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIGZpbHRlcidzIHZhbHVlLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuICAgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgZXF1YWwoZmllbGQsIHZhbHVlKSB7XG5cdFx0cmV0dXJuIG5ldyBGaWx0ZXIoZmllbGQsICc9JywgdmFsdWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSB0aGF0IHVzZXMgdGhlIFwiZXhpc3RzXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQncyBuYW1lLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgZXhpc3RzKGZpZWxkKSB7XG5cdFx0cmV0dXJuIEZpbHRlci5maWVsZChmaWVsZCwgJ2V4aXN0cycsIG51bGwpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSB0aGF0IHVzZXMgdGhlIFwiZnV6enlcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkT3JRdWVyeSBJZiBubyBzZWNvbmQgc3RyaW5nIGFyZ3VtZW50IGlzIGdpdmVuLCB0aGlzXG5cdCAqICAgc2hvdWxkIGJlIHRoZSBxdWVyeSBzdHJpbmcsIGluIHdoaWNoIGNhc2UgYWxsIGZpZWxkcyB3aWxsIGJlIG1hdGNoZWQuXG5cdCAqICAgT3RoZXJ3aXNlLCB0aGlzIHNob3VsZCBiZSB0aGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gbWF0Y2guXG5cdCAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcj19IG9wdF9xdWVyeU9yRnV6emluZXNzIElmIHRoaXMgaXMgYSBzdHJpbmcsIGl0IHNob3VsZFxuXHQgKiAgIGJlIHRoZSBxdWVyeSwgb3RoZXJ3aXNlIGl0IHNob3VsZCBiZSB0aGUgZnV6emluZXNzIHZhbHVlLlxuXHQgKiBAcGFyYW0ge251bWJlcj19IG9wdF9mdXp6aW5lc3MgVGhlIGZ1enppbmVzcyB2YWx1ZS5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGZ1enp5KGZpZWxkT3JRdWVyeSwgb3B0X3F1ZXJ5T3JGdXp6aW5lc3MsIG9wdF9mdXp6aW5lc3MpIHtcblx0XHRyZXR1cm4gRmlsdGVyLmZ1enp5SW50ZXJuYWxfKCdmdXp6eScsIGZpZWxkT3JRdWVyeSwgb3B0X3F1ZXJ5T3JGdXp6aW5lc3MsIG9wdF9mdXp6aW5lc3MpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSB0aGF0IHVzZXMgdGhlIGdpdmVuIGZ1enp5IG9wZXJhdG9yLiBUaGlzXG5cdCAqIGlzIGFuIGludGVybmFsIGltcGxlbWVudGF0aW9uIHVzZWQgYnkgdGhlIGBGaWx0ZXIuZnV6enlgIG1ldGhvZC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhdG9yIFRoZSBmdXp6eSBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkT3JRdWVyeSBJZiBubyBzZWNvbmQgc3RyaW5nIGFyZ3VtZW50IGlzIGdpdmVuLCB0aGlzXG5cdCAqICAgc2hvdWxkIGJlIHRoZSBxdWVyeSBzdHJpbmcsIGluIHdoaWNoIGNhc2UgYWxsIGZpZWxkcyB3aWxsIGJlIG1hdGNoZWQuXG5cdCAqICAgT3RoZXJ3aXNlLCB0aGlzIHNob3VsZCBiZSB0aGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gbWF0Y2guXG5cdCAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcj19IG9wdF9xdWVyeU9yRnV6emluZXNzIElmIHRoaXMgaXMgYSBzdHJpbmcsIGl0IHNob3VsZFxuXHQgKiAgIGJlIHRoZSBxdWVyeSwgb3RoZXJ3aXNlIGl0IHNob3VsZCBiZSB0aGUgZnV6emluZXNzIHZhbHVlLlxuXHQgKiBAcGFyYW0ge251bWJlcj19IG9wdF9mdXp6aW5lc3MgVGhlIGZ1enppbmVzcyB2YWx1ZS5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgZnV6enlJbnRlcm5hbF8ob3BlcmF0b3IsIGZpZWxkT3JRdWVyeSwgb3B0X3F1ZXJ5T3JGdXp6aW5lc3MsIG9wdF9mdXp6aW5lc3MpIHtcblx0XHR2YXIgYXJnMklzU3RyaW5nID0gY29yZS5pc1N0cmluZyhvcHRfcXVlcnlPckZ1enppbmVzcyk7XG5cblx0XHR2YXIgdmFsdWUgPSB7XG5cdFx0XHRxdWVyeTogYXJnMklzU3RyaW5nID8gb3B0X3F1ZXJ5T3JGdXp6aW5lc3MgOiBmaWVsZE9yUXVlcnlcblx0XHR9O1xuXHRcdHZhciBmdXp6aW5lc3MgPSBhcmcySXNTdHJpbmcgPyBvcHRfZnV6emluZXNzIDogb3B0X3F1ZXJ5T3JGdXp6aW5lc3M7XG5cdFx0aWYgKGZ1enppbmVzcykge1xuXHRcdFx0dmFsdWUuZnV6emluZXNzID0gZnV6emluZXNzO1xuXHRcdH1cblxuXHRcdHZhciBmaWVsZCA9IGFyZzJJc1N0cmluZyA/IGZpZWxkT3JRdWVyeSA6IEZpbHRlci5BTEw7XG5cdFx0cmV0dXJuIEZpbHRlci5maWVsZChmaWVsZCwgb3BlcmF0b3IsIHZhbHVlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcIj5cIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIGZpbHRlcidzIHZhbHVlLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuICAgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgZ3QoZmllbGQsIHZhbHVlKSB7XG5cdFx0cmV0dXJuIG5ldyBGaWx0ZXIoZmllbGQsICc+JywgdmFsdWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSB0aGF0IHVzZXMgdGhlIFwiPj1cIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIGZpbHRlcidzIHZhbHVlLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuICAgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgZ3RlKGZpZWxkLCB2YWx1ZSkge1xuXHRcdHJldHVybiBuZXcgRmlsdGVyKGZpZWxkLCAnPj0nLCB2YWx1ZSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIHRoYXQgdXNlcyB0aGUgXCJtYXRjaFwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGRPclF1ZXJ5IElmIG5vIHNlY29uZCBzdHJpbmcgYXJndW1lbnQgaXMgZ2l2ZW4sIHRoaXNcblx0ICogICBzaG91bGQgYmUgdGhlIHF1ZXJ5IHN0cmluZywgaW4gd2hpY2ggY2FzZSBhbGwgZmllbGRzIHdpbGwgYmUgbWF0Y2hlZC5cblx0ICogICBPdGhlcndpc2UsIHRoaXMgc2hvdWxkIGJlIHRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBtYXRjaC5cblx0ICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfcXVlcnkgVGhlIHF1ZXJ5IHN0cmluZy5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIG1hdGNoKGZpZWxkT3JRdWVyeSwgb3B0X3F1ZXJ5KSB7XG5cdFx0dmFyIGZpZWxkID0gY29yZS5pc1N0cmluZyhvcHRfcXVlcnkpID8gZmllbGRPclF1ZXJ5IDogRmlsdGVyLkFMTDtcblx0XHR2YXIgcXVlcnkgPSBjb3JlLmlzU3RyaW5nKG9wdF9xdWVyeSkgPyBvcHRfcXVlcnkgOiBmaWVsZE9yUXVlcnk7XG5cdFx0cmV0dXJuIEZpbHRlci5maWVsZChmaWVsZCwgJ21hdGNoJywgcXVlcnkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSB0aGF0IHVzZXMgdGhlIFwibWlzc2luZ1wiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGZpZWxkJ3MgbmFtZS5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIG1pc3NpbmcoZmllbGQpIHtcblx0XHRyZXR1cm4gRmlsdGVyLmZpZWxkKGZpZWxkLCAnbWlzc2luZycsIG51bGwpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSB0aGF0IHVzZXMgdGhlIFwicGhyYXNlXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZE9yUXVlcnkgSWYgbm8gc2Vjb25kIHN0cmluZyBhcmd1bWVudCBpcyBnaXZlbiwgdGhpc1xuXHQgKiAgIHNob3VsZCBiZSB0aGUgcXVlcnkgc3RyaW5nLCBpbiB3aGljaCBjYXNlIGFsbCBmaWVsZHMgd2lsbCBiZSBtYXRjaGVkLlxuXHQgKiAgIE90aGVyd2lzZSwgdGhpcyBzaG91bGQgYmUgdGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIG1hdGNoLlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9xdWVyeSBUaGUgcXVlcnkgc3RyaW5nLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgcGhyYXNlKGZpZWxkT3JRdWVyeSwgb3B0X3F1ZXJ5KSB7XG5cdFx0dmFyIGZpZWxkID0gY29yZS5pc1N0cmluZyhvcHRfcXVlcnkpID8gZmllbGRPclF1ZXJ5IDogRmlsdGVyLkFMTDtcblx0XHR2YXIgcXVlcnkgPSBjb3JlLmlzU3RyaW5nKG9wdF9xdWVyeSkgPyBvcHRfcXVlcnkgOiBmaWVsZE9yUXVlcnk7XG5cdFx0cmV0dXJuIEZpbHRlci5maWVsZChmaWVsZCwgJ3BocmFzZScsIHF1ZXJ5KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcImdwXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgbmFtZSBvZiB0aGUgZmllbGQuXG5cdCAqIEBwYXJhbSB7Li4uIU9iamVjdH0gcG9pbnRzIE9iamVjdHMgcmVwcmVzZW50aW5nIHBvaW50cyBpbiB0aGUgcG9seWdvbi5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIHBvbHlnb24oZmllbGQsIC4uLnBvaW50cykge1xuXHRcdHBvaW50cyA9IHBvaW50cy5tYXAocG9pbnQgPT4gRW1ib2RpZWQudG9Cb2R5KHBvaW50KSk7XG5cdFx0cmV0dXJuIEZpbHRlci5maWVsZChmaWVsZCwgJ2dwJywgcG9pbnRzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcInByZWZpeFwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGRPclF1ZXJ5IElmIG5vIHNlY29uZCBhcmd1bWVudCBpcyBnaXZlbiwgdGhpcyBzaG91bGRcblx0ICogICBiZSB0aGUgcXVlcnkgc3RyaW5nLCBpbiB3aGljaCBjYXNlIGFsbCBmaWVsZHMgd2lsbCBiZSBtYXRjaGVkLiBPdGhlcndpc2UsXG5cdCAqICAgdGhpcyBzaG91bGQgYmUgdGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIG1hdGNoLlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9xdWVyeSBUaGUgcXVlcnkgc3RyaW5nLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgcHJlZml4KGZpZWxkT3JRdWVyeSwgb3B0X3F1ZXJ5KSB7XG5cdFx0dmFyIGZpZWxkID0gb3B0X3F1ZXJ5ID8gZmllbGRPclF1ZXJ5IDogRmlsdGVyLkFMTDtcblx0XHR2YXIgcXVlcnkgPSBvcHRfcXVlcnkgPyBvcHRfcXVlcnkgOiBmaWVsZE9yUXVlcnk7XG5cdFx0cmV0dXJuIEZpbHRlci5maWVsZChmaWVsZCwgJ3ByZWZpeCcsIHF1ZXJ5KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcInJhbmdlXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQncyBuYW1lLlxuXHQgKiBAcGFyYW0geyp9IHJhbmdlT3JNaW4gRWl0aGVyIGEgYFJhbmdlYCBpbnN0YW5jZSBvciBhIHRoZSByYW5nZSdzIG1pbiB2YWx1ZS5cblx0ICogQHBhcmFtIHsqPX0gb3B0X21heCBUaGUgcmFuZ2UncyBtYXggdmFsdWUuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyByYW5nZShmaWVsZCwgcmFuZ2VPck1pbiwgb3B0X21heCkge1xuXHRcdHZhciByYW5nZSA9IHJhbmdlT3JNaW47XG5cdFx0aWYgKCEocmFuZ2UgaW5zdGFuY2VvZiBSYW5nZSkpIHtcblx0XHRcdHJhbmdlID0gUmFuZ2UucmFuZ2UocmFuZ2VPck1pbiwgb3B0X21heCk7XG5cdFx0fVxuXHRcdHJldHVybiBGaWx0ZXIuZmllbGQoZmllbGQsICdyYW5nZScsIHJhbmdlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcIn5cIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIGZpbHRlcidzIHZhbHVlLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuICAgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgcmVnZXgoZmllbGQsIHZhbHVlKSB7XG5cdFx0cmV0dXJuIG5ldyBGaWx0ZXIoZmllbGQsICd+JywgdmFsdWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSB0aGF0IHVzZXMgdGhlIFwiZ3NcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBmaWVsZCdzIG5hbWUuXG5cdCAqIEBwYXJhbSB7Li4uIU9iamVjdH0gc2hhcGVzIE9iamVjdHMgcmVwcmVzZW50aW5nIHNoYXBlcy5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIHNoYXBlKGZpZWxkLCAuLi5zaGFwZXMpIHtcblx0XHRzaGFwZXMgPSBzaGFwZXMubWFwKHNoYXBlID0+IEVtYm9kaWVkLnRvQm9keShzaGFwZSkpO1xuXHRcdHZhciB2YWx1ZSA9IHtcblx0XHRcdHR5cGU6ICdnZW9tZXRyeWNvbGxlY3Rpb24nLFxuXHRcdFx0Z2VvbWV0cmllczogc2hhcGVzXG5cdFx0fTtcblx0XHRyZXR1cm4gRmlsdGVyLmZpZWxkKGZpZWxkLCAnZ3MnLCB2YWx1ZSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIHRoYXQgdXNlcyB0aGUgXCJzaW1pbGFyXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZE9yUXVlcnkgSWYgbm8gc2Vjb25kIHN0cmluZyBhcmd1bWVudCBpcyBnaXZlbiwgdGhpc1xuXHQgKiAgIHNob3VsZCBiZSB0aGUgcXVlcnkgc3RyaW5nLCBpbiB3aGljaCBjYXNlIGFsbCBmaWVsZHMgd2lsbCBiZSBtYXRjaGVkLlxuXHQgKiAgIE90aGVyd2lzZSwgdGhpcyBzaG91bGQgYmUgdGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIG1hdGNoLlxuXHQgKiBAcGFyYW0gez9zdHJpbmd9IHF1ZXJ5IFRoZSBxdWVyeSBzdHJpbmcuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBzaW1pbGFyKGZpZWxkT3JRdWVyeSwgcXVlcnkpIHtcblx0XHR2YXIgZmllbGQgPSBjb3JlLmlzU3RyaW5nKHF1ZXJ5KSA/IGZpZWxkT3JRdWVyeSA6IEZpbHRlci5BTEw7XG5cdFx0dmFyIHZhbHVlID0ge1xuXHRcdFx0cXVlcnk6IGNvcmUuaXNTdHJpbmcocXVlcnkpID8gcXVlcnkgOiBmaWVsZE9yUXVlcnlcblx0XHR9O1xuXHRcdHJldHVybiBGaWx0ZXIuZmllbGQoZmllbGQsICdzaW1pbGFyJywgdmFsdWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSB0aGF0IHVzZXMgdGhlIFwiPFwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIGZpbHRlciBieS5cblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgZmlsdGVyJ3MgdmFsdWUuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG4gICAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBsdChmaWVsZCwgdmFsdWUpIHtcblx0XHRyZXR1cm4gbmV3IEZpbHRlcihmaWVsZCwgJzwnLCB2YWx1ZSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIHRoYXQgdXNlcyB0aGUgXCI8PVwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIGZpbHRlciBieS5cblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgZmlsdGVyJ3MgdmFsdWUuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG4gICAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBsdGUoZmllbGQsIHZhbHVlKSB7XG5cdFx0cmV0dXJuIG5ldyBGaWx0ZXIoZmllbGQsICc8PScsIHZhbHVlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcIm5vbmVcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7IShBcnJheXwuLi4qKX0gdmFsdWUgQSB2YXJpYWJsZSBhbW91bnQgb2YgdmFsdWVzIHRvIGJlIHVzZWQgd2l0aFxuXHQgKiB0aGUgXCJub25lXCIgb3BlcmF0b3IuIENhbiBiZSBwYXNzZWQgZWl0aGVyIGFzIGEgc2luZ2xlIGFycmF5IG9yIGFzXG5cdCAqIHNlcGFyYXRlIHBhcmFtcy5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIG5vbmUoZmllbGQpIHtcblx0XHR2YXIgdmFsdWVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblx0XHRpZiAodmFsdWVzLmxlbmd0aCA9PT0gMSAmJiB2YWx1ZXNbMF0gaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdFx0dmFsdWVzID0gdmFsdWVzWzBdO1xuXHRcdH1cblx0XHRyZXR1cm4gbmV3IEZpbHRlcihmaWVsZCwgJ25vbmUnLCB2YWx1ZXMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSB0aGF0IHVzZXMgdGhlIFwiIT1cIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIGZpbHRlcidzIHZhbHVlLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgbm90RXF1YWwoZmllbGQsIHZhbHVlKSB7XG5cdFx0cmV0dXJuIG5ldyBGaWx0ZXIoZmllbGQsICchPScsIHZhbHVlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcIm5vdFwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0geyFGaWx0ZXJ8c3RyaW5nfSBmaWVsZE9yRmlsdGVyIEVpdGhlciBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIG9yXG5cdCAqIHRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF9vcGVyYXRvck9yVmFsdWUgRWl0aGVyIHRoZSBmaWVsZCdzIG9wZXJhdG9yIG9yIGl0cyB2YWx1ZS5cblx0ICogQHBhcmFtIHsqPX0gb3B0X3ZhbHVlIFRoZSBmaWx0ZXIncyB2YWx1ZS5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIG5vdChmaWVsZE9yRmlsdGVyLCBvcHRfb3BlcmF0b3JPclZhbHVlLCBvcHRfdmFsdWUpIHtcblx0XHRyZXR1cm4gRmlsdGVyLnRvRmlsdGVyKGZpZWxkT3JGaWx0ZXIsIG9wdF9vcGVyYXRvck9yVmFsdWUsIG9wdF92YWx1ZSkuYWRkKCdub3QnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gZmlsdGVyIGJ5LlxuXHQgKiBAcGFyYW0geyp9IG9wZXJhdG9yT3JWYWx1ZSBJZiBhIHRoaXJkIHBhcmFtIGlzIGdpdmVuLCB0aGlzIHNob3VsZCBiZSB0aGVcblx0ICogZmlsdGVyJ3Mgb3BlcmF0b3IgKGxpa2UgXCI+PVwiKS4gT3RoZXJ3aXNlLCB0aGlzIHdpbGwgYmUgdXNlZCBhcyB0aGVcblx0ICogZmlsdGVyJ3MgdmFsdWUsIGFuZCB0aGUgZmlsdGVyJ3Mgb3BlcmF0b3Igd2lsbCBiZSBcIj1cIi5cblx0ICogQHBhcmFtIHsqPX0gb3B0X3ZhbHVlIFRoZSBmaWx0ZXIncyB2YWx1ZS5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGZpZWxkKGZpZWxkLCBvcGVyYXRvck9yVmFsdWUsIG9wdF92YWx1ZSkge1xuXHRcdHJldHVybiBuZXcgRmlsdGVyKGZpZWxkLCBvcGVyYXRvck9yVmFsdWUsIG9wdF92YWx1ZSk7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIGZpbHRlciB0byBiZSBjb21wb3NlZCB3aXRoIHRoaXMgZmlsdGVyIHVzaW5nIHRoZSBcIm9yXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7IUZpbHRlcnxzdHJpbmd9IGZpZWxkT3JGaWx0ZXIgRWl0aGVyIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2Ugb3Jcblx0ICogdGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIGZpbHRlciBieS5cblx0ICogQHBhcmFtIHsqPX0gb3B0X29wZXJhdG9yT3JWYWx1ZSBFaXRoZXIgdGhlIGZpZWxkJ3Mgb3BlcmF0b3Igb3IgaXRzIHZhbHVlLlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfdmFsdWUgVGhlIGZpbHRlcidzIHZhbHVlLlxuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cblx0b3IoZmllbGRPckZpbHRlciwgb3B0X29wZXJhdG9yT3JWYWx1ZSwgb3B0X3ZhbHVlKSB7XG5cdFx0cmV0dXJuIHRoaXMuYWRkKCdvcicsIGZpZWxkT3JGaWx0ZXIsIG9wdF9vcGVyYXRvck9yVmFsdWUsIG9wdF92YWx1ZSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgdGhlIGdpdmVuIGFyZ3VtZW50cyBpbnRvIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7IUZpbHRlcnxzdHJpbmd9IGZpZWxkT3JGaWx0ZXIgRWl0aGVyIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2Ugb3Jcblx0ICogdGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIGZpbHRlciBieS5cblx0ICogQHBhcmFtIHsqPX0gb3B0X29wZXJhdG9yT3JWYWx1ZSBFaXRoZXIgdGhlIGZpZWxkJ3Mgb3BlcmF0b3Igb3IgaXRzIHZhbHVlLlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfdmFsdWUgVGhlIGZpbHRlcidzIHZhbHVlLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuXHQgKi9cblx0c3RhdGljIHRvRmlsdGVyKGZpZWxkT3JGaWx0ZXIsIG9wdF9vcGVyYXRvck9yVmFsdWUsIG9wdF92YWx1ZSkge1xuXHRcdHZhciBmaWx0ZXIgPSBmaWVsZE9yRmlsdGVyO1xuXHRcdGlmICghKGZpbHRlciBpbnN0YW5jZW9mIEZpbHRlcikpIHtcblx0XHRcdGZpbHRlciA9IEZpbHRlci5maWVsZChmaWVsZE9yRmlsdGVyLCBvcHRfb3BlcmF0b3JPclZhbHVlLCBvcHRfdmFsdWUpO1xuXHRcdH1cblx0XHRyZXR1cm4gZmlsdGVyO1xuXHR9XG59XG5cbi8qKlxuICogU3RyaW5nIGNvbnN0YW50IHRoYXQgcmVwcmVzZW50cyBhbGwgZmllbGRzLlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBzdGF0aWNcbiAqL1xuRmlsdGVyLkFMTCA9ICcqJztcblxuZXhwb3J0IGRlZmF1bHQgRmlsdGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFBhcnNlcyB0aGUgZ2l2ZW4gdXJpIHN0cmluZyBpbnRvIGFuIG9iamVjdC5cbiAqIEBwYXJhbSB7Kj19IG9wdF91cmkgT3B0aW9uYWwgc3RyaW5nIFVSSSB0byBwYXJzZVxuICovXG5mdW5jdGlvbiBwYXJzZUZyb21BbmNob3Iob3B0X3VyaSkge1xuXHR2YXIgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcblx0bGluay5ocmVmID0gb3B0X3VyaTtcblx0cmV0dXJuIHtcblx0XHRoYXNoOiBsaW5rLmhhc2gsXG5cdFx0aG9zdG5hbWU6IGxpbmsuaG9zdG5hbWUsXG5cdFx0cGFzc3dvcmQ6IGxpbmsucGFzc3dvcmQsXG5cdFx0cGF0aG5hbWU6IGxpbmsucGF0aG5hbWVbMF0gPT09ICcvJyA/IGxpbmsucGF0aG5hbWUgOiAnLycgKyBsaW5rLnBhdGhuYW1lLFxuXHRcdHBvcnQ6IGxpbmsucG9ydCxcblx0XHRwcm90b2NvbDogbGluay5wcm90b2NvbCxcblx0XHRzZWFyY2g6IGxpbmsuc2VhcmNoLFxuXHRcdHVzZXJuYW1lOiBsaW5rLnVzZXJuYW1lXG5cdH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IHBhcnNlRnJvbUFuY2hvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHsgaXNGdW5jdGlvbiB9IGZyb20gJ21ldGFsJztcbmltcG9ydCBwYXJzZUZyb21BbmNob3IgZnJvbSAnLi9wYXJzZUZyb21BbmNob3InO1xuXG4vKipcbiAqIFBhcnNlcyB0aGUgZ2l2ZW4gdXJpIHN0cmluZyBpbnRvIGFuIG9iamVjdC4gVGhlIFVSTCBmdW5jdGlvbiB3aWxsIGJlIHVzZWRcbiAqIHdoZW4gcHJlc2VudCwgb3RoZXJ3aXNlIHdlJ2xsIGZhbGwgYmFjayB0byB0aGUgYW5jaG9yIG5vZGUgZWxlbWVudC5cbiAqIEBwYXJhbSB7Kj19IG9wdF91cmkgT3B0aW9uYWwgc3RyaW5nIFVSSSB0byBwYXJzZVxuICovXG5mdW5jdGlvbiBwYXJzZShvcHRfdXJpKSB7XG5cdGlmIChpc0Z1bmN0aW9uKFVSTCkgJiYgVVJMLmxlbmd0aCkge1xuXHRcdHJldHVybiBuZXcgVVJMKG9wdF91cmkpO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBwYXJzZUZyb21BbmNob3Iob3B0X3VyaSk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgcGFyc2U7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7IERpc3Bvc2FibGUgfSBmcm9tICdtZXRhbCc7XG5cbi8qKlxuICogQSBjYWNoZWQgcmVmZXJlbmNlIHRvIHRoZSBjcmVhdGUgZnVuY3Rpb24uXG4gKi9cbnZhciBjcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xuXG4vKipcbiAqIENhc2UgaW5zZW5zaXRpdmUgc3RyaW5nIE11bHRpbWFwIGltcGxlbWVudGF0aW9uLiBBbGxvd3MgbXVsdGlwbGUgdmFsdWVzIGZvclxuICogdGhlIHNhbWUga2V5IG5hbWUuXG4gKiBAZXh0ZW5kcyB7RGlzcG9zYWJsZX1cbiAqL1xuY2xhc3MgTXVsdGlNYXAgZXh0ZW5kcyBEaXNwb3NhYmxlIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLmtleXMgPSBjcmVhdGUobnVsbCk7XG5cdFx0dGhpcy52YWx1ZXMgPSBjcmVhdGUobnVsbCk7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyB2YWx1ZSB0byBhIGtleSBuYW1lLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuXHQgKiBAcGFyYW0geyp9IHZhbHVlXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdGFkZChuYW1lLCB2YWx1ZSkge1xuXHRcdHRoaXMua2V5c1tuYW1lLnRvTG93ZXJDYXNlKCldID0gbmFtZTtcblx0XHR0aGlzLnZhbHVlc1tuYW1lLnRvTG93ZXJDYXNlKCldID0gdGhpcy52YWx1ZXNbbmFtZS50b0xvd2VyQ2FzZSgpXSB8fCBbXTtcblx0XHR0aGlzLnZhbHVlc1tuYW1lLnRvTG93ZXJDYXNlKCldLnB1c2godmFsdWUpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIENsZWFycyBtYXAgbmFtZXMgYW5kIHZhbHVlcy5cblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0Y2xlYXIoKSB7XG5cdFx0dGhpcy5rZXlzID0gY3JlYXRlKG51bGwpO1xuXHRcdHRoaXMudmFsdWVzID0gY3JlYXRlKG51bGwpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiBtYXAgY29udGFpbnMgYSB2YWx1ZSB0byB0aGUga2V5IG5hbWUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdGNvbnRhaW5zKG5hbWUpIHtcblx0XHRyZXR1cm4gbmFtZS50b0xvd2VyQ2FzZSgpIGluIHRoaXMudmFsdWVzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBpbmhlcml0RG9jXG5cdCAqL1xuXHRkaXNwb3NlSW50ZXJuYWwoKSB7XG5cdFx0dGhpcy52YWx1ZXMgPSBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBgTXVsdGlNYXBgIGluc3RhbmNlIGZyb20gdGhlIGdpdmVuIG9iamVjdC5cblx0ICogQHBhcmFtIHshT2JqZWN0fSBvYmpcblx0ICogQHJldHVybiB7IU11bHRpTWFwfVxuXHQgKi9cblx0c3RhdGljIGZyb21PYmplY3Qob2JqKSB7XG5cdFx0dmFyIG1hcCA9IG5ldyBNdWx0aU1hcCgpO1xuXHRcdHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdG1hcC5zZXQoa2V5c1tpXSwgb2JqW2tleXNbaV1dKTtcblx0XHR9XG5cdFx0cmV0dXJuIG1hcDtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBmaXJzdCBhZGRlZCB2YWx1ZSBmcm9tIGEga2V5IG5hbWUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG5cdCAqIEByZXR1cm4geyp9XG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdGdldChuYW1lKSB7XG5cdFx0dmFyIHZhbHVlcyA9IHRoaXMudmFsdWVzW25hbWUudG9Mb3dlckNhc2UoKV07XG5cdFx0aWYgKHZhbHVlcykge1xuXHRcdFx0cmV0dXJuIHZhbHVlc1swXTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyBhbGwgdmFsdWVzIGZyb20gYSBrZXkgbmFtZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcblx0ICogQHJldHVybiB7QXJyYXkuPCo+fVxuXHQgKi9cblx0Z2V0QWxsKG5hbWUpIHtcblx0XHRyZXR1cm4gdGhpcy52YWx1ZXNbbmFtZS50b0xvd2VyQ2FzZSgpXTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIG1hcCBpcyBlbXB0eSwgZmFsc2Ugb3RoZXJ3aXNlLlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cblx0aXNFbXB0eSgpIHtcblx0XHRyZXR1cm4gdGhpcy5zaXplKCkgPT09IDA7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyBhcnJheSBvZiBrZXkgbmFtZXMuXG5cdCAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmc+fVxuXHQgKi9cblx0bmFtZXMoKSB7XG5cdFx0cmV0dXJuIE9iamVjdC5rZXlzKHRoaXMudmFsdWVzKS5tYXAoKGtleSkgPT4gdGhpcy5rZXlzW2tleV0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgYWxsIHZhbHVlcyBmcm9tIGEga2V5IG5hbWUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdHJlbW92ZShuYW1lKSB7XG5cdFx0ZGVsZXRlIHRoaXMua2V5c1tuYW1lLnRvTG93ZXJDYXNlKCldO1xuXHRcdGRlbGV0ZSB0aGlzLnZhbHVlc1tuYW1lLnRvTG93ZXJDYXNlKCldO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHZhbHVlIG9mIGEga2V5IG5hbWUuIFJlbGV2YW50IHRvIHJlcGxhY2UgdGhlIGN1cnJlbnQgdmFsdWVzIHdpdGhcblx0ICogYSBuZXcgb25lLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuXHQgKiBAcGFyYW0geyp9IHZhbHVlXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdHNldChuYW1lLCB2YWx1ZSkge1xuXHRcdHRoaXMua2V5c1tuYW1lLnRvTG93ZXJDYXNlKCldID0gbmFtZTtcblx0XHR0aGlzLnZhbHVlc1tuYW1lLnRvTG93ZXJDYXNlKCldID0gW3ZhbHVlXTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBzaXplIG9mIHRoZSBtYXAga2V5IG5hbWVzLlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuXHRzaXplKCkge1xuXHRcdHJldHVybiB0aGlzLm5hbWVzKCkubGVuZ3RoO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHBhcnNlZCB2YWx1ZXMgYXMgYSBzdHJpbmcuXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLnZhbHVlcyk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTXVsdGlNYXA7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7IGFycmF5IH0gZnJvbSAnbWV0YWwnO1xuXG4vKipcbiAqIEdlbmVyaWMgdHJlZSBub2RlIGRhdGEgc3RydWN0dXJlIHdpdGggYXJiaXRyYXJ5IG51bWJlciBvZiBjaGlsZCBub2Rlcy5cbiAqIEBwYXJhbSB7Vn0gdmFsdWUgVmFsdWUuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgVHJlZU5vZGUge1xuXG5cdGNvbnN0cnVjdG9yKHZhbHVlKSB7XG5cdFx0LyoqXG5cdFx0ICogVGhlIHZhbHVlLlxuXHRcdCAqIEBwcml2YXRlIHtWfVxuXHRcdCAqL1xuXHRcdHRoaXMudmFsdWVfID0gdmFsdWU7XG5cblx0XHQvKipcblx0XHQgKiBSZWZlcmVuY2UgdG8gdGhlIHBhcmVudCBub2RlIG9yIG51bGwgaWYgaXQgaGFzIG5vIHBhcmVudC5cblx0XHQgKiBAcHJpdmF0ZSB7VHJlZU5vZGV9XG5cdFx0ICovXG5cdFx0dGhpcy5wYXJlbnRfID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIENoaWxkIG5vZGVzIG9yIG51bGwgaW4gY2FzZSBvZiBsZWFmIG5vZGUuXG5cdFx0ICogQHByaXZhdGUge0FycmF5PCFUcmVlTm9kZT59XG5cdFx0ICovXG5cdFx0dGhpcy5jaGlsZHJlbl8gPSBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFwcGVuZHMgYSBjaGlsZCBub2RlIHRvIHRoaXMgbm9kZS5cblx0ICogQHBhcmFtIHshVHJlZU5vZGV9IGNoaWxkIE9ycGhhbiBjaGlsZCBub2RlLlxuXHQgKi9cblx0YWRkQ2hpbGQoY2hpbGQpIHtcblx0XHRhc3NlcnRDaGlsZEhhc05vUGFyZW50KGNoaWxkKTtcblx0XHRjaGlsZC5zZXRQYXJlbnQodGhpcyk7XG5cdFx0dGhpcy5jaGlsZHJlbl8gPSB0aGlzLmNoaWxkcmVuXyB8fCBbXTtcblx0XHR0aGlzLmNoaWxkcmVuXy5wdXNoKGNoaWxkKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUZWxscyB3aGV0aGVyIHRoaXMgbm9kZSBpcyB0aGUgYW5jZXN0b3Igb2YgdGhlIGdpdmVuIG5vZGUuXG5cdCAqIEBwYXJhbSB7IVRyZWVOb2RlfSBub2RlIEEgbm9kZS5cblx0ICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGlzIG5vZGUgaXMgdGhlIGFuY2VzdG9yIG9mIHtAY29kZSBub2RlfS5cblx0ICovXG5cdGNvbnRhaW5zKG5vZGUpIHtcblx0XHRsZXQgY3VycmVudCA9IG5vZGUuZ2V0UGFyZW50KCk7XG5cdFx0d2hpbGUgKGN1cnJlbnQpIHtcblx0XHRcdGlmIChjdXJyZW50ID09PSB0aGlzKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0Y3VycmVudCA9IGN1cnJlbnQuZ2V0UGFyZW50KCk7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJuIHshQXJyYXk8VHJlZU5vZGU+fSBBbGwgYW5jZXN0b3Igbm9kZXMgaW4gYm90dG9tLXVwIG9yZGVyLlxuXHQgKi9cblx0Z2V0QW5jZXN0b3JzKCkge1xuXHRcdGxldCBhbmNlc3RvcnMgPSBbXTtcblx0XHRsZXQgbm9kZSA9IHRoaXMuZ2V0UGFyZW50KCk7XG5cdFx0d2hpbGUgKG5vZGUpIHtcblx0XHRcdGFuY2VzdG9ycy5wdXNoKG5vZGUpO1xuXHRcdFx0bm9kZSA9IG5vZGUuZ2V0UGFyZW50KCk7XG5cdFx0fVxuXHRcdHJldHVybiBhbmNlc3RvcnM7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgY2hpbGQgbm9kZSBvZiB0aGlzIG5vZGUgYXQgdGhlIGdpdmVuIGluZGV4LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggQ2hpbGQgaW5kZXguXG5cdCAqIEByZXR1cm4gez9UcmVlTm9kZX0gVGhlIG5vZGUgYXQgdGhlIGdpdmVuIGluZGV4XG5cdCAqIG9yIG51bGwgaWYgbm90IGZvdW5kLlxuXHQgKi9cblx0Z2V0Q2hpbGRBdChpbmRleCkge1xuXHRcdHJldHVybiB0aGlzLmdldENoaWxkcmVuKClbaW5kZXhdIHx8IG51bGw7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybiB7P0FycmF5PCFUcmVlTm9kZT59IENoaWxkIG5vZGVzIG9yIG51bGwgaW4gY2FzZSBvZiBsZWFmIG5vZGUuXG5cdCAqL1xuXHRnZXRDaGlsZHJlbigpIHtcblx0XHRyZXR1cm4gdGhpcy5jaGlsZHJlbl8gfHwgVHJlZU5vZGUuRU1QVFlfQVJSQVk7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuLlxuXHQgKi9cblx0Z2V0Q2hpbGRDb3VudCgpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRDaGlsZHJlbigpLmxlbmd0aDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgYW5jZXN0b3JzIG9mIHRoZSBub2RlLlxuXHQgKi9cblx0Z2V0RGVwdGgoKSB7XG5cdFx0bGV0IGRlcHRoID0gMDtcblx0XHRsZXQgbm9kZSA9IHRoaXM7XG5cdFx0d2hpbGUgKG5vZGUuZ2V0UGFyZW50KCkpIHtcblx0XHRcdGRlcHRoKys7XG5cdFx0XHRub2RlID0gbm9kZS5nZXRQYXJlbnQoKTtcblx0XHR9XG5cdFx0cmV0dXJuIGRlcHRoO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm4gez9UcmVlTm9kZX0gUGFyZW50IG5vZGUgb3IgbnVsbCBpZiBpdCBoYXMgbm8gcGFyZW50LlxuXHQgKi9cblx0Z2V0UGFyZW50KCkge1xuXHRcdHJldHVybiB0aGlzLnBhcmVudF87XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybiB7IVRyZWVOb2RlfSBUaGUgcm9vdCBvZiB0aGUgdHJlZSBzdHJ1Y3R1cmUsIGkuZS4gdGhlIGZhcnRoZXN0XG5cdCAqIGFuY2VzdG9yIG9mIHRoZSBub2RlIG9yIHRoZSBub2RlIGl0c2VsZiBpZiBpdCBoYXMgbm8gcGFyZW50cy5cblx0ICovXG5cdGdldFJvb3QoKSB7XG5cdFx0bGV0IHJvb3QgPSB0aGlzO1xuXHRcdHdoaWxlIChyb290LmdldFBhcmVudCgpKSB7XG5cdFx0XHRyb290ID0gcm9vdC5nZXRQYXJlbnQoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJvb3Q7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgdmFsdWUuXG5cdCAqIEByZXR1cm4ge1Z9IFRoZSB2YWx1ZS5cblx0ICovXG5cdGdldFZhbHVlKCkge1xuXHRcdHJldHVybiB0aGlzLnZhbHVlXztcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBub2RlIGlzIGEgbGVhZiBub2RlLlxuXHQgKi9cblx0aXNMZWFmKCkge1xuXHRcdHJldHVybiAhdGhpcy5nZXRDaGlsZENvdW50KCk7XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlcyB0aGUgZ2l2ZW4gY2hpbGQgbm9kZSBvZiB0aGlzIG5vZGUuXG5cdCAqIEBwYXJhbSB7VHJlZU5vZGV9IGNoaWxkIFRoZSBub2RlIHRvIHJlbW92ZS5cblx0ICogQHJldHVybiB7VHJlZU5vZGV9IFRoZSByZW1vdmVkIG5vZGUgaWYgYW55LCBudWxsIG90aGVyd2lzZS5cblx0ICovXG5cdHJlbW92ZUNoaWxkKGNoaWxkKSB7XG5cdFx0aWYgKGFycmF5LnJlbW92ZSh0aGlzLmdldENoaWxkcmVuKCksIGNoaWxkKSkge1xuXHRcdFx0cmV0dXJuIGNoaWxkO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBwYXJlbnQgbm9kZSBvZiB0aGlzIG5vZGUuIFRoZSBjYWxsZXJzIG11c3QgZW5zdXJlIHRoYXQgdGhlXG5cdCAqIHBhcmVudCBub2RlIGFuZCBvbmx5IHRoYXQgaGFzIHRoaXMgbm9kZSBhbW9uZyBpdHMgY2hpbGRyZW4uXG5cdCAqIEBwYXJhbSB7VHJlZU5vZGV9IHBhcmVudCBUaGUgcGFyZW50IHRvIHNldC4gSWYgbnVsbCwgdGhlIG5vZGUgd2lsbCBiZVxuXHQgKiBkZXRhY2hlZCBmcm9tIHRoZSB0cmVlLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRzZXRQYXJlbnQocGFyZW50KSB7XG5cdFx0dGhpcy5wYXJlbnRfID0gcGFyZW50O1xuXHR9XG5cblx0LyoqXG5cdCAqIFRyYXZlcnNlcyB0aGUgc3VidHJlZS4gVGhlIGZpcnN0IGNhbGxiYWNrIHN0YXJ0cyB3aXRoIHRoaXMgbm9kZSxcblx0ICogYW5kIHZpc2l0cyB0aGUgZGVzY2VuZGFudCBub2RlcyBkZXB0aC1maXJzdCwgaW4gcHJlb3JkZXIuXG5cdCAqIFRoZSBzZWNvbmQgY2FsbGJhY2ssIHN0YXJ0cyB3aXRoIGRlZXBlc3QgY2hpbGQgdGhlbiB2aXNpdHNcblx0ICogdGhlIGFuY2VzdG9yIG5vZGVzIGRlcHRoLWZpcnN0LCBpbiBwb3N0b3JkZXIuIEUuZy5cblx0ICpcblx0ICogIFx0IEFcblx0ICogICAgLyBcXFxuXHQgKiAgIEIgICBDXG5cdCAqICAvICAgLyBcXFxuXHQgKiBEICAgRSAgIEZcblx0ICpcblx0ICogcHJlb3JkZXIgLT4gWydBJywgJ0InLCAnRCcsICdDJywgJ0UnLCAnRiddXG5cdCAqIHBvc3RvcmRlciAtPiBbJ0QnLCAnQicsICdFJywgJ0YnLCAnQycsICdBJ11cblx0ICpcblx0ICogQHBhcmFtIHtmdW5jdGlvbj19IG9wdF9wcmVvcmRlckZuIFRoZSBjYWxsYmFjayB0byBleGVjdXRlIHdoZW4gdmlzaXRpbmcgYSBub2RlLlxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9uPX0gb3B0X3Bvc3RvcmRlckZuIFRoZSBjYWxsYmFjayB0byBleGVjdXRlIGJlZm9yZSBsZWF2aW5nIGEgbm9kZS5cblx0ICovXG5cdHRyYXZlcnNlKG9wdF9wcmVvcmRlckZuLCBvcHRfcG9zdG9yZGVyRm4pIHtcblx0XHRpZiAob3B0X3ByZW9yZGVyRm4pIHtcblx0XHRcdG9wdF9wcmVvcmRlckZuKHRoaXMpO1xuXHRcdH1cblx0XHR0aGlzLmdldENoaWxkcmVuKCkuZm9yRWFjaCgoY2hpbGQpID0+IGNoaWxkLnRyYXZlcnNlKG9wdF9wcmVvcmRlckZuLCBvcHRfcG9zdG9yZGVyRm4pKTtcblx0XHRpZiAob3B0X3Bvc3RvcmRlckZuKSB7XG5cdFx0XHRvcHRfcG9zdG9yZGVyRm4odGhpcyk7XG5cdFx0fVxuXHR9XG5cbn1cblxuLyoqXG4gKiBDb25zdGFudCBmb3IgZW1wdHkgYXJyYXkgdG8gYXZvaWQgdW5uZWNlc3NhcnkgYWxsb2NhdGlvbnMuXG4gKiBAcHJpdmF0ZVxuICovXG5UcmVlTm9kZS5FTVBUWV9BUlJBWSA9IFtdO1xuXG4vKipcbiAqIEFzc2VydHMgdGhhdCBjaGlsZCBoYXMgbm8gcGFyZW50LlxuICogQHBhcmFtIHtUcmVlTm9kZX0gY2hpbGQgQSBjaGlsZC5cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGFzc2VydENoaWxkSGFzTm9QYXJlbnQgPSBmdW5jdGlvbihjaGlsZCkge1xuXHRpZiAoY2hpbGQuZ2V0UGFyZW50KCkpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhZGQgY2hpbGQgd2l0aCBwYXJlbnQuJyk7XG5cdH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IFRyZWVOb2RlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgeyBpc0RlZiwgc3RyaW5nIH0gZnJvbSAnbWV0YWwnO1xuaW1wb3J0IHBhcnNlIGZyb20gJy4vcGFyc2UnO1xuaW1wb3J0IHsgTXVsdGlNYXAgfSBmcm9tICdtZXRhbC1zdHJ1Y3RzJztcblxudmFyIHBhcnNlRm5fID0gcGFyc2U7XG5cbmNsYXNzIFVyaSB7XG5cblx0LyoqXG5cdCAqIFRoaXMgY2xhc3MgY29udGFpbnMgc2V0dGVycyBhbmQgZ2V0dGVycyBmb3IgdGhlIHBhcnRzIG9mIHRoZSBVUkkuXG5cdCAqIFRoZSBmb2xsb3dpbmcgZmlndXJlIGRpc3BsYXlzIGFuIGV4YW1wbGUgVVJJcyBhbmQgdGhlaXIgY29tcG9uZW50IHBhcnRzLlxuXHQgKlxuXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoXG5cdCAqXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUjOKUgOKUgOKUgOKUtOKUgOKUgOKUgOKUgOKUkFxuXHQgKlx0ICBhYmM6Ly9leGFtcGxlLmNvbToxMjMvcGF0aC9kYXRhP2tleT12YWx1ZSNmcmFnaWQxXG5cdCAqXHQgIOKUlOKUrOKUmCAgIOKUlOKUgOKUgOKUgOKUgOKUrOKUgOKUgOKUgOKUgOKUmCDilJTilKzilJggICAgICAgICAgIOKUlOKUgOKUgOKUgOKUrOKUgOKUgOKUgOKUmCDilJTilIDilIDilKzilIDilIDilJhcblx0ICogcHJvdG9jb2wgIGhvc3RuYW1lICBwb3J0ICAgICAgICAgICAgc2VhcmNoICAgIGhhc2hcblx0ICogICAgICAgICAg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSs4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYXG5cdCAqICAgICAgICAgICAgICAgIGhvc3Rcblx0ICpcblx0ICogQHBhcmFtIHsqPX0gb3B0X3VyaSBPcHRpb25hbCBzdHJpbmcgVVJJIHRvIHBhcnNlXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0Y29uc3RydWN0b3Iob3B0X3VyaSA9ICcnKSB7XG5cdFx0dGhpcy51cmwgPSBVcmkucGFyc2UodGhpcy5tYXliZUFkZFByb3RvY29sQW5kSG9zdG5hbWVfKG9wdF91cmkpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIHBhcmFtZXRlcnMgdG8gdXJpIGZyb20gYSA8Y29kZT5NdWx0aU1hcDwvY29kZT4gYXMgc291cmNlLlxuXHQgKiBAcGFyYW0ge011bHRpTWFwfSBtdWx0aW1hcCBUaGUgPGNvZGU+TXVsdGlNYXA8L2NvZGU+IGNvbnRhaW5pbmcgdGhlXG5cdCAqICAgcGFyYW1ldGVycy5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRhZGRQYXJhbWV0ZXJzRnJvbU11bHRpTWFwKG11bHRpbWFwKSB7XG5cdFx0bXVsdGltYXAubmFtZXMoKS5mb3JFYWNoKChuYW1lKSA9PiB7XG5cdFx0XHRtdWx0aW1hcC5nZXRBbGwobmFtZSkuZm9yRWFjaCgodmFsdWUpID0+IHtcblx0XHRcdFx0dGhpcy5hZGRQYXJhbWV0ZXJWYWx1ZShuYW1lLCB2YWx1ZSk7XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIHRoZSB2YWx1ZSBvZiB0aGUgbmFtZWQgcXVlcnkgcGFyYW1ldGVycy5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcGFyYW1ldGVyIHRvIHNldC5cblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgbmV3IHZhbHVlLiBXaWxsIGJlIGV4cGxpY2l0bHkgY2FzdGVkIHRvIFN0cmluZy5cblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0YWRkUGFyYW1ldGVyVmFsdWUobmFtZSwgdmFsdWUpIHtcblx0XHR0aGlzLmVuc3VyZVF1ZXJ5SW5pdGlhbGl6ZWRfKCk7XG5cdFx0aWYgKGlzRGVmKHZhbHVlKSkge1xuXHRcdFx0dmFsdWUgPSBTdHJpbmcodmFsdWUpO1xuXHRcdH1cblx0XHR0aGlzLnF1ZXJ5LmFkZChuYW1lLCB2YWx1ZSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyB0aGUgdmFsdWVzIG9mIHRoZSBuYW1lZCBxdWVyeSBwYXJhbWV0ZXIuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHBhcmFtZXRlciB0byBzZXQuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIG5ldyB2YWx1ZS5cblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0YWRkUGFyYW1ldGVyVmFsdWVzKG5hbWUsIHZhbHVlcykge1xuXHRcdHZhbHVlcy5mb3JFYWNoKCh2YWx1ZSkgPT4gdGhpcy5hZGRQYXJhbWV0ZXJWYWx1ZShuYW1lLCB2YWx1ZSkpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEVuc3VyZXMgcXVlcnkgaW50ZXJuYWwgbWFwIGlzIGluaXRpYWxpemVkIGFuZCBzeW5jZWQgd2l0aCBpbml0aWFsIHZhbHVlXG5cdCAqIGV4dHJhY3RlZCBmcm9tIFVSSSBzZWFyY2ggcGFydC5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0ZW5zdXJlUXVlcnlJbml0aWFsaXplZF8oKSB7XG5cdFx0aWYgKHRoaXMucXVlcnkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5xdWVyeSA9IG5ldyBNdWx0aU1hcCgpO1xuXHRcdHZhciBzZWFyY2ggPSB0aGlzLnVybC5zZWFyY2g7XG5cdFx0aWYgKHNlYXJjaCkge1xuXHRcdFx0c2VhcmNoLnN1YnN0cmluZygxKS5zcGxpdCgnJicpLmZvckVhY2goKHBhcmFtKSA9PiB7XG5cdFx0XHRcdHZhciBba2V5LCB2YWx1ZV0gPSBwYXJhbS5zcGxpdCgnPScpO1xuXHRcdFx0XHRpZiAoaXNEZWYodmFsdWUpKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBVcmkudXJsRGVjb2RlKHZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmFkZFBhcmFtZXRlclZhbHVlKGtleSwgdmFsdWUpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGhhc2ggcGFydCBvZiB1cmkuXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdGdldEhhc2goKSB7XG5cdFx0cmV0dXJuIHRoaXMudXJsLmhhc2ggfHwgJyc7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgaG9zdCBwYXJ0IG9mIHVyaS4gRS5nLiA8Y29kZT5baG9zdG5hbWVdOltwb3J0XTwvY29kZT4uXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdGdldEhvc3QoKSB7XG5cdFx0dmFyIGhvc3QgPSB0aGlzLmdldEhvc3RuYW1lKCk7XG5cdFx0aWYgKGhvc3QpIHtcblx0XHRcdHZhciBwb3J0ID0gdGhpcy5nZXRQb3J0KCk7XG5cdFx0XHRpZiAocG9ydCAmJiBwb3J0ICE9PSAnODAnKSB7XG5cdFx0XHRcdGhvc3QgKz0gJzonICsgcG9ydDtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGhvc3Q7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgaG9zdG5hbWUgcGFydCBvZiB1cmkgd2l0aG91dCBwcm90b2NvbCBhbmQgcG9ydC5cblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cblx0Z2V0SG9zdG5hbWUoKSB7XG5cdFx0dmFyIGhvc3RuYW1lID0gdGhpcy51cmwuaG9zdG5hbWU7XG5cdFx0aWYgKGhvc3RuYW1lID09PSBVcmkuSE9TVE5BTUVfUExBQ0VIT0xERVIpIHtcblx0XHRcdHJldHVybiAnJztcblx0XHR9XG5cdFx0cmV0dXJuIGhvc3RuYW1lO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIG9yaWdpbiBwYXJ0IG9mIHVyaS4gRS5nLiA8Y29kZT5odHRwOi8vW2hvc3RuYW1lXTpbcG9ydF08L2NvZGU+LlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuXHRnZXRPcmlnaW4oKSB7XG5cdFx0dmFyIGhvc3QgPSB0aGlzLmdldEhvc3QoKTtcblx0XHRpZiAoaG9zdCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0UHJvdG9jb2woKSArICcvLycgKyBob3N0O1xuXHRcdH1cblx0XHRyZXR1cm4gJyc7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgZmlyc3QgdmFsdWUgZm9yIGEgZ2l2ZW4gcGFyYW1ldGVyIG9yIHVuZGVmaW5lZCBpZiB0aGUgZ2l2ZW5cblx0ICogcGFyYW1ldGVyIG5hbWUgZG9lcyBub3QgYXBwZWFyIGluIHRoZSBxdWVyeSBzdHJpbmcuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbU5hbWUgVW5lc2NhcGVkIHBhcmFtZXRlciBuYW1lLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd8dW5kZWZpbmVkfSBUaGUgZmlyc3QgdmFsdWUgZm9yIGEgZ2l2ZW4gcGFyYW1ldGVyIG9yXG5cdCAqICAgdW5kZWZpbmVkIGlmIHRoZSBnaXZlbiBwYXJhbWV0ZXIgbmFtZSBkb2VzIG5vdCBhcHBlYXIgaW4gdGhlIHF1ZXJ5XG5cdCAqICAgc3RyaW5nLlxuXHQgKi9cblx0Z2V0UGFyYW1ldGVyVmFsdWUobmFtZSkge1xuXHRcdHRoaXMuZW5zdXJlUXVlcnlJbml0aWFsaXplZF8oKTtcblx0XHRyZXR1cm4gdGhpcy5xdWVyeS5nZXQobmFtZSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgdmFsdWU8Yj5zPC9iPiBmb3IgYSBnaXZlbiBwYXJhbWV0ZXIgYXMgYSBsaXN0IG9mIGRlY29kZWRcblx0ICogcXVlcnkgcGFyYW1ldGVyIHZhbHVlcy5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIHBhcmFtZXRlciB0byBnZXQgdmFsdWVzIGZvci5cblx0ICogQHJldHVybiB7IUFycmF5PD8+fSBUaGUgdmFsdWVzIGZvciBhIGdpdmVuIHBhcmFtZXRlciBhcyBhIGxpc3Qgb2YgZGVjb2RlZFxuXHQgKiAgIHF1ZXJ5IHBhcmFtZXRlciB2YWx1ZXMuXG5cdCAqL1xuXHRnZXRQYXJhbWV0ZXJWYWx1ZXMobmFtZSkge1xuXHRcdHRoaXMuZW5zdXJlUXVlcnlJbml0aWFsaXplZF8oKTtcblx0XHRyZXR1cm4gdGhpcy5xdWVyeS5nZXRBbGwobmFtZSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbmFtZTxiPnM8L2I+IG9mIHRoZSBwYXJhbWV0ZXJzLlxuXHQgKiBAcmV0dXJuIHshQXJyYXk8c3RyaW5nPn0gVGhlIG5hbWVzIGZvciB0aGUgcGFyYW1ldGVycyBhcyBhIGxpc3Qgb2Zcblx0ICogICBzdHJpbmdzLlxuXHQgKi9cblx0Z2V0UGFyYW1ldGVyTmFtZXMoKSB7XG5cdFx0dGhpcy5lbnN1cmVRdWVyeUluaXRpYWxpemVkXygpO1xuXHRcdHJldHVybiB0aGlzLnF1ZXJ5Lm5hbWVzKCk7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgZnVuY3Rpb24gY3VycmVudGx5IGJlaW5nIHVzZWQgdG8gcGFyc2UgVVJJcy5cblx0ICogQHJldHVybiB7IWZ1bmN0aW9uKCl9XG5cdCAqL1xuXHRzdGF0aWMgZ2V0UGFyc2VGbigpIHtcblx0XHRyZXR1cm4gcGFyc2VGbl87XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgcGF0aG5hbWUgcGFydCBvZiB1cmkuXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdGdldFBhdGhuYW1lKCkge1xuXHRcdHJldHVybiB0aGlzLnVybC5wYXRobmFtZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBwb3J0IG51bWJlciBwYXJ0IG9mIHVyaSBhcyBzdHJpbmcuXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdGdldFBvcnQoKSB7XG5cdFx0cmV0dXJuIHRoaXMudXJsLnBvcnQ7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgcHJvdG9jb2wgcGFydCBvZiB1cmkuIEUuZy4gPGNvZGU+aHR0cDo8L2NvZGU+LlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuXHRnZXRQcm90b2NvbCgpIHtcblx0XHRyZXR1cm4gdGhpcy51cmwucHJvdG9jb2w7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgc2VhcmNoIHBhcnQgb2YgdXJpLiBTZWFyY2ggdmFsdWUgaXMgcmV0cmlldmVkIGZyb20gcXVlcnlcblx0ICogcGFyYW1ldGVycy5cblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cblx0Z2V0U2VhcmNoKCkge1xuXHRcdHZhciBzZWFyY2ggPSAnJztcblx0XHR2YXIgcXVlcnlzdHJpbmcgPSAnJztcblx0XHR0aGlzLmdldFBhcmFtZXRlck5hbWVzKCkuZm9yRWFjaCgobmFtZSkgPT4ge1xuXHRcdFx0dGhpcy5nZXRQYXJhbWV0ZXJWYWx1ZXMobmFtZSkuZm9yRWFjaCgodmFsdWUpID0+IHtcblx0XHRcdFx0cXVlcnlzdHJpbmcgKz0gbmFtZTtcblx0XHRcdFx0aWYgKGlzRGVmKHZhbHVlKSkge1xuXHRcdFx0XHRcdHF1ZXJ5c3RyaW5nICs9ICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cXVlcnlzdHJpbmcgKz0gJyYnO1xuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdFx0cXVlcnlzdHJpbmcgPSBxdWVyeXN0cmluZy5zbGljZSgwLCAtMSk7XG5cdFx0aWYgKHF1ZXJ5c3RyaW5nKSB7XG5cdFx0XHRzZWFyY2ggKz0gJz8nICsgcXVlcnlzdHJpbmc7XG5cdFx0fVxuXHRcdHJldHVybiBzZWFyY2g7XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIHVyaSBjb250YWlucyB0aGUgcGFyYW1ldGVyLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cblx0aGFzUGFyYW1ldGVyKG5hbWUpIHtcblx0XHR0aGlzLmVuc3VyZVF1ZXJ5SW5pdGlhbGl6ZWRfKCk7XG5cdFx0cmV0dXJuIHRoaXMucXVlcnkuY29udGFpbnMobmFtZSk7XG5cdH1cblxuXHQvKipcblx0ICogTWFrZXMgdGhpcyBVUkwgdW5pcXVlIGJ5IGFkZGluZyBhIHJhbmRvbSBwYXJhbSB0byBpdC4gVXNlZnVsIGZvciBhdm9pZGluZ1xuXHQgKiBjYWNoZS5cblx0ICovXG5cdG1ha2VVbmlxdWUoKSB7XG5cdFx0dGhpcy5zZXRQYXJhbWV0ZXJWYWx1ZShVcmkuUkFORE9NX1BBUkFNLCBzdHJpbmcuZ2V0UmFuZG9tU3RyaW5nKCkpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIE1heWJlIGFkZHMgcHJvdG9jb2wgYW5kIGEgaG9zdG5hbWUgcGxhY2Vob2xkZXIgb24gYSBwYXJpYWwgVVJJIGlmIG5lZWRlZC5cblx0ICogUmVsZXZlbnQgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCA8Y29kZT5VUkw8L2NvZGU+IG5hdGl2ZSBvYmplY3QuXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X3VyaVxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9IFVSSSB3aXRoIHByb3RvY29sIGFuZCBob3N0bmFtZSBwbGFjZWhvbGRlci5cblx0ICovXG5cdG1heWJlQWRkUHJvdG9jb2xBbmRIb3N0bmFtZV8ob3B0X3VyaSkge1xuXHRcdHZhciB1cmwgPSBvcHRfdXJpO1xuXHRcdGlmIChvcHRfdXJpLmluZGV4T2YoJzovLycpID09PSAtMSAmJlxuXHRcdFx0b3B0X3VyaS5pbmRleE9mKCdqYXZhc2NyaXB0OicpICE9PSAwKSB7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuXG5cdFx0XHR1cmwgPSBVcmkuREVGQVVMVF9QUk9UT0NPTDtcblx0XHRcdGlmIChvcHRfdXJpWzBdICE9PSAnLycgfHwgb3B0X3VyaVsxXSAhPT0gJy8nKSB7XG5cdFx0XHRcdHVybCArPSAnLy8nO1xuXHRcdFx0fVxuXG5cdFx0XHRzd2l0Y2ggKG9wdF91cmkuY2hhckF0KDApKSB7XG5cdFx0XHRcdGNhc2UgJy4nOlxuXHRcdFx0XHRjYXNlICc/Jzpcblx0XHRcdFx0Y2FzZSAnIyc6XG5cdFx0XHRcdFx0dXJsICs9IFVyaS5IT1NUTkFNRV9QTEFDRUhPTERFUjtcblx0XHRcdFx0XHR1cmwgKz0gJy8nO1xuXHRcdFx0XHRcdHVybCArPSBvcHRfdXJpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICcnOlxuXHRcdFx0XHRjYXNlICcvJzpcblx0XHRcdFx0XHRpZiAob3B0X3VyaVsxXSAhPT0gJy8nKSB7XG5cdFx0XHRcdFx0XHR1cmwgKz0gVXJpLkhPU1ROQU1FX1BMQUNFSE9MREVSO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR1cmwgKz0gb3B0X3VyaTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHR1cmwgKz0gb3B0X3VyaTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHVybDtcblx0fVxuXG5cdC8qKlxuXHQgKiBOb3JtYWxpemVzIHRoZSBwYXJzZWQgb2JqZWN0IHRvIGJlIGluIHRoZSBleHBlY3RlZCBzdGFuZGFyZC5cblx0ICogQHBhcmFtIHshT2JqZWN0fVxuXHQgKi9cblx0c3RhdGljIG5vcm1hbGl6ZU9iamVjdChwYXJzZWQpIHtcblx0XHR2YXIgbGVuZ3RoID0gcGFyc2VkLnBhdGhuYW1lID8gcGFyc2VkLnBhdGhuYW1lLmxlbmd0aCA6IDA7XG5cdFx0aWYgKGxlbmd0aCA+IDEgJiYgcGFyc2VkLnBhdGhuYW1lW2xlbmd0aCAtIDFdID09PSAnLycpIHtcblx0XHRcdHBhcnNlZC5wYXRobmFtZSA9IHBhcnNlZC5wYXRobmFtZS5zdWJzdHIoMCwgbGVuZ3RoIC0gMSk7XG5cdFx0fVxuXHRcdHJldHVybiBwYXJzZWQ7XG5cdH1cblxuXHQvKipcblx0ICogUGFyc2VzIHRoZSBnaXZlbiB1cmkgc3RyaW5nIGludG8gYW4gb2JqZWN0LlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfdXJpIE9wdGlvbmFsIHN0cmluZyBVUkkgdG8gcGFyc2Vcblx0ICovXG5cdHN0YXRpYyBwYXJzZShvcHRfdXJpKSB7XG5cdFx0cmV0dXJuIFVyaS5ub3JtYWxpemVPYmplY3QocGFyc2VGbl8ob3B0X3VyaSkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgdGhlIG5hbWVkIHF1ZXJ5IHBhcmFtZXRlci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIHBhcmFtZXRlciB0byByZW1vdmUuXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdHJlbW92ZVBhcmFtZXRlcihuYW1lKSB7XG5cdFx0dGhpcy5lbnN1cmVRdWVyeUluaXRpYWxpemVkXygpO1xuXHRcdHRoaXMucXVlcnkucmVtb3ZlKG5hbWUpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgdW5pcXVlbmVzcyBwYXJhbWV0ZXIgb2YgdGhlIHVyaS5cblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0cmVtb3ZlVW5pcXVlKCkge1xuXHRcdHRoaXMucmVtb3ZlUGFyYW1ldGVyKFVyaS5SQU5ET01fUEFSQU0pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGhhc2guXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBoYXNoXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdHNldEhhc2goaGFzaCkge1xuXHRcdHRoaXMudXJsLmhhc2ggPSBoYXNoO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGhvc3RuYW1lLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaG9zdG5hbWVcblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0c2V0SG9zdG5hbWUoaG9zdG5hbWUpIHtcblx0XHR0aGlzLnVybC5ob3N0bmFtZSA9IGhvc3RuYW1lO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHZhbHVlIG9mIHRoZSBuYW1lZCBxdWVyeSBwYXJhbWV0ZXJzLCBjbGVhcmluZyBwcmV2aW91cyB2YWx1ZXNcblx0ICogZm9yIHRoYXQga2V5LlxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBwYXJhbWV0ZXIgdG8gc2V0LlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBuZXcgdmFsdWUuXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdHNldFBhcmFtZXRlclZhbHVlKG5hbWUsIHZhbHVlKSB7XG5cdFx0dGhpcy5yZW1vdmVQYXJhbWV0ZXIobmFtZSk7XG5cdFx0dGhpcy5hZGRQYXJhbWV0ZXJWYWx1ZShuYW1lLCB2YWx1ZSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgdmFsdWVzIG9mIHRoZSBuYW1lZCBxdWVyeSBwYXJhbWV0ZXJzLCBjbGVhcmluZyBwcmV2aW91cyB2YWx1ZXNcblx0ICogZm9yIHRoYXQga2V5LlxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBwYXJhbWV0ZXIgdG8gc2V0LlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBuZXcgdmFsdWUuXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdHNldFBhcmFtZXRlclZhbHVlcyhuYW1lLCB2YWx1ZXMpIHtcblx0XHR0aGlzLnJlbW92ZVBhcmFtZXRlcihuYW1lKTtcblx0XHR2YWx1ZXMuZm9yRWFjaCgodmFsdWUpID0+IHRoaXMuYWRkUGFyYW1ldGVyVmFsdWUobmFtZSwgdmFsdWUpKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBwYXRobmFtZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHBhdGhuYW1lXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdHNldFBhdGhuYW1lKHBhdGhuYW1lKSB7XG5cdFx0dGhpcy51cmwucGF0aG5hbWUgPSBwYXRobmFtZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBwb3J0IG51bWJlci5cblx0ICogQHBhcmFtIHsqfSBwb3J0IFBvcnQgbnVtYmVyLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRzZXRQb3J0KHBvcnQpIHtcblx0XHR0aGlzLnVybC5wb3J0ID0gcG9ydDtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgcGFyc2luZyB0aGUgb3JpZ2luYWwgc3RyaW5nIHVyaVxuXHQgKiBpbnRvIGFuIG9iamVjdC5cblx0ICogQHBhcmFtIHshZnVuY3Rpb24oKX0gcGFyc2VGblxuXHQgKi9cblx0c3RhdGljIHNldFBhcnNlRm4ocGFyc2VGbikge1xuXHRcdHBhcnNlRm5fID0gcGFyc2VGbjtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBwcm90b2NvbC4gSWYgbWlzc2luZyA8Y29kZT5odHRwOjwvY29kZT4gaXMgdXNlZCBhcyBkZWZhdWx0LlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gcHJvdG9jb2xcblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0c2V0UHJvdG9jb2wocHJvdG9jb2wpIHtcblx0XHR0aGlzLnVybC5wcm90b2NvbCA9IHByb3RvY29sO1xuXHRcdGlmICh0aGlzLnVybC5wcm90b2NvbFt0aGlzLnVybC5wcm90b2NvbC5sZW5ndGggLSAxXSAhPT0gJzonKSB7XG5cdFx0XHR0aGlzLnVybC5wcm90b2NvbCArPSAnOic7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHN0cmluZyBmb3JtIG9mIHRoZSB1cmwuXG5cdCAqIEBvdmVycmlkZVxuXHQgKi9cblx0dG9TdHJpbmcoKSB7XG5cdFx0dmFyIGhyZWYgPSAnJztcblx0XHR2YXIgaG9zdCA9IHRoaXMuZ2V0SG9zdCgpO1xuXHRcdGlmIChob3N0KSB7XG5cdFx0XHRocmVmICs9IHRoaXMuZ2V0UHJvdG9jb2woKSArICcvLyc7XG5cdFx0fVxuXHRcdGhyZWYgKz0gaG9zdCArIHRoaXMuZ2V0UGF0aG5hbWUoKSArIHRoaXMuZ2V0U2VhcmNoKCkgKyB0aGlzLmdldEhhc2goKTtcblx0XHRyZXR1cm4gaHJlZjtcblx0fVxuXG5cdC8qKlxuXHQgKiBKb2lucyB0aGUgZ2l2ZW4gcGF0aHMuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlUGF0aFxuXHQgKiBAcGFyYW0gey4uLnN0cmluZ30gLi4ucGF0aHMgQW55IG51bWJlciBvZiBwYXRocyB0byBiZSBqb2luZWQgd2l0aCB0aGUgYmFzZSB1cmwuXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBqb2luUGF0aHMoYmFzZVBhdGgsIC4uLnBhdGhzKSB7XG5cdFx0aWYgKGJhc2VQYXRoLmNoYXJBdChiYXNlUGF0aC5sZW5ndGggLSAxKSA9PT0gJy8nKSB7XG5cdFx0XHRiYXNlUGF0aCA9IGJhc2VQYXRoLnN1YnN0cmluZygwLCBiYXNlUGF0aC5sZW5ndGggLSAxKTtcblx0XHR9XG5cdFx0cGF0aHMgPSBwYXRocy5tYXAocGF0aCA9PiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nID8gcGF0aC5zdWJzdHJpbmcoMSkgOiBwYXRoKTtcblx0XHRyZXR1cm4gW2Jhc2VQYXRoXS5jb25jYXQocGF0aHMpLmpvaW4oJy8nKS5yZXBsYWNlKC9cXC8kLywgJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFVSTC1kZWNvZGVzIHRoZSBzdHJpbmcuIFdlIG5lZWQgdG8gc3BlY2lhbGx5IGhhbmRsZSAnKydzIGJlY2F1c2Vcblx0ICogdGhlIGphdmFzY3JpcHQgbGlicmFyeSBkb2Vzbid0IGNvbnZlcnQgdGhlbSB0byBzcGFjZXMuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byB1cmwgZGVjb2RlLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBkZWNvZGVkIHtAY29kZSBzdHJ9LlxuXHQgKi9cblx0c3RhdGljIHVybERlY29kZShzdHIpIHtcblx0XHRyZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHN0ci5yZXBsYWNlKC9cXCsvZywgJyAnKSk7XG5cdH1cblxufVxuXG4vKipcbiAqIERlZmF1bHQgcHJvdG9jb2wgdmFsdWUuXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQGRlZmF1bHQgaHR0cDpcbiAqIEBzdGF0aWNcbiAqL1xuVXJpLkRFRkFVTFRfUFJPVE9DT0wgPSAnaHR0cDonO1xuXG4vKipcbiAqIEhvc3RuYW1lIHBsYWNlaG9sZGVyLiBSZWxldmFudCB0byBpbnRlcm5hbCB1c2FnZSBvbmx5LlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBzdGF0aWNcbiAqL1xuVXJpLkhPU1ROQU1FX1BMQUNFSE9MREVSID0gJ2hvc3RuYW1lJyArIERhdGUubm93KCk7XG5cbi8qKlxuICogTmFtZSB1c2VkIGJ5IHRoZSBwYXJhbSBnZW5lcmF0ZWQgYnkgYG1ha2VVbmlxdWVgLlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBzdGF0aWNcbiAqL1xuVXJpLlJBTkRPTV9QQVJBTSA9ICd6eCc7XG5cbmV4cG9ydCBkZWZhdWx0IFVyaTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHsgY29yZSB9IGZyb20gJ21ldGFsJztcbmltcG9ydCBnbG9iYWxzIGZyb20gJy4uL2dsb2JhbHMvZ2xvYmFscyc7XG5pbXBvcnQgVXJpIGZyb20gJ21ldGFsLXVyaSc7XG5cbmZ1bmN0aW9uIGFzc2VydEJyb3dzZXJFbnZpcm9ubWVudCgpIHtcblx0aWYgKCFnbG9iYWxzLndpbmRvdykge1xuXHRcdHRocm93IG5ldyBFcnJvcignU2lnbi1pbiB0eXBlIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBlbnZpcm9ubWVudCcpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGFzc2VydERlZkFuZE5vdE51bGwodmFsdWUsIGVycm9yTWVzc2FnZSkge1xuXHRpZiAoIWNvcmUuaXNEZWZBbmROb3ROdWxsKHZhbHVlKSkge1xuXHRcdHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGFzc2VydE5vdE51bGwodmFsdWUsIGVycm9yTWVzc2FnZSkge1xuXHRpZiAoY29yZS5pc051bGwodmFsdWUpKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0RnVuY3Rpb24odmFsdWUsIGVycm9yTWVzc2FnZSkge1xuXHRpZiAoIWNvcmUuaXNGdW5jdGlvbih2YWx1ZSkpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcblx0fVxufVxuXG5mdW5jdGlvbiBhc3NlcnRPYmplY3QodmFsdWUsIGVycm9yTWVzc2FnZSkge1xuXHRpZiAoIWNvcmUuaXNPYmplY3QodmFsdWUpKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0UmVzcG9uc2VTdWNjZWVkZWQocmVzcG9uc2UpIHtcblx0aWYgKCFyZXNwb25zZS5zdWNjZWVkZWQoKSkge1xuXHRcdHRocm93IHJlc3BvbnNlLmJvZHkoKTtcblx0fVxuXHRyZXR1cm4gcmVzcG9uc2U7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFVzZXJTaWduZWRJbih1c2VyKSB7XG5cdGlmICghY29yZS5pc0RlZkFuZE5vdE51bGwodXNlcikpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IGJlIHNpZ25lZC1pbiB0byBwZXJmb3JtIHRoaXMgb3BlcmF0aW9uJyk7XG5cdH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0VXJpV2l0aE5vUGF0aCh1cmwsIG1lc3NhZ2UpIHtcblx0dmFyIHVyaSA9IG5ldyBVcmkodXJsKTtcblx0aWYgKHVyaS5nZXRQYXRobmFtZSgpLmxlbmd0aCA+IDEpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG5cdH1cbn1cblxuZXhwb3J0IHsgYXNzZXJ0QnJvd3NlckVudmlyb25tZW50LCBhc3NlcnREZWZBbmROb3ROdWxsLCBhc3NlcnROb3ROdWxsLCBhc3NlcnRGdW5jdGlvbiwgYXNzZXJ0T2JqZWN0LCBhc3NlcnRSZXNwb25zZVN1Y2NlZWRlZCwgYXNzZXJ0VXNlclNpZ25lZEluLCBhc3NlcnRVcmlXaXRoTm9QYXRoIH07XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7IGNvcmUgfSBmcm9tICdtZXRhbCc7XG5cbmltcG9ydCB7IGFzc2VydERlZkFuZE5vdE51bGwsIGFzc2VydE9iamVjdCwgYXNzZXJ0UmVzcG9uc2VTdWNjZWVkZWQgfSBmcm9tICcuLi9hc3NlcnRpb25zJztcblxuLyoqXG4gKiBDbGFzcyByZXNwb25zaWJsZSBmb3Igc3RvcmluZyBhdXRob3JpemF0aW9uIGluZm9ybWF0aW9uLlxuICovXG5jbGFzcyBBdXRoIHtcblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYW4ge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW5PckVtYWlsIEVpdGhlciB0aGUgYXV0aG9yaXphdGlvbiB0b2tlbiwgb3Jcblx0ICogICB0aGUgdXNlcm5hbWUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X3Bhc3N3b3JkIElmIGEgdXNlcm5hbWUgaXMgZ2l2ZW4gYXMgdGhlIGZpcnN0IHBhcmFtLFxuXHQgKiAgIHRoaXMgc2hvdWxkIGJlIHRoZSBwYXNzd29yZC5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcih0b2tlbk9yRW1haWwsIG9wdF9wYXNzd29yZCA9IG51bGwpIHtcblx0XHR0aGlzLnRva2VuID0gY29yZS5pc1N0cmluZyhvcHRfcGFzc3dvcmQpID8gbnVsbCA6IHRva2VuT3JFbWFpbDtcblx0XHR0aGlzLmVtYWlsID0gY29yZS5pc1N0cmluZyhvcHRfcGFzc3dvcmQpID8gdG9rZW5PckVtYWlsIDogbnVsbDtcblx0XHR0aGlzLnBhc3N3b3JkID0gb3B0X3Bhc3N3b3JkO1xuXG5cdFx0dGhpcy5jcmVhdGVkQXQgPSBudWxsO1xuXHRcdHRoaXMuaWQgPSBudWxsO1xuXHRcdHRoaXMubmFtZSA9IG51bGw7XG5cdFx0dGhpcy5waG90b1VybCA9IG51bGw7XG5cdFx0dGhpcy53ZWRlcGxveUNsaWVudCA9IG51bGw7XG5cdH1cblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhbiB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbk9yVXNlcm5hbWUgRWl0aGVyIHRoZSBhdXRob3JpemF0aW9uIHRva2VuLCBvclxuXHQgKiAgIHRoZSB1c2VybmFtZS5cblx0ICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfcGFzc3dvcmQgSWYgYSB1c2VybmFtZSBpcyBnaXZlbiBhcyB0aGUgZmlyc3QgcGFyYW0sXG5cdCAqICAgdGhpcyBzaG91bGQgYmUgdGhlIHBhc3N3b3JkLlxuXHQgKiBAcmV0dXJuIHshQXV0aH1cblx0ICovXG5cdHN0YXRpYyBjcmVhdGUodG9rZW5PclVzZXJuYW1lLCBvcHRfcGFzc3dvcmQpIHtcblx0XHRyZXR1cm4gbmV3IEF1dGgodG9rZW5PclVzZXJuYW1lLCBvcHRfcGFzc3dvcmQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGNyZWF0ZWQgYXQgZGF0ZS5cblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cblx0Z2V0Q3JlYXRlZEF0KCkge1xuXHRcdHJldHVybiB0aGlzLmNyZWF0ZWRBdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBlbWFpbC5cblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cblx0Z2V0RW1haWwoKSB7XG5cdFx0cmV0dXJuIHRoaXMuZW1haWw7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgaWQuXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdGdldElkKCkge1xuXHRcdHJldHVybiB0aGlzLmlkO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIG5hbWUuXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdGdldE5hbWUoKSB7XG5cdFx0cmV0dXJuIHRoaXMubmFtZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBwYXNzd29yZC5cblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cblx0Z2V0UGFzc3dvcmQoKSB7XG5cdFx0cmV0dXJuIHRoaXMucGFzc3dvcmQ7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgcGhvdG8gdXJsLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuXHRnZXRQaG90b1VybCgpIHtcblx0XHRyZXR1cm4gdGhpcy5waG90b1VybDtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSB0b2tlbi5cblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cblx0Z2V0VG9rZW4oKSB7XG5cdFx0cmV0dXJuIHRoaXMudG9rZW47XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIGNyZWF0ZWQgYXQgaXMgc2V0LlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cblx0aGFzQ3JlYXRlZEF0KCkge1xuXHRcdHJldHVybiBjb3JlLmlzRGVmQW5kTm90TnVsbCh0aGlzLmNyZWF0ZWRBdCk7XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIHRoZSBlbWFpbCBpcyBzZXQuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqL1xuXHRoYXNFbWFpbCgpIHtcblx0XHRyZXR1cm4gY29yZS5pc0RlZkFuZE5vdE51bGwodGhpcy5lbWFpbCk7XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIHRoZSBpZCBpcyBzZXQuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqL1xuXHRoYXNJZCgpIHtcblx0XHRyZXR1cm4gY29yZS5pc0RlZkFuZE5vdE51bGwodGhpcy5pZCk7XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIHRoZSBuYW1lIGlzIHNldC5cblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICovXG5cdGhhc05hbWUoKSB7XG5cdFx0cmV0dXJuIGNvcmUuaXNEZWZBbmROb3ROdWxsKHRoaXMubmFtZSk7XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIHRoZSBwYXNzd29yZCBpcyBzZXQuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqL1xuXHRoYXNQYXNzd29yZCgpIHtcblx0XHRyZXR1cm4gY29yZS5pc0RlZkFuZE5vdE51bGwodGhpcy5wYXNzd29yZCk7XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIHRoZSBwaG90byB1cmwgaXMgc2V0LlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cblx0aGFzUGhvdG9VcmwoKSB7XG5cdFx0cmV0dXJuIGNvcmUuaXNEZWZBbmROb3ROdWxsKHRoaXMucGhvdG9VcmwpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiB0aGUgdG9rZW4gaXMgc2V0LlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cblx0aGFzVG9rZW4oKSB7XG5cdFx0cmV0dXJuIGNvcmUuaXNEZWZBbmROb3ROdWxsKHRoaXMudG9rZW4pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgY3JlYXRlZCBhdC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGNyZWF0ZWRBdFxuXHQgKi9cblx0c2V0Q3JlYXRlZEF0KGNyZWF0ZWRBdCkge1xuXHRcdHRoaXMuY3JlYXRlZEF0ID0gY3JlYXRlZEF0O1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGVtYWlsLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZW1haWxcblx0ICovXG5cdHNldEVtYWlsKGVtYWlsKSB7XG5cdFx0dGhpcy5lbWFpbCA9IGVtYWlsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGlkLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWRcblx0ICovXG5cdHNldElkKGlkKSB7XG5cdFx0dGhpcy5pZCA9IGlkO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIG5hbWUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG5cdCAqL1xuXHRzZXROYW1lKG5hbWUpIHtcblx0XHR0aGlzLm5hbWUgPSBuYW1lO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHBhc3N3b3JkLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmRcblx0ICovXG5cdHNldFBhc3N3b3JkKHBhc3N3b3JkKSB7XG5cdFx0dGhpcy5wYXNzd29yZCA9IHBhc3N3b3JkO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHBob3RvIHVybC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHBob3RvVXJsXG5cdCAqL1xuXHRzZXRQaG90b1VybChwaG90b1VybCkge1xuXHRcdHRoaXMucGhvdG9VcmwgPSBwaG90b1VybDtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSB0b2tlbi5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHRva2VuXG5cdCAqL1xuXHRzZXRUb2tlbih0b2tlbikge1xuXHRcdHRoaXMudG9rZW4gPSB0b2tlbjtcblx0fVxuXG5cdHNldFdlZGVwbG95Q2xpZW50KHdlZGVwbG95Q2xpZW50KSB7XG5cdFx0dGhpcy53ZWRlcGxveUNsaWVudCA9IHdlZGVwbG95Q2xpZW50O1xuXHR9XG5cblx0LyoqXG5cdCAqIFVwZGF0ZXMgdGhlIHVzZXIuXG5cdCAqIEBwYXJhbSB7IW9iamVjdH0gZGF0YVxuXHQgKiBAcmV0dXJuIHtDb21wbGV0YWJsZUZ1dHVyZX1cblx0ICovXG5cdHVwZGF0ZVVzZXIoZGF0YSkge1xuXHRcdGFzc2VydE9iamVjdChkYXRhLCAnVXNlciBkYXRhIG11c3QgYmUgc3BlY2lmaWVkIGFzIG9iamVjdCcpO1xuXHRcdHJldHVybiB0aGlzLndlZGVwbG95Q2xpZW50XG5cdFx0XHQudXJsKHRoaXMud2VkZXBsb3lDbGllbnQuYXV0aFVybF8pXG5cdFx0XHQucGF0aCgnL3VzZXJzJylcblx0XHRcdC5hdXRoKHRoaXMpXG5cdFx0XHQucGF0Y2goZGF0YSlcblx0XHRcdC50aGVuKHJlc3BvbnNlID0+IGFzc2VydFJlc3BvbnNlU3VjY2VlZGVkKHJlc3BvbnNlKSk7XG5cdH1cblxuXHQvKipcblx0ICogRGVsZXRlcyB0aGUgY3VycmVudCB1c2VyLlxuXHQgKiBAcmV0dXJuIHtDb21wbGV0YWJsZUZ1dHVyZX1cblx0ICovXG5cdGRlbGV0ZVVzZXIoKSB7XG5cdFx0YXNzZXJ0RGVmQW5kTm90TnVsbCh0aGlzLmlkLCAnQ2Fubm90IGRlbGV0ZSB1c2VyIHdpdGhvdXQgaWQnKTtcblx0XHRyZXR1cm4gdGhpcy53ZWRlcGxveUNsaWVudFxuXHRcdFx0LnVybCh0aGlzLndlZGVwbG95Q2xpZW50LmF1dGhVcmxfKVxuXHRcdFx0LnBhdGgoJy91c2VycycsIHRoaXMuaWQpXG5cdFx0XHQuYXV0aCh0aGlzKVxuXHRcdFx0LmRlbGV0ZSgpXG5cdFx0XHQudGhlbihyZXNwb25zZSA9PiBhc3NlcnRSZXNwb25zZVN1Y2NlZWRlZChyZXNwb25zZSkpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEF1dGg7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBBdXRoIGZyb20gJy4vYXV0aC9BdXRoJztcbmltcG9ydCB7IGFzc2VydERlZkFuZE5vdE51bGwgfSBmcm9tICcuL2Fzc2VydGlvbnMnO1xuXG5jbGFzcyBBcGlIZWxwZXIge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGFuIHtAbGluayBBcGlIZWxwZXJ9IGluc3RhbmNlLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGNvbnN0cnVjdG9yKHdlZGVwbG95Q2xpZW50KSB7XG5cdFx0YXNzZXJ0RGVmQW5kTm90TnVsbCh3ZWRlcGxveUNsaWVudCwgJ1dlRGVwbG95IGNsaWVudCByZWZlcmVuY2UgbXVzdCBiZSBzcGVjaWZpZWQnKTtcblx0XHR0aGlzLndlZGVwbG95Q2xpZW50ID0gd2VkZXBsb3lDbGllbnQ7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhdXRob3JpemF0aW9uIGluZm9ybWF0aW9uIHRvIHRoaXMgcmVxdWVzdC5cblx0ICogQHBhcmFtIHshQXV0aHxzdHJpbmd9IGF1dGhPclRva2VuT3JFbWFpbCBFaXRoZXIgYW4ge0BsaW5rIEF1dGh9IGluc3RhbmNlLFxuXHQgKiBhbiBhdXRob3JpemF0aW9uIHRva2VuLCBvciB0aGUgZW1haWwuXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X3Bhc3N3b3JkIElmIGEgZW1haWwgaXMgZ2l2ZW4gYXMgdGhlIGZpcnN0IHBhcmFtLFxuXHQgKiB0aGlzIHNob3VsZCBiZSB0aGUgcGFzc3dvcmQuXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdGF1dGgoYXV0aE9yVG9rZW5PckVtYWlsLCBvcHRfcGFzc3dvcmQpIHtcblx0XHR0aGlzLmhlbHBlckF1dGhTY29wZSA9IGF1dGhPclRva2VuT3JFbWFpbDtcblx0XHRpZiAoISh0aGlzLmhlbHBlckF1dGhTY29wZSBpbnN0YW5jZW9mIEF1dGgpKSB7XG5cdFx0XHR0aGlzLmhlbHBlckF1dGhTY29wZSA9IEF1dGguY3JlYXRlKGF1dGhPclRva2VuT3JFbWFpbCwgb3B0X3Bhc3N3b3JkKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBBcGlIZWxwZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7IGNvcmUgfSBmcm9tICdtZXRhbCc7XG5pbXBvcnQgVXJpIGZyb20gJ21ldGFsLXVyaSc7XG5cbi8qKlxuICogQ2xhc3MgcmVzcG9uc2libGUgZm9yIGVuY2Fwc3VsYXRlIHByb3ZpZGVyIGluZm9ybWF0aW9uLlxuICovXG5jbGFzcyBBdXRoUHJvdmlkZXIge1xuXHQvKipcblx0ICogQ29uc3RydWN0cyBhbiB7QGxpbmsgQXV0aFByb3ZpZGVyfSBpbnN0YW5jZS5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHR0aGlzLnByb3ZpZGVyID0gbnVsbDtcblx0XHR0aGlzLnByb3ZpZGVyU2NvcGUgPSBudWxsO1xuXHRcdHRoaXMucmVkaXJlY3RVcmkgPSBudWxsO1xuXHRcdHRoaXMuc2NvcGUgPSBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiBwcm92aWRlciBpcyBkZWZpbmVkIGFuZCBub3QgbnVsbC5cblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICovXG5cdGhhc1Byb3ZpZGVyKCkge1xuXHRcdHJldHVybiBjb3JlLmlzRGVmQW5kTm90TnVsbCh0aGlzLnByb3ZpZGVyKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgc2NvcGUgaXMgZGVmaW5lZCBhbmQgbm90IG51bGwuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqL1xuXHRoYXNQcm92aWRlclNjb3BlKCkge1xuXHRcdHJldHVybiBjb3JlLmlzRGVmQW5kTm90TnVsbCh0aGlzLnByb3ZpZGVyU2NvcGUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiByZWRpcmVjdCB1cmkgaXMgZGVmaW5lZCBhbmQgbm90IG51bGwuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqL1xuXHRoYXNSZWRpcmVjdFVyaSgpIHtcblx0XHRyZXR1cm4gY29yZS5pc0RlZkFuZE5vdE51bGwodGhpcy5yZWRpcmVjdFVyaSk7XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIHNjb3BlIGlzIGRlZmluZWQgYW5kIG5vdCBudWxsLlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cblx0aGFzU2NvcGUoKSB7XG5cdFx0cmV0dXJuIGNvcmUuaXNEZWZBbmROb3ROdWxsKHRoaXMuc2NvcGUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIE1ha2VzIGF1dGhvcml6YXRpb24gdXJsLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmc9fSBBdXRob3JpemF0aW9uIHVybC5cblx0ICovXG5cdG1ha2VBdXRob3JpemF0aW9uVXJsKG9wdF9hdXRoVXJsKSB7XG5cdFx0dmFyIHVyaSA9IG5ldyBVcmkob3B0X2F1dGhVcmwpO1xuXG5cdFx0dXJpLnNldFBhdGhuYW1lKCcvb2F1dGgvYXV0aG9yaXplJyk7XG5cblx0XHRpZiAodGhpcy5oYXNQcm92aWRlcigpKSB7XG5cdFx0XHR1cmkuc2V0UGFyYW1ldGVyVmFsdWUoJ3Byb3ZpZGVyJywgdGhpcy5nZXRQcm92aWRlcigpKTtcblx0XHR9XG5cdFx0aWYgKHRoaXMuaGFzUHJvdmlkZXJTY29wZSgpKSB7XG5cdFx0XHR1cmkuc2V0UGFyYW1ldGVyVmFsdWUoJ3Byb3ZpZGVyX3Njb3BlJywgdGhpcy5nZXRQcm92aWRlclNjb3BlKCkpO1xuXHRcdH1cblx0XHRpZiAodGhpcy5oYXNSZWRpcmVjdFVyaSgpKSB7XG5cdFx0XHR1cmkuc2V0UGFyYW1ldGVyVmFsdWUoJ3JlZGlyZWN0X3VyaScsIHRoaXMuZ2V0UmVkaXJlY3RVcmkoKSk7XG5cdFx0fVxuXHRcdGlmICh0aGlzLmhhc1Njb3BlKCkpIHtcblx0XHRcdHVyaS5zZXRQYXJhbWV0ZXJWYWx1ZSgnc2NvcGUnLCB0aGlzLmdldFNjb3BlKCkpO1xuXHRcdH1cblxuXHRcdHJldHVybiB1cmkudG9TdHJpbmcoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHByb3ZpZGVyIG5hbWUuXG5cdCAqIEByZXR1cm4ge3N0cmluZz19IFByb3ZpZGVyIG5hbWUuXG5cdCAqL1xuXHRnZXRQcm92aWRlcigpIHtcblx0XHRyZXR1cm4gdGhpcy5wcm92aWRlcjtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHByb3ZpZGVyIHNjb3BlLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmc9fSBTdHJpbmcgd2l0aCBzY29wZXMuXG5cdCAqL1xuXHRnZXRQcm92aWRlclNjb3BlKCkge1xuXHRcdHJldHVybiB0aGlzLnByb3ZpZGVyU2NvcGU7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyByZWRpcmVjdCB1cmkuXG5cdCAqIEByZXR1cm4ge3N0cmluZz19LlxuXHQgKi9cblx0Z2V0UmVkaXJlY3RVcmkoKSB7XG5cdFx0cmV0dXJuIHRoaXMucmVkaXJlY3RVcmk7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyBzY29wZS5cblx0ICogQHJldHVybiB7c3RyaW5nPX0gU3RyaW5nIHdpdGggc2NvcGVzLlxuXHQgKi9cblx0Z2V0U2NvcGUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2NvcGU7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyBwcm92aWRlciBzY29wZS5cblx0ICogQHBhcmFtIHtzdHJpbmc9fSBzY29wZSBTY29wZSBzdHJpbmcuIFNlcGFyYXRlIGJ5IHNwYWNlIGZvciBtdWx0aXBsZVxuXHQgKiAgIHNjb3BlcywgZS5nLiBcInNjb3BlMSBzY29wZTJcIi5cblx0ICovXG5cdHNldFByb3ZpZGVyU2NvcGUocHJvdmlkZXJTY29wZSkge1xuXHRcdGFzc2VydFN0cmluZ0lmRGVmQW5kTm90TnVsbChwcm92aWRlclNjb3BlLCAnUHJvdmlkZXIgc2NvcGUgbXVzdCBiZSBhIHN0cmluZycpO1xuXHRcdHRoaXMucHJvdmlkZXJTY29wZSA9IHByb3ZpZGVyU2NvcGU7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyByZWRpcmVjdCB1cmkuXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gcmVkaXJlY3RVcmkuXG5cdCAqL1xuXHRzZXRSZWRpcmVjdFVyaShyZWRpcmVjdFVyaSkge1xuXHRcdGFzc2VydFN0cmluZ0lmRGVmQW5kTm90TnVsbChyZWRpcmVjdFVyaSwgJ1JlZGlyZWN0IHVyaSBtdXN0IGJlIGEgc3RyaW5nJyk7XG5cdFx0dGhpcy5yZWRpcmVjdFVyaSA9IHJlZGlyZWN0VXJpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgc2NvcGUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gc2NvcGUgU2NvcGUgc3RyaW5nLiBTZXBhcmF0ZSBieSBzcGFjZSBmb3IgbXVsdGlwbGVcblx0ICogICBzY29wZXMsIGUuZy4gXCJzY29wZTEgc2NvcGUyXCIuXG5cdCAqL1xuXHRzZXRTY29wZShzY29wZSkge1xuXHRcdGFzc2VydFN0cmluZ0lmRGVmQW5kTm90TnVsbChzY29wZSwgJ1Njb3BlIG11c3QgYmUgYSBzdHJpbmcnKTtcblx0XHR0aGlzLnNjb3BlID0gc2NvcGU7XG5cdH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0U3RyaW5nSWZEZWZBbmROb3ROdWxsKHZhbHVlLCBlcnJvck1lc3NhZ2UpIHtcblx0aWYgKGNvcmUuaXNEZWZBbmROb3ROdWxsKHZhbHVlKSAmJiAhY29yZS5pc1N0cmluZyh2YWx1ZSkpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBBdXRoUHJvdmlkZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBBdXRoUHJvdmlkZXIgZnJvbSAnLi9BdXRoUHJvdmlkZXInO1xuXG4vKipcbiAqIEZhY2Vib29rIGF1dGggcHJvdmlkZXIgaW1wbGVtZW50YXRpb24uXG4gKi9cbmNsYXNzIEZhY2Vib29rQXV0aFByb3ZpZGVyIGV4dGVuZHMgQXV0aFByb3ZpZGVyIHtcblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYW4ge0BsaW5rIEZhY2Vib29rQXV0aFByb3ZpZGVyfSBpbnN0YW5jZS5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMucHJvdmlkZXIgPSBGYWNlYm9va0F1dGhQcm92aWRlci5QUk9WSURFUjtcblx0fVxufVxuXG5GYWNlYm9va0F1dGhQcm92aWRlci5QUk9WSURFUiA9ICdmYWNlYm9vayc7XG5cbmV4cG9ydCBkZWZhdWx0IEZhY2Vib29rQXV0aFByb3ZpZGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgQXV0aFByb3ZpZGVyIGZyb20gJy4vQXV0aFByb3ZpZGVyJztcblxuLyoqXG4gKiBHaXRodWIgYXV0aCBwcm92aWRlciBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuY2xhc3MgR2l0aHViQXV0aFByb3ZpZGVyIGV4dGVuZHMgQXV0aFByb3ZpZGVyIHtcblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYW4ge0BsaW5rIEdpdGh1YkF1dGhQcm92aWRlcn0gaW5zdGFuY2UuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLnByb3ZpZGVyID0gR2l0aHViQXV0aFByb3ZpZGVyLlBST1ZJREVSO1xuXHR9XG59XG5cbkdpdGh1YkF1dGhQcm92aWRlci5QUk9WSURFUiA9ICdnaXRodWInO1xuXG5leHBvcnQgZGVmYXVsdCBHaXRodWJBdXRoUHJvdmlkZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBBdXRoUHJvdmlkZXIgZnJvbSAnLi9BdXRoUHJvdmlkZXInO1xuXG4vKipcbiAqIEdvb2dsZSBhdXRoIHByb3ZpZGVyIGltcGxlbWVudGF0aW9uLlxuICovXG5jbGFzcyBHb29nbGVBdXRoUHJvdmlkZXIgZXh0ZW5kcyBBdXRoUHJvdmlkZXIge1xuXHQvKipcblx0ICogQ29uc3RydWN0cyBhbiB7QGxpbmsgR29vZ2xlQXV0aFByb3ZpZGVyfSBpbnN0YW5jZS5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMucHJvdmlkZXIgPSBHb29nbGVBdXRoUHJvdmlkZXIuUFJPVklERVI7XG5cdH1cbn1cblxuR29vZ2xlQXV0aFByb3ZpZGVyLlBST1ZJREVSID0gJ2dvb2dsZSc7XG5cbmV4cG9ydCBkZWZhdWx0IEdvb2dsZUF1dGhQcm92aWRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoganNoaW50IGlnbm9yZTpzdGFydCAqL1xuXG4vKipcbiAqIEFic3RyYWN0IGludGVyZmFjZSBmb3Igc3RvcmluZyBhbmQgcmV0cmlldmluZyBkYXRhIHVzaW5nIHNvbWUgcGVyc2lzdGVuY2VcbiAqIG1lY2hhbmlzbS5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBTdG9yYWdlTWVjaGFuaXNtIHtcblx0LyoqXG5cdCAqIENsZWFyIGFsbCBpdGVtcyBmcm9tIHRoZSBkYXRhIHN0b3JhZ2UuXG5cdCAqL1xuXHRjbGVhcigpIHtcblx0XHR0aHJvdyBFcnJvcignVW5pbXBsZW1lbnRlZCBhYnN0cmFjdCBtZXRob2QnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIGFuIGl0ZW0gaW4gdGhlIGRhdGEgc3RvcmFnZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IHRvIHNldC5cblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VyaWFsaXplIHRvIGEgc3RyaW5nIGFuZCBzYXZlLlxuXHQgKi9cblx0c2V0KGtleSwgdmFsdWUpIHtcblx0XHR0aHJvdyBFcnJvcignVW5pbXBsZW1lbnRlZCBhYnN0cmFjdCBtZXRob2QnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIGFuIGl0ZW0gZnJvbSB0aGUgZGF0YSBzdG9yYWdlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgdG8gZ2V0LlxuXHQgKiBAcmV0dXJuIHsqfSBEZXNlcmlhbGl6ZWQgdmFsdWUgb3IgdW5kZWZpbmVkIGlmIG5vdCBmb3VuZC5cblx0ICovXG5cdGdldChrZXkpIHtcblx0XHR0aHJvdyBFcnJvcignVW5pbXBsZW1lbnRlZCBhYnN0cmFjdCBtZXRob2QnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgdGhpcyBtZWNoYW5pc20gaXMgc3VwcG9ydGVkIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50LlxuXHQgKiBTdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZSB0aGlzIHdoZW4gbmVjZXNzYXJ5LlxuXHQgKi9cblx0c3RhdGljIGlzU3VwcG9ydGVkKCkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGxpc3Qgb2Yga2V5cyBzdG9yZWQgaW4gdGhlIFN0b3JhZ2Ugb2JqZWN0LlxuXHQgKiBAcGFyYW0geyFBcnJheTxzdHJpbmc+fSBrZXlzXG5cdCAqL1xuXHRrZXlzKCkge1xuXHRcdHRocm93IEVycm9yKCdVbmltcGxlbWVudGVkIGFic3RyYWN0IG1ldGhvZCcpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgYW4gaXRlbSBmcm9tIHRoZSBkYXRhIHN0b3JhZ2UuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSB0byByZW1vdmUuXG5cdCAqL1xuXHRyZW1vdmUoa2V5KSB7XG5cdFx0dGhyb3cgRXJyb3IoJ1VuaW1wbGVtZW50ZWQgYWJzdHJhY3QgbWV0aG9kJyk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGRhdGEgaXRlbXMgc3RvcmVkIGluIHRoZSBTdG9yYWdlIG9iamVjdC5cblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cblx0c2l6ZSgpIHtcblx0XHR0aHJvdyBFcnJvcignVW5pbXBsZW1lbnRlZCBhYnN0cmFjdCBtZXRob2QnKTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBTdG9yYWdlTWVjaGFuaXNtO1xuXG4vKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgY29yZSBmcm9tICdtZXRhbCc7XG5pbXBvcnQgU3RvcmFnZU1lY2hhbmlzbSBmcm9tICcuL21lY2hhbmlzbS9TdG9yYWdlTWVjaGFuaXNtJztcblxuY2xhc3MgU3RvcmFnZSB7XG5cblx0LyoqXG5cdCAqIFByb3ZpZGVzIGEgY29udmVuaWVudCBBUEkgZm9yIGRhdGEgcGVyc2lzdGVuY2UgdXNpbmcgYSBzZWxlY3RlZCBkYXRhXG5cdCAqIHN0b3JhZ2UgbWVjaGFuaXNtLlxuXHQgKiBAcGFyYW0geyFTdG9yYWdlTWVjaGFuaXNtfSBtZWNoYW5pc20gVGhlIHVuZGVybHlpbmcgc3RvcmFnZSBtZWNoYW5pc20uXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0Y29uc3RydWN0b3IobWVjaGFuaXNtKSB7XG5cdFx0YXNzZXJ0TWVjaGFuaXNtRGVmQW5kTm90TnVsbChtZWNoYW5pc20pO1xuXHRcdGFzc2VydE1lY2hhbmlzbUludGFuY2VPZihtZWNoYW5pc20pO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIG1lY2hhbmlzbSB1c2VkIHRvIHBlcnNpc3Qga2V5LXZhbHVlIHBhaXJzLlxuXHRcdCAqIEB0eXBlIHtTdG9yYWdlTWVjaGFuaXNtfVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLm1lY2hhbmlzbSA9IG1lY2hhbmlzbTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDbGVhciBhbGwgaXRlbXMgZnJvbSB0aGUgZGF0YSBzdG9yYWdlLlxuXHQgKi9cblx0Y2xlYXIoKSB7XG5cdFx0dGhpcy5tZWNoYW5pc20uY2xlYXIoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIGFuIGl0ZW0gaW4gdGhlIGRhdGEgc3RvcmFnZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IHRvIHNldC5cblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VyaWFsaXplIHRvIGEgc3RyaW5nIGFuZCBzYXZlLlxuXHQgKi9cblx0c2V0KGtleSwgdmFsdWUpIHtcblx0XHRpZiAoIWNvcmUuaXNEZWYodmFsdWUpKSB7XG5cdFx0XHR0aGlzLm1lY2hhbmlzbS5yZW1vdmUoa2V5KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5tZWNoYW5pc20uc2V0KGtleSwgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIGFuIGl0ZW0gZnJvbSB0aGUgZGF0YSBzdG9yYWdlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgdG8gZ2V0LlxuXHQgKiBAcmV0dXJuIHsqfSBEZXNlcmlhbGl6ZWQgdmFsdWUgb3IgdW5kZWZpbmVkIGlmIG5vdCBmb3VuZC5cblx0ICovXG5cdGdldChrZXkpIHtcblx0XHR2YXIganNvbjtcblx0XHR0cnkge1xuXHRcdFx0anNvbiA9IHRoaXMubWVjaGFuaXNtLmdldChrZXkpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmIChjb3JlLmlzTnVsbChqc29uKSkge1xuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiBKU09OLnBhcnNlKGpzb24pO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdHRocm93IFN0b3JhZ2UuRXJyb3JDb2RlLklOVkFMSURfVkFMVUU7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGxpc3Qgb2Yga2V5cyBzdG9yZWQgaW4gdGhlIFN0b3JhZ2Ugb2JqZWN0LlxuXHQgKiBAcGFyYW0geyFBcnJheTxzdHJpbmc+fSBrZXlzXG5cdCAqL1xuXHRrZXlzKCkge1xuXHRcdHJldHVybiB0aGlzLm1lY2hhbmlzbS5rZXlzKCk7XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlcyBhbiBpdGVtIGZyb20gdGhlIGRhdGEgc3RvcmFnZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IHRvIHJlbW92ZS5cblx0ICovXG5cdHJlbW92ZShrZXkpIHtcblx0XHR0aGlzLm1lY2hhbmlzbS5yZW1vdmUoa2V5KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZGF0YSBpdGVtcyBzdG9yZWQgaW4gdGhlIFN0b3JhZ2Ugb2JqZWN0LlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuXHRzaXplKCkge1xuXHRcdHJldHVybiB0aGlzLm1lY2hhbmlzbS5zaXplKCk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbGlzdCBvZiB2YWx1ZXMgc3RvcmVkIGluIHRoZSBTdG9yYWdlIG9iamVjdC5cblx0ICogQHBhcmFtIHshQXJyYXk8c3RyaW5nPn0gdmFsdWVzXG5cdCAqL1xuXHR2YWx1ZXMoKSB7XG5cdFx0cmV0dXJuIHRoaXMua2V5cygpLm1hcCgoa2V5KSA9PiB0aGlzLmdldChrZXkpKTtcblx0fVxufVxuXG4vKipcbiAqIEVycm9ycyB0aHJvd24gYnkgdGhlIHN0b3JhZ2UuXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5TdG9yYWdlLkVycm9yQ29kZSA9IHtcblx0SU5WQUxJRF9WQUxVRTogJ1N0b3JhZ2U6IEludmFsaWQgdmFsdWUgd2FzIGVuY291bnRlcmVkJ1xufTtcblxuZnVuY3Rpb24gYXNzZXJ0TWVjaGFuaXNtRGVmQW5kTm90TnVsbChtZWNoYW5pc20pIHtcblx0aWYgKCFjb3JlLmlzRGVmQW5kTm90TnVsbChtZWNoYW5pc20pKSB7XG5cdFx0dGhyb3cgRXJyb3IoJ1N0b3JhZ2UgbWVjaGFuaXNtIGlzIHJlcXVpcmVkJyk7XG5cdH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0TWVjaGFuaXNtSW50YW5jZU9mKG1lY2hhbmlzbSkge1xuXHRpZiAoIShtZWNoYW5pc20gaW5zdGFuY2VvZiBTdG9yYWdlTWVjaGFuaXNtKSkge1xuXHRcdHRocm93IEVycm9yKCdTdG9yYWdlIG1lY2hhbmlzbSBtdXN0IG1lIGFuIGltcGxlbWVudGF0aW9uIG9mIFN0b3JhZ2VNZWNoYW5pc20nKTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBTdG9yYWdlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgU3RvcmFnZU1lY2hhbmlzbSBmcm9tICcuL1N0b3JhZ2VNZWNoYW5pc20nO1xuXG4vKipcbiAqIEFic3RyYWN0IGludGVyZmFjZSBmb3Igc3RvcmluZyBhbmQgcmV0cmlldmluZyBkYXRhIHVzaW5nIHNvbWUgcGVyc2lzdGVuY2VcbiAqIG1lY2hhbmlzbS5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBMb2NhbFN0b3JhZ2VNZWNoYW5pc20gZXh0ZW5kcyBTdG9yYWdlTWVjaGFuaXNtIHtcblx0LyoqXG5cdCAqIFJldHVybnMgcmVmZXJlbmNlIGZvciBnbG9iYWwgbG9jYWwgc3RvcmFnZS4gYnkgZGVmYXVsdFxuXHQgKi9cblx0c3RvcmFnZSgpIHtcblx0XHRyZXR1cm4gTG9jYWxTdG9yYWdlTWVjaGFuaXNtLmdsb2JhbHMubG9jYWxTdG9yYWdlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBpbmhlcml0RG9jXG5cdCAqL1xuXHRjbGVhcigpIHtcblx0XHR0aGlzLnN0b3JhZ2UoKS5jbGVhcigpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBpbmhlcml0RG9jXG5cdCAqL1xuXHRrZXlzKCkge1xuXHRcdHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnN0b3JhZ2UoKSk7XG5cdH1cblxuXHQvKipcblx0ICogQGluaGVyaXREb2Ncblx0ICovXG5cdGdldChrZXkpIHtcblx0XHRyZXR1cm4gdGhpcy5zdG9yYWdlKCkuZ2V0SXRlbShrZXkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBpbmhlcml0RG9jXG5cdCAqL1xuXHRzdGF0aWMgaXNTdXBwb3J0ZWQoKSB7XG5cdFx0cmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBpbmhlcml0RG9jXG5cdCAqL1xuXHRyZW1vdmUoa2V5KSB7XG5cdFx0dGhpcy5zdG9yYWdlKCkucmVtb3ZlSXRlbShrZXkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBpbmhlcml0RG9jXG5cdCAqL1xuXHRzZXQoa2V5LCB2YWx1ZSkge1xuXHRcdHRoaXMuc3RvcmFnZSgpLnNldEl0ZW0oa2V5LCB2YWx1ZSk7XG5cdH1cblxuXHQvKipcblx0ICogQGluaGVyaXREb2Ncblx0ICovXG5cdHNpemUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc3RvcmFnZSgpLmxlbmd0aDtcblx0fVxufVxuXG5pZiAoTG9jYWxTdG9yYWdlTWVjaGFuaXNtLmlzU3VwcG9ydGVkKCkpIHtcblx0TG9jYWxTdG9yYWdlTWVjaGFuaXNtLmdsb2JhbHMgPSB7XG5cdFx0bG9jYWxTdG9yYWdlOiB3aW5kb3cubG9jYWxTdG9yYWdlXG5cdH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IExvY2FsU3RvcmFnZU1lY2hhbmlzbTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEF1dGggZnJvbSAnLi9BdXRoJztcbmltcG9ydCBBcGlIZWxwZXIgZnJvbSAnLi4vQXBpSGVscGVyJztcbmltcG9ydCBGYWNlYm9va0F1dGhQcm92aWRlciBmcm9tICcuL0ZhY2Vib29rQXV0aFByb3ZpZGVyJztcbmltcG9ydCBHaXRodWJBdXRoUHJvdmlkZXIgZnJvbSAnLi9HaXRodWJBdXRoUHJvdmlkZXInO1xuaW1wb3J0IGdsb2JhbHMgZnJvbSAnLi4vLi4vZ2xvYmFscy9nbG9iYWxzJztcbmltcG9ydCBHb29nbGVBdXRoUHJvdmlkZXIgZnJvbSAnLi9Hb29nbGVBdXRoUHJvdmlkZXInO1xuaW1wb3J0IHsgU3RvcmFnZSwgTG9jYWxTdG9yYWdlTWVjaGFuaXNtIH0gZnJvbSAnbWV0YWwtc3RvcmFnZSc7XG5cbmltcG9ydCB7IGFzc2VydERlZkFuZE5vdE51bGwsIGFzc2VydEZ1bmN0aW9uLCBhc3NlcnRPYmplY3QsIGFzc2VydFVzZXJTaWduZWRJbiwgYXNzZXJ0QnJvd3NlckVudmlyb25tZW50LCBhc3NlcnRSZXNwb25zZVN1Y2NlZWRlZCB9IGZyb20gJy4uL2Fzc2VydGlvbnMnO1xuXG4vKipcbiAqIENsYXNzIHJlc3BvbnNpYmxlIGZvciBlbmNhcHN1bGF0ZSBhdXRoIGFwaSBjYWxscy5cbiAqL1xuY2xhc3MgQXV0aEFwaUhlbHBlciBleHRlbmRzIEFwaUhlbHBlciB7XG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGFuIHtAbGluayBBdXRoQXBpSGVscGVyfSBpbnN0YW5jZS5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcih3ZWRlcGxveUNsaWVudCkge1xuXHRcdHN1cGVyKHdlZGVwbG95Q2xpZW50KTtcblxuXHRcdHRoaXMuY3VycmVudFVzZXIgPSBudWxsO1xuXHRcdHRoaXMub25TaWduSW5DYWxsYmFjayA9IG51bGw7XG5cdFx0dGhpcy5vblNpZ25PdXRDYWxsYmFjayA9IG51bGw7XG5cdFx0aWYgKExvY2FsU3RvcmFnZU1lY2hhbmlzbS5pc1N1cHBvcnRlZCgpKSB7XG5cdFx0XHR0aGlzLnN0b3JhZ2UgPSBuZXcgU3RvcmFnZShuZXcgTG9jYWxTdG9yYWdlTWVjaGFuaXNtKCkpO1xuXHRcdH1cblxuXHRcdHRoaXMucHJvY2Vzc1NpZ25Jbl8oKTtcblxuXHRcdHRoaXMucHJvdmlkZXIgPSB7XG5cdFx0XHRGYWNlYm9vazogRmFjZWJvb2tBdXRoUHJvdmlkZXIsXG5cdFx0XHRHb29nbGU6IEdvb2dsZUF1dGhQcm92aWRlcixcblx0XHRcdEdpdGh1YjogR2l0aHViQXV0aFByb3ZpZGVyXG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIHVzZXIuXG5cdCAqIEBwYXJhbSB7IW9iamVjdH0gZGF0YSBUaGUgZGF0YSB0byBiZSB1c2VkIHRvIGNyZWF0ZSB0aGUgdXNlci5cblx0ICogQHJldHVybiB7Q2FuY2VsbGFibGVQcm9taXNlfVxuXHQgKi9cblx0Y3JlYXRlVXNlcihkYXRhKSB7XG5cdFx0YXNzZXJ0T2JqZWN0KGRhdGEsICdVc2VyIGRhdGEgbXVzdCBiZSBzcGVjaWZpZWQgYXMgb2JqZWN0Jyk7XG5cdFx0cmV0dXJuIHRoaXMud2VkZXBsb3lDbGllbnRcblx0XHRcdC51cmwodGhpcy53ZWRlcGxveUNsaWVudC5hdXRoVXJsXylcblx0XHRcdC5wYXRoKCcvdXNlcnMnKVxuXHRcdFx0LnBvc3QoZGF0YSlcblx0XHRcdC50aGVuKHJlc3BvbnNlID0+IGFzc2VydFJlc3BvbnNlU3VjY2VlZGVkKHJlc3BvbnNlKSlcblx0XHRcdC50aGVuKHJlc3BvbnNlID0+IHRoaXMubWFrZVVzZXJBdXRoRnJvbURhdGEocmVzcG9uc2UuYm9keSgpKSk7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgY3VycmVudCBicm93c2VyIHVybCB3aXRob3V0IHRoZSBmcmFnbWVudCBwYXJ0LlxuXHQgKiBAcmV0dXJuIHshc3RyaW5nfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRnZXRIcmVmV2l0aG91dEZyYWdtZW50XygpIHtcblx0XHR2YXIgbG9jYXRpb24gPSBnbG9iYWxzLndpbmRvdy5sb2NhdGlvbjtcblx0XHRyZXR1cm4gbG9jYXRpb24ucHJvdG9jb2wgKyAnLy8nICsgbG9jYXRpb24uaG9zdCArIGxvY2F0aW9uLnBhdGhuYW1lICsgKGxvY2F0aW9uLnNlYXJjaCA/IGxvY2F0aW9uLnNlYXJjaCA6ICcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBhY2Nlc3MgdG9rZW4gZnJvbSB0aGUgdXJsIGZyYWdtZW50IGFuZCByZW1vdmVzIGl0LlxuXHQgKiBAcmV0dXJuIHs/c3RyaW5nfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRnZXRSZWRpcmVjdEFjY2Vzc1Rva2VuXygpIHtcblx0XHRpZiAoZ2xvYmFscy53aW5kb3cpIHtcblx0XHRcdHZhciBmcmFnbWVudCA9IGdsb2JhbHMud2luZG93LmxvY2F0aW9uLmhhc2g7XG5cdFx0XHRpZiAoZnJhZ21lbnQuaW5kZXhPZignI2FjY2Vzc190b2tlbj0nKSA9PT0gMCkge1xuXHRcdFx0XHRyZXR1cm4gZnJhZ21lbnQuc3Vic3RyaW5nKDE0KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB1c2VyIGJ5IGlkLlxuXHQgKiBAcGFyYW0geyFzdHJpbmd9IHVzZXJJZFxuXHQgKiBAcmV0dXJuIHtDYW5jZWxsYWJsZVByb21pc2V9XG5cdCAqL1xuXHRnZXRVc2VyKHVzZXJJZCkge1xuXHRcdGFzc2VydERlZkFuZE5vdE51bGwodXNlcklkLCAnVXNlciB1c2VySWQgbXVzdCBiZSBzcGVjaWZpZWQnKTtcblx0XHRhc3NlcnRVc2VyU2lnbmVkSW4odGhpcy5jdXJyZW50VXNlcik7XG5cdFx0cmV0dXJuIHRoaXMud2VkZXBsb3lDbGllbnRcblx0XHRcdC51cmwodGhpcy53ZWRlcGxveUNsaWVudC5hdXRoVXJsXylcblx0XHRcdC5wYXRoKCcvdXNlcnMnLCB1c2VySWQpXG5cdFx0XHQuYXV0aCh0aGlzLnJlc29sdmVBdXRoU2NvcGUoKS50b2tlbilcblx0XHRcdC5nZXQoKVxuXHRcdFx0LnRoZW4ocmVzcG9uc2UgPT4gYXNzZXJ0UmVzcG9uc2VTdWNjZWVkZWQocmVzcG9uc2UpKVxuXHRcdFx0LnRoZW4ocmVzcG9uc2UgPT4gdGhpcy5tYWtlVXNlckF1dGhGcm9tRGF0YShyZXNwb25zZS5ib2R5KCkpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBMb2FkcyBjdXJyZW50IHVzZXIuIFJlcXVpcmVzIGEgdXNlciB0b2tlbiBhcyBhcmd1bWVudC5cblx0ICogQHBhcmFtIHshc3RyaW5nfSB0b2tlblxuXHQgKiBAcmV0dXJuIHtDYW5jZWxsYWJsZVByb21pc2V9XG5cdCAqL1xuXHRsb2FkQ3VycmVudFVzZXIodG9rZW4pIHtcblx0XHRhc3NlcnREZWZBbmROb3ROdWxsKHRva2VuLCAnVXNlciB0b2tlbiBtdXN0IGJlIHNwZWNpZmllZCcpO1xuXHRcdHJldHVybiB0aGlzLndlZGVwbG95Q2xpZW50XG5cdFx0XHQudXJsKHRoaXMud2VkZXBsb3lDbGllbnQuYXV0aFVybF8pXG5cdFx0XHQucGF0aCgnL3VzZXInKVxuXHRcdFx0LmF1dGgodG9rZW4pXG5cdFx0XHQuZ2V0KClcblx0XHRcdC50aGVuKHJlc3BvbnNlID0+IHtcblx0XHRcdFx0dmFyIGRhdGEgPSByZXNwb25zZS5ib2R5KCk7XG5cdFx0XHRcdGRhdGEudG9rZW4gPSB0b2tlbjtcblx0XHRcdFx0dGhpcy5jdXJyZW50VXNlciA9IHRoaXMubWFrZVVzZXJBdXRoRnJvbURhdGEoZGF0YSk7XG5cdFx0XHRcdGlmICh0aGlzLnN0b3JhZ2UpIHtcblx0XHRcdFx0XHR0aGlzLnN0b3JhZ2Uuc2V0KCdjdXJyZW50VXNlcicsIGRhdGEpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzLmN1cnJlbnRVc2VyO1xuXHRcdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogTWFrZXMgdXNlciBBdXRoIGZyb20gZGF0YSBvYmplY3QuXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhXG5cdCAqIEByZXR1cm4ge0F1dGh9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdG1ha2VVc2VyQXV0aEZyb21EYXRhKGRhdGEpIHtcblx0XHR2YXIgYXV0aCA9IG5ldyBBdXRoKCk7XG5cdFx0YXV0aC5zZXRXZWRlcGxveUNsaWVudCh0aGlzLndlZGVwbG95Q2xpZW50KTtcblx0XHRhdXRoLnNldENyZWF0ZWRBdChkYXRhLmNyZWF0ZWRBdCk7XG5cdFx0YXV0aC5zZXRFbWFpbChkYXRhLmVtYWlsKTtcblx0XHRhdXRoLnNldElkKGRhdGEuaWQpO1xuXHRcdGF1dGguc2V0TmFtZShkYXRhLm5hbWUpO1xuXHRcdGF1dGguc2V0UGhvdG9VcmwoZGF0YS5waG90b1VybCk7XG5cdFx0YXV0aC5zZXRUb2tlbihkYXRhLnRva2VuKTtcblx0XHRyZXR1cm4gYXV0aDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDYWxscyB0aGUgb24gc2lnbiBpbiBjYWxsYmFjayBpZiBzZXQuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdG1heWJlQ2FsbE9uU2lnbkluQ2FsbGJhY2tfKCkge1xuXHRcdGlmICh0aGlzLm9uU2lnbkluQ2FsbGJhY2spIHtcblx0XHRcdHRoaXMub25TaWduSW5DYWxsYmFjay5jYWxsKHRoaXMsIHRoaXMuY3VycmVudFVzZXIpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBDYWxscyB0aGUgb24gc2lnbiBvdXQgY2FsbGJhY2sgaWYgc2V0LlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRtYXliZUNhbGxPblNpZ25PdXRDYWxsYmFja18oKSB7XG5cdFx0aWYgKHRoaXMub25TaWduT3V0Q2FsbGJhY2spIHtcblx0XHRcdHRoaXMub25TaWduT3V0Q2FsbGJhY2suY2FsbCh0aGlzLCB0aGlzLmN1cnJlbnRVc2VyKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogRmlyZXMgcGFzc2VkIGNhbGxiYWNrIHdoZW4gYSB1c2VyIHNpZ24taW4uIE5vdGUgdGhhdCBpdCBrZWVwcyBvbmx5IHRoZVxuXHQgKiBsYXN0IGNhbGxiYWNrIHBhc3NlZC5cblx0ICogQHBhcmFtIHshRnVuY3Rpb259IGNhbGxiYWNrXG5cdCAqL1xuXHRvblNpZ25JbihjYWxsYmFjaykge1xuXHRcdGFzc2VydEZ1bmN0aW9uKGNhbGxiYWNrLCAnU2lnbi1pbiBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblx0XHR0aGlzLm9uU2lnbkluQ2FsbGJhY2sgPSBjYWxsYmFjaztcblx0fVxuXG5cdC8qKlxuXHQgKiBGaXJlcyBwYXNzZWQgY2FsbGJhY2sgd2hlbiBhIHVzZXIgc2lnbi1vdXQuIE5vdGUgdGhhdCBpdCBrZWVwcyBvbmx5IHRoZVxuXHQgKiBsYXN0IGNhbGxiYWNrIHBhc3NlZC5cblx0ICogQHBhcmFtIHshRnVuY3Rpb259IGNhbGxiYWNrXG5cdCAqL1xuXHRvblNpZ25PdXQoY2FsbGJhY2spIHtcblx0XHRhc3NlcnRGdW5jdGlvbihjYWxsYmFjaywgJ1NpZ24tb3V0IGNhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXHRcdHRoaXMub25TaWduT3V0Q2FsbGJhY2sgPSBjYWxsYmFjaztcblx0fVxuXG5cdC8qKlxuXHQgKiBQcm9jZXNzZXMgc2lnbi1pbiBieSBkZXRlY3RpbmcgYSBwcmVzZW5jZSBvZiBhIGZyYWdtZW50XG5cdCAqIDxjb2RlPiNhY2Nlc3NfdG9rZW49PC9jb2RlPiBpbiB0aGUgdXJsIG9yLCBhbHRlcm5hdGl2ZWx5LCBieSBsb2NhbFxuXHQgKiBzdG9yYWdlIGN1cnJlbnQgdXNlci5cblx0ICovXG5cdHByb2Nlc3NTaWduSW5fKCkge1xuXHRcdHZhciByZWRpcmVjdEFjY2Vzc1Rva2VuID0gdGhpcy5nZXRSZWRpcmVjdEFjY2Vzc1Rva2VuXygpO1xuXHRcdGlmIChyZWRpcmVjdEFjY2Vzc1Rva2VuKSB7XG5cdFx0XHR0aGlzLnJlbW92ZVVybEZyYWdtZW50Q29tcGxldGVseV8oKTtcblx0XHRcdHRoaXMubG9hZEN1cnJlbnRVc2VyKHJlZGlyZWN0QWNjZXNzVG9rZW4pXG5cdFx0XHRcdC50aGVuKCgpID0+IHRoaXMubWF5YmVDYWxsT25TaWduSW5DYWxsYmFja18oKSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHZhciBjdXJyZW50VXNlciA9IHRoaXMuc3RvcmFnZSAmJiB0aGlzLnN0b3JhZ2UuZ2V0KCdjdXJyZW50VXNlcicpO1xuXHRcdGlmIChjdXJyZW50VXNlcikge1xuXHRcdFx0dGhpcy5jdXJyZW50VXNlciA9IHRoaXMubWFrZVVzZXJBdXRoRnJvbURhdGEoY3VycmVudFVzZXIpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIGZyYWdtZW50IGZyb20gdXJsIGJ5IHBlcmZvcm1pbmcgYSBwdXNoIHN0YXRlIHRvIHRoZSBjdXJyZW50IHBhdGguXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHJlbW92ZVVybEZyYWdtZW50Q29tcGxldGVseV8oKSB7XG5cdFx0Z2xvYmFscy53aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoe30sIGRvY3VtZW50LnRpdGxlLCB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgKyB3aW5kb3cubG9jYXRpb24uc2VhcmNoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXNvbHZlcyBhdXRoIHNjb3BlIGZyb20gbGFzdCBsb2dpbiBvciBhcGkgaGVscGVyLlxuXHQgKiBAcmV0dXJuIHtBdXRofVxuXHQgKi9cblx0cmVzb2x2ZUF1dGhTY29wZSgpIHtcblx0XHRpZiAodGhpcy5oZWxwZXJBdXRoU2NvcGUpIHtcblx0XHRcdHJldHVybiB0aGlzLmhlbHBlckF1dGhTY29wZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuY3VycmVudFVzZXI7XG5cdH1cblxuXHQvKipcblx0ICogU2VuZHMgcGFzc3dvcmQgcmVzZXQgZW1haWwgdG8gdGhlIHNwZWNpZmllZCBlbWFpbCBpZiBmb3VuZCBpbiBkYXRhYmFzZS5cblx0ICogRm9yIHNlY3VyaXR5IHJlYXNvbnMgY2FsbCBkbyBub3QgZmFpbCBpZiBlbWFpbCBub3QgZm91bmQuXG5cdCAqIEBwYXJhbSB7IXN0cmluZ30gZW1haWxcblx0ICogQHJldHVybiB7Q2FuY2VsbGFibGVQcm9taXNlfVxuXHQgKi9cblx0c2VuZFBhc3N3b3JkUmVzZXRFbWFpbChlbWFpbCkge1xuXHRcdGFzc2VydERlZkFuZE5vdE51bGwoZW1haWwsICdTZW5kIHBhc3N3b3JkIHJlc2V0IGVtYWlsIG11c3QgYmUgc3BlY2lmaWVkJyk7XG5cdFx0cmV0dXJuIHRoaXMud2VkZXBsb3lDbGllbnRcblx0XHRcdC51cmwodGhpcy53ZWRlcGxveUNsaWVudC5hdXRoVXJsXylcblx0XHRcdC5wYXRoKCcvdXNlci9yZWNvdmVyJylcblx0XHRcdC5wYXJhbSgnZW1haWwnLCBlbWFpbClcblx0XHRcdC5wb3N0KClcblx0XHRcdC50aGVuKHJlc3BvbnNlID0+IGFzc2VydFJlc3BvbnNlU3VjY2VlZGVkKHJlc3BvbnNlKSk7XG5cdH1cblxuXHQvKipcblx0ICogU2lnbnMgaW4gdXNpbmcgZW1haWwgYW5kIHBhc3N3b3JkLlxuXHQgKiBAcGFyYW0geyFzdHJpbmd9IGVtYWlsXG5cdCAqIEBwYXJhbSB7IXN0cmluZ30gcGFzc3dvcmRcblx0ICogQHJldHVybiB7Q2FuY2VsbGFibGVQcm9taXNlfVxuXHQgKi9cblx0c2lnbkluV2l0aEVtYWlsQW5kUGFzc3dvcmQoZW1haWwsIHBhc3N3b3JkKSB7XG5cdFx0YXNzZXJ0RGVmQW5kTm90TnVsbChlbWFpbCwgJ1NpZ24taW4gZW1haWwgbXVzdCBiZSBzcGVjaWZpZWQnKTtcblx0XHRhc3NlcnREZWZBbmROb3ROdWxsKHBhc3N3b3JkLCAnU2lnbi1pbiBwYXNzd29yZCBtdXN0IGJlIHNwZWNpZmllZCcpO1xuXG5cdFx0cmV0dXJuIHRoaXMud2VkZXBsb3lDbGllbnRcblx0XHRcdC51cmwodGhpcy53ZWRlcGxveUNsaWVudC5hdXRoVXJsXylcblx0XHRcdC5wYXRoKCcvb2F1dGgvdG9rZW4nKVxuXHRcdFx0LnBhcmFtKCdncmFudF90eXBlJywgJ3Bhc3N3b3JkJylcblx0XHRcdC5wYXJhbSgndXNlcm5hbWUnLCBlbWFpbClcblx0XHRcdC5wYXJhbSgncGFzc3dvcmQnLCBwYXNzd29yZClcblx0XHRcdC5nZXQoKVxuXHRcdFx0LnRoZW4ocmVzcG9uc2UgPT4gYXNzZXJ0UmVzcG9uc2VTdWNjZWVkZWQocmVzcG9uc2UpKVxuXHRcdFx0LnRoZW4ocmVzcG9uc2UgPT4gdGhpcy5sb2FkQ3VycmVudFVzZXIocmVzcG9uc2UuYm9keSgpLmFjY2Vzc190b2tlbikpXG5cdFx0XHQudGhlbigodXNlcikgPT4ge1xuXHRcdFx0XHR0aGlzLm1heWJlQ2FsbE9uU2lnbkluQ2FsbGJhY2tfKCk7XG5cdFx0XHRcdHJldHVybiB1c2VyO1xuXHRcdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogU2lnbnMgaW4gd2l0aCByZWRpcmVjdC4gU29tZSBwcm92aWRlcnMgYW5kIGVudmlyb25tZW50IG1heSBub3Qgc3VwcG9ydFxuXHQgKiB0aGlzIGZsb3cuXG5cdCAqIEBwYXJhbSB7QXV0aFByb3ZpZGVyfSBwcm92aWRlclxuXHQgKi9cblx0c2lnbkluV2l0aFJlZGlyZWN0KHByb3ZpZGVyKSB7XG5cdFx0YXNzZXJ0QnJvd3NlckVudmlyb25tZW50KCk7XG5cdFx0YXNzZXJ0RGVmQW5kTm90TnVsbChwcm92aWRlciwgJ1NpZ24taW4gcHJvdmlkZXIgbXVzdCBiZSBkZWZpbmVkJyk7XG5cdFx0YXNzZXJ0U3VwcG9ydGVkUHJvdmlkZXIocHJvdmlkZXIpO1xuXG5cdFx0aWYgKCFwcm92aWRlci5oYXNSZWRpcmVjdFVyaSgpKSB7XG5cdFx0XHRwcm92aWRlci5zZXRSZWRpcmVjdFVyaSh0aGlzLmdldEhyZWZXaXRob3V0RnJhZ21lbnRfKCkpO1xuXHRcdH1cblx0XHRnbG9iYWxzLndpbmRvdy5sb2NhdGlvbi5ocmVmID0gcHJvdmlkZXIubWFrZUF1dGhvcml6YXRpb25VcmwodGhpcy53ZWRlcGxveUNsaWVudC5hdXRoVXJsXyk7XG5cdH1cblxuXHQvKipcblx0ICogU2lnbnMgb3V0IDxjb2RlPmN1cnJlbnRVc2VyPC9jb2RlPiBhbmQgcmVtb3ZlcyBmcm9tIDxjb2RlPmxvY2FsU3RvcmFnZTwvY29kZT4uXG5cdCAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxuXHQgKi9cblx0c2lnbk91dCgpIHtcblx0XHRhc3NlcnRVc2VyU2lnbmVkSW4odGhpcy5jdXJyZW50VXNlcik7XG5cdFx0cmV0dXJuIHRoaXMud2VkZXBsb3lDbGllbnRcblx0XHRcdC51cmwodGhpcy53ZWRlcGxveUNsaWVudC5hdXRoVXJsXylcblx0XHRcdC5wYXRoKCcvb2F1dGgvcmV2b2tlJylcblx0XHRcdC5wYXJhbSgndG9rZW4nLCB0aGlzLmN1cnJlbnRVc2VyLnRva2VuKVxuXHRcdFx0LmdldCgpXG5cdFx0XHQudGhlbihyZXNwb25zZSA9PiBhc3NlcnRSZXNwb25zZVN1Y2NlZWRlZChyZXNwb25zZSkpXG5cdFx0XHQudGhlbihyZXNwb25zZSA9PiB7XG5cdFx0XHRcdHRoaXMubWF5YmVDYWxsT25TaWduT3V0Q2FsbGJhY2tfKCk7XG5cdFx0XHRcdHRoaXMudW5sb2FkQ3VycmVudFVzZXJfKCk7XG5cdFx0XHRcdHJldHVybiByZXNwb25zZTtcblx0XHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFVubG9hZHMgYWxsIGluZm9ybWF0aW9uIGZvciA8Y29kZT5jdXJyZW50VXNlcjwvY29kZT4gYW5kIHJlbW92ZXMgZnJvbVxuXHQgKiA8Y29kZT5sb2NhbFN0b3JhZ2U8L2NvZGU+IGlmIHByZXNlbnQuXG5cdCAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxuXHQgKi9cblx0dW5sb2FkQ3VycmVudFVzZXJfKCkge1xuXHRcdHRoaXMuY3VycmVudFVzZXIgPSBudWxsO1xuXHRcdGlmICh0aGlzLnN0b3JhZ2UpIHtcblx0XHRcdHRoaXMuc3RvcmFnZS5yZW1vdmUoJ2N1cnJlbnRVc2VyJyk7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFN1cHBvcnRlZFByb3ZpZGVyKHByb3ZpZGVyKSB7XG5cdHN3aXRjaCAocHJvdmlkZXIuY29uc3RydWN0b3IuUFJPVklERVIpIHtcblx0XHRjYXNlIEZhY2Vib29rQXV0aFByb3ZpZGVyLlBST1ZJREVSOlxuXHRcdGNhc2UgR2l0aHViQXV0aFByb3ZpZGVyLlBST1ZJREVSOlxuXHRcdGNhc2UgR29vZ2xlQXV0aFByb3ZpZGVyLlBST1ZJREVSOlxuXHRcdFx0YnJlYWs7XG5cdFx0ZGVmYXVsdDpcblx0XHRcdHRocm93IG5ldyBFcnJvcignU2lnbi1pbiBwcm92aWRlciBub3Qgc3VwcG9ydGVkJyk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQXV0aEFwaUhlbHBlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEVtYm9kaWVkIGZyb20gJy4vRW1ib2RpZWQnO1xuaW1wb3J0IFJhbmdlIGZyb20gJy4vUmFuZ2UnO1xuXG4vKipcbiAqIENsYXNzIHRoYXQgcmVwcmVzZW50cyBhIHNlYXJjaCBhZ2dyZWdhdGlvbi5cbiAqL1xuY2xhc3MgQWdncmVnYXRpb24ge1xuXHQvKipcblx0ICogQ29uc3RydWN0cyBhbiB7QGxpbmsgQWdncmVnYXRpb259IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGFnZ3JlZ2F0aW9uIGZpZWxkLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3IgVGhlIGFnZ3JlZ2F0aW9uIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfdmFsdWUgVGhlIGFnZ3JlZ2F0aW9uIHZhbHVlLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGNvbnN0cnVjdG9yKGZpZWxkLCBvcGVyYXRvciwgb3B0X3ZhbHVlKSB7XG5cdFx0dGhpcy5maWVsZF8gPSBmaWVsZDtcblx0XHR0aGlzLm9wZXJhdG9yXyA9IG9wZXJhdG9yO1xuXHRcdHRoaXMudmFsdWVfID0gb3B0X3ZhbHVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4ge0BsaW5rIEFnZ3JlZ2F0aW9ufSBpbnN0YW5jZSB3aXRoIHRoZSBcImF2Z1wiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGFnZ3JlZ2F0aW9uIGZpZWxkLlxuXHQgKiBAcmV0dXJuIHshQWdncmVnYXRpb259XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBhdmcoZmllbGQpIHtcblx0XHRyZXR1cm4gQWdncmVnYXRpb24uZmllbGQoZmllbGQsICdhdmcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIHtAbGluayBBZ2dyZWdhdGlvbn0gaW5zdGFuY2Ugd2l0aCB0aGUgXCJjb3VudFwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGFnZ3JlZ2F0aW9uIGZpZWxkLlxuXHQgKiBAcmV0dXJuIHshQWdncmVnYXRpb259XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBjb3VudChmaWVsZCkge1xuXHRcdHJldHVybiBBZ2dyZWdhdGlvbi5maWVsZChmaWVsZCwgJ2NvdW50Jyk7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiB7QGxpbmsgRGlzdGFuY2VBZ2dyZWdhdGlvbn0gaW5zdGFuY2Ugd2l0aCB0aGUgXCJnZW9EaXN0YW5jZVwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGFnZ3JlZ2F0aW9uIGZpZWxkLlxuXHQgKiBAcGFyYW0geyp9IGxvY2F0aW9uIFRoZSBhZ2dyZWdhdGlvbiBsb2NhdGlvbi5cblx0ICogQHBhcmFtIHsuLi4hUmFuZ2V9IHJhbmdlcyBUaGUgYWdncmVnYXRpb24gcmFuZ2VzLlxuXHQgKiBAcmV0dXJuIHshRGlzdGFuY2VBZ2dyZWdhdGlvbn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGRpc3RhbmNlKGZpZWxkLCBsb2NhdGlvbiwgLi4ucmFuZ2VzKSB7XG5cdFx0cmV0dXJuIG5ldyBBZ2dyZWdhdGlvbi5EaXN0YW5jZUFnZ3JlZ2F0aW9uKGZpZWxkLCBsb2NhdGlvbiwgLi4ucmFuZ2VzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIHtAbGluayBBZ2dyZWdhdGlvbn0gaW5zdGFuY2Ugd2l0aCB0aGUgXCJleHRlbmRlZFN0YXRzXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgYWdncmVnYXRpb24gZmllbGQuXG5cdCAqIEByZXR1cm4geyFBZ2dyZWdhdGlvbn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGV4dGVuZGVkU3RhdHMoZmllbGQpIHtcblx0XHRyZXR1cm4gQWdncmVnYXRpb24uZmllbGQoZmllbGQsICdleHRlbmRlZFN0YXRzJyk7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGlzIGFnZ3JlZ2F0aW9uJ3MgZmllbGQuXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdGdldEZpZWxkKCkge1xuXHRcdHJldHVybiB0aGlzLmZpZWxkXztcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoaXMgYWdncmVnYXRpb24ncyBvcGVyYXRvci5cblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cblx0Z2V0T3BlcmF0b3IoKSB7XG5cdFx0cmV0dXJuIHRoaXMub3BlcmF0b3JfO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhpcyBhZ2dyZWdhdGlvbidzIHZhbHVlLlxuXHQgKiBAcmV0dXJuIHsqfVxuXHQgKi9cblx0Z2V0VmFsdWUoKSB7XG5cdFx0cmV0dXJuIHRoaXMudmFsdWVfO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4ge0BsaW5rIEFnZ3JlZ2F0aW9ufSBpbnN0YW5jZSB3aXRoIHRoZSBcImhpc3RvZ3JhbVwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGFnZ3JlZ2F0aW9uIGZpZWxkLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gaW50ZXJ2YWwgVGhlIGhpc3RvZ3JhbSdzIGludGVydmFsLlxuXHQgKiBAcmV0dXJuIHshQWdncmVnYXRpb259XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBoaXN0b2dyYW0oZmllbGQsIGludGVydmFsKSB7XG5cdFx0cmV0dXJuIG5ldyBBZ2dyZWdhdGlvbihmaWVsZCwgJ2hpc3RvZ3JhbScsIGludGVydmFsKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIHtAbGluayBBZ2dyZWdhdGlvbn0gaW5zdGFuY2Ugd2l0aCB0aGUgXCJtYXhcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBhZ2dyZWdhdGlvbiBmaWVsZC5cblx0ICogQHJldHVybiB7IUFnZ3JlZ2F0aW9ufVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgbWF4KGZpZWxkKSB7XG5cdFx0cmV0dXJuIEFnZ3JlZ2F0aW9uLmZpZWxkKGZpZWxkLCAnbWF4Jyk7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiB7QGxpbmsgQWdncmVnYXRpb259IGluc3RhbmNlIHdpdGggdGhlIFwibWluXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgYWdncmVnYXRpb24gZmllbGQuXG5cdCAqIEByZXR1cm4geyFBZ2dyZWdhdGlvbn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIG1pbihmaWVsZCkge1xuXHRcdHJldHVybiBBZ2dyZWdhdGlvbi5maWVsZChmaWVsZCwgJ21pbicpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4ge0BsaW5rIEFnZ3JlZ2F0aW9ufSBpbnN0YW5jZSB3aXRoIHRoZSBcIm1pc3NpbmdcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBhZ2dyZWdhdGlvbiBmaWVsZC5cblx0ICogQHJldHVybiB7IUFnZ3JlZ2F0aW9ufVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgbWlzc2luZyhmaWVsZCkge1xuXHRcdHJldHVybiBBZ2dyZWdhdGlvbi5maWVsZChmaWVsZCwgJ21pc3NpbmcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgbmV3IHtAbGluayBBZ2dyZWdhdGlvbn0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgYWdncmVnYXRpb24gZmllbGQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBvcGVyYXRvciBUaGUgYWdncmVnYXRpb24gb3BlcmF0b3IuXG5cdCAqIEByZXR1cm4geyFBZ2dyZWdhdGlvbn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGZpZWxkKGZpZWxkLCBvcGVyYXRvcikge1xuXHRcdHJldHVybiBuZXcgQWdncmVnYXRpb24oZmllbGQsIG9wZXJhdG9yKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIHtAbGluayBSYW5nZUFnZ3JlZ2F0aW9ufSBpbnN0YW5jZSB3aXRoIHRoZSBcInJhbmdlXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgYWdncmVnYXRpb24gZmllbGQuXG5cdCAqIEBwYXJhbSB7Li4uIVJhbmdlfSByYW5nZXMgVGhlIGFnZ3JlZ2F0aW9uIHJhbmdlcy5cblx0ICogQHJldHVybiB7IVJhbmdlQWdncmVnYXRpb259XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyByYW5nZShmaWVsZCwgLi4ucmFuZ2VzKSB7XG5cdFx0cmV0dXJuIG5ldyBBZ2dyZWdhdGlvbi5SYW5nZUFnZ3JlZ2F0aW9uKGZpZWxkLCAuLi5yYW5nZXMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4ge0BsaW5rIEFnZ3JlZ2F0aW9ufSBpbnN0YW5jZSB3aXRoIHRoZSBcInN0YXRzXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgYWdncmVnYXRpb24gZmllbGQuXG5cdCAqIEByZXR1cm4geyFBZ2dyZWdhdGlvbn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIHN0YXRzKGZpZWxkKSB7XG5cdFx0cmV0dXJuIEFnZ3JlZ2F0aW9uLmZpZWxkKGZpZWxkLCAnc3RhdHMnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIHtAbGluayBBZ2dyZWdhdGlvbn0gaW5zdGFuY2Ugd2l0aCB0aGUgXCJzdW1cIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBhZ2dyZWdhdGlvbiBmaWVsZC5cblx0ICogQHJldHVybiB7IUFnZ3JlZ2F0aW9ufVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgc3VtKGZpZWxkKSB7XG5cdFx0cmV0dXJuIEFnZ3JlZ2F0aW9uLmZpZWxkKGZpZWxkLCAnc3VtJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiB7QGxpbmsgQWdncmVnYXRpb259IGluc3RhbmNlIHdpdGggdGhlIFwidGVybXNcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBhZ2dyZWdhdGlvbiBmaWVsZC5cblx0ICogQHJldHVybiB7IUFnZ3JlZ2F0aW9ufVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgdGVybXMoZmllbGQpIHtcblx0XHRyZXR1cm4gQWdncmVnYXRpb24uZmllbGQoZmllbGQsICd0ZXJtcycpO1xuXHR9XG59XG5cbi8qKlxuICogQ2xhc3MgdGhhdCByZXByZXNlbnRzIGEgZGlzdGFuY2UgYWdncmVnYXRpb24uXG4gKiBAZXh0ZW5kcyB7QWdncmVnYXRpb259XG4gKi9cbmNsYXNzIERpc3RhbmNlQWdncmVnYXRpb24gZXh0ZW5kcyBBZ2dyZWdhdGlvbiB7XG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGFuIHtAbGluayBEaXN0YW5jZUFnZ3JlZ2F0aW9ufSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBhZ2dyZWdhdGlvbiBmaWVsZC5cblx0ICogQHBhcmFtIHsqfSBsb2NhdGlvbiBUaGUgYWdncmVnYXRpb24gbG9jYXRpb24uXG5cdCAqIEBwYXJhbSB7Li4uIVJhbmdlfSByYW5nZXMgVGhlIGFnZ3JlZ2F0aW9uIHJhbmdlcy5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihmaWVsZCwgbG9jYXRpb24sIC4uLnJhbmdlcykge1xuXHRcdHN1cGVyKGZpZWxkLCAnZ2VvRGlzdGFuY2UnLCB7fSk7XG5cdFx0dGhpcy52YWx1ZV8ubG9jYXRpb24gPSBFbWJvZGllZC50b0JvZHkobG9jYXRpb24pO1xuXHRcdHRoaXMudmFsdWVfLnJhbmdlcyA9IHJhbmdlcy5tYXAocmFuZ2UgPT4gcmFuZ2UuYm9keSgpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgcmFuZ2UgdG8gdGhpcyBhZ2dyZWdhdGlvbi5cblx0ICogQHBhcmFtIHsqfSByYW5nZU9yRnJvbVxuXHQgKiBAcGFyYW0geyo9fSBvcHRfdG9cblx0ICogQGNoYWlubmFibGVcblx0ICovXG5cdHJhbmdlKHJhbmdlT3JGcm9tLCBvcHRfdG8pIHtcblx0XHR2YXIgcmFuZ2UgPSByYW5nZU9yRnJvbTtcblx0XHRpZiAoIShyYW5nZSBpbnN0YW5jZW9mIFJhbmdlKSkge1xuXHRcdFx0cmFuZ2UgPSBSYW5nZS5yYW5nZShyYW5nZU9yRnJvbSwgb3B0X3RvKTtcblx0XHR9XG5cdFx0dGhpcy52YWx1ZV8ucmFuZ2VzLnB1c2gocmFuZ2UuYm9keSgpKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoaXMgYWdncmVnYXRpb24ncyB1bml0LlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdW5pdFxuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cblx0dW5pdCh1bml0KSB7XG5cdFx0dGhpcy52YWx1ZV8udW5pdCA9IHVuaXQ7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn1cbkFnZ3JlZ2F0aW9uLkRpc3RhbmNlQWdncmVnYXRpb24gPSBEaXN0YW5jZUFnZ3JlZ2F0aW9uO1xuXG4vKipcbiAqIENsYXNzIHRoYXQgcmVwcmVzZW50cyBhIHJhbmdlIGFnZ3JlZ2F0aW9uLlxuICogQGV4dGVuZHMge0FnZ3JlZ2F0aW9ufVxuICovXG5jbGFzcyBSYW5nZUFnZ3JlZ2F0aW9uIGV4dGVuZHMgQWdncmVnYXRpb24ge1xuXHQvKipcblx0ICogQ29uc3RydWN0cyBhbiB7QGxpbmsgUmFuZ2VBZ2dyZWdhdGlvbn0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgYWdncmVnYXRpb24gZmllbGQuXG5cdCAqIEBwYXJhbSB7Li4uIVJhbmdlfSByYW5nZXMgVGhlIGFnZ3JlZ2F0aW9uIHJhbmdlcy5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihmaWVsZCwgLi4ucmFuZ2VzKSB7XG5cdFx0c3VwZXIoZmllbGQsICdyYW5nZScpO1xuXHRcdHRoaXMudmFsdWVfID0gcmFuZ2VzLm1hcChyYW5nZSA9PiByYW5nZS5ib2R5KCkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSByYW5nZSB0byB0aGlzIGFnZ3JlZ2F0aW9uLlxuXHQgKiBAcGFyYW0geyp9IHJhbmdlT3JGcm9tXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF90b1xuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cblx0cmFuZ2UocmFuZ2VPckZyb20sIG9wdF90bykge1xuXHRcdHZhciByYW5nZSA9IHJhbmdlT3JGcm9tO1xuXHRcdGlmICghKHJhbmdlIGluc3RhbmNlb2YgUmFuZ2UpKSB7XG5cdFx0XHRyYW5nZSA9IFJhbmdlLnJhbmdlKHJhbmdlT3JGcm9tLCBvcHRfdG8pO1xuXHRcdH1cblx0XHR0aGlzLnZhbHVlXy5wdXNoKHJhbmdlLmJvZHkoKSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn1cbkFnZ3JlZ2F0aW9uLlJhbmdlQWdncmVnYXRpb24gPSBSYW5nZUFnZ3JlZ2F0aW9uO1xuXG5leHBvcnQgZGVmYXVsdCBBZ2dyZWdhdGlvbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHsgY29yZSB9IGZyb20gJ21ldGFsJztcbmltcG9ydCBFbWJvZGllZCBmcm9tICcuL0VtYm9kaWVkJztcbmltcG9ydCBGaWx0ZXIgZnJvbSAnLi9GaWx0ZXInO1xuaW1wb3J0IEFnZ3JlZ2F0aW9uIGZyb20gJy4vQWdncmVnYXRpb24nO1xuXG4vKipcbiAqIENsYXNzIHJlc3BvbnNpYmxlIGZvciBidWlsZGluZyBxdWVyaWVzLlxuICogQGV4dGVuZHMge0VtYm9kaWVkfVxuICovXG5jbGFzcyBRdWVyeSBleHRlbmRzIEVtYm9kaWVkIHtcblx0LyoqXG5cdCAqIEFkZHMgYW4gYWdncmVnYXRpb24gdG8gdGhpcyB7QGxpbmsgUXVlcnl9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgYWdncmVnYXRpb24gbmFtZS5cblx0ICogQHBhcmFtIHshQWdncmVnYXRpb258c3RyaW5nfSBhZ2dyZWdhdGlvbk9yRmllbGQgRWl0aGVyIGFuXG5cdCAqICAge0BsaW5rIEFnZ3JlZ2F0aW9ufSBpbnN0YW5jZSBvciB0aGUgbmFtZSBvZiB0aGUgYWdncmVnYXRpb24gZmllbGQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X29wZXJhdG9yIFRoZSBhZ2dyZWdhdGlvbiBvcGVyYXRvci5cblx0ICogQHJldHVybiB7IVF1ZXJ5fVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgYWdncmVnYXRlKG5hbWUsIGFnZ3JlZ2F0aW9uT3JGaWVsZCwgb3B0X29wZXJhdG9yKSB7XG5cdFx0cmV0dXJuIG5ldyBRdWVyeSgpLmFnZ3JlZ2F0ZShuYW1lLCBhZ2dyZWdhdGlvbk9yRmllbGQsIG9wdF9vcGVyYXRvcik7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGlzIHF1ZXJ5J3MgdHlwZSB0byBcImNvdW50XCIuXG5cdCAqIEByZXR1cm4geyFRdWVyeX1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGNvdW50KCkge1xuXHRcdHJldHVybiBuZXcgUXVlcnkoKS50eXBlKCdjb3VudCcpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhpcyBxdWVyeSdzIHR5cGUgdG8gXCJmZXRjaFwiLlxuXHQgKiBAcmV0dXJuIHshUXVlcnl9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBmZXRjaCgpIHtcblx0XHRyZXR1cm4gbmV3IFF1ZXJ5KCkudHlwZSgnZmV0Y2gnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgZmlsdGVyIHRvIHRoaXMgUXVlcnkuXG5cdCAqIEBwYXJhbSB7IUZpbHRlcnxzdHJpbmd9IGZpZWxkT3JGaWx0ZXIgRWl0aGVyIGEge0BsaW5rIEZpbHRlcn0gb3IgdGhlXG5cdCAqICAgbmFtZSBvZiB0aGUgZmllbGQgdG8gZmlsdGVyIGJ5LlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfb3BlcmF0b3JPclZhbHVlIEVpdGhlciB0aGUgZmllbGQncyBvcGVyYXRvciBvciBpdHMgdmFsdWUuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF92YWx1ZSBUaGUgZmlsdGVyJ3MgdmFsdWUuXG5cdCAqIEByZXR1cm4geyFRdWVyeX1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGZpbHRlcihmaWVsZE9yRmlsdGVyLCBvcHRfb3BlcmF0b3JPclZhbHVlLCBvcHRfdmFsdWUpIHtcblx0XHRyZXR1cm4gbmV3IFF1ZXJ5KCkuZmlsdGVyKGZpZWxkT3JGaWx0ZXIsIG9wdF9vcGVyYXRvck9yVmFsdWUsIG9wdF92YWx1ZSk7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgcXVlcnkgb2Zmc2V0LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IFRoZSBpbmRleCBvZiB0aGUgZmlyc3QgZW50cnkgdGhhdCBzaG91bGQgYmUgcmV0dXJuZWRcblx0ICogICBieSB0aGlzIHF1ZXJ5LlxuXHQgKiBAcmV0dXJuIHshUXVlcnl9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBvZmZzZXQob2Zmc2V0KSB7XG5cdFx0cmV0dXJuIG5ldyBRdWVyeSgpLm9mZnNldChvZmZzZXQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBoaWdobGlnaHQgZW50cnkgdG8gdGhpcyB7QGxpbmsgUXVlcnl9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGZpZWxkJ3MgbmFtZS5cblx0ICogQHJldHVybiB7IVF1ZXJ5fVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgaGlnaGxpZ2h0KGZpZWxkKSB7XG5cdFx0cmV0dXJuIG5ldyBRdWVyeSgpLmhpZ2hsaWdodChmaWVsZCk7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgcXVlcnkgbGltaXQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCBUaGUgbWF4IGFtb3VudCBvZiBlbnRyaWVzIHRoYXQgdGhpcyBxdWVyeSBzaG91bGQgcmV0dXJuLlxuXHQgKiBAcmV0dXJuIHshUXVlcnl9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBsaW1pdChsaW1pdCkge1xuXHRcdHJldHVybiBuZXcgUXVlcnkoKS5saW1pdChsaW1pdCk7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIHNlYXJjaCB0byB0aGlzIHtAbGluayBRdWVyeX0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7IUZpbHRlcnxzdHJpbmd9IGZpbHRlck9yVGV4dE9yRmllbGQgSWYgbm8gb3RoZXIgYXJndW1lbnRzXG5cdCAqICAgYXJlIHBhc3NlZCB0byB0aGlzIGZ1bmN0aW9uLCB0aGlzIHNob3VsZCBiZSBlaXRoZXIgYSB7QGxpbmsgRmlsdGVyfVxuXHQgKiAgIGluc3RhbmNlIG9yIGEgdGV4dCB0byBiZSB1c2VkIGluIGEgbWF0Y2ggZmlsdGVyLiBJbiBib3RoIGNhc2VzXG5cdCAqICAgdGhlIGZpbHRlciB3aWxsIGJlIGFwcGxpZWQgdG8gYWxsIGZpZWxkcy4gQW5vdGhlciBvcHRpb24gaXMgdG9cblx0ICogICBwYXNzIHRoaXMgYXMgYSBmaWVsZCBuYW1lIGluc3RlYWQsIHRvZ2V0aGVyIHdpdGggb3RoZXIgYXJndW1lbnRzXG5cdCAqICAgc28gdGhlIGZpbHRlciBjYW4gYmUgY3JlYXRlZC5cblx0ICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfdGV4dE9yT3BlcmF0b3IgRWl0aGVyIGEgdGV4dCB0byBiZSB1c2VkIGluIGFcblx0ICogICBtYXRjaCBmaWx0ZXIsIG9yIHRoZSBvcGVyYXRvciB0aGF0IHNob3VsZCBiZSB1c2VkLlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfdmFsdWUgVGhlIHZhbHVlIHRvIGJlIHVzZWQgYnkgdGhlIGZpbHRlci4gU2hvdWxkXG5cdCAqICAgb25seSBiZSBwYXNzZWQgaWYgYW4gb3BlcmF0b3Igd2FzIHBhc3NlZCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LlxuXHQgKiBAcmV0dXJuIHshUXVlcnl9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBzZWFyY2goZmlsdGVyT3JUZXh0T3JGaWVsZCwgb3B0X3RleHRPck9wZXJhdG9yLCBvcHRfdmFsdWUpIHtcblx0XHRyZXR1cm4gbmV3IFF1ZXJ5KCkuc2VhcmNoKGZpbHRlck9yVGV4dE9yRmllbGQsIG9wdF90ZXh0T3JPcGVyYXRvciwgb3B0X3ZhbHVlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgc29ydCBlbnRyeSB0byB0aGlzIHF1ZXJ5LCBzcGVjaWZ5aW5nIHRoZSBmaWVsZCB0aGlzIHF1ZXJ5IHNob3VsZCBiZVxuXHQgKiBzb3J0ZWQgYnkgYW5kLCBvcHRpb25hbGx5LCB0aGUgc29ydCBkaXJlY3Rpb24uXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQgdGhhdCB0aGUgcXVlcnkgc2hvdWxkIGJlIHNvcnRlZCBieS5cblx0ICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfZGlyZWN0aW9uIFRoZSBkaXJlY3Rpb24gdGhlIHNvcnQgb3BlcmF0aW9uIHNob3VsZCB1c2UuXG5cdCAqICAgSWYgbm9uZSBpcyBnaXZlbiwgXCJhc2NcIiBpcyB1c2VkIGJ5IGRlZmF1bHQuXG5cdCAqIEByZXR1cm4geyFRdWVyeX1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIHNvcnQoZmllbGQsIG9wdF9kaXJlY3Rpb24pIHtcblx0XHRyZXR1cm4gbmV3IFF1ZXJ5KCkuc29ydChmaWVsZCwgb3B0X2RpcmVjdGlvbik7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgcXVlcnkgdHlwZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVGhlIHF1ZXJ5J3MgdHlwZS4gRm9yIGV4YW1wbGU6IFwiY291bnRcIiwgXCJmZXRjaFwiLlxuXHQgKiBAcmV0dXJuIHshUXVlcnl9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyB0eXBlKHR5cGUpIHtcblx0XHRyZXR1cm4gbmV3IFF1ZXJ5KCkudHlwZSh0eXBlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGFuIGFnZ3JlZ2F0aW9uIHRvIHRoaXMge0BsaW5rIFF1ZXJ5fSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIGFnZ3JlZ2F0aW9uIG5hbWUuXG5cdCAqIEBwYXJhbSB7IUFnZ3JlZ2F0aW9ufHN0cmluZ30gYWdncmVnYXRpb25PckZpZWxkIEVpdGhlciBhblxuXHQgKiAgIHtAbGluayBBZ2dyZWdhdGlvbn0gaW5zdGFuY2Ugb3IgdGhlIG5hbWUgb2YgdGhlIGFnZ3JlZ2F0aW9uIGZpZWxkLlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9vcGVyYXRvciBUaGUgYWdncmVnYXRpb24gb3BlcmF0b3IuXG5cdCAqIEBjaGFpbm5hYmxlXG5cdCAqL1xuXHRhZ2dyZWdhdGUobmFtZSwgYWdncmVnYXRpb25PckZpZWxkLCBvcHRfb3BlcmF0b3IpIHtcblx0XHR2YXIgYWdncmVnYXRpb24gPSBhZ2dyZWdhdGlvbk9yRmllbGQ7XG5cdFx0aWYgKCEoYWdncmVnYXRpb24gaW5zdGFuY2VvZiBBZ2dyZWdhdGlvbikpIHtcblx0XHRcdGFnZ3JlZ2F0aW9uID0gQWdncmVnYXRpb24uZmllbGQoYWdncmVnYXRpb25PckZpZWxkLCBvcHRfb3BlcmF0b3IpO1xuXHRcdH1cblxuXHRcdHZhciBmaWVsZCA9IGFnZ3JlZ2F0aW9uLmdldEZpZWxkKCk7XG5cdFx0dmFyIHZhbHVlID0ge307XG5cdFx0dmFsdWVbZmllbGRdID0ge1xuXHRcdFx0bmFtZTogbmFtZSxcblx0XHRcdG9wZXJhdG9yOiBhZ2dyZWdhdGlvbi5nZXRPcGVyYXRvcigpXG5cdFx0fTtcblx0XHRpZiAoY29yZS5pc0RlZkFuZE5vdE51bGwoYWdncmVnYXRpb24uZ2V0VmFsdWUoKSkpIHtcblx0XHRcdHZhbHVlW2ZpZWxkXS52YWx1ZSA9IGFnZ3JlZ2F0aW9uLmdldFZhbHVlKCk7XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLmJvZHlfLmFnZ3JlZ2F0aW9uKSB7XG5cdFx0XHR0aGlzLmJvZHlfLmFnZ3JlZ2F0aW9uID0gW107XG5cdFx0fVxuXHRcdHRoaXMuYm9keV8uYWdncmVnYXRpb24ucHVzaCh2YWx1ZSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGlzIHF1ZXJ5J3MgdHlwZSB0byBcImNvdW50XCIuXG5cdCAqIEBjaGFpbm5hYmxlXG5cdCAqL1xuXHRjb3VudCgpIHtcblx0XHRyZXR1cm4gdGhpcy50eXBlKCdjb3VudCcpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhpcyBxdWVyeSdzIHR5cGUgdG8gXCJmZXRjaFwiLlxuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cblx0ZmV0Y2goKSB7XG5cdFx0cmV0dXJuIHRoaXMudHlwZSgnZmV0Y2gnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgZmlsdGVyIHRvIHRoaXMgUXVlcnkuXG5cdCAqIEBwYXJhbSB7IUZpbHRlcnxzdHJpbmd9IGZpZWxkT3JGaWx0ZXIgRWl0aGVyIGEge0BsaW5rIEZpbHRlcn0gb3IgdGhlXG5cdCAqICAgbmFtZSBvZiB0aGUgZmllbGQgdG8gZmlsdGVyIGJ5LlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfb3BlcmF0b3JPclZhbHVlIEVpdGhlciB0aGUgZmllbGQncyBvcGVyYXRvciBvciBpdHMgdmFsdWUuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF92YWx1ZSBUaGUgZmlsdGVyJ3MgdmFsdWUuXG5cdCAqIEBjaGFpbm5hYmxlXG5cdCAqL1xuXHRmaWx0ZXIoZmllbGRPckZpbHRlciwgb3B0X29wZXJhdG9yT3JWYWx1ZSwgb3B0X3ZhbHVlKSB7XG5cdFx0bGV0IGZpbHRlciA9IEZpbHRlci50b0ZpbHRlcihmaWVsZE9yRmlsdGVyLCBvcHRfb3BlcmF0b3JPclZhbHVlLCBvcHRfdmFsdWUpO1xuXHRcdGlmICghdGhpcy5ib2R5Xy5maWx0ZXIpIHtcblx0XHRcdHRoaXMuYm9keV8uZmlsdGVyID0gW107XG5cdFx0fVxuXHRcdHRoaXMuYm9keV8uZmlsdGVyLnB1c2goZmlsdGVyLmJvZHkoKSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgcXVlcnkgb2Zmc2V0LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IFRoZSBpbmRleCBvZiB0aGUgZmlyc3QgZW50cnkgdGhhdCBzaG91bGQgYmUgcmV0dXJuZWRcblx0ICogICBieSB0aGlzIHF1ZXJ5LlxuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cblx0b2Zmc2V0KG9mZnNldCkge1xuXHRcdHRoaXMuYm9keV8ub2Zmc2V0ID0gb2Zmc2V0O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBoaWdobGlnaHQgZW50cnkgdG8gdGhpcyB7QGxpbmsgUXVlcnl9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGZpZWxkJ3MgbmFtZS5cblx0ICogQGNoYWlubmFibGVcblx0ICovXG5cdGhpZ2hsaWdodChmaWVsZCkge1xuXHRcdGlmICghdGhpcy5ib2R5Xy5oaWdobGlnaHQpIHtcblx0XHRcdHRoaXMuYm9keV8uaGlnaGxpZ2h0ID0gW107XG5cdFx0fVxuXG5cdFx0dGhpcy5ib2R5Xy5oaWdobGlnaHQucHVzaChmaWVsZCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgcXVlcnkgbGltaXQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCBUaGUgbWF4IGFtb3VudCBvZiBlbnRyaWVzIHRoYXQgdGhpcyBxdWVyeSBzaG91bGQgcmV0dXJuLlxuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cblx0bGltaXQobGltaXQpIHtcblx0XHR0aGlzLmJvZHlfLmxpbWl0ID0gbGltaXQ7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIHNlYXJjaCB0byB0aGlzIHtAbGluayBRdWVyeX0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7IUZpbHRlcnxzdHJpbmd9IGZpbHRlck9yVGV4dE9yRmllbGQgSWYgbm8gb3RoZXIgYXJndW1lbnRzXG5cdCAqICAgYXJlIHBhc3NlZCB0byB0aGlzIGZ1bmN0aW9uLCB0aGlzIHNob3VsZCBiZSBlaXRoZXIgYSB7QGxpbmsgRmlsdGVyfVxuXHQgKiAgIGluc3RhbmNlIG9yIGEgdGV4dCB0byBiZSB1c2VkIGluIGEgbWF0Y2ggZmlsdGVyLiBJbiBib3RoIGNhc2VzXG5cdCAqICAgdGhlIGZpbHRlciB3aWxsIGJlIGFwcGxpZWQgdG8gYWxsIGZpZWxkcy4gQW5vdGhlciBvcHRpb24gaXMgdG9cblx0ICogICBwYXNzIHRoaXMgYXMgYSBmaWVsZCBuYW1lIGluc3RlYWQsIHRvZ2V0aGVyIHdpdGggb3RoZXIgYXJndW1lbnRzXG5cdCAqICAgc28gdGhlIGZpbHRlciBjYW4gYmUgY3JlYXRlZC5cblx0ICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfdGV4dE9yT3BlcmF0b3IgRWl0aGVyIGEgdGV4dCB0byBiZSB1c2VkIGluIGFcblx0ICogICBtYXRjaCBmaWx0ZXIsIG9yIHRoZSBvcGVyYXRvciB0aGF0IHNob3VsZCBiZSB1c2VkLlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfdmFsdWUgVGhlIHZhbHVlIHRvIGJlIHVzZWQgYnkgdGhlIGZpbHRlci4gU2hvdWxkXG5cdCAqICAgb25seSBiZSBwYXNzZWQgaWYgYW4gb3BlcmF0b3Igd2FzIHBhc3NlZCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LlxuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cblx0c2VhcmNoKGZpbHRlck9yVGV4dE9yRmllbGQsIG9wdF90ZXh0T3JPcGVyYXRvciwgb3B0X3ZhbHVlKSB7XG5cdFx0dmFyIGZpbHRlciA9IGZpbHRlck9yVGV4dE9yRmllbGQ7XG5cblx0XHRpZiAob3B0X3ZhbHVlKSB7XG5cdFx0XHRmaWx0ZXIgPSBGaWx0ZXIuZmllbGQoZmlsdGVyT3JUZXh0T3JGaWVsZCwgb3B0X3RleHRPck9wZXJhdG9yLCBvcHRfdmFsdWUpO1xuXHRcdH0gZWxzZSBpZiAob3B0X3RleHRPck9wZXJhdG9yKSB7XG5cdFx0XHRmaWx0ZXIgPSBGaWx0ZXIubWF0Y2goZmlsdGVyT3JUZXh0T3JGaWVsZCwgb3B0X3RleHRPck9wZXJhdG9yKTtcblx0XHR9IGVsc2UgaWYgKCEoZmlsdGVyIGluc3RhbmNlb2YgRmlsdGVyKSkge1xuXHRcdFx0ZmlsdGVyID0gRmlsdGVyLm1hdGNoKGZpbHRlck9yVGV4dE9yRmllbGQpO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5ib2R5Xy5zZWFyY2gpIHtcblx0XHRcdHRoaXMuYm9keV8uc2VhcmNoID0gW107XG5cdFx0fVxuXG5cdFx0aWYgKGNvcmUuaXNEZWZBbmROb3ROdWxsKGZpbHRlck9yVGV4dE9yRmllbGQpKSB7XG5cdFx0XHR0aGlzLmJvZHlfLnNlYXJjaC5wdXNoKGZpbHRlci5ib2R5KCkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmJvZHlfLnNlYXJjaC5wdXNoKHt9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgc29ydCBlbnRyeSB0byB0aGlzIHF1ZXJ5LCBzcGVjaWZ5aW5nIHRoZSBmaWVsZCB0aGlzIHF1ZXJ5IHNob3VsZCBiZVxuXHQgKiBzb3J0ZWQgYnkgYW5kLCBvcHRpb25hbGx5LCB0aGUgc29ydCBkaXJlY3Rpb24uXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQgdGhhdCB0aGUgcXVlcnkgc2hvdWxkIGJlIHNvcnRlZCBieS5cblx0ICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfZGlyZWN0aW9uIFRoZSBkaXJlY3Rpb24gdGhlIHNvcnQgb3BlcmF0aW9uIHNob3VsZCB1c2UuXG5cdCAqICAgSWYgbm9uZSBpcyBnaXZlbiwgXCJhc2NcIiBpcyB1c2VkIGJ5IGRlZmF1bHQuXG5cdCAqIEBjaGFpbm5hYmxlXG5cdCAqL1xuXHRzb3J0KGZpZWxkLCBvcHRfZGlyZWN0aW9uKSB7XG5cdFx0aWYgKCF0aGlzLmJvZHlfLnNvcnQpIHtcblx0XHRcdHRoaXMuYm9keV8uc29ydCA9IFtdO1xuXHRcdH1cblx0XHR2YXIgc29ydEVudHJ5ID0ge307XG5cdFx0c29ydEVudHJ5W2ZpZWxkXSA9IG9wdF9kaXJlY3Rpb24gfHwgJ2FzYyc7XG5cdFx0dGhpcy5ib2R5Xy5zb3J0LnB1c2goc29ydEVudHJ5KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBxdWVyeSB0eXBlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUaGUgcXVlcnkncyB0eXBlLiBGb3IgZXhhbXBsZTogXCJjb3VudFwiLCBcImZldGNoXCIuXG5cdCAqIEBjaGFpbm5hYmxlXG5cdCAqL1xuXHR0eXBlKHR5cGUpIHtcblx0XHR0aGlzLmJvZHlfLnR5cGUgPSB0eXBlO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFF1ZXJ5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgQXBpSGVscGVyIGZyb20gJy4uL0FwaUhlbHBlcic7XG5pbXBvcnQgUXVlcnkgZnJvbSAnLi4vLi4vYXBpLXF1ZXJ5L1F1ZXJ5JztcbmltcG9ydCBGaWx0ZXIgZnJvbSAnLi4vLi4vYXBpLXF1ZXJ5L0ZpbHRlcic7XG5pbXBvcnQgeyBhc3NlcnREZWZBbmROb3ROdWxsLCBhc3NlcnRPYmplY3QsIGFzc2VydFJlc3BvbnNlU3VjY2VlZGVkIH0gZnJvbSAnLi4vYXNzZXJ0aW9ucyc7XG5pbXBvcnQgeyBjb3JlIH0gZnJvbSAnbWV0YWwnO1xuXG4vKipcbiAqIENsYXNzIHJlc3BvbnNpYmxlIGZvciBlbmNhcHN1bGF0ZSBkYXRhIGFwaSBjYWxscy5cbiAqL1xuY2xhc3MgRGF0YUFwaUhlbHBlciBleHRlbmRzIEFwaUhlbHBlciB7XG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGFuIHtAbGluayBEYXRhQXBpSGVscGVyfSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtAbGluayBXZURlcGxveX0gaW5zdGFuY2UuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0Y29uc3RydWN0b3Iod2VkZXBsb3lDbGllbnQpIHtcblx0XHRzdXBlcih3ZWRlcGxveUNsaWVudCk7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIGZpbHRlciB0byB0aGlzIHJlcXVlc3QncyB7QGxpbmsgUXVlcnl9LlxuXHQgKiBAcGFyYW0geyFGaWx0ZXJ8c3RyaW5nfSBmaWVsZE9yRmlsdGVyIEVpdGhlciBhIEZpbHRlciBpbnN0YW5jZSBvciB0aGVcblx0ICogICBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF9vcGVyYXRvck9yVmFsdWUgRWl0aGVyIHRoZSBmaWVsZCdzIG9wZXJhdG9yIG9yIGl0cyB2YWx1ZS5cblx0ICogQHBhcmFtIHsqPX0gb3B0X3ZhbHVlIFRoZSBmaWx0ZXIncyB2YWx1ZS5cblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0d2hlcmUoZmllbGRPckZpbHRlciwgb3B0X29wZXJhdG9yT3JWYWx1ZSwgb3B0X3ZhbHVlKSB7XG5cdFx0dGhpcy5nZXRPckNyZWF0ZUZpbHRlcl8oKS5hbmQoZmllbGRPckZpbHRlciwgb3B0X29wZXJhdG9yT3JWYWx1ZSwgb3B0X3ZhbHVlKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgZmlsdGVyIHRvIGJlIGNvbXBvc2VkIHdpdGggdGhpcyBmaWx0ZXIgdXNpbmcgdGhlIFwib3JcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHshRmlsdGVyfHN0cmluZ30gZmllbGRPckZpbHRlciBFaXRoZXIgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSBvclxuXHQgKiAgIHRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF9vcGVyYXRvck9yVmFsdWUgRWl0aGVyIHRoZSBmaWVsZCdzIG9wZXJhdG9yIG9yIGl0cyB2YWx1ZS5cblx0ICogQHBhcmFtIHsqPX0gb3B0X3ZhbHVlIFRoZSBmaWx0ZXIncyB2YWx1ZS5cblx0ICogQGNoYWlubmFibGVcblx0ICovXG5cdG9yKGZpZWxkT3JGaWx0ZXIsIG9wdF9vcGVyYXRvck9yVmFsdWUsIG9wdF92YWx1ZSkge1xuXHRcdGlmICh0aGlzLmdldE9yQ3JlYXRlRmlsdGVyXygpLmJvZHkoKS5hbmQubGVuZ3RoID09PSAwKSB7XG5cdFx0XHR0aHJvdyBFcnJvcignSXRcXCdzIHJlcXVpcmVkIHRvIGhhdmUgYSBjb25kaXRpb24gYmVmb3JlIHVzaW5nIGFuIFxcJ29yKClcXCcgZm9yIHRoZSBmaXJzdCB0aW1lLicpO1xuXHRcdH1cblx0XHR0aGlzLmdldE9yQ3JlYXRlRmlsdGVyXygpLm9yKGZpZWxkT3JGaWx0ZXIsIG9wdF9vcGVyYXRvck9yVmFsdWUsIG9wdF92YWx1ZSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIGZpbHRlciB0byBiZSBjb21wb3NlIHdpdGggdGhpcyBmaWx0ZXIgdXNpbmcgXCJub25lXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gZmlsdGVyIGJ5LlxuXHQgKiBAcGFyYW0geyEoQXJyYXl8Li4uKil9IGFyZ3MgQSB2YXJpYWJsZSBhbW91bnQgb2YgdmFsdWVzIHRvIGJlIHVzZWQgd2l0aFxuXHQgKiB0aGUgXCJub25lXCIgb3BlcmF0b3IuIENhbiBiZSBwYXNzZWQgZWl0aGVyIGFzIGEgc2luZ2xlIGFycmF5IG9yIGFzXG5cdCAqIHNlcGFyYXRlIHBhcmFtcy5cblx0ICogQGNoYWlubmFibGVcblx0ICovXG5cdG5vbmUoZmllbGQsIC4uLmFyZ3MpIHtcblx0XHRyZXR1cm4gdGhpcy53aGVyZShGaWx0ZXIubm9uZShmaWVsZCwgYXJncykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBmaWx0ZXIgdG8gYmUgY29tcG9zZSB3aXRoIHRoaXMgZmlsdGVyIHVzaW5nIFwibWF0Y2hcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkT3JRdWVyeSBJZiBubyBzZWNvbmQgc3RyaW5nIGFyZ3VtZW50IGlzIGdpdmVuLCB0aGlzXG5cdCAqIHNob3VsZCBiZSB0aGUgcXVlcnkgc3RyaW5nLCBpbiB3aGljaCBjYXNlIGFsbCBmaWVsZHMgd2lsbCBiZSBtYXRjaGVkLlxuXHQgKiBPdGhlcndpc2UsIHRoaXMgc2hvdWxkIGJlIHRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBtYXRjaC5cblx0ICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfcXVlcnkgVGhlIHF1ZXJ5IHN0cmluZy5cblx0ICogQGNoYWlubmFibGVcblx0ICovXG5cdG1hdGNoKGZpZWxkLCB2YWx1ZSkge1xuXHRcdHJldHVybiB0aGlzLndoZXJlKEZpbHRlci5tYXRjaChmaWVsZCwgdmFsdWUpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgZmlsdGVyIHRvIGJlIGNvbXBvc2Ugd2l0aCB0aGlzIGZpbHRlciB1c2luZyBcInNpbWlsYXJcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkT3JRdWVyeSBJZiBubyBzZWNvbmQgc3RyaW5nIGFyZ3VtZW50IGlzIGdpdmVuLCB0aGlzXG5cdCAqIHNob3VsZCBiZSB0aGUgcXVlcnkgc3RyaW5nLCBpbiB3aGljaCBjYXNlIGFsbCBmaWVsZHMgd2lsbCBiZSBtYXRjaGVkLlxuXHQgKiBPdGhlcndpc2UsIHRoaXMgc2hvdWxkIGJlIHRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBtYXRjaC5cblx0ICogQHBhcmFtIHs/c3RyaW5nfSBxdWVyeSBUaGUgcXVlcnkgc3RyaW5nLlxuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cblx0c2ltaWxhcihmaWVsZE9yUXVlcnksIHF1ZXJ5KSB7XG5cdFx0cmV0dXJuIHRoaXMud2hlcmUoRmlsdGVyLnNpbWlsYXIoZmllbGRPclF1ZXJ5LCBxdWVyeSkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSB0aGF0IHVzZXMgdGhlIFwiPFwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIGZpbHRlciBieS5cblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgZmlsdGVyJ3MgdmFsdWUuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG4gICAqIEBzdGF0aWNcblx0ICovXG5cdGx0KGZpZWxkLCB2YWx1ZSkge1xuXHRcdHJldHVybiB0aGlzLndoZXJlKEZpbHRlci5sdChmaWVsZCwgdmFsdWUpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcIjw9XCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gZmlsdGVyIGJ5LlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBmaWx0ZXIncyB2YWx1ZS5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cbiAgICogQHN0YXRpY1xuXHQgKi9cblx0bHRlKGZpZWxkLCB2YWx1ZSkge1xuXHRcdHJldHVybiB0aGlzLndoZXJlKEZpbHRlci5sdGUoZmllbGQsIHZhbHVlKSk7XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgZmlsdGVyIHRvIGJlIGNvbXBvc2Ugd2l0aCB0aGlzIGZpbHRlciB1c2luZyBcImFueVwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIGZpbHRlciBieS5cblx0ICogQHBhcmFtIHshKEFycmF5fC4uLiopfSBhcmdzIEEgdmFyaWFibGUgYW1vdW50IG9mIHZhbHVlcyB0byBiZSB1c2VkIHdpdGhcblx0ICogdGhlIFwibm9uZVwiIG9wZXJhdG9yLiBDYW4gYmUgcGFzc2VkIGVpdGhlciBhcyBhIHNpbmdsZSBhcnJheSBvciBhc1xuXHQgKiBzZXBhcmF0ZSBwYXJhbXMuXG5cdCAqIEBjaGFpbm5hYmxlXG5cdCAqL1xuXHRhbnkoZmllbGQsIC4uLmFyZ3MpIHtcblx0XHRyZXR1cm4gdGhpcy53aGVyZShGaWx0ZXIuYW55KGZpZWxkLCBhcmdzKSk7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIGZpbHRlciB0byBiZSBjb21wb3NlIHdpdGggdGhpcyBmaWx0ZXIgdXNpbmcgXCJncFwiIG9wZXJhdG9yLiBUaGlzIGlzIGFcblx0ICogc3BlY2lhbCB1c2UgY2FzZSBvZiBgRmlsdGVyLnBvbHlnb25gIGZvciBib3VuZGluZyBib3hlcy5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBmaWVsZCdzIG5hbWUuXG5cdCAqIEBwYXJhbSB7Kn0gYm94T3JVcHBlckxlZnQgRWl0aGVyIGEgYEdlby5Cb3VuZGluZ0JveGAgaW5zdGFuY2UsIG9yIGFcblx0ICogYm91bmRpbmcgYm94J3MgdXBwZXIgbGVmdCBjb29yZGluYXRlLlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfbG93ZXJSaWdodCBBIGJvdW5kaW5nIGJveCdzIGxvd2VyIHJpZ2h0IGNvb3JkaW5hdGUuXG5cdCAqIEBjaGFpbm5hYmxlXG5cdCAqL1xuXHRib3VuZGluZ0JveChmaWVsZCwgYm94T3JVcHBlckxlZnQsIG9wdF9sb3dlclJpZ2h0KSB7XG5cdFx0cmV0dXJuIHRoaXMud2hlcmUoRmlsdGVyLmJvdW5kaW5nQm94KGZpZWxkLCBib3hPclVwcGVyTGVmdCwgb3B0X2xvd2VyUmlnaHQpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgZmlsdGVyIHRvIGJlIGNvbXBvc2Ugd2l0aCB0aGlzIGZpbHRlciB1c2luZyBcImdkXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQncyBuYW1lLlxuXHQgKiBAcGFyYW0geyp9IGxvY2F0aW9uT3JDaXJjbGUgRWl0aGVyIGEgYEdlby5DaXJjbGVgIGluc3RhbmNlIG9yIGFcblx0ICogY29vcmRpbmF0ZS5cblx0ICogQHBhcmFtIHtSYW5nZXxzdHJpbmc9fSBvcHRfcmFuZ2VPckRpc3RhbmNlIEVpdGhlciBhIGBSYW5nZWAgaW5zdGFuY2Ugb3Jcblx0ICogdGhlIGRpc3RhbmNlIHZhbHVlLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cblx0ZGlzdGFuY2UoZmllbGQsIGxvY2F0aW9uT3JDaXJjbGUsIG9wdF9yYW5nZU9yRGlzdGFuY2UpIHtcblx0XHRyZXR1cm4gdGhpcy53aGVyZShGaWx0ZXIuZGlzdGFuY2UoZmllbGQsIGxvY2F0aW9uT3JDaXJjbGUsIG9wdF9yYW5nZU9yRGlzdGFuY2UpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgZmlsdGVyIHRvIGJlIGNvbXBvc2Ugd2l0aCB0aGlzIGZpbHRlciB1c2luZyBcInJhbmdlXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQncyBuYW1lLlxuXHQgKiBAcGFyYW0geyp9IHJhbmdlT3JNaW4gRWl0aGVyIGEgYFJhbmdlYCBpbnN0YW5jZSBvciBhIHRoZSByYW5nZSdzIG1pblxuXHQgKiB2YWx1ZS5cblx0ICogQHBhcmFtIHsqPX0gb3B0X21heCBUaGUgcmFuZ2UncyBtYXggdmFsdWUuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG5cdCAqIEBjaGFpbm5hYmxlXG5cdCAqL1xuXHRyYW5nZShmaWVsZCwgcmFuZ2VPck1pbiwgb3B0X21heCkge1xuXHRcdHJldHVybiB0aGlzLndoZXJlKEZpbHRlci5yYW5nZShmaWVsZCwgcmFuZ2VPck1pbiwgb3B0X21heCkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGxpbWl0IGZvciB0aGlzIHJlcXVlc3QncyB7QGxpbmsgUXVlcnl9LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gbGltaXQgVGhlIG1heCBhbW91bnQgb2YgZW50cmllcyB0aGF0IHRoaXMgcmVxdWVzdCBzaG91bGQgcmV0dXJuLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRsaW1pdChsaW1pdCkge1xuXHRcdHRoaXMuZ2V0T3JDcmVhdGVRdWVyeV8oKS5saW1pdChsaW1pdCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgb2Zmc2V0IGZvciB0aGlzIHJlcXVlc3QncyB7QGxpbmsgUXVlcnl9LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IFRoZSBpbmRleCBvZiB0aGUgZmlyc3QgZW50cnkgdGhhdCBzaG91bGQgYmVcblx0ICogcmV0dXJuZWQgYnkgdGhpcyBxdWVyeS5cblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0b2Zmc2V0KG9mZnNldCkge1xuXHRcdHRoaXMuZ2V0T3JDcmVhdGVRdWVyeV8oKS5vZmZzZXQob2Zmc2V0KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgaGlnaGxpZ2h0IGVudHJ5IHRvIHRoaXMgcmVxdWVzdCdzIHtAbGluayBRdWVyeX0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQncyBuYW1lLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRoaWdobGlnaHQoZmllbGQpIHtcblx0XHR0aGlzLmdldE9yQ3JlYXRlUXVlcnlfKCkuaGlnaGxpZ2h0KGZpZWxkKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGFuIGFnZ3JlZ2F0aW9uIHRvIHRoaXMge0BsaW5rIFF1ZXJ5fSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIGFnZ3JlZ2F0aW9uIG5hbWUuXG5cdCAqIEBwYXJhbSB7IUFnZ3JlZ2F0aW9ufHN0cmluZ30gYWdncmVnYXRpb25PckZpZWxkIEVpdGhlciBhbiB7QGxpbmtcblx0ICogQWdncmVnYXRpb259IGluc3RhbmNlIG9yIHRoZSBuYW1lIG9mIHRoZSBhZ2dyZWdhdGlvbiBmaWVsZC5cblx0ICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfb3BlcmF0b3IgVGhlIGFnZ3JlZ2F0aW9uIG9wZXJhdG9yLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRhZ2dyZWdhdGUobmFtZSwgYWdncmVnYXRpb25PckZpZWxkLCBvcHRfb3BlcmF0b3IpIHtcblx0XHR0aGlzLmdldE9yQ3JlYXRlUXVlcnlfKCkuYWdncmVnYXRlKG5hbWUsIGFnZ3JlZ2F0aW9uT3JGaWVsZCwgb3B0X29wZXJhdG9yKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoaXMgcmVxdWVzdCdzIHF1ZXJ5IHR5cGUgdG8gJ2NvdW50Jy5cblx0ICogQGNoYWlubmFibGVcblx0ICovXG5cdGNvdW50KCkge1xuXHRcdHRoaXMuZ2V0T3JDcmVhdGVRdWVyeV8oKS50eXBlKCdjb3VudCcpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBzb3J0IHF1ZXJ5IHRvIHRoaXMgcmVxdWVzdCdzIGJvZHkuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQgdGhhdCB0aGUgcXVlcnkgc2hvdWxkIGJlIHNvcnRlZCBieS5cblx0ICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfZGlyZWN0aW9uIFRoZSBkaXJlY3Rpb24gdGhlIHNvcnQgb3BlcmF0aW9uIHNob3VsZFxuXHQgKiB1c2UuIElmIG5vbmUgaXMgZ2l2ZW4sICdhc2MnIGlzIHVzZWQgYnkgZGVmYXVsdC5cblx0ICogQGNoYWlubmFibGVcblx0ICovXG5cdG9yZGVyQnkoZmllbGQsIG9wdF9kaXJlY3Rpb24pIHtcblx0XHR0aGlzLmdldE9yQ3JlYXRlUXVlcnlfKCkuc29ydChmaWVsZCwgb3B0X2RpcmVjdGlvbik7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiBvYmplY3QgKG9yIG11bHRpcGxlIG9iamVjdHMpIGFuZCBzYXZlcyBpdCB0byBXZURlcGxveSBkYXRhLiBJZlxuXHQgKiB0aGVyZSdzIGEgdmFsaWRhdGlvbiByZWdpc3RlcmVkIGluIHRoZSBjb2xsZWN0aW9uIGFuZCB0aGUgcmVxdWVzdCBpc1xuXHQgKiBzdWNjZXNzZnVsLCB0aGUgcmVzdWx0aW5nIG9iamVjdCAob3IgYXJyYXkgb2Ygb2JqZWN0cykgaXMgcmV0dXJuZWQuIFRoZVxuXHQgKiBkYXRhIHBhcmFtZXRlciBjYW4gYmUgZWl0aGVyIGFuIE9iamVjdCBvciBhbiBBcnJheSBvZiBPYmplY3RzLlxuXHQgKiBUaGVzZSBPYmplY3RzIGRlc2NyaWJlIHRoZSBhdHRyaWJ1dGVzIG9uIHRoZSBvYmplY3RzIHRoYXQgYXJlIHRvIGJlIGNyZWF0ZWQuXG5cdCAqIGBgYGphdmFzY3JpcHRcblx0ICogdmFyIGRhdGEgPSBXZURlcGxveS5kYXRhKCdodHRwOi8vZGVtb2RhdGEud2VkZXBsb3kuaW8nKTtcblx0ICpcblx0ICogZGF0YS5jcmVhdGUoJ21vdmllcycsIHsndGl0bGUnPT4gJ1N0YXIgV2FyczogRXBpc29kZSBJIOKAkyBUaGUgUGhhbnRvbSBNZW5hY2UnfSlcblx0ICogXHRcdCAudGhlbihmdW5jdGlvbihtb3ZpZSl7XG5cdCAqIFx0XHRcdCBjb25zb2xlLmxvZyhtb3ZpZSlcblx0ICogICAgIH0pO1xuXHQgKlxuXHQgKiBkYXRhLmNyZWF0ZSgnbW92aWVzJywgW3sndGl0bGUnPT4gJ1N0YXIgV2FyczogRXBpc29kZSBJSSDigJMgQXR0YWNrIG9mIHRoZSBDbG9uZXMnfSxcblx0ICogXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0eyd0aXRsZSc9PiAnU3RhciBXYXJzOiBFcGlzb2RlIElJSSDigJMgUmV2ZW5nZSBvZiB0aGUgU2l0aCd9KVxuXHQgKiBcdFx0IC50aGVuKGZ1bmN0aW9uKG1vdmllcyl7XG5cdCAqIFx0XHRcdCBjb25zb2xlLmxvZyhtb3ZpZXMpXG5cdCAqICAgICB9KTtcblx0ICogYGBgXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBjb2xsZWN0aW9uIENvbGxlY3Rpb24gKGtleSkgdXNlZCB0byBjcmVhdGUgdGhlIG5ldyBkYXRhLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBBdHRyaWJ1dGVzIG9uIHRoZSBvYmplY3QgdGhhdCBpcyB0byBiZSBjcmVhdGVkLlxuXHQgKiBAcmV0dXJuIHshQ2FuY2VsbGFibGVQcm9taXNlfVxuXHQgKi9cblx0Y3JlYXRlKGNvbGxlY3Rpb24sIGRhdGEpIHtcblx0XHRhc3NlcnREZWZBbmROb3ROdWxsKGNvbGxlY3Rpb24sICdDb2xsZWN0aW9uIGtleSBtdXN0IGJlIHNwZWNpZmllZC4nKTtcblx0XHRhc3NlcnRPYmplY3QoZGF0YSwgJ0RhdGEgY2FuXFwndCBiZSBlbXB0eS4nKTtcblxuXHRcdHJldHVybiB0aGlzLndlZGVwbG95Q2xpZW50XG5cdFx0XHQudXJsKHRoaXMud2VkZXBsb3lDbGllbnQuZGF0YVVybF8pXG5cdFx0XHQuYXV0aCh0aGlzLmhlbHBlckF1dGhTY29wZSlcblx0XHRcdC5wYXRoKGNvbGxlY3Rpb24pXG5cdFx0XHQucG9zdChkYXRhKVxuXHRcdFx0LnRoZW4ocmVzcG9uc2UgPT4gYXNzZXJ0UmVzcG9uc2VTdWNjZWVkZWQocmVzcG9uc2UpKVxuXHRcdFx0LnRoZW4ocmVzcG9uc2UgPT4gcmVzcG9uc2UuYm9keSgpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBVcGRhdGUgdGhlIGF0dHJpYnV0ZXMgb2YgYSBkb2N1bWVudCBmb3JtIHRoZSBwYXNzZWQtaW4gb2JqZWN0IGFuZCBzYXZlc1xuXHQgKiB0aGUgcmVjb3JkLiBJZiB0aGUgb2JqZWN0IGlzIGludmFsaWQsIHRoZSBzYXZpbmcgd2lsbCBmYWlsIGFuZCBhbiBlcnJvclxuXHQgKiBvYmplY3Qgd2lsbCBiZSByZXR1cm5lZC5cblx0ICpcblx0ICogYGBgamF2YXNjcmlwdFxuXHQgKiB2YXIgZGF0YSA9IFdlRGVwbG95LmRhdGEoJ2h0dHA6Ly9kZW1vZGF0YS53ZWRlcGxveS5pbycpO1xuXHQgKlxuXHQgKiBkYXRhLnVwZGF0ZSgnbW92aWVzLzEwMTkxMTIzNTMnLCB7J3RpdGxlJz0+ICdTdGFyIFdhcnM6IEVwaXNvZGUgSSd9KVxuXHQgKiBcdFx0IC50aGVuKGZ1bmN0aW9uKG1vdmllKXtcblx0ICogXHRcdFx0IGNvbnNvbGUubG9nKG1vdmllKVxuXHQgKiAgICAgfSk7XG5cdCAqIGBgYFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZG9jdW1lbnQgS2V5IHVzZWQgdG8gdXBkYXRlIHRoZSBkb2N1bWVudC5cblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGEgQXR0cmlidXRlcyBvbiB0aGUgb2JqZWN0IHRoYXQgaXMgdG8gYmUgdXBkYXRlZC5cblx0ICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZX1cblx0ICovXG5cdHVwZGF0ZShkb2N1bWVudCwgZGF0YSkge1xuXHRcdGFzc2VydERlZkFuZE5vdE51bGwoZG9jdW1lbnQsICdEb2N1bWVudCBrZXkgbXVzdCBiZSBzcGVjaWZpZWQuJyk7XG5cdFx0YXNzZXJ0T2JqZWN0KGRhdGEsICdEYXRhIG11c3QgYmUgc3BlY2lmaWVkLicpO1xuXG5cdFx0cmV0dXJuIHRoaXMud2VkZXBsb3lDbGllbnRcblx0XHRcdC51cmwodGhpcy53ZWRlcGxveUNsaWVudC5kYXRhVXJsXylcblx0XHRcdC5hdXRoKHRoaXMuaGVscGVyQXV0aFNjb3BlKVxuXHRcdFx0LnBhdGgoZG9jdW1lbnQpXG5cdFx0XHQucHV0KGRhdGEpXG5cdFx0XHQudGhlbihyZXNwb25zZSA9PiBhc3NlcnRSZXNwb25zZVN1Y2NlZWRlZChyZXNwb25zZSkpXG5cdFx0XHQudGhlbihyZXNwb25zZSA9PiByZXNwb25zZS5ib2R5KCkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIERlbGV0ZXMgYSBbZG9jdW1lbnQvZmllbGQvY29sbGVjdGlvbl0uXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgS2V5IHVzZWQgdG8gZGVsZXRlIHRoZVxuXHQgKiBkb2N1bWVudC9maWVsZC9jb2xsZWN0aW9uLlxuXHQgKiBAcmV0dXJuIHshQ2FuY2VsbGFibGVQcm9taXNlfVxuXHQgKi9cblx0ZGVsZXRlKGtleSkge1xuXHRcdGFzc2VydERlZkFuZE5vdE51bGwoa2V5LCAnRG9jdW1lbnQvRmllbGQvQ29sbGVjdGlvbiBrZXkgbXVzdCBiZSBzcGVjaWZpZWQnKTtcblxuXHRcdHJldHVybiB0aGlzLndlZGVwbG95Q2xpZW50XG5cdFx0XHQudXJsKHRoaXMud2VkZXBsb3lDbGllbnQuZGF0YVVybF8pXG5cdFx0XHQuYXV0aCh0aGlzLmhlbHBlckF1dGhTY29wZSlcblx0XHRcdC5wYXRoKGtleSlcblx0XHRcdC5kZWxldGUoKVxuXHRcdFx0LnRoZW4ocmVzcG9uc2UgPT4gYXNzZXJ0UmVzcG9uc2VTdWNjZWVkZWQocmVzcG9uc2UpKVxuXHRcdFx0LnRoZW4oKCkgPT4gdW5kZWZpbmVkKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXRyaWV2ZSBkYXRhIGZyb20gYSBbZG9jdW1lbnQvZmllbGQvY29sbGVjdGlvbl0uXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgS2V5IHVzZWQgdG8gZGVsZXRlIHRoZSBkb2N1bWVudC9maWVsZC9jb2xsZWN0aW9uLlxuXHQgKiBAcmV0dXJuIHshQ2FuY2VsbGFibGVQcm9taXNlfVxuXHQgKi9cblx0Z2V0KGtleSkge1xuXHRcdGFzc2VydERlZkFuZE5vdE51bGwoa2V5LCAnRG9jdW1lbnQvRmllbGQvQ29sbGVjdGlvbiBrZXkgbXVzdCBiZSBzcGVjaWZpZWQnKTtcblxuXHRcdHRoaXMuYWRkRmlsdGVyc1RvUXVlcnlfKCk7XG5cblx0XHRyZXR1cm4gdGhpcy53ZWRlcGxveUNsaWVudFxuXHRcdFx0LnVybCh0aGlzLndlZGVwbG95Q2xpZW50LmRhdGFVcmxfKVxuXHRcdFx0LmF1dGgodGhpcy5oZWxwZXJBdXRoU2NvcGUpXG5cdFx0XHQucGF0aChrZXkpXG5cdFx0XHQuZ2V0KHRoaXMucXVlcnlfKVxuXHRcdFx0LnRoZW4ocmVzcG9uc2UgPT4gYXNzZXJ0UmVzcG9uc2VTdWNjZWVkZWQocmVzcG9uc2UpKVxuXHRcdFx0LnRoZW4ocmVzcG9uc2UgPT4gcmVzcG9uc2UuYm9keSgpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXRyaWV2ZSBkYXRhIGZyb20gYSBbZG9jdW1lbnQvZmllbGQvY29sbGVjdGlvbl0gYW5kIHB1dCBpdCBpbiBhIHNlYXJjaFxuXHQgKiBmb3JtYXQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgS2V5IHVzZWQgdG8gZGVsZXRlIHRoZSBkb2N1bWVudC9maWVsZC9jb2xsZWN0aW9uLlxuXHQgKiBAcmV0dXJuIHshQ2FuY2VsbGFibGVQcm9taXNlfVxuXHQgKi9cblx0c2VhcmNoKGtleSkge1xuXHRcdGFzc2VydERlZkFuZE5vdE51bGwoa2V5LCAnRG9jdW1lbnQvRmllbGQvQ29sbGVjdGlvbiBrZXkgbXVzdCBiZSBzcGVjaWZpZWQnKTtcblxuXHRcdHRoaXMub25TZWFyY2hfKCk7XG5cblx0XHR0aGlzLmFkZEZpbHRlcnNUb1F1ZXJ5XygpO1xuXG5cdFx0cmV0dXJuIHRoaXMud2VkZXBsb3lDbGllbnRcblx0XHRcdC51cmwodGhpcy53ZWRlcGxveUNsaWVudC5kYXRhVXJsXylcblx0XHRcdC5hdXRoKHRoaXMuaGVscGVyQXV0aFNjb3BlKVxuXHRcdFx0LnBhdGgoa2V5KVxuXHRcdFx0LmdldCh0aGlzLnF1ZXJ5Xylcblx0XHRcdC50aGVuKHJlc3BvbnNlID0+IGFzc2VydFJlc3BvbnNlU3VjY2VlZGVkKHJlc3BvbnNlKSlcblx0XHRcdC50aGVuKHJlc3BvbnNlID0+IHJlc3BvbnNlLmJvZHkoKSk7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBuZXcgc29ja2V0LmlvIGluc3RhbmNlLiBNb25pdG9yIHRoZSBhcnJpdmFsIG9mIG5ldyBicm9hZGNhc3RlZFxuXHQgKiBkYXRhLlxuXHQgKiBAcGFyYW0gIHtzdHJpbmd9IGNvbGxlY3Rpb24ga2V5L2NvbGxlY3Rpb24gdXNlZCB0byBmaW5kIG9yZ2FuaXplZCBkYXRhLlxuXHQgKiBAcGFyYW0gIHtPYmplY3Q9fSBvcHRfb3B0aW9ucyBPYmplY3Qgd2l0aCBTb2NrZXQgSU8gb3B0aW9ucy5cblx0ICogQHJldHVybiB7IWlvfSBTb2NrZXQgSU8gcmVmZXJlbmNlLiBTZXJ2ZXIgZXZlbnRzIGNhbiBiZSBsaXN0ZW5lZCBvbiBpdC5cblx0ICovXG5cdHdhdGNoKGNvbGxlY3Rpb24sIG9wdF9vcHRpb25zKSB7XG5cdFx0YXNzZXJ0RGVmQW5kTm90TnVsbChjb2xsZWN0aW9uLCAnQ29sbGVjdGlvbiBrZXkgbXVzdCBiZSBzcGVjaWZpZWQnKTtcblxuXHRcdHRoaXMuYWRkRmlsdGVyc1RvUXVlcnlfKCk7XG5cblx0XHRyZXR1cm4gdGhpcy53ZWRlcGxveUNsaWVudFxuXHRcdFx0LnVybCh0aGlzLndlZGVwbG95Q2xpZW50LmRhdGFVcmxfKVxuXHRcdFx0LmF1dGgodGhpcy5oZWxwZXJBdXRoU2NvcGUpXG5cdFx0XHQucGF0aChjb2xsZWN0aW9uKVxuXHRcdFx0LndhdGNoKHRoaXMucXVlcnlfLCBvcHRfb3B0aW9ucyk7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgY3VycmVudGwgdXNlZCBtYWluIHtAbGluayBGaWx0ZXJ9IG9iamVjdC4gSWYgbm9uZSBleGlzdHMgeWV0LCBhXG5cdCAqIG5ldyBvbmUgaXMgY3JlYXRlZC5cblx0ICogQHJldHVybiB7IVF1ZXJ5fVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRnZXRPckNyZWF0ZUZpbHRlcl8oKSB7XG5cdFx0aWYgKCF0aGlzLmZpbHRlcl8pIHtcblx0XHRcdHRoaXMuZmlsdGVyXyA9IG5ldyBGaWx0ZXIoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyXztcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBjdXJyZW50bHkgdXNlZCB7QGxpbmsgUXVlcnl9IG9iamVjdC4gSWYgbm9uZSBleGlzdHMgeWV0LFxuXHQgKiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cblx0ICogQHJldHVybiB7IVF1ZXJ5fVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRnZXRPckNyZWF0ZVF1ZXJ5XygpIHtcblx0XHRpZiAoIXRoaXMucXVlcnlfKSB7XG5cdFx0XHR0aGlzLnF1ZXJ5XyA9IG5ldyBRdWVyeSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5xdWVyeV87XG5cdH1cblxuXHQvKipcblx0ICogTG9hZCB0aGUgY3VycmVudGx5IHVzZWQgbWFpbiB7QGxpbmsgRmlsdGVyfSBvYmplY3QgaW50byB0aGUgY3VycmVudGx5XG5cdCAqIHVzZWQge0BsaW5rIFF1ZXJ5fS5cblx0ICogQGNoYWluYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRhZGRGaWx0ZXJzVG9RdWVyeV8oKSB7XG5cdFx0aWYgKGNvcmUuaXNEZWYodGhpcy5maWx0ZXJfKSAmJiB0aGlzLnRvU2VhcmNoXyAhPT0gdHJ1ZSkge1xuXHRcdFx0dGhpcy5nZXRPckNyZWF0ZVF1ZXJ5XygpLmZpbHRlcih0aGlzLmZpbHRlcl8pO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgc2VhcmNoIHRvIHRoaXMgcmVxdWVzdCdzIHtAbGluayBRdWVyeX0gaW5zdGFuY2UuXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0b25TZWFyY2hfKCkge1xuXHRcdGlmIChjb3JlLmlzRGVmKHRoaXMuZmlsdGVyXykpIHtcblx0XHRcdHRoaXMuZ2V0T3JDcmVhdGVRdWVyeV8oKS5zZWFyY2godGhpcy5nZXRPckNyZWF0ZUZpbHRlcl8oKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IEVycm9yKCdJdFxcJ3MgcmVxdWlyZWQgdG8gaGF2ZSBhIGNvbmRpdGlvbiBiZWZvcmUgdXNpbmcgYW4gXFwnc2VhcmNoKClcXCcgZm9yIHRoZSBmaXJzdCB0aW1lLicpO1xuXHRcdH1cblx0XHR0aGlzLnRvU2VhcmNoXyA9IHRydWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBEYXRhQXBpSGVscGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEFic3RyYWN0aW9uIGxheWVyIGZvciBzdHJpbmcgdG8gYmFzZTY0IGNvbnZlcnNpb25cbiAqIHJlZmVyZW5jZTogaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy8zNDYyXG4gKi9cbmNsYXNzIEJhc2U2NCB7XG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgYmFzZS02NCBlbmNvZGVkIEFTQ0lJIHN0cmluZyBmcm9tIGEgXCJzdHJpbmdcIiBvZiBiaW5hcnkgZGF0YS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyB0byBiZSBlbmNvZGVkLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBlbmNvZGVTdHJpbmcoc3RyaW5nKSB7XG5cdFx0aWYgKHR5cGVvZiBidG9hID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRyZXR1cm4gYnRvYShzdHJpbmcpO1xuXHRcdH1cblxuXHRcdHJldHVybiBuZXcgQnVmZmVyKHN0cmluZy50b1N0cmluZygpLCAnYmluYXJ5Jyk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZTY0O1xuIiwiLyohXG4gKiBQcm9taXNlcyBwb2x5ZmlsbCBmcm9tIEdvb2dsZSdzIENsb3N1cmUgTGlicmFyeS5cbiAqXG4gKiAgICAgIENvcHlyaWdodCAyMDEzIFRoZSBDbG9zdXJlIExpYnJhcnkgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBOT1RFKGVkdWFyZG8pOiBQcm9taXNlIHN1cHBvcnQgaXMgbm90IHJlYWR5IG9uIGFsbCBzdXBwb3J0ZWQgYnJvd3NlcnMsXG4gKiB0aGVyZWZvcmUgbWV0YWwtcHJvbWlzZSBpcyB0ZW1wb3JhcmlseSB1c2luZyBHb29nbGUncyBwcm9taXNlcyBhcyBwb2x5ZmlsbC5cbiAqIEl0IHN1cHBvcnRzIGNhbmNlbGxhYmxlIHByb21pc2VzIGFuZCBoYXMgY2xlYW4gYW5kIGZhc3QgaW1wbGVtZW50YXRpb24uXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgeyBpc0RlZiwgaXNGdW5jdGlvbiwgaXNPYmplY3QgfSBmcm9tICdtZXRhbCc7XG5pbXBvcnQgeyBhc3luYyB9IGZyb20gJ21ldGFsJztcblxuLyoqXG4gKiBQcm92aWRlcyBhIG1vcmUgc3RyaWN0IGludGVyZmFjZSBmb3IgVGhlbmFibGVzIGluIHRlcm1zIG9mXG4gKiBodHRwOi8vcHJvbWlzZXNhcGx1cy5jb20gZm9yIGludGVyb3Agd2l0aCB7QHNlZSBDYW5jZWxsYWJsZVByb21pc2V9LlxuICpcbiAqIEBpbnRlcmZhY2VcbiAqIEBleHRlbmRzIHtJVGhlbmFibGUuPFRZUEU+fVxuICogQHRlbXBsYXRlIFRZUEVcbiAqL1xudmFyIFRoZW5hYmxlID0gZnVuY3Rpb24oKSB7fTtcblxuLyoqXG4gKiBBZGRzIGNhbGxiYWNrcyB0aGF0IHdpbGwgb3BlcmF0ZSBvbiB0aGUgcmVzdWx0IG9mIHRoZSBUaGVuYWJsZSwgcmV0dXJuaW5nIGFcbiAqIG5ldyBjaGlsZCBQcm9taXNlLlxuICpcbiAqIElmIHRoZSBUaGVuYWJsZSBpcyBmdWxmaWxsZWQsIHRoZSB7QGNvZGUgb25GdWxmaWxsZWR9IGNhbGxiYWNrIHdpbGwgYmVcbiAqIGludm9rZWQgd2l0aCB0aGUgZnVsZmlsbG1lbnQgdmFsdWUgYXMgYXJndW1lbnQsIGFuZCB0aGUgY2hpbGQgUHJvbWlzZSB3aWxsXG4gKiBiZSBmdWxmaWxsZWQgd2l0aCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBjYWxsYmFjay4gSWYgdGhlIGNhbGxiYWNrIHRocm93c1xuICogYW4gZXhjZXB0aW9uLCB0aGUgY2hpbGQgUHJvbWlzZSB3aWxsIGJlIHJlamVjdGVkIHdpdGggdGhlIHRocm93biB2YWx1ZVxuICogaW5zdGVhZC5cbiAqXG4gKiBJZiB0aGUgVGhlbmFibGUgaXMgcmVqZWN0ZWQsIHRoZSB7QGNvZGUgb25SZWplY3RlZH0gY2FsbGJhY2sgd2lsbCBiZSBpbnZva2VkXG4gKiB3aXRoIHRoZSByZWplY3Rpb24gcmVhc29uIGFzIGFyZ3VtZW50LCBhbmQgdGhlIGNoaWxkIFByb21pc2Ugd2lsbCBiZSByZWplY3RlZFxuICogd2l0aCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBjYWxsYmFjayBvciB0aHJvd24gdmFsdWUuXG4gKlxuICogQHBhcmFtIHs/KGZ1bmN0aW9uKHRoaXM6VEhJUywgVFlQRSk6XG4gKiAgICAgICAgICAgICAoUkVTVUxUfElUaGVuYWJsZS48UkVTVUxUPnxUaGVuYWJsZSkpPX0gb3B0X29uRnVsZmlsbGVkIEFcbiAqICAgICBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgaW52b2tlZCB3aXRoIHRoZSBmdWxmaWxsbWVudCB2YWx1ZSBpZiB0aGUgUHJvbWlzZVxuICogICAgIGlzIGZ1bGxmaWxsZWQuXG4gKiBAcGFyYW0gez8oZnVuY3Rpb24oKik6ICopPX0gb3B0X29uUmVqZWN0ZWQgQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgaW52b2tlZFxuICogICAgIHdpdGggdGhlIHJlamVjdGlvbiByZWFzb24gaWYgdGhlIFByb21pc2UgaXMgcmVqZWN0ZWQuXG4gKiBAcGFyYW0ge1RISVM9fSBvcHRfY29udGV4dCBBbiBvcHRpb25hbCBjb250ZXh0IG9iamVjdCB0aGF0IHdpbGwgYmUgdGhlXG4gKiAgICAgZXhlY3V0aW9uIGNvbnRleHQgZm9yIHRoZSBjYWxsYmFja3MuIEJ5IGRlZmF1bHQsIGZ1bmN0aW9ucyBhcmUgZXhlY3V0ZWRcbiAqICAgICB3aXRoIHRoZSBkZWZhdWx0IHRoaXMuXG4gKiBAcmV0dXJuIHshQ2FuY2VsbGFibGVQcm9taXNlLjxSRVNVTFQ+fSBBIG5ldyBQcm9taXNlIHRoYXQgd2lsbCByZWNlaXZlIHRoZVxuICogICAgIHJlc3VsdCBvZiB0aGUgZnVsZmlsbG1lbnQgb3IgcmVqZWN0aW9uIGNhbGxiYWNrLlxuICogQHRlbXBsYXRlIFJFU1VMVCxUSElTXG4gKi9cblRoZW5hYmxlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24oKSB7fTtcblxuXG4vKipcbiAqIEFuIGV4cGFuZG8gcHJvcGVydHkgdG8gaW5kaWNhdGUgdGhhdCBhbiBvYmplY3QgaW1wbGVtZW50c1xuICoge0Bjb2RlIFRoZW5hYmxlfS5cbiAqXG4gKiB7QHNlZSBhZGRJbXBsZW1lbnRhdGlvbn0uXG4gKlxuICogQGNvbnN0XG4gKi9cblRoZW5hYmxlLklNUExFTUVOVEVEX0JZX1BST1AgPSAnJGdvb2dfVGhlbmFibGUnO1xuXG5cbi8qKlxuICogTWFya3MgYSBnaXZlbiBjbGFzcyAoY29uc3RydWN0b3IpIGFzIGFuIGltcGxlbWVudGF0aW9uIG9mIFRoZW5hYmxlLCBzb1xuICogdGhhdCB3ZSBjYW4gcXVlcnkgdGhhdCBmYWN0IGF0IHJ1bnRpbWUuIFRoZSBjbGFzcyBtdXN0IGhhdmUgYWxyZWFkeVxuICogaW1wbGVtZW50ZWQgdGhlIGludGVyZmFjZS5cbiAqIEV4cG9ydHMgYSAndGhlbicgbWV0aG9kIG9uIHRoZSBjb25zdHJ1Y3RvciBwcm90b3R5cGUsIHNvIHRoYXQgdGhlIG9iamVjdHNcbiAqIGFsc28gaW1wbGVtZW50IHRoZSBleHRlcm4ge0BzZWUgVGhlbmFibGV9IGludGVyZmFjZSBmb3IgaW50ZXJvcCB3aXRoXG4gKiBvdGhlciBQcm9taXNlIGltcGxlbWVudGF0aW9ucy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24obmV3OlRoZW5hYmxlLC4uLls/XSl9IGN0b3IgVGhlIGNsYXNzIGNvbnN0cnVjdG9yLiBUaGVcbiAqICAgICBjb3JyZXNwb25kaW5nIGNsYXNzIG11c3QgaGF2ZSBhbHJlYWR5IGltcGxlbWVudGVkIHRoZSBpbnRlcmZhY2UuXG4gKi9cblRoZW5hYmxlLmFkZEltcGxlbWVudGF0aW9uID0gZnVuY3Rpb24oY3Rvcikge1xuICBjdG9yLnByb3RvdHlwZS50aGVuID0gY3Rvci5wcm90b3R5cGUudGhlbjtcbiAgY3Rvci5wcm90b3R5cGUuJGdvb2dfVGhlbmFibGUgPSB0cnVlO1xufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIGEgZ2l2ZW4gaW5zdGFuY2UgaW1wbGVtZW50cyB7QGNvZGUgVGhlbmFibGV9LlxuICogICAgIFRoZSBjbGFzcy9zdXBlcmNsYXNzIG9mIHRoZSBpbnN0YW5jZSBtdXN0IGNhbGwge0Bjb2RlIGFkZEltcGxlbWVudGF0aW9ufS5cbiAqL1xuVGhlbmFibGUuaXNJbXBsZW1lbnRlZEJ5ID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gIGlmICghb2JqZWN0KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhb2JqZWN0LiRnb29nX1RoZW5hYmxlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gUHJvcGVydHkgYWNjZXNzIHNlZW1zIHRvIGJlIGZvcmJpZGRlbi5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBMaWtlIGJpbmQoKSwgZXhjZXB0IHRoYXQgYSAndGhpcyBvYmplY3QnIGlzIG5vdCByZXF1aXJlZC4gVXNlZnVsIHdoZW4gdGhlXG4gKiB0YXJnZXQgZnVuY3Rpb24gaXMgYWxyZWFkeSBib3VuZC5cbiAqXG4gKiBVc2FnZTpcbiAqIHZhciBnID0gcGFydGlhbChmLCBhcmcxLCBhcmcyKTtcbiAqIGcoYXJnMywgYXJnNCk7XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gQSBmdW5jdGlvbiB0byBwYXJ0aWFsbHkgYXBwbHkuXG4gKiBAcGFyYW0gey4uLip9IHZhcl9hcmdzIEFkZGl0aW9uYWwgYXJndW1lbnRzIHRoYXQgYXJlIHBhcnRpYWxseSBhcHBsaWVkIHRvIGZuLlxuICogQHJldHVybiB7IUZ1bmN0aW9ufSBBIHBhcnRpYWxseS1hcHBsaWVkIGZvcm0gb2YgdGhlIGZ1bmN0aW9uIGJpbmQoKSB3YXNcbiAqICAgICBpbnZva2VkIGFzIGEgbWV0aG9kIG9mLlxuICovXG52YXIgcGFydGlhbCA9IGZ1bmN0aW9uKGZuKSB7XG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIC8vIENsb25lIHRoZSBhcnJheSAod2l0aCBzbGljZSgpKSBhbmQgYXBwZW5kIGFkZGl0aW9uYWwgYXJndW1lbnRzXG4gICAgLy8gdG8gdGhlIGV4aXN0aW5nIGFyZ3VtZW50cy5cbiAgICB2YXIgbmV3QXJncyA9IGFyZ3Muc2xpY2UoKTtcbiAgICBuZXdBcmdzLnB1c2guYXBwbHkobmV3QXJncywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgbmV3QXJncyk7XG4gIH07XG59O1xuXG4vKipcbiAqIFByb21pc2VzIHByb3ZpZGUgYSByZXN1bHQgdGhhdCBtYXkgYmUgcmVzb2x2ZWQgYXN5bmNocm9ub3VzbHkuIEEgUHJvbWlzZSBtYXlcbiAqIGJlIHJlc29sdmVkIGJ5IGJlaW5nIGZ1bGZpbGxlZCBvciByZWplY3RlZCB3aXRoIGEgdmFsdWUsIHdoaWNoIHdpbGwgYmUga25vd25cbiAqIGFzIHRoZSBmdWxmaWxsbWVudCB2YWx1ZSBvciB0aGUgcmVqZWN0aW9uIHJlYXNvbi4gV2hldGhlciBmdWxmaWxsZWQgb3JcbiAqIHJlamVjdGVkLCB0aGUgUHJvbWlzZSByZXN1bHQgaXMgaW1tdXRhYmxlIG9uY2UgaXQgaXMgc2V0LlxuICpcbiAqIFByb21pc2VzIG1heSByZXByZXNlbnQgcmVzdWx0cyBvZiBhbnkgdHlwZSwgaW5jbHVkaW5nIHVuZGVmaW5lZC4gUmVqZWN0aW9uXG4gKiByZWFzb25zIGFyZSB0eXBpY2FsbHkgRXJyb3JzLCBidXQgbWF5IGFsc28gYmUgb2YgYW55IHR5cGUuIENsb3N1cmUgUHJvbWlzZXNcbiAqIGFsbG93IGZvciBvcHRpb25hbCB0eXBlIGFubm90YXRpb25zIHRoYXQgZW5mb3JjZSB0aGF0IGZ1bGZpbGxtZW50IHZhbHVlcyBhcmVcbiAqIG9mIHRoZSBhcHByb3ByaWF0ZSB0eXBlcyBhdCBjb21waWxlIHRpbWUuXG4gKlxuICogVGhlIHJlc3VsdCBvZiBhIFByb21pc2UgaXMgYWNjZXNzaWJsZSBieSBjYWxsaW5nIHtAY29kZSB0aGVufSBhbmQgcmVnaXN0ZXJpbmdcbiAqIHtAY29kZSBvbkZ1bGZpbGxlZH0gYW5kIHtAY29kZSBvblJlamVjdGVkfSBjYWxsYmFja3MuIE9uY2UgdGhlIFByb21pc2VcbiAqIHJlc29sdmVzLCB0aGUgcmVsZXZhbnQgY2FsbGJhY2tzIGFyZSBpbnZva2VkIHdpdGggdGhlIGZ1bGZpbGxtZW50IHZhbHVlIG9yXG4gKiByZWplY3Rpb24gcmVhc29uIGFzIGFyZ3VtZW50LiBDYWxsYmFja3MgYXJlIGFsd2F5cyBpbnZva2VkIGluIHRoZSBvcmRlciB0aGV5XG4gKiB3ZXJlIHJlZ2lzdGVyZWQsIGV2ZW4gd2hlbiBhZGRpdGlvbmFsIHtAY29kZSB0aGVufSBjYWxscyBhcmUgbWFkZSBmcm9tIGluc2lkZVxuICogYW5vdGhlciBjYWxsYmFjay4gQSBjYWxsYmFjayBpcyBhbHdheXMgcnVuIGFzeW5jaHJvbm91c2x5IHNvbWV0aW1lIGFmdGVyIHRoZVxuICogc2NvcGUgY29udGFpbmluZyB0aGUgcmVnaXN0ZXJpbmcge0Bjb2RlIHRoZW59IGludm9jYXRpb24gaGFzIHJldHVybmVkLlxuICpcbiAqIElmIGEgUHJvbWlzZSBpcyByZXNvbHZlZCB3aXRoIGFub3RoZXIgUHJvbWlzZSwgdGhlIGZpcnN0IFByb21pc2Ugd2lsbCBibG9ja1xuICogdW50aWwgdGhlIHNlY29uZCBpcyByZXNvbHZlZCwgYW5kIHRoZW4gYXNzdW1lcyB0aGUgc2FtZSByZXN1bHQgYXMgdGhlIHNlY29uZFxuICogUHJvbWlzZS4gVGhpcyBhbGxvd3MgUHJvbWlzZXMgdG8gZGVwZW5kIG9uIHRoZSByZXN1bHRzIG9mIG90aGVyIFByb21pc2VzLFxuICogbGlua2luZyB0b2dldGhlciBtdWx0aXBsZSBhc3luY2hyb25vdXMgb3BlcmF0aW9ucy5cbiAqXG4gKiBUaGlzIGltcGxlbWVudGF0aW9uIGlzIGNvbXBhdGlibGUgd2l0aCB0aGUgUHJvbWlzZXMvQSsgc3BlY2lmaWNhdGlvbiBhbmRcbiAqIHBhc3NlcyB0aGF0IHNwZWNpZmljYXRpb24ncyBjb25mb3JtYW5jZSB0ZXN0IHN1aXRlLiBBIENsb3N1cmUgUHJvbWlzZSBtYXkgYmVcbiAqIHJlc29sdmVkIHdpdGggYSBQcm9taXNlIGluc3RhbmNlIChvciBzdWZmaWNpZW50bHkgY29tcGF0aWJsZSBQcm9taXNlLWxpa2VcbiAqIG9iamVjdCkgY3JlYXRlZCBieSBvdGhlciBQcm9taXNlIGltcGxlbWVudGF0aW9ucy4gRnJvbSB0aGUgc3BlY2lmaWNhdGlvbixcbiAqIFByb21pc2UtbGlrZSBvYmplY3RzIGFyZSBrbm93biBhcyBcIlRoZW5hYmxlc1wiLlxuICpcbiAqIEBzZWUgaHR0cDovL3Byb21pc2VzYXBsdXMuY29tL1xuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oXG4gKiAgICAgICAgICAgICB0aGlzOlJFU09MVkVSX0NPTlRFWFQsXG4gKiAgICAgICAgICAgICBmdW5jdGlvbigoVFlQRXxJVGhlbmFibGUuPFRZUEU+fFRoZW5hYmxlKSksXG4gKiAgICAgICAgICAgICBmdW5jdGlvbigqKSk6IHZvaWR9IHJlc29sdmVyXG4gKiAgICAgSW5pdGlhbGl6YXRpb24gZnVuY3Rpb24gdGhhdCBpcyBpbnZva2VkIGltbWVkaWF0ZWx5IHdpdGgge0Bjb2RlIHJlc29sdmV9XG4gKiAgICAgYW5kIHtAY29kZSByZWplY3R9IGZ1bmN0aW9ucyBhcyBhcmd1bWVudHMuIFRoZSBQcm9taXNlIGlzIHJlc29sdmVkIG9yXG4gKiAgICAgcmVqZWN0ZWQgd2l0aCB0aGUgZmlyc3QgYXJndW1lbnQgcGFzc2VkIHRvIGVpdGhlciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7UkVTT0xWRVJfQ09OVEVYVD19IG9wdF9jb250ZXh0IEFuIG9wdGlvbmFsIGNvbnRleHQgZm9yIGV4ZWN1dGluZyB0aGVcbiAqICAgICByZXNvbHZlciBmdW5jdGlvbi4gSWYgdW5zcGVjaWZpZWQsIHRoZSByZXNvbHZlciBmdW5jdGlvbiB3aWxsIGJlIGV4ZWN1dGVkXG4gKiAgICAgaW4gdGhlIGRlZmF1bHQgc2NvcGUuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBzdHJ1Y3RcbiAqIEBmaW5hbFxuICogQGltcGxlbWVudHMge1RoZW5hYmxlLjxUWVBFPn1cbiAqIEB0ZW1wbGF0ZSBUWVBFLFJFU09MVkVSX0NPTlRFWFRcbiAqL1xudmFyIENhbmNlbGxhYmxlUHJvbWlzZSA9IGZ1bmN0aW9uKHJlc29sdmVyLCBvcHRfY29udGV4dCkge1xuICAvKipcbiAgICogVGhlIGludGVybmFsIHN0YXRlIG9mIHRoaXMgUHJvbWlzZS4gRWl0aGVyIFBFTkRJTkcsIEZVTEZJTExFRCwgUkVKRUNURUQsIG9yXG4gICAqIEJMT0NLRUQuXG4gICAqIEBwcml2YXRlIHtDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVffVxuICAgKi9cbiAgdGhpcy5zdGF0ZV8gPSBDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLlBFTkRJTkc7XG5cbiAgLyoqXG4gICAqIFRoZSByZXNvbHZlZCByZXN1bHQgb2YgdGhlIFByb21pc2UuIEltbXV0YWJsZSBvbmNlIHNldCB3aXRoIGVpdGhlciBhXG4gICAqIGZ1bGZpbGxtZW50IHZhbHVlIG9yIHJlamVjdGlvbiByZWFzb24uXG4gICAqIEBwcml2YXRlIHsqfVxuICAgKi9cbiAgdGhpcy5yZXN1bHRfID0gdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBGb3IgUHJvbWlzZXMgY3JlYXRlZCBieSBjYWxsaW5nIHtAY29kZSB0aGVuKCl9LCB0aGUgb3JpZ2luYXRpbmcgcGFyZW50LlxuICAgKiBAcHJpdmF0ZSB7Q2FuY2VsbGFibGVQcm9taXNlfVxuICAgKi9cbiAgdGhpcy5wYXJlbnRfID0gbnVsbDtcblxuICAvKipcbiAgICogVGhlIGxpc3Qgb2Yge0Bjb2RlIG9uRnVsZmlsbGVkfSBhbmQge0Bjb2RlIG9uUmVqZWN0ZWR9IGNhbGxiYWNrcyBhZGRlZCB0b1xuICAgKiB0aGlzIFByb21pc2UgYnkgY2FsbHMgdG8ge0Bjb2RlIHRoZW4oKX0uXG4gICAqIEBwcml2YXRlIHtBcnJheS48Q2FuY2VsbGFibGVQcm9taXNlLkNhbGxiYWNrRW50cnlfPn1cbiAgICovXG4gIHRoaXMuY2FsbGJhY2tFbnRyaWVzXyA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIFByb21pc2UgaXMgaW4gdGhlIHF1ZXVlIG9mIFByb21pc2VzIHRvIGV4ZWN1dGUuXG4gICAqIEBwcml2YXRlIHtib29sZWFufVxuICAgKi9cbiAgdGhpcy5leGVjdXRpbmdfID0gZmFsc2U7XG5cbiAgaWYgKENhbmNlbGxhYmxlUHJvbWlzZS5VTkhBTkRMRURfUkVKRUNUSU9OX0RFTEFZID4gMCkge1xuICAgIC8qKlxuICAgICAqIEEgdGltZW91dCBJRCB1c2VkIHdoZW4gdGhlIHtAY29kZSBVTkhBTkRMRURfUkVKRUNUSU9OX0RFTEFZfSBpcyBncmVhdGVyXG4gICAgICogdGhhbiAwIG1pbGxpc2Vjb25kcy4gVGhlIElEIGlzIHNldCB3aGVuIHRoZSBQcm9taXNlIGlzIHJlamVjdGVkLCBhbmRcbiAgICAgKiBjbGVhcmVkIG9ubHkgaWYgYW4ge0Bjb2RlIG9uUmVqZWN0ZWR9IGNhbGxiYWNrIGlzIGludm9rZWQgZm9yIHRoZVxuICAgICAqIFByb21pc2UgKG9yIG9uZSBvZiBpdHMgZGVzY2VuZGFudHMpIGJlZm9yZSB0aGUgZGVsYXkgaXMgZXhjZWVkZWQuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgcmVqZWN0aW9uIGlzIG5vdCBoYW5kbGVkIGJlZm9yZSB0aGUgdGltZW91dCBjb21wbGV0ZXMsIHRoZVxuICAgICAqIHJlamVjdGlvbiByZWFzb24gaXMgcGFzc2VkIHRvIHRoZSB1bmhhbmRsZWQgcmVqZWN0aW9uIGhhbmRsZXIuXG4gICAgICogQHByaXZhdGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnVuaGFuZGxlZFJlamVjdGlvbklkXyA9IDA7XG4gIH0gZWxzZSBpZiAoQ2FuY2VsbGFibGVQcm9taXNlLlVOSEFORExFRF9SRUpFQ1RJT05fREVMQVkgPT09IDApIHtcbiAgICAvKipcbiAgICAgKiBXaGVuIHRoZSB7QGNvZGUgVU5IQU5ETEVEX1JFSkVDVElPTl9ERUxBWX0gaXMgc2V0IHRvIDAgbWlsbGlzZWNvbmRzLCBhXG4gICAgICogYm9vbGVhbiB0aGF0IGlzIHNldCBpZiB0aGUgUHJvbWlzZSBpcyByZWplY3RlZCwgYW5kIHJlc2V0IHRvIGZhbHNlIGlmIGFuXG4gICAgICoge0Bjb2RlIG9uUmVqZWN0ZWR9IGNhbGxiYWNrIGlzIGludm9rZWQgZm9yIHRoZSBQcm9taXNlIChvciBvbmUgb2YgaXRzXG4gICAgICogZGVzY2VuZGFudHMpLiBJZiB0aGUgcmVqZWN0aW9uIGlzIG5vdCBoYW5kbGVkIGJlZm9yZSB0aGUgbmV4dCB0aW1lc3RlcCxcbiAgICAgKiB0aGUgcmVqZWN0aW9uIHJlYXNvbiBpcyBwYXNzZWQgdG8gdGhlIHVuaGFuZGxlZCByZWplY3Rpb24gaGFuZGxlci5cbiAgICAgKiBAcHJpdmF0ZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmhhZFVuaGFuZGxlZFJlamVjdGlvbl8gPSBmYWxzZTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHJlc29sdmVyLmNhbGwoXG4gICAgICBvcHRfY29udGV4dCwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgc2VsZi5yZXNvbHZlXyhDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLkZVTEZJTExFRCwgdmFsdWUpO1xuICAgICAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICAgIHNlbGYucmVzb2x2ZV8oQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5SRUpFQ1RFRCwgcmVhc29uKTtcbiAgICAgIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhpcy5yZXNvbHZlXyhDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLlJFSkVDVEVELCBlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBUaGUgZGVsYXkgaW4gbWlsbGlzZWNvbmRzIGJlZm9yZSBhIHJlamVjdGVkIFByb21pc2UncyByZWFzb24gaXMgcGFzc2VkIHRvXG4gKiB0aGUgcmVqZWN0aW9uIGhhbmRsZXIuIEJ5IGRlZmF1bHQsIHRoZSByZWplY3Rpb24gaGFuZGxlciByZXRocm93cyB0aGVcbiAqIHJlamVjdGlvbiByZWFzb24gc28gdGhhdCBpdCBhcHBlYXJzIGluIHRoZSBkZXZlbG9wZXIgY29uc29sZSBvclxuICoge0Bjb2RlIHdpbmRvdy5vbmVycm9yfSBoYW5kbGVyLlxuICogUmVqZWN0aW9ucyBhcmUgcmV0aHJvd24gYXMgcXVpY2tseSBhcyBwb3NzaWJsZSBieSBkZWZhdWx0LiBBIG5lZ2F0aXZlIHZhbHVlXG4gKiBkaXNhYmxlcyByZWplY3Rpb24gaGFuZGxpbmcgZW50aXJlbHkuXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UuVU5IQU5ETEVEX1JFSkVDVElPTl9ERUxBWSA9IDA7XG5cblxuLyoqXG4gKiBUaGUgcG9zc2libGUgaW50ZXJuYWwgc3RhdGVzIGZvciBhIFByb21pc2UuIFRoZXNlIHN0YXRlcyBhcmUgbm90IGRpcmVjdGx5XG4gKiBvYnNlcnZhYmxlIHRvIGV4dGVybmFsIGNhbGxlcnMuXG4gKiBAZW51bSB7bnVtYmVyfVxuICogQHByaXZhdGVcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXyA9IHtcbiAgLyoqIFRoZSBQcm9taXNlIGlzIHdhaXRpbmcgZm9yIHJlc29sdXRpb24uICovXG4gIFBFTkRJTkc6IDAsXG5cbiAgLyoqIFRoZSBQcm9taXNlIGlzIGJsb2NrZWQgd2FpdGluZyBmb3IgdGhlIHJlc3VsdCBvZiBhbm90aGVyIFRoZW5hYmxlLiAqL1xuICBCTE9DS0VEOiAxLFxuXG4gIC8qKiBUaGUgUHJvbWlzZSBoYXMgYmVlbiByZXNvbHZlZCB3aXRoIGEgZnVsZmlsbG1lbnQgdmFsdWUuICovXG4gIEZVTEZJTExFRDogMixcblxuICAvKiogVGhlIFByb21pc2UgaGFzIGJlZW4gcmVzb2x2ZWQgd2l0aCBhIHJlamVjdGlvbiByZWFzb24uICovXG4gIFJFSkVDVEVEOiAzXG59O1xuXG5cbi8qKlxuICogVHlwZWRlZiBmb3IgZW50cmllcyBpbiB0aGUgY2FsbGJhY2sgY2hhaW4uIEVhY2ggY2FsbCB0byB7QGNvZGUgdGhlbn0sXG4gKiB7QGNvZGUgdGhlbkNhdGNofSwgb3Ige0Bjb2RlIHRoZW5BbHdheXN9IGNyZWF0ZXMgYW4gZW50cnkgY29udGFpbmluZyB0aGVcbiAqIGZ1bmN0aW9ucyB0aGF0IG1heSBiZSBpbnZva2VkIG9uY2UgdGhlIFByb21pc2UgaXMgcmVzb2x2ZWQuXG4gKlxuICogQHR5cGVkZWYge3tcbiAqICAgY2hpbGQ6IENhbmNlbGxhYmxlUHJvbWlzZSxcbiAqICAgb25GdWxmaWxsZWQ6IGZ1bmN0aW9uKCopLFxuICogICBvblJlamVjdGVkOiBmdW5jdGlvbigqKVxuICogfX1cbiAqIEBwcml2YXRlXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5DYWxsYmFja0VudHJ5XyA9IG51bGw7XG5cblxuLyoqXG4gKiBAcGFyYW0geyhUWVBFfFRoZW5hYmxlLjxUWVBFPnxUaGVuYWJsZSk9fSBvcHRfdmFsdWVcbiAqIEByZXR1cm4geyFDYW5jZWxsYWJsZVByb21pc2UuPFRZUEU+fSBBIG5ldyBQcm9taXNlIHRoYXQgaXMgaW1tZWRpYXRlbHkgcmVzb2x2ZWRcbiAqICAgICB3aXRoIHRoZSBnaXZlbiB2YWx1ZS5cbiAqIEB0ZW1wbGF0ZSBUWVBFXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5yZXNvbHZlID0gZnVuY3Rpb24ob3B0X3ZhbHVlKSB7XG4gIHJldHVybiBuZXcgQ2FuY2VsbGFibGVQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgIHJlc29sdmUob3B0X3ZhbHVlKTtcbiAgICB9KTtcbn07XG5cblxuLyoqXG4gKiBAcGFyYW0geyo9fSBvcHRfcmVhc29uXG4gKiBAcmV0dXJuIHshQ2FuY2VsbGFibGVQcm9taXNlfSBBIG5ldyBQcm9taXNlIHRoYXQgaXMgaW1tZWRpYXRlbHkgcmVqZWN0ZWQgd2l0aCB0aGVcbiAqICAgICBnaXZlbiByZWFzb24uXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5yZWplY3QgPSBmdW5jdGlvbihvcHRfcmVhc29uKSB7XG4gIHJldHVybiBuZXcgQ2FuY2VsbGFibGVQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgcmVqZWN0KG9wdF9yZWFzb24pO1xuICAgIH0pO1xufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7IUFycmF5LjwhKFRoZW5hYmxlLjxUWVBFPnxUaGVuYWJsZSk+fSBwcm9taXNlc1xuICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZS48VFlQRT59IEEgUHJvbWlzZSB0aGF0IHJlY2VpdmVzIHRoZSByZXN1bHQgb2YgdGhlXG4gKiAgICAgZmlyc3QgUHJvbWlzZSAob3IgUHJvbWlzZS1saWtlKSBpbnB1dCB0byBjb21wbGV0ZS5cbiAqIEB0ZW1wbGF0ZSBUWVBFXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5yYWNlID0gZnVuY3Rpb24ocHJvbWlzZXMpIHtcbiAgcmV0dXJuIG5ldyBDYW5jZWxsYWJsZVByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBpZiAoIXByb21pc2VzLmxlbmd0aCkge1xuICAgICAgICByZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMCwgcHJvbWlzZTsgKHByb21pc2UgPSBwcm9taXNlc1tpXSk7IGkrKykge1xuICAgICAgICBwcm9taXNlLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH1cbiAgICB9KTtcbn07XG5cblxuLyoqXG4gKiBAcGFyYW0geyFBcnJheS48IShUaGVuYWJsZS48VFlQRT58VGhlbmFibGUpPn0gcHJvbWlzZXNcbiAqIEByZXR1cm4geyFDYW5jZWxsYWJsZVByb21pc2UuPCFBcnJheS48VFlQRT4+fSBBIFByb21pc2UgdGhhdCByZWNlaXZlcyBhIGxpc3Qgb2ZcbiAqICAgICBldmVyeSBmdWxmaWxsZWQgdmFsdWUgb25jZSBldmVyeSBpbnB1dCBQcm9taXNlIChvciBQcm9taXNlLWxpa2UpIGlzXG4gKiAgICAgc3VjY2Vzc2Z1bGx5IGZ1bGZpbGxlZCwgb3IgaXMgcmVqZWN0ZWQgYnkgdGhlIGZpcnN0IHJlamVjdGlvbiByZXN1bHQuXG4gKiBAdGVtcGxhdGUgVFlQRVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UuYWxsID0gZnVuY3Rpb24ocHJvbWlzZXMpIHtcbiAgcmV0dXJuIG5ldyBDYW5jZWxsYWJsZVByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgdG9GdWxmaWxsID0gcHJvbWlzZXMubGVuZ3RoO1xuICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuXG4gICAgICBpZiAoIXRvRnVsZmlsbCkge1xuICAgICAgICByZXNvbHZlKHZhbHVlcyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIG9uRnVsZmlsbCA9IGZ1bmN0aW9uKGluZGV4LCB2YWx1ZSkge1xuICAgICAgICB0b0Z1bGZpbGwtLTtcbiAgICAgICAgdmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICBpZiAodG9GdWxmaWxsID09PSAwKSB7XG4gICAgICAgICAgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgb25SZWplY3QgPSBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgICAgcmVqZWN0KHJlYXNvbik7XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgcHJvbWlzZTsgKHByb21pc2UgPSBwcm9taXNlc1tpXSk7IGkrKykge1xuICAgICAgICBwcm9taXNlLnRoZW4ocGFydGlhbChvbkZ1bGZpbGwsIGkpLCBvblJlamVjdCk7XG4gICAgICB9XG4gICAgfSk7XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHshQXJyYXkuPCEoVGhlbmFibGUuPFRZUEU+fFRoZW5hYmxlKT59IHByb21pc2VzXG4gKiBAcmV0dXJuIHshQ2FuY2VsbGFibGVQcm9taXNlLjxUWVBFPn0gQSBQcm9taXNlIHRoYXQgcmVjZWl2ZXMgdGhlIHZhbHVlIG9mXG4gKiAgICAgdGhlIGZpcnN0IGlucHV0IHRvIGJlIGZ1bGZpbGxlZCwgb3IgaXMgcmVqZWN0ZWQgd2l0aCBhIGxpc3Qgb2YgZXZlcnlcbiAqICAgICByZWplY3Rpb24gcmVhc29uIGlmIGFsbCBpbnB1dHMgYXJlIHJlamVjdGVkLlxuICogQHRlbXBsYXRlIFRZUEVcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLmZpcnN0RnVsZmlsbGVkID0gZnVuY3Rpb24ocHJvbWlzZXMpIHtcbiAgcmV0dXJuIG5ldyBDYW5jZWxsYWJsZVByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgdG9SZWplY3QgPSBwcm9taXNlcy5sZW5ndGg7XG4gICAgICB2YXIgcmVhc29ucyA9IFtdO1xuXG4gICAgICBpZiAoIXRvUmVqZWN0KSB7XG4gICAgICAgIHJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgb25GdWxmaWxsID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgb25SZWplY3QgPSBmdW5jdGlvbihpbmRleCwgcmVhc29uKSB7XG4gICAgICAgIHRvUmVqZWN0LS07XG4gICAgICAgIHJlYXNvbnNbaW5kZXhdID0gcmVhc29uO1xuICAgICAgICBpZiAodG9SZWplY3QgPT09IDApIHtcbiAgICAgICAgICByZWplY3QocmVhc29ucyk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBwcm9taXNlOyAocHJvbWlzZSA9IHByb21pc2VzW2ldKTsgaSsrKSB7XG4gICAgICAgIHByb21pc2UudGhlbihvbkZ1bGZpbGwsIHBhcnRpYWwob25SZWplY3QsIGkpKTtcbiAgICAgIH1cbiAgICB9KTtcbn07XG5cblxuLyoqXG4gKiBBZGRzIGNhbGxiYWNrcyB0aGF0IHdpbGwgb3BlcmF0ZSBvbiB0aGUgcmVzdWx0IG9mIHRoZSBQcm9taXNlLCByZXR1cm5pbmcgYVxuICogbmV3IGNoaWxkIFByb21pc2UuXG4gKlxuICogSWYgdGhlIFByb21pc2UgaXMgZnVsZmlsbGVkLCB0aGUge0Bjb2RlIG9uRnVsZmlsbGVkfSBjYWxsYmFjayB3aWxsIGJlIGludm9rZWRcbiAqIHdpdGggdGhlIGZ1bGZpbGxtZW50IHZhbHVlIGFzIGFyZ3VtZW50LCBhbmQgdGhlIGNoaWxkIFByb21pc2Ugd2lsbCBiZVxuICogZnVsZmlsbGVkIHdpdGggdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgY2FsbGJhY2suIElmIHRoZSBjYWxsYmFjayB0aHJvd3MgYW5cbiAqIGV4Y2VwdGlvbiwgdGhlIGNoaWxkIFByb21pc2Ugd2lsbCBiZSByZWplY3RlZCB3aXRoIHRoZSB0aHJvd24gdmFsdWUgaW5zdGVhZC5cbiAqXG4gKiBJZiB0aGUgUHJvbWlzZSBpcyByZWplY3RlZCwgdGhlIHtAY29kZSBvblJlamVjdGVkfSBjYWxsYmFjayB3aWxsIGJlIGludm9rZWRcbiAqIHdpdGggdGhlIHJlamVjdGlvbiByZWFzb24gYXMgYXJndW1lbnQsIGFuZCB0aGUgY2hpbGQgUHJvbWlzZSB3aWxsIGJlIHJlamVjdGVkXG4gKiB3aXRoIHRoZSByZXR1cm4gdmFsdWUgKG9yIHRocm93biB2YWx1ZSkgb2YgdGhlIGNhbGxiYWNrLlxuICpcbiAqIEBvdmVycmlkZVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbihvcHRfb25GdWxmaWxsZWQsIG9wdF9vblJlamVjdGVkLCBvcHRfY29udGV4dCkge1xuICByZXR1cm4gdGhpcy5hZGRDaGlsZFByb21pc2VfKFxuICAgIGlzRnVuY3Rpb24ob3B0X29uRnVsZmlsbGVkKSA/IG9wdF9vbkZ1bGZpbGxlZCA6IG51bGwsXG4gICAgaXNGdW5jdGlvbihvcHRfb25SZWplY3RlZCkgPyBvcHRfb25SZWplY3RlZCA6IG51bGwsXG4gICAgb3B0X2NvbnRleHQpO1xufTtcblRoZW5hYmxlLmFkZEltcGxlbWVudGF0aW9uKENhbmNlbGxhYmxlUHJvbWlzZSk7XG5cblxuLyoqXG4gKiBBZGRzIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGludm9rZWQgd2hldGhlciB0aGUgUHJvbWlzZSBpcyBmdWxmaWxsZWQgb3JcbiAqIHJlamVjdGVkLiBUaGUgY2FsbGJhY2sgcmVjZWl2ZXMgbm8gYXJndW1lbnQsIGFuZCBubyBuZXcgY2hpbGQgUHJvbWlzZSBpc1xuICogY3JlYXRlZC4gVGhpcyBpcyB1c2VmdWwgZm9yIGVuc3VyaW5nIHRoYXQgY2xlYW51cCB0YWtlcyBwbGFjZSBhZnRlciBjZXJ0YWluXG4gKiBhc3luY2hyb25vdXMgb3BlcmF0aW9ucy4gQ2FsbGJhY2tzIGFkZGVkIHdpdGgge0Bjb2RlIHRoZW5BbHdheXN9IHdpbGwgYmVcbiAqIGV4ZWN1dGVkIGluIHRoZSBzYW1lIG9yZGVyIHdpdGggb3RoZXIgY2FsbHMgdG8ge0Bjb2RlIHRoZW59LFxuICoge0Bjb2RlIHRoZW5BbHdheXN9LCBvciB7QGNvZGUgdGhlbkNhdGNofS5cbiAqXG4gKiBTaW5jZSBpdCBkb2VzIG5vdCBwcm9kdWNlIGEgbmV3IGNoaWxkIFByb21pc2UsIGNhbmNlbGxhdGlvbiBwcm9wYWdhdGlvbiBpc1xuICogbm90IHByZXZlbnRlZCBieSBhZGRpbmcgY2FsbGJhY2tzIHdpdGgge0Bjb2RlIHRoZW5BbHdheXN9LiBBIFByb21pc2UgdGhhdCBoYXNcbiAqIGEgY2xlYW51cCBoYW5kbGVyIGFkZGVkIHdpdGgge0Bjb2RlIHRoZW5BbHdheXN9IHdpbGwgYmUgY2FuY2VsZWQgaWYgYWxsIG9mXG4gKiBpdHMgY2hpbGRyZW4gY3JlYXRlZCBieSB7QGNvZGUgdGhlbn0gKG9yIHtAY29kZSB0aGVuQ2F0Y2h9KSBhcmUgY2FuY2VsZWQuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOlRISVMpOiB2b2lkfSBvblJlc29sdmVkIEEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGludm9rZWRcbiAqICAgICB3aGVuIHRoZSBQcm9taXNlIGlzIHJlc29sdmVkLlxuICogQHBhcmFtIHtUSElTPX0gb3B0X2NvbnRleHQgQW4gb3B0aW9uYWwgY29udGV4dCBvYmplY3QgdGhhdCB3aWxsIGJlIHRoZVxuICogICAgIGV4ZWN1dGlvbiBjb250ZXh0IGZvciB0aGUgY2FsbGJhY2tzLiBCeSBkZWZhdWx0LCBmdW5jdGlvbnMgYXJlIGV4ZWN1dGVkXG4gKiAgICAgaW4gdGhlIGdsb2JhbCBzY29wZS5cbiAqIEByZXR1cm4geyFDYW5jZWxsYWJsZVByb21pc2UuPFRZUEU+fSBUaGlzIFByb21pc2UsIGZvciBjaGFpbmluZyBhZGRpdGlvbmFsIGNhbGxzLlxuICogQHRlbXBsYXRlIFRISVNcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLnByb3RvdHlwZS50aGVuQWx3YXlzID0gZnVuY3Rpb24ob25SZXNvbHZlZCwgb3B0X2NvbnRleHQpIHtcbiAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEVuc3VyZSB0aGF0IG5vIGFyZ3VtZW50cyBhcmUgcGFzc2VkIHRvIG9uUmVzb2x2ZWQuXG4gICAgICBvblJlc29sdmVkLmNhbGwob3B0X2NvbnRleHQpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgQ2FuY2VsbGFibGVQcm9taXNlLmhhbmRsZVJlamVjdGlvbl8uY2FsbChudWxsLCBlcnIpO1xuICAgIH1cbiAgfTtcblxuICB0aGlzLmFkZENhbGxiYWNrRW50cnlfKHtcbiAgICBjaGlsZDogbnVsbCxcbiAgICBvblJlamVjdGVkOiBjYWxsYmFjayxcbiAgICBvbkZ1bGZpbGxlZDogY2FsbGJhY2tcbiAgfSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vKipcbiAqIEFkZHMgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgaW52b2tlZCBvbmx5IGlmIHRoZSBQcm9taXNlIGlzIHJlamVjdGVkLiBUaGlzXG4gKiBpcyBlcXVpdmFsZW50IHRvIHtAY29kZSB0aGVuKG51bGwsIG9uUmVqZWN0ZWQpfS5cbiAqXG4gKiBAcGFyYW0geyFmdW5jdGlvbih0aGlzOlRISVMsICopOiAqfSBvblJlamVjdGVkIEEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlXG4gKiAgICAgaW52b2tlZCB3aXRoIHRoZSByZWplY3Rpb24gcmVhc29uIGlmIHRoZSBQcm9taXNlIGlzIHJlamVjdGVkLlxuICogQHBhcmFtIHtUSElTPX0gb3B0X2NvbnRleHQgQW4gb3B0aW9uYWwgY29udGV4dCBvYmplY3QgdGhhdCB3aWxsIGJlIHRoZVxuICogICAgIGV4ZWN1dGlvbiBjb250ZXh0IGZvciB0aGUgY2FsbGJhY2tzLiBCeSBkZWZhdWx0LCBmdW5jdGlvbnMgYXJlIGV4ZWN1dGVkXG4gKiAgICAgaW4gdGhlIGdsb2JhbCBzY29wZS5cbiAqIEByZXR1cm4geyFDYW5jZWxsYWJsZVByb21pc2V9IEEgbmV3IFByb21pc2UgdGhhdCB3aWxsIHJlY2VpdmUgdGhlIHJlc3VsdCBvZiB0aGVcbiAqICAgICBjYWxsYmFjay5cbiAqIEB0ZW1wbGF0ZSBUSElTXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5wcm90b3R5cGUudGhlbkNhdGNoID0gZnVuY3Rpb24ob25SZWplY3RlZCwgb3B0X2NvbnRleHQpIHtcbiAgcmV0dXJuIHRoaXMuYWRkQ2hpbGRQcm9taXNlXyhudWxsLCBvblJlamVjdGVkLCBvcHRfY29udGV4dCk7XG59O1xuXG4vKipcbiAqIEFsaWFzIG9mIHtAbGluayBDYW5jZWxsYWJsZVByb21pc2UucHJvdG90eXBlLnRoZW5DYXRjaH1cbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLnByb3RvdHlwZS5jYXRjaCA9IENhbmNlbGxhYmxlUHJvbWlzZS5wcm90b3R5cGUudGhlbkNhdGNoO1xuXG5cbi8qKlxuICogQ2FuY2VscyB0aGUgUHJvbWlzZSBpZiBpdCBpcyBzdGlsbCBwZW5kaW5nIGJ5IHJlamVjdGluZyBpdCB3aXRoIGEgY2FuY2VsXG4gKiBFcnJvci4gTm8gYWN0aW9uIGlzIHBlcmZvcm1lZCBpZiB0aGUgUHJvbWlzZSBpcyBhbHJlYWR5IHJlc29sdmVkLlxuICpcbiAqIEFsbCBjaGlsZCBQcm9taXNlcyBvZiB0aGUgY2FuY2VsZWQgUHJvbWlzZSB3aWxsIGJlIHJlamVjdGVkIHdpdGggdGhlIHNhbWVcbiAqIGNhbmNlbCBlcnJvciwgYXMgd2l0aCBub3JtYWwgUHJvbWlzZSByZWplY3Rpb24uIElmIHRoZSBQcm9taXNlIHRvIGJlIGNhbmNlbGVkXG4gKiBpcyB0aGUgb25seSBjaGlsZCBvZiBhIHBlbmRpbmcgUHJvbWlzZSwgdGhlIHBhcmVudCBQcm9taXNlIHdpbGwgYWxzbyBiZVxuICogY2FuY2VsZWQuIENhbmNlbGxhdGlvbiBtYXkgcHJvcGFnYXRlIHVwd2FyZCB0aHJvdWdoIG11bHRpcGxlIGdlbmVyYXRpb25zLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X21lc3NhZ2UgQW4gb3B0aW9uYWwgZGVidWdnaW5nIG1lc3NhZ2UgZm9yIGRlc2NyaWJpbmcgdGhlXG4gKiAgICAgY2FuY2VsbGF0aW9uIHJlYXNvbi5cbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbihvcHRfbWVzc2FnZSkge1xuICBpZiAodGhpcy5zdGF0ZV8gPT09IENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uUEVORElORykge1xuICAgIGFzeW5jLnJ1bihmdW5jdGlvbigpIHtcbiAgICAgIHZhciBlcnIgPSBuZXcgQ2FuY2VsbGFibGVQcm9taXNlLkNhbmNlbGxhdGlvbkVycm9yKG9wdF9tZXNzYWdlKTtcbiAgICAgIGVyci5JU19DQU5DRUxMQVRJT05fRVJST1IgPSB0cnVlO1xuICAgICAgdGhpcy5jYW5jZWxJbnRlcm5hbF8oZXJyKTtcbiAgICB9LCB0aGlzKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIENhbmNlbHMgdGhpcyBQcm9taXNlIHdpdGggdGhlIGdpdmVuIGVycm9yLlxuICpcbiAqIEBwYXJhbSB7IUVycm9yfSBlcnIgVGhlIGNhbmNlbGxhdGlvbiBlcnJvci5cbiAqIEBwcml2YXRlXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5wcm90b3R5cGUuY2FuY2VsSW50ZXJuYWxfID0gZnVuY3Rpb24oZXJyKSB7XG4gIGlmICh0aGlzLnN0YXRlXyA9PT0gQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5QRU5ESU5HKSB7XG4gICAgaWYgKHRoaXMucGFyZW50Xykge1xuICAgICAgLy8gQ2FuY2VsIHRoZSBQcm9taXNlIGFuZCByZW1vdmUgaXQgZnJvbSB0aGUgcGFyZW50J3MgY2hpbGQgbGlzdC5cbiAgICAgIHRoaXMucGFyZW50Xy5jYW5jZWxDaGlsZF8odGhpcywgZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZXNvbHZlXyhDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLlJFSkVDVEVELCBlcnIpO1xuICAgIH1cbiAgfVxufTtcblxuXG4vKipcbiAqIENhbmNlbHMgYSBjaGlsZCBQcm9taXNlIGZyb20gdGhlIGxpc3Qgb2YgY2FsbGJhY2sgZW50cmllcy4gSWYgdGhlIFByb21pc2UgaGFzXG4gKiBub3QgYWxyZWFkeSBiZWVuIHJlc29sdmVkLCByZWplY3QgaXQgd2l0aCBhIGNhbmNlbCBlcnJvci4gSWYgdGhlcmUgYXJlIG5vXG4gKiBvdGhlciBjaGlsZHJlbiBpbiB0aGUgbGlzdCBvZiBjYWxsYmFjayBlbnRyaWVzLCBwcm9wYWdhdGUgdGhlIGNhbmNlbGxhdGlvblxuICogYnkgY2FuY2VsaW5nIHRoaXMgUHJvbWlzZSBhcyB3ZWxsLlxuICpcbiAqIEBwYXJhbSB7IUNhbmNlbGxhYmxlUHJvbWlzZX0gY2hpbGRQcm9taXNlIFRoZSBQcm9taXNlIHRvIGNhbmNlbC5cbiAqIEBwYXJhbSB7IUVycm9yfSBlcnIgVGhlIGNhbmNlbCBlcnJvciB0byB1c2UgZm9yIHJlamVjdGluZyB0aGUgUHJvbWlzZS5cbiAqIEBwcml2YXRlXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5wcm90b3R5cGUuY2FuY2VsQ2hpbGRfID0gZnVuY3Rpb24oY2hpbGRQcm9taXNlLCBlcnIpIHtcbiAgaWYgKCF0aGlzLmNhbGxiYWNrRW50cmllc18pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGNoaWxkQ291bnQgPSAwO1xuICB2YXIgY2hpbGRJbmRleCA9IC0xO1xuXG4gIC8vIEZpbmQgdGhlIGNhbGxiYWNrIGVudHJ5IGZvciB0aGUgY2hpbGRQcm9taXNlLCBhbmQgY291bnQgd2hldGhlciB0aGVyZSBhcmVcbiAgLy8gYWRkaXRpb25hbCBjaGlsZCBQcm9taXNlcy5cbiAgZm9yICh2YXIgaSA9IDAsIGVudHJ5OyAoZW50cnkgPSB0aGlzLmNhbGxiYWNrRW50cmllc19baV0pOyBpKyspIHtcbiAgICB2YXIgY2hpbGQgPSBlbnRyeS5jaGlsZDtcbiAgICBpZiAoY2hpbGQpIHtcbiAgICAgIGNoaWxkQ291bnQrKztcbiAgICAgIGlmIChjaGlsZCA9PT0gY2hpbGRQcm9taXNlKSB7XG4gICAgICAgIGNoaWxkSW5kZXggPSBpO1xuICAgICAgfVxuICAgICAgaWYgKGNoaWxkSW5kZXggPj0gMCAmJiBjaGlsZENvdW50ID4gMSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBJZiB0aGUgY2hpbGQgUHJvbWlzZSB3YXMgdGhlIG9ubHkgY2hpbGQsIGNhbmNlbCB0aGlzIFByb21pc2UgYXMgd2VsbC5cbiAgLy8gT3RoZXJ3aXNlLCByZWplY3Qgb25seSB0aGUgY2hpbGQgUHJvbWlzZSB3aXRoIHRoZSBjYW5jZWwgZXJyb3IuXG4gIGlmIChjaGlsZEluZGV4ID49IDApIHtcbiAgICBpZiAodGhpcy5zdGF0ZV8gPT09IENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uUEVORElORyAmJiBjaGlsZENvdW50ID09PSAxKSB7XG4gICAgICB0aGlzLmNhbmNlbEludGVybmFsXyhlcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY2FsbGJhY2tFbnRyeSA9IHRoaXMuY2FsbGJhY2tFbnRyaWVzXy5zcGxpY2UoY2hpbGRJbmRleCwgMSlbMF07XG4gICAgICB0aGlzLmV4ZWN1dGVDYWxsYmFja18oXG4gICAgICAgIGNhbGxiYWNrRW50cnksIENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uUkVKRUNURUQsIGVycik7XG4gICAgfVxuICB9XG59O1xuXG5cbi8qKlxuICogQWRkcyBhIGNhbGxiYWNrIGVudHJ5IHRvIHRoZSBjdXJyZW50IFByb21pc2UsIGFuZCBzY2hlZHVsZXMgY2FsbGJhY2tcbiAqIGV4ZWN1dGlvbiBpZiB0aGUgUHJvbWlzZSBoYXMgYWxyZWFkeSBiZWVuIHJlc29sdmVkLlxuICpcbiAqIEBwYXJhbSB7Q2FuY2VsbGFibGVQcm9taXNlLkNhbGxiYWNrRW50cnlffSBjYWxsYmFja0VudHJ5IFJlY29yZCBjb250YWluaW5nXG4gKiAgICAge0Bjb2RlIG9uRnVsZmlsbGVkfSBhbmQge0Bjb2RlIG9uUmVqZWN0ZWR9IGNhbGxiYWNrcyB0byBleGVjdXRlIGFmdGVyXG4gKiAgICAgdGhlIFByb21pc2UgaXMgcmVzb2x2ZWQuXG4gKiBAcHJpdmF0ZVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UucHJvdG90eXBlLmFkZENhbGxiYWNrRW50cnlfID0gZnVuY3Rpb24oY2FsbGJhY2tFbnRyeSkge1xuICBpZiAoKCF0aGlzLmNhbGxiYWNrRW50cmllc18gfHwgIXRoaXMuY2FsbGJhY2tFbnRyaWVzXy5sZW5ndGgpICYmXG4gICAgKHRoaXMuc3RhdGVfID09PSBDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLkZVTEZJTExFRCB8fFxuICAgIHRoaXMuc3RhdGVfID09PSBDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLlJFSkVDVEVEKSkge1xuICAgIHRoaXMuc2NoZWR1bGVDYWxsYmFja3NfKCk7XG4gIH1cbiAgaWYgKCF0aGlzLmNhbGxiYWNrRW50cmllc18pIHtcbiAgICB0aGlzLmNhbGxiYWNrRW50cmllc18gPSBbXTtcbiAgfVxuICB0aGlzLmNhbGxiYWNrRW50cmllc18ucHVzaChjYWxsYmFja0VudHJ5KTtcbn07XG5cblxuLyoqXG4gKiBDcmVhdGVzIGEgY2hpbGQgUHJvbWlzZSBhbmQgYWRkcyBpdCB0byB0aGUgY2FsbGJhY2sgZW50cnkgbGlzdC4gVGhlIHJlc3VsdCBvZlxuICogdGhlIGNoaWxkIFByb21pc2UgaXMgZGV0ZXJtaW5lZCBieSB0aGUgc3RhdGUgb2YgdGhlIHBhcmVudCBQcm9taXNlIGFuZCB0aGVcbiAqIHJlc3VsdCBvZiB0aGUge0Bjb2RlIG9uRnVsZmlsbGVkfSBvciB7QGNvZGUgb25SZWplY3RlZH0gY2FsbGJhY2tzIGFzXG4gKiBzcGVjaWZpZWQgaW4gdGhlIFByb21pc2UgcmVzb2x1dGlvbiBwcm9jZWR1cmUuXG4gKlxuICogQHNlZSBodHRwOi8vcHJvbWlzZXNhcGx1cy5jb20vI3RoZV9fbWV0aG9kXG4gKlxuICogQHBhcmFtIHs/ZnVuY3Rpb24odGhpczpUSElTLCBUWVBFKTpcbiAqICAgICAgICAgIChSRVNVTFR8Q2FuY2VsbGFibGVQcm9taXNlLjxSRVNVTFQ+fFRoZW5hYmxlKX0gb25GdWxmaWxsZWQgQSBjYWxsYmFjayB0aGF0XG4gKiAgICAgd2lsbCBiZSBpbnZva2VkIGlmIHRoZSBQcm9taXNlIGlzIGZ1bGxmaWxsZWQsIG9yIG51bGwuXG4gKiBAcGFyYW0gez9mdW5jdGlvbih0aGlzOlRISVMsICopOiAqfSBvblJlamVjdGVkIEEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlXG4gKiAgICAgaW52b2tlZCBpZiB0aGUgUHJvbWlzZSBpcyByZWplY3RlZCwgb3IgbnVsbC5cbiAqIEBwYXJhbSB7VEhJUz19IG9wdF9jb250ZXh0IEFuIG9wdGlvbmFsIGV4ZWN1dGlvbiBjb250ZXh0IGZvciB0aGUgY2FsbGJhY2tzLlxuICogICAgIGluIHRoZSBkZWZhdWx0IGNhbGxpbmcgY29udGV4dC5cbiAqIEByZXR1cm4geyFDYW5jZWxsYWJsZVByb21pc2V9IFRoZSBjaGlsZCBQcm9taXNlLlxuICogQHRlbXBsYXRlIFJFU1VMVCxUSElTXG4gKiBAcHJpdmF0ZVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UucHJvdG90eXBlLmFkZENoaWxkUHJvbWlzZV8gPSBmdW5jdGlvbihcbm9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBvcHRfY29udGV4dCkge1xuXG4gIHZhciBjYWxsYmFja0VudHJ5ID0ge1xuICAgIGNoaWxkOiBudWxsLFxuICAgIG9uRnVsZmlsbGVkOiBudWxsLFxuICAgIG9uUmVqZWN0ZWQ6IG51bGxcbiAgfTtcblxuICBjYWxsYmFja0VudHJ5LmNoaWxkID0gbmV3IENhbmNlbGxhYmxlUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAvLyBJbnZva2Ugb25GdWxmaWxsZWQsIG9yIHJlc29sdmUgd2l0aCB0aGUgcGFyZW50J3MgdmFsdWUgaWYgYWJzZW50LlxuICAgIGNhbGxiYWNrRW50cnkub25GdWxmaWxsZWQgPSBvbkZ1bGZpbGxlZCA/IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gb25GdWxmaWxsZWQuY2FsbChvcHRfY29udGV4dCwgdmFsdWUpO1xuICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgfSA6IHJlc29sdmU7XG5cbiAgICAvLyBJbnZva2Ugb25SZWplY3RlZCwgb3IgcmVqZWN0IHdpdGggdGhlIHBhcmVudCdzIHJlYXNvbiBpZiBhYnNlbnQuXG4gICAgY2FsbGJhY2tFbnRyeS5vblJlamVjdGVkID0gb25SZWplY3RlZCA/IGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG9uUmVqZWN0ZWQuY2FsbChvcHRfY29udGV4dCwgcmVhc29uKTtcbiAgICAgICAgaWYgKCFpc0RlZihyZXN1bHQpICYmIHJlYXNvbi5JU19DQU5DRUxMQVRJT05fRVJST1IpIHtcbiAgICAgICAgICAvLyBQcm9wYWdhdGUgY2FuY2VsbGF0aW9uIHRvIGNoaWxkcmVuIGlmIG5vIG90aGVyIHJlc3VsdCBpcyByZXR1cm5lZC5cbiAgICAgICAgICByZWplY3QocmVhc29uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICB9IDogcmVqZWN0O1xuICB9KTtcblxuICBjYWxsYmFja0VudHJ5LmNoaWxkLnBhcmVudF8gPSB0aGlzO1xuICB0aGlzLmFkZENhbGxiYWNrRW50cnlfKFxuICAgIC8qKiBAdHlwZSB7Q2FuY2VsbGFibGVQcm9taXNlLkNhbGxiYWNrRW50cnlffSAqLyAoY2FsbGJhY2tFbnRyeSkpO1xuICByZXR1cm4gY2FsbGJhY2tFbnRyeS5jaGlsZDtcbn07XG5cblxuLyoqXG4gKiBVbmJsb2NrcyB0aGUgUHJvbWlzZSBhbmQgZnVsZmlsbHMgaXQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWUuXG4gKlxuICogQHBhcmFtIHtUWVBFfSB2YWx1ZVxuICogQHByaXZhdGVcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLnByb3RvdHlwZS51bmJsb2NrQW5kRnVsZmlsbF8gPSBmdW5jdGlvbih2YWx1ZSkge1xuICBpZiAodGhpcy5zdGF0ZV8gIT09IENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uQkxPQ0tFRCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2FuY2VsbGFibGVQcm9taXNlIGlzIG5vdCBibG9ja2VkLicpO1xuICB9XG4gIHRoaXMuc3RhdGVfID0gQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5QRU5ESU5HO1xuICB0aGlzLnJlc29sdmVfKENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uRlVMRklMTEVELCB2YWx1ZSk7XG59O1xuXG5cbi8qKlxuICogVW5ibG9ja3MgdGhlIFByb21pc2UgYW5kIHJlamVjdHMgaXQgd2l0aCB0aGUgZ2l2ZW4gcmVqZWN0aW9uIHJlYXNvbi5cbiAqXG4gKiBAcGFyYW0geyp9IHJlYXNvblxuICogQHByaXZhdGVcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLnByb3RvdHlwZS51bmJsb2NrQW5kUmVqZWN0XyA9IGZ1bmN0aW9uKHJlYXNvbikge1xuICBpZiAodGhpcy5zdGF0ZV8gIT09IENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uQkxPQ0tFRCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2FuY2VsbGFibGVQcm9taXNlIGlzIG5vdCBibG9ja2VkLicpO1xuICB9XG4gIHRoaXMuc3RhdGVfID0gQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5QRU5ESU5HO1xuICB0aGlzLnJlc29sdmVfKENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uUkVKRUNURUQsIHJlYXNvbik7XG59O1xuXG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gcmVzb2x2ZSBhIFByb21pc2Ugd2l0aCBhIGdpdmVuIHJlc29sdXRpb24gc3RhdGUgYW5kIHZhbHVlLiBUaGlzXG4gKiBpcyBhIG5vLW9wIGlmIHRoZSBnaXZlbiBQcm9taXNlIGhhcyBhbHJlYWR5IGJlZW4gcmVzb2x2ZWQuXG4gKlxuICogSWYgdGhlIGdpdmVuIHJlc3VsdCBpcyBhIFRoZW5hYmxlIChzdWNoIGFzIGFub3RoZXIgUHJvbWlzZSksIHRoZSBQcm9taXNlIHdpbGxcbiAqIGJlIHJlc29sdmVkIHdpdGggdGhlIHNhbWUgc3RhdGUgYW5kIHJlc3VsdCBhcyB0aGUgVGhlbmFibGUgb25jZSBpdCBpcyBpdHNlbGZcbiAqIHJlc29sdmVkLlxuICpcbiAqIElmIHRoZSBnaXZlbiByZXN1bHQgaXMgbm90IGEgVGhlbmFibGUsIHRoZSBQcm9taXNlIHdpbGwgYmUgZnVsZmlsbGVkIG9yXG4gKiByZWplY3RlZCB3aXRoIHRoYXQgcmVzdWx0IGJhc2VkIG9uIHRoZSBnaXZlbiBzdGF0ZS5cbiAqXG4gKiBAc2VlIGh0dHA6Ly9wcm9taXNlc2FwbHVzLmNvbS8jdGhlX3Byb21pc2VfcmVzb2x1dGlvbl9wcm9jZWR1cmVcbiAqXG4gKiBAcGFyYW0ge0NhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV99IHN0YXRlXG4gKiBAcGFyYW0geyp9IHggVGhlIHJlc3VsdCB0byBhcHBseSB0byB0aGUgUHJvbWlzZS5cbiAqIEBwcml2YXRlXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5wcm90b3R5cGUucmVzb2x2ZV8gPSBmdW5jdGlvbihzdGF0ZSwgeCkge1xuICBpZiAodGhpcy5zdGF0ZV8gIT09IENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uUEVORElORykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0aGlzID09PSB4KSB7XG4gICAgc3RhdGUgPSBDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLlJFSkVDVEVEO1xuICAgIHggPSBuZXcgVHlwZUVycm9yKCdDYW5jZWxsYWJsZVByb21pc2UgY2Fubm90IHJlc29sdmUgdG8gaXRzZWxmJyk7XG5cbiAgfSBlbHNlIGlmIChUaGVuYWJsZS5pc0ltcGxlbWVudGVkQnkoeCkpIHtcbiAgICB4ID0gLyoqIEB0eXBlIHshVGhlbmFibGV9ICovICh4KTtcbiAgICB0aGlzLnN0YXRlXyA9IENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uQkxPQ0tFRDtcbiAgICB4LnRoZW4odGhpcy51bmJsb2NrQW5kRnVsZmlsbF8sIHRoaXMudW5ibG9ja0FuZFJlamVjdF8sIHRoaXMpO1xuICAgIHJldHVybjtcblxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHgpKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciB0aGVuID0geC50aGVuO1xuICAgICAgaWYgKGlzRnVuY3Rpb24odGhlbikpIHtcbiAgICAgICAgdGhpcy50cnlUaGVuXyh4LCB0aGVuKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHN0YXRlID0gQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5SRUpFQ1RFRDtcbiAgICAgIHggPSBlO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMucmVzdWx0XyA9IHg7XG4gIHRoaXMuc3RhdGVfID0gc3RhdGU7XG4gIHRoaXMuc2NoZWR1bGVDYWxsYmFja3NfKCk7XG5cbiAgaWYgKHN0YXRlID09PSBDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLlJFSkVDVEVEICYmICF4LklTX0NBTkNFTExBVElPTl9FUlJPUikge1xuICAgIENhbmNlbGxhYmxlUHJvbWlzZS5hZGRVbmhhbmRsZWRSZWplY3Rpb25fKHRoaXMsIHgpO1xuICB9XG59O1xuXG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gY2FsbCB0aGUge0Bjb2RlIHRoZW59IG1ldGhvZCBvbiBhbiBvYmplY3QgaW4gdGhlIGhvcGVzIHRoYXQgaXQgaXNcbiAqIGEgUHJvbWlzZS1jb21wYXRpYmxlIGluc3RhbmNlLiBUaGlzIGFsbG93cyBpbnRlcm9wZXJhdGlvbiBiZXR3ZWVuIGRpZmZlcmVudFxuICogUHJvbWlzZSBpbXBsZW1lbnRhdGlvbnMsIGhvd2V2ZXIgYSBub24tY29tcGxpYW50IG9iamVjdCBtYXkgY2F1c2UgYSBQcm9taXNlXG4gKiB0byBoYW5nIGluZGVmaW5pdGVseS4gSWYgdGhlIHtAY29kZSB0aGVufSBtZXRob2QgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgdGhlXG4gKiBkZXBlbmRlbnQgUHJvbWlzZSB3aWxsIGJlIHJlamVjdGVkIHdpdGggdGhlIHRocm93biB2YWx1ZS5cbiAqXG4gKiBAc2VlIGh0dHA6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNzBcbiAqXG4gKiBAcGFyYW0ge1RoZW5hYmxlfSB0aGVuYWJsZSBBbiBvYmplY3Qgd2l0aCBhIHtAY29kZSB0aGVufSBtZXRob2QgdGhhdCBtYXkgYmVcbiAqICAgICBjb21wYXRpYmxlIHdpdGggdGhlIFByb21pc2UvQSsgc3BlY2lmaWNhdGlvbi5cbiAqIEBwYXJhbSB7IUZ1bmN0aW9ufSB0aGVuIFRoZSB7QGNvZGUgdGhlbn0gbWV0aG9kIG9mIHRoZSBUaGVuYWJsZSBvYmplY3QuXG4gKiBAcHJpdmF0ZVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UucHJvdG90eXBlLnRyeVRoZW5fID0gZnVuY3Rpb24odGhlbmFibGUsIHRoZW4pIHtcbiAgdGhpcy5zdGF0ZV8gPSBDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLkJMT0NLRUQ7XG4gIHZhciBwcm9taXNlID0gdGhpcztcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuXG4gIHZhciByZXNvbHZlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgIHByb21pc2UudW5ibG9ja0FuZEZ1bGZpbGxfKHZhbHVlKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHJlamVjdCA9IGZ1bmN0aW9uKHJlYXNvbikge1xuICAgIGlmICghY2FsbGVkKSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgcHJvbWlzZS51bmJsb2NrQW5kUmVqZWN0XyhyZWFzb24pO1xuICAgIH1cbiAgfTtcblxuICB0cnkge1xuICAgIHRoZW4uY2FsbCh0aGVuYWJsZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJlamVjdChlKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIEV4ZWN1dGVzIHRoZSBwZW5kaW5nIGNhbGxiYWNrcyBvZiBhIHJlc29sdmVkIFByb21pc2UgYWZ0ZXIgYSB0aW1lb3V0LlxuICpcbiAqIFNlY3Rpb24gMi4yLjQgb2YgdGhlIFByb21pc2VzL0ErIHNwZWNpZmljYXRpb24gcmVxdWlyZXMgdGhhdCBQcm9taXNlXG4gKiBjYWxsYmFja3MgbXVzdCBvbmx5IGJlIGludm9rZWQgZnJvbSBhIGNhbGwgc3RhY2sgdGhhdCBvbmx5IGNvbnRhaW5zIFByb21pc2VcbiAqIGltcGxlbWVudGF0aW9uIGNvZGUsIHdoaWNoIHdlIGFjY29tcGxpc2ggYnkgaW52b2tpbmcgY2FsbGJhY2sgZXhlY3V0aW9uIGFmdGVyXG4gKiBhIHRpbWVvdXQuIElmIHtAY29kZSBzdGFydEV4ZWN1dGlvbl99IGlzIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyBmb3IgdGhlIHNhbWVcbiAqIFByb21pc2UsIHRoZSBjYWxsYmFjayBjaGFpbiB3aWxsIGJlIGV2YWx1YXRlZCBvbmx5IG9uY2UuIEFkZGl0aW9uYWwgY2FsbGJhY2tzXG4gKiBtYXkgYmUgYWRkZWQgZHVyaW5nIHRoZSBldmFsdWF0aW9uIHBoYXNlLCBhbmQgd2lsbCBiZSBleGVjdXRlZCBpbiB0aGUgc2FtZVxuICogZXZlbnQgbG9vcC5cbiAqXG4gKiBBbGwgUHJvbWlzZXMgYWRkZWQgdG8gdGhlIHdhaXRpbmcgbGlzdCBkdXJpbmcgdGhlIHNhbWUgYnJvd3NlciBldmVudCBsb29wXG4gKiB3aWxsIGJlIGV4ZWN1dGVkIGluIG9uZSBiYXRjaCB0byBhdm9pZCB1c2luZyBhIHNlcGFyYXRlIHRpbWVvdXQgcGVyIFByb21pc2UuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLnByb3RvdHlwZS5zY2hlZHVsZUNhbGxiYWNrc18gPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLmV4ZWN1dGluZ18pIHtcbiAgICB0aGlzLmV4ZWN1dGluZ18gPSB0cnVlO1xuICAgIGFzeW5jLnJ1bih0aGlzLmV4ZWN1dGVDYWxsYmFja3NfLCB0aGlzKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIEV4ZWN1dGVzIGFsbCBwZW5kaW5nIGNhbGxiYWNrcyBmb3IgdGhpcyBQcm9taXNlLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5wcm90b3R5cGUuZXhlY3V0ZUNhbGxiYWNrc18gPSBmdW5jdGlvbigpIHtcbiAgd2hpbGUgKHRoaXMuY2FsbGJhY2tFbnRyaWVzXyAmJiB0aGlzLmNhbGxiYWNrRW50cmllc18ubGVuZ3RoKSB7XG4gICAgdmFyIGVudHJpZXMgPSB0aGlzLmNhbGxiYWNrRW50cmllc187XG4gICAgdGhpcy5jYWxsYmFja0VudHJpZXNfID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVudHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuZXhlY3V0ZUNhbGxiYWNrXyhlbnRyaWVzW2ldLCB0aGlzLnN0YXRlXywgdGhpcy5yZXN1bHRfKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5leGVjdXRpbmdfID0gZmFsc2U7XG59O1xuXG5cbi8qKlxuICogRXhlY3V0ZXMgYSBwZW5kaW5nIGNhbGxiYWNrIGZvciB0aGlzIFByb21pc2UuIEludm9rZXMgYW4ge0Bjb2RlIG9uRnVsZmlsbGVkfVxuICogb3Ige0Bjb2RlIG9uUmVqZWN0ZWR9IGNhbGxiYWNrIGJhc2VkIG9uIHRoZSByZXNvbHZlZCBzdGF0ZSBvZiB0aGUgUHJvbWlzZS5cbiAqXG4gKiBAcGFyYW0geyFDYW5jZWxsYWJsZVByb21pc2UuQ2FsbGJhY2tFbnRyeV99IGNhbGxiYWNrRW50cnkgQW4gZW50cnkgY29udGFpbmluZyB0aGVcbiAqICAgICBvbkZ1bGZpbGxlZCBhbmQvb3Igb25SZWplY3RlZCBjYWxsYmFja3MgZm9yIHRoaXMgc3RlcC5cbiAqIEBwYXJhbSB7Q2FuY2VsbGFibGVQcm9taXNlLlN0YXRlX30gc3RhdGUgVGhlIHJlc29sdXRpb24gc3RhdHVzIG9mIHRoZSBQcm9taXNlLFxuICogICAgIGVpdGhlciBGVUxGSUxMRUQgb3IgUkVKRUNURUQuXG4gKiBAcGFyYW0geyp9IHJlc3VsdCBUaGUgcmVzb2x2ZWQgcmVzdWx0IG9mIHRoZSBQcm9taXNlLlxuICogQHByaXZhdGVcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLnByb3RvdHlwZS5leGVjdXRlQ2FsbGJhY2tfID0gZnVuY3Rpb24oXG5jYWxsYmFja0VudHJ5LCBzdGF0ZSwgcmVzdWx0KSB7XG4gIGlmIChzdGF0ZSA9PT0gQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5GVUxGSUxMRUQpIHtcbiAgICBjYWxsYmFja0VudHJ5Lm9uRnVsZmlsbGVkKHJlc3VsdCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5yZW1vdmVVbmhhbmRsZWRSZWplY3Rpb25fKCk7XG4gICAgY2FsbGJhY2tFbnRyeS5vblJlamVjdGVkKHJlc3VsdCk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBNYXJrcyB0aGlzIHJlamVjdGVkIFByb21pc2UgYXMgaGF2aW5nIGJlaW5nIGhhbmRsZWQuIEFsc28gbWFya3MgYW55IHBhcmVudFxuICogUHJvbWlzZXMgaW4gdGhlIHJlamVjdGVkIHN0YXRlIGFzIGhhbmRsZWQuIFRoZSByZWplY3Rpb24gaGFuZGxlciB3aWxsIG5vXG4gKiBsb25nZXIgYmUgaW52b2tlZCBmb3IgdGhpcyBQcm9taXNlIChpZiBpdCBoYXMgbm90IGJlZW4gY2FsbGVkIGFscmVhZHkpLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5wcm90b3R5cGUucmVtb3ZlVW5oYW5kbGVkUmVqZWN0aW9uXyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcDtcbiAgaWYgKENhbmNlbGxhYmxlUHJvbWlzZS5VTkhBTkRMRURfUkVKRUNUSU9OX0RFTEFZID4gMCkge1xuICAgIGZvciAocCA9IHRoaXM7IHAgJiYgcC51bmhhbmRsZWRSZWplY3Rpb25JZF87IHAgPSBwLnBhcmVudF8pIHtcbiAgICAgIGNsZWFyVGltZW91dChwLnVuaGFuZGxlZFJlamVjdGlvbklkXyk7XG4gICAgICBwLnVuaGFuZGxlZFJlamVjdGlvbklkXyA9IDA7XG4gICAgfVxuICB9IGVsc2UgaWYgKENhbmNlbGxhYmxlUHJvbWlzZS5VTkhBTkRMRURfUkVKRUNUSU9OX0RFTEFZID09PSAwKSB7XG4gICAgZm9yIChwID0gdGhpczsgcCAmJiBwLmhhZFVuaGFuZGxlZFJlamVjdGlvbl87IHAgPSBwLnBhcmVudF8pIHtcbiAgICAgIHAuaGFkVW5oYW5kbGVkUmVqZWN0aW9uXyA9IGZhbHNlO1xuICAgIH1cbiAgfVxufTtcblxuXG4vKipcbiAqIE1hcmtzIHRoaXMgcmVqZWN0ZWQgUHJvbWlzZSBhcyB1bmhhbmRsZWQuIElmIG5vIHtAY29kZSBvblJlamVjdGVkfSBjYWxsYmFja1xuICogaXMgY2FsbGVkIGZvciB0aGlzIFByb21pc2UgYmVmb3JlIHRoZSB7QGNvZGUgVU5IQU5ETEVEX1JFSkVDVElPTl9ERUxBWX1cbiAqIGV4cGlyZXMsIHRoZSByZWFzb24gd2lsbCBiZSBwYXNzZWQgdG8gdGhlIHVuaGFuZGxlZCByZWplY3Rpb24gaGFuZGxlci4gVGhlXG4gKiBoYW5kbGVyIHR5cGljYWxseSByZXRocm93cyB0aGUgcmVqZWN0aW9uIHJlYXNvbiBzbyB0aGF0IGl0IGJlY29tZXMgdmlzaWJsZSBpblxuICogdGhlIGRldmVsb3BlciBjb25zb2xlLlxuICpcbiAqIEBwYXJhbSB7IUNhbmNlbGxhYmxlUHJvbWlzZX0gcHJvbWlzZSBUaGUgcmVqZWN0ZWQgUHJvbWlzZS5cbiAqIEBwYXJhbSB7Kn0gcmVhc29uIFRoZSBQcm9taXNlIHJlamVjdGlvbiByZWFzb24uXG4gKiBAcHJpdmF0ZVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UuYWRkVW5oYW5kbGVkUmVqZWN0aW9uXyA9IGZ1bmN0aW9uKHByb21pc2UsIHJlYXNvbikge1xuICBpZiAoQ2FuY2VsbGFibGVQcm9taXNlLlVOSEFORExFRF9SRUpFQ1RJT05fREVMQVkgPiAwKSB7XG4gICAgcHJvbWlzZS51bmhhbmRsZWRSZWplY3Rpb25JZF8gPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgQ2FuY2VsbGFibGVQcm9taXNlLmhhbmRsZVJlamVjdGlvbl8uY2FsbChudWxsLCByZWFzb24pO1xuICAgIH0sIENhbmNlbGxhYmxlUHJvbWlzZS5VTkhBTkRMRURfUkVKRUNUSU9OX0RFTEFZKTtcblxuICB9IGVsc2UgaWYgKENhbmNlbGxhYmxlUHJvbWlzZS5VTkhBTkRMRURfUkVKRUNUSU9OX0RFTEFZID09PSAwKSB7XG4gICAgcHJvbWlzZS5oYWRVbmhhbmRsZWRSZWplY3Rpb25fID0gdHJ1ZTtcbiAgICBhc3luYy5ydW4oZnVuY3Rpb24oKSB7XG4gICAgICBpZiAocHJvbWlzZS5oYWRVbmhhbmRsZWRSZWplY3Rpb25fKSB7XG4gICAgICAgIENhbmNlbGxhYmxlUHJvbWlzZS5oYW5kbGVSZWplY3Rpb25fLmNhbGwobnVsbCwgcmVhc29uKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcblxuXG4vKipcbiAqIEEgbWV0aG9kIHRoYXQgaXMgaW52b2tlZCB3aXRoIHRoZSByZWplY3Rpb24gcmVhc29ucyBmb3IgUHJvbWlzZXMgdGhhdCBhcmVcbiAqIHJlamVjdGVkIGJ1dCBoYXZlIG5vIHtAY29kZSBvblJlamVjdGVkfSBjYWxsYmFja3MgcmVnaXN0ZXJlZCB5ZXQuXG4gKiBAdHlwZSB7ZnVuY3Rpb24oKil9XG4gKiBAcHJpdmF0ZVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UuaGFuZGxlUmVqZWN0aW9uXyA9IGFzeW5jLnRocm93RXhjZXB0aW9uO1xuXG5cbi8qKlxuICogU2V0cyBhIGhhbmRsZXIgdGhhdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHJlYXNvbnMgZnJvbSB1bmhhbmRsZWQgcmVqZWN0ZWRcbiAqIFByb21pc2VzLiBJZiB0aGUgcmVqZWN0ZWQgUHJvbWlzZSAob3Igb25lIG9mIGl0cyBkZXNjZW5kYW50cykgaGFzIGFuXG4gKiB7QGNvZGUgb25SZWplY3RlZH0gY2FsbGJhY2sgcmVnaXN0ZXJlZCwgdGhlIHJlamVjdGlvbiB3aWxsIGJlIGNvbnNpZGVyZWRcbiAqIGhhbmRsZWQsIGFuZCB0aGUgcmVqZWN0aW9uIGhhbmRsZXIgd2lsbCBub3QgYmUgY2FsbGVkLlxuICpcbiAqIEJ5IGRlZmF1bHQsIHVuaGFuZGxlZCByZWplY3Rpb25zIGFyZSByZXRocm93biBzbyB0aGF0IHRoZSBlcnJvciBtYXkgYmVcbiAqIGNhcHR1cmVkIGJ5IHRoZSBkZXZlbG9wZXIgY29uc29sZSBvciBhIHtAY29kZSB3aW5kb3cub25lcnJvcn0gaGFuZGxlci5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCopfSBoYW5kbGVyIEEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHJlYXNvbnMgZnJvbVxuICogICAgIHJlamVjdGVkIFByb21pc2VzLiBEZWZhdWx0cyB0byB7QGNvZGUgYXN5bmMudGhyb3dFeGNlcHRpb259LlxuICovXG5DYW5jZWxsYWJsZVByb21pc2Uuc2V0VW5oYW5kbGVkUmVqZWN0aW9uSGFuZGxlciA9IGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgQ2FuY2VsbGFibGVQcm9taXNlLmhhbmRsZVJlamVjdGlvbl8gPSBoYW5kbGVyO1xufTtcblxuXG5cbi8qKlxuICogRXJyb3IgdXNlZCBhcyBhIHJlamVjdGlvbiByZWFzb24gZm9yIGNhbmNlbGVkIFByb21pc2VzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X21lc3NhZ2VcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge0Vycm9yfVxuICogQGZpbmFsXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5DYW5jZWxsYXRpb25FcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihvcHRfbWVzc2FnZSkge1xuICAgICBzdXBlcihvcHRfbWVzc2FnZSk7XG5cbiAgICAgaWYgKG9wdF9tZXNzYWdlKSB7XG4gICAgICAgdGhpcy5tZXNzYWdlID0gb3B0X21lc3NhZ2U7XG4gICAgIH1cbiAgIH1cbn07XG5cbi8qKiBAb3ZlcnJpZGUgKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5DYW5jZWxsYXRpb25FcnJvci5wcm90b3R5cGUubmFtZSA9ICdjYW5jZWwnO1xuXG5leHBvcnQge0NhbmNlbGxhYmxlUHJvbWlzZX07XG5leHBvcnQgZGVmYXVsdCBDYW5jZWxsYWJsZVByb21pc2U7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7IGlzRGVmLCBpc0RlZkFuZE5vdE51bGwgfSBmcm9tICdtZXRhbCc7XG5pbXBvcnQgVXJpIGZyb20gJ21ldGFsLXVyaSc7XG5pbXBvcnQgeyBDYW5jZWxsYWJsZVByb21pc2UgYXMgUHJvbWlzZSB9IGZyb20gJ21ldGFsLXByb21pc2UnO1xuXG5jbGFzcyBBamF4IHtcblxuXHQvKipcblx0ICogWG1sSHR0cFJlcXVlc3QncyBnZXRBbGxSZXNwb25zZUhlYWRlcnMoKSBtZXRob2QgcmV0dXJucyBhIHN0cmluZyBvZlxuXHQgKiByZXNwb25zZSBoZWFkZXJzIGFjY29yZGluZyB0byB0aGUgZm9ybWF0IGRlc2NyaWJlZCBvbiB0aGUgc3BlYzpcblx0ICoge0BsaW5rIGh0dHA6Ly93d3cudzMub3JnL1RSL1hNTEh0dHBSZXF1ZXN0LyN0aGUtZ2V0YWxscmVzcG9uc2VoZWFkZXJzLW1ldGhvZH0uXG5cdCAqIFRoaXMgbWV0aG9kIHBhcnNlcyB0aGF0IHN0cmluZyBpbnRvIGEgdXNlci1mcmllbmRseSBuYW1lL3ZhbHVlIHBhaXJcblx0ICogb2JqZWN0LlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gYWxsSGVhZGVycyBBbGwgaGVhZGVycyBhcyBzdHJpbmcuXG5cdCAqIEByZXR1cm4geyFBcnJheS48T2JqZWN0PHN0cmluZywgc3RyaW5nPj59XG5cdCAqL1xuXHRzdGF0aWMgcGFyc2VSZXNwb25zZUhlYWRlcnMoYWxsSGVhZGVycykge1xuXHRcdHZhciBoZWFkZXJzID0gW107XG5cdFx0aWYgKCFhbGxIZWFkZXJzKSB7XG5cdFx0XHRyZXR1cm4gaGVhZGVycztcblx0XHR9XG5cdFx0dmFyIHBhaXJzID0gYWxsSGVhZGVycy5zcGxpdCgnXFx1MDAwZFxcdTAwMGEnKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHBhaXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaW5kZXggPSBwYWlyc1tpXS5pbmRleE9mKCdcXHUwMDNhXFx1MDAyMCcpO1xuXHRcdFx0aWYgKGluZGV4ID4gMCkge1xuXHRcdFx0XHR2YXIgbmFtZSA9IHBhaXJzW2ldLnN1YnN0cmluZygwLCBpbmRleCk7XG5cdFx0XHRcdHZhciB2YWx1ZSA9IHBhaXJzW2ldLnN1YnN0cmluZyhpbmRleCArIDIpO1xuXHRcdFx0XHRoZWFkZXJzLnB1c2goe1xuXHRcdFx0XHRcdG5hbWU6IG5hbWUsXG5cdFx0XHRcdFx0dmFsdWU6IHZhbHVlXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gaGVhZGVycztcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXF1ZXN0cyB0aGUgdXJsIHVzaW5nIFhNTEh0dHBSZXF1ZXN0LlxuXHQgKiBAcGFyYW0geyFzdHJpbmd9IHVybFxuXHQgKiBAcGFyYW0geyFzdHJpbmd9IG1ldGhvZFxuXHQgKiBAcGFyYW0gez9zdHJpbmd9IGJvZHlcblx0ICogQHBhcmFtIHtNdWx0aU1hcD19IG9wdF9oZWFkZXJzXG5cdCAqIEBwYXJhbSB7TXVsdGlNYXA9fSBvcHRfcGFyYW1zXG5cdCAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X3RpbWVvdXRcblx0ICogQHBhcmFtIHtib29sZWFuPX0gb3B0X3N5bmNcblx0ICogQHBhcmFtIHtib29sZWFuPX0gb3B0X3dpdGhDcmVkZW50aWFsc1xuXHQgKiBAcmV0dXJuIHtQcm9taXNlfSBEZWZlcnJlZCBhamF4IHJlcXVlc3QuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHN0YXRpYyByZXF1ZXN0KHVybCwgbWV0aG9kLCBib2R5LCBvcHRfaGVhZGVycywgb3B0X3BhcmFtcywgb3B0X3RpbWVvdXQsIG9wdF9zeW5jLCBvcHRfd2l0aENyZWRlbnRpYWxzKSB7XG5cdFx0dXJsID0gdXJsIHx8ICcnO1xuXHRcdG1ldGhvZCA9IG1ldGhvZCB8fCAnR0VUJztcblxuXHRcdHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cblx0XHR2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuXHRcdFx0cmVxdWVzdC5vbmxvYWQgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKHJlcXVlc3QuYWJvcnRlZCkge1xuXHRcdFx0XHRcdHJlcXVlc3Qub25lcnJvcigpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXNvbHZlKHJlcXVlc3QpO1xuXHRcdFx0fTtcblx0XHRcdHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ1JlcXVlc3QgZXJyb3InKTtcblx0XHRcdFx0ZXJyb3IucmVxdWVzdCA9IHJlcXVlc3Q7XG5cdFx0XHRcdHJlamVjdChlcnJvcik7XG5cdFx0XHR9O1xuXHRcdH0pLnRoZW5DYXRjaChmdW5jdGlvbihyZWFzb24pIHtcblx0XHRcdHJlcXVlc3QuYWJvcnQoKTtcblx0XHRcdHRocm93IHJlYXNvbjtcblx0XHR9KS50aGVuQWx3YXlzKGZ1bmN0aW9uKCkge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuXHRcdH0pO1xuXG5cdFx0aWYgKG9wdF9wYXJhbXMpIHtcblx0XHRcdHVybCA9IG5ldyBVcmkodXJsKS5hZGRQYXJhbWV0ZXJzRnJvbU11bHRpTWFwKG9wdF9wYXJhbXMpLnRvU3RyaW5nKCk7XG5cdFx0fVxuXG5cdFx0cmVxdWVzdC5vcGVuKG1ldGhvZCwgdXJsLCAhb3B0X3N5bmMpO1xuXG5cdFx0aWYgKG9wdF93aXRoQ3JlZGVudGlhbHMpIHtcblx0XHRcdHJlcXVlc3Qud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAob3B0X2hlYWRlcnMpIHtcblx0XHRcdG9wdF9oZWFkZXJzLm5hbWVzKCkuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG5cdFx0XHRcdHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcihuYW1lLCBvcHRfaGVhZGVycy5nZXRBbGwobmFtZSkuam9pbignLCAnKSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXF1ZXN0LnNlbmQoaXNEZWYoYm9keSkgPyBib2R5IDogbnVsbCk7XG5cblx0XHRpZiAoaXNEZWZBbmROb3ROdWxsKG9wdF90aW1lb3V0KSkge1xuXHRcdFx0dmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRwcm9taXNlLmNhbmNlbCgnUmVxdWVzdCB0aW1lb3V0Jyk7XG5cdFx0XHR9LCBvcHRfdGltZW91dCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHByb21pc2U7XG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBBamF4O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFByb3ZpZGVzIGEgY29udmVuaWVudCBpbnRlcmZhY2UgZm9yIGRhdGEgdHJhbnNwb3J0LlxuICogQGludGVyZmFjZVxuICovXG5jbGFzcyBUcmFuc3BvcnQge1xuXG5cdC8qKlxuXHQgKiBTZW5kcyBhIG1lc3NhZ2UgZm9yIHRoZSBzcGVjaWZpZWQgY2xpZW50LlxuXHQgKiBAcGFyYW0geyFDbGllbnRSZXF1ZXN0fSBjbGllbnRSZXF1ZXN0XG5cdCAqIEByZXR1cm4geyFQcm9taXNlfSBEZWZlcnJlZCByZXF1ZXN0LlxuXHQgKi9cblx0c2VuZCgpIHt9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgVHJhbnNwb3J0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgeyBjb3JlIH0gZnJvbSAnbWV0YWwnO1xuaW1wb3J0IHsgTXVsdGlNYXAgfSBmcm9tICdtZXRhbC1zdHJ1Y3RzJztcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgY2xpZW50IG1lc3NhZ2UgKGUuZy4gYSByZXF1ZXN0IG9yIGEgcmVzcG9uc2UpLlxuICovXG5jbGFzcyBDbGllbnRNZXNzYWdlIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0dGhpcy5oZWFkZXJzXyA9IG5ldyBNdWx0aU1hcCgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEZsdWVudCBnZXR0ZXIgYW5kIHNldHRlciBmb3IgcmVxdWVzdCBib2R5LlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfYm9keSBSZXF1ZXN0IGJvZHkgdG8gYmUgc2V0LiBJZiBub25lIGlzIGdpdmVuLFxuXHQgKiAgIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBib2R5IHdpbGwgYmUgcmV0dXJuZWQuXG5cdCAqIEByZXR1cm4geyp9IFJldHVybnMgcmVxdWVzdCBib2R5IGlmIG5vIGJvZHkgdmFsdWUgd2FzIGdpdmVuLiBPdGhlcndpc2Vcblx0ICogICByZXR1cm5zIHRoZSB7QGxpbmsgQ2xpZW50TWVzc2FnZX0gb2JqZWN0IGl0c2VsZiwgc28gY2FsbHMgY2FuIGJlIGNoYWluZWQuXG5cdCAqIEBjaGFpbmFibGUgQ2hhaW5hYmxlIHdoZW4gdXNlZCBhcyBzZXR0ZXIuXG5cdCAqL1xuXHRib2R5KG9wdF9ib2R5KSB7XG5cdFx0aWYgKGNvcmUuaXNEZWYob3B0X2JvZHkpKSB7XG5cdFx0XHR0aGlzLmJvZHlfID0gb3B0X2JvZHk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuYm9keV87XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIGhlYWRlci4gSWYgYSBoZWFkZXIgd2l0aCB0aGUgc2FtZSBuYW1lIGFscmVhZHkgZXhpc3RzLCBpdCB3aWxsIG5vdCBiZVxuXHQgKiBvdmVyd3JpdHRlbiwgYnV0IHRoZSBuZXcgdmFsdWUgd2lsbCBiZSBzdG9yZWQgYXMgd2VsbC4gVGhlIG9yZGVyIGlzIHByZXNlcnZlZC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcblx0ICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdGhlYWRlcihuYW1lLCB2YWx1ZSkge1xuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAyKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzJyk7XG5cdFx0fVxuXHRcdHRoaXMuaGVhZGVyc18uc2V0KG5hbWUsIHZhbHVlKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBGbHVlbnQgZ2V0dGVyIGFuZCBzZXR0ZXIgZm9yIHJlcXVlc3QgaGVhZGVycy5cblx0ICogQHBhcmFtIHtNdWx0aU1hcHxPYmplY3Q9fSBvcHRfaGVhZGVycyBSZXF1ZXN0IGhlYWRlcnMgbGlzdCB0b1xuXHQgKiAgIGJlIHNldC4gSWYgbm9uZSBpcyBnaXZlbiB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgaGVhZGVycyB3aWxsXG5cdCAqICAgYmUgcmV0dXJuZWQuXG5cdCAqIEByZXR1cm4geyFNdWx0aU1hcHxDbGllbnRNZXNzYWdlfSBSZXR1cm5zIG1hcCBvZiByZXF1ZXN0IGhlYWRlcnNcblx0ICogICBpZiBubyBuZXcgdmFsdWUgd2FzIGdpdmVuLiBPdGhlcndpc2UgcmV0dXJucyB0aGUge0BsaW5rIENsaWVudE1lc3NhZ2V9XG5cdCAqICAgb2JqZWN0IGl0c2VsZiwgc28gY2FsbHMgY2FuIGJlIGNoYWluZWQuXG5cdCAqIEBjaGFpbmFibGUgQ2hhaW5hYmxlIHdoZW4gdXNlZCBhcyBzZXR0ZXIuXG5cdCAqL1xuXHRoZWFkZXJzKG9wdF9oZWFkZXJzKSB7XG5cdFx0aWYgKGNvcmUuaXNEZWYob3B0X2hlYWRlcnMpKSB7XG5cdFx0XHRpZiAob3B0X2hlYWRlcnMgaW5zdGFuY2VvZiBNdWx0aU1hcCkge1xuXHRcdFx0XHR0aGlzLmhlYWRlcnNfID0gb3B0X2hlYWRlcnM7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmhlYWRlcnNfLnZhbHVlcyA9IG9wdF9oZWFkZXJzO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG9wdF9oZWFkZXJzO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5oZWFkZXJzXztcblx0fVxuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIHRoZSBib2R5LlxuXHQgKi9cblx0cmVtb3ZlQm9keSgpIHtcblx0XHR0aGlzLmJvZHlfID0gdW5kZWZpbmVkO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENsaWVudE1lc3NhZ2U7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7IGNvcmUgfSBmcm9tICdtZXRhbCc7XG5pbXBvcnQgQ2xpZW50TWVzc2FnZSBmcm9tICcuL0NsaWVudE1lc3NhZ2UnO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBjbGllbnQgcmVzcG9uc2Ugb2JqZWN0LlxuICogQGV4dGVuZHMge0NsaWVudE1lc3NhZ2V9XG4gKi9cbmNsYXNzIENsaWVudFJlc3BvbnNlIGV4dGVuZHMgQ2xpZW50TWVzc2FnZSB7XG5cdGNvbnN0cnVjdG9yKGNsaWVudFJlcXVlc3QpIHtcblx0XHRzdXBlcigpO1xuXHRcdGlmICghY2xpZW50UmVxdWVzdCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdDYW5cXCd0IGNyZWF0ZSByZXNwb25zZSB3aXRob3V0IHJlcXVlc3QnKTtcblx0XHR9XG5cdFx0dGhpcy5jbGllbnRSZXF1ZXN0XyA9IGNsaWVudFJlcXVlc3Q7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyByZXF1ZXN0IHRoYXQgY3JlYXRlZCB0aGlzIHJlc3BvbnNlLlxuXHQgKiBAcmV0dXJuIHshQ2xpZW50UmVxdWVzdH1cblx0ICovXG5cdHJlcXVlc3QoKSB7XG5cdFx0cmV0dXJuIHRoaXMuY2xpZW50UmVxdWVzdF87XG5cdH1cblxuXHQvKipcblx0ICogRmx1ZW50IGdldHRlciBhbmQgc2V0dGVyIGZvciByZXNwb25zZSBzdGF0dXMgY29kZS5cblx0ICogQHBhcmFtIHtudW1iZXI9fSBvcHRfc3RhdHVzQ29kZSBSZXF1ZXN0IHN0YXR1cyBjb2RlIHRvIGJlIHNldC4gSWYgbm9uZSBpcyBnaXZlbixcblx0ICogICB0aGUgY3VycmVudCBzdGF0dXMgY29kZSB2YWx1ZSB3aWxsIGJlIHJldHVybmVkLlxuXHQgKiBAcmV0dXJuIHshQ2xpZW50TWVzc2FnZXxudW1iZXJ9IFJldHVybnMgcmVzcG9uc2Ugc3RhdHVzIGNvZGUgaWYgbm8gbmV3IHZhbHVlIHdhc1xuXHQgKiAgIGdpdmVuLiBPdGhlcndpc2UgcmV0dXJucyB0aGUge0BsaW5rIENsaWVudE1lc3NhZ2V9IG9iamVjdCBpdHNlbGYsIHNvIGNhbGxzIGNhblxuXHQgKiAgIGJlIGNoYWluZWQuXG5cdCAqIEBjaGFpbmFibGUgQ2hhaW5hYmxlIHdoZW4gdXNlZCBhcyBzZXR0ZXIuXG5cdCAqL1xuXHRzdGF0dXNDb2RlKG9wdF9zdGF0dXNDb2RlKSB7XG5cdFx0aWYgKGNvcmUuaXNEZWYob3B0X3N0YXR1c0NvZGUpKSB7XG5cdFx0XHR0aGlzLnN0YXR1c0NvZGVfID0gb3B0X3N0YXR1c0NvZGU7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuc3RhdHVzQ29kZV87XG5cdH1cblxuXHQvKipcblx0ICogRmx1ZW50IGdldHRlciBhbmQgc2V0dGVyIGZvciByZXNwb25zZSBzdGF0dXMgdGV4dC5cblx0ICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfc3RhdHVzVGV4dCBSZXF1ZXN0IHN0YXR1cyB0ZXh0IHRvIGJlIHNldC4gSWYgbm9uZSBpcyBnaXZlbixcblx0ICogICB0aGUgY3VycmVudCBzdGF0dXMgdGV4dCB2YWx1ZSB3aWxsIGJlIHJldHVybmVkLlxuXHQgKiBAcmV0dXJuIHshQ2xpZW50TWVzc2FnZXxudW1iZXJ9IFJldHVybnMgcmVzcG9uc2Ugc3RhdHVzIHRleHQgaWYgbm8gbmV3IHZhbHVlIHdhc1xuXHQgKiAgIGdpdmVuLiBPdGhlcndpc2UgcmV0dXJucyB0aGUge0BsaW5rIENsaWVudE1lc3NhZ2V9IG9iamVjdCBpdHNlbGYsIHNvIGNhbGxzIGNhblxuXHQgKiAgIGJlIGNoYWluZWQuXG5cdCAqIEBjaGFpbmFibGUgQ2hhaW5hYmxlIHdoZW4gdXNlZCBhcyBzZXR0ZXIuXG5cdCAqL1xuXHRzdGF0dXNUZXh0KG9wdF9zdGF0dXNUZXh0KSB7XG5cdFx0aWYgKGNvcmUuaXNEZWYob3B0X3N0YXR1c1RleHQpKSB7XG5cdFx0XHR0aGlzLnN0YXR1c1RleHRfID0gb3B0X3N0YXR1c1RleHQ7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuc3RhdHVzVGV4dF87XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIHJlc3BvbnNlIHN1Y2NlZWRlZC4gQW55IHN0YXR1cyBjb2RlIDJ4eCBvciAzeHggaXMgY29uc2lkZXJlZCB2YWxpZC5cblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICovXG5cdHN1Y2NlZWRlZCgpIHtcblx0XHRyZXR1cm4gdGhpcy5zdGF0dXNDb2RlKCkgPj0gMjAwICYmIHRoaXMuc3RhdHVzQ29kZSgpIDw9IDM5OTtcblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IENsaWVudFJlc3BvbnNlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgQWpheCBmcm9tICdtZXRhbC1hamF4JztcbmltcG9ydCBUcmFuc3BvcnQgZnJvbSAnLi4vVHJhbnNwb3J0JztcbmltcG9ydCBDbGllbnRSZXNwb25zZSBmcm9tICcuLi9DbGllbnRSZXNwb25zZSc7XG5cbi8qKlxuICogVGhlIGltcGxlbWVudGF0aW9uIG9mIGFuIGFqYXggdHJhbnNwb3J0IHRvIGJlIHVzZWQgd2l0aCB7QGxpbmsgV2VEZXBsb3l9LlxuICogQGV4dGVuZHMge1RyYW5zcG9ydH1cbiAqL1xuY2xhc3MgQWpheFRyYW5zcG9ydCBleHRlbmRzIFRyYW5zcG9ydCB7XG5cdC8qKlxuXHQgKiBAaW5oZXJpdERvY1xuXHQgKi9cblx0c2VuZChjbGllbnRSZXF1ZXN0KSB7XG5cdFx0dmFyIGRlZmVycmVkID0gQWpheC5yZXF1ZXN0KFxuXHRcdFx0Y2xpZW50UmVxdWVzdC51cmwoKSwgY2xpZW50UmVxdWVzdC5tZXRob2QoKSwgY2xpZW50UmVxdWVzdC5ib2R5KCksXG5cdFx0XHRjbGllbnRSZXF1ZXN0LmhlYWRlcnMoKSwgY2xpZW50UmVxdWVzdC5wYXJhbXMoKSwgbnVsbCwgZmFsc2UsIGNsaWVudFJlcXVlc3Qud2l0aENyZWRlbnRpYWxzKCkpO1xuXG5cdFx0cmV0dXJuIGRlZmVycmVkLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcblx0XHRcdHZhciBjbGllbnRSZXNwb25zZSA9IG5ldyBDbGllbnRSZXNwb25zZShjbGllbnRSZXF1ZXN0KTtcblx0XHRcdGNsaWVudFJlc3BvbnNlLmJvZHkocmVzcG9uc2UucmVzcG9uc2VUZXh0KTtcblx0XHRcdGNsaWVudFJlc3BvbnNlLnN0YXR1c0NvZGUocmVzcG9uc2Uuc3RhdHVzKTtcblx0XHRcdGNsaWVudFJlc3BvbnNlLnN0YXR1c1RleHQocmVzcG9uc2Uuc3RhdHVzVGV4dCk7XG5cdFx0XHRBamF4LnBhcnNlUmVzcG9uc2VIZWFkZXJzKHJlc3BvbnNlLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKS5mb3JFYWNoKGZ1bmN0aW9uKGhlYWRlcikge1xuXHRcdFx0XHRjbGllbnRSZXNwb25zZS5oZWFkZXIoaGVhZGVyLm5hbWUsIGhlYWRlci52YWx1ZSk7XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiBjbGllbnRSZXNwb25zZTtcblx0XHR9KTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBBamF4VHJhbnNwb3J0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgQWpheFRyYW5zcG9ydCBmcm9tICcuL2Jyb3dzZXIvQWpheFRyYW5zcG9ydCc7XG5cbi8qKlxuICogUHJvdmlkZXMgYSBmYWN0b3J5IGZvciBkYXRhIHRyYW5zcG9ydC5cbiAqL1xuY2xhc3MgVHJhbnNwb3J0RmFjdG9yeSB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHRoaXMudHJhbnNwb3J0cyA9IHt9O1xuXHRcdHRoaXMudHJhbnNwb3J0c1tUcmFuc3BvcnRGYWN0b3J5LkRFRkFVTFRfVFJBTlNQT1JUX05BTUVdID0gVHJhbnNwb3J0RmFjdG9yeVtUcmFuc3BvcnRGYWN0b3J5LkRFRkFVTFRfVFJBTlNQT1JUX05BTUVdO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMge0BsaW5rIFRyYW5zcG9ydEZhY3Rvcnl9IGluc3RhbmNlLlxuXHQgKi9cblx0c3RhdGljIGluc3RhbmNlKCkge1xuXHRcdGlmICghVHJhbnNwb3J0RmFjdG9yeS5pbnN0YW5jZV8pIHtcblx0XHRcdFRyYW5zcG9ydEZhY3RvcnkuaW5zdGFuY2VfID0gbmV3IFRyYW5zcG9ydEZhY3RvcnkoKTtcblx0XHR9XG5cdFx0cmV0dXJuIFRyYW5zcG9ydEZhY3RvcnkuaW5zdGFuY2VfO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgYW4gaW5zdGFuY2Ugb2YgdGhlIHRyYW5zcG9ydCBpbXBsZW1lbnRhdGlvbiB3aXRoIHRoZSBnaXZlbiBuYW1lLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaW1wbGVtZW50YXRpb25OYW1lXG5cdCAqIEByZXR1cm4geyFUcmFuc3BvcnR9XG5cdCAqL1xuXHRnZXQoaW1wbGVtZW50YXRpb25OYW1lKSB7XG5cdFx0dmFyIFRyYW5zcG9ydENsYXNzID0gdGhpcy50cmFuc3BvcnRzW2ltcGxlbWVudGF0aW9uTmFtZV07XG5cblx0XHRpZiAoIVRyYW5zcG9ydENsYXNzKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHJhbnNwb3J0IG5hbWU6ICcgKyBpbXBsZW1lbnRhdGlvbk5hbWUpO1xuXHRcdH1cblxuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4gbmV3IChUcmFuc3BvcnRDbGFzcykoKTtcblx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignQ2FuXFwndCBjcmVhdGUgdHJhbnNwb3J0JywgZXJyKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgZGVmYXVsdCB0cmFuc3BvcnQgaW1wbGVtZW50YXRpb24uXG5cdCAqIEByZXR1cm4geyFUcmFuc3BvcnR9XG5cdCAqL1xuXHRnZXREZWZhdWx0KCkge1xuXHRcdHJldHVybiB0aGlzLmdldChUcmFuc3BvcnRGYWN0b3J5LkRFRkFVTFRfVFJBTlNQT1JUX05BTUUpO1xuXHR9XG59XG5cblRyYW5zcG9ydEZhY3RvcnkuREVGQVVMVF9UUkFOU1BPUlRfTkFNRSA9ICdkZWZhdWx0JztcblxuVHJhbnNwb3J0RmFjdG9yeVtUcmFuc3BvcnRGYWN0b3J5LkRFRkFVTFRfVFJBTlNQT1JUX05BTUVdID0gQWpheFRyYW5zcG9ydDtcblxuZXhwb3J0IGRlZmF1bHQgVHJhbnNwb3J0RmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHsgY29yZSB9IGZyb20gJ21ldGFsJztcbmltcG9ydCBDbGllbnRNZXNzYWdlIGZyb20gJy4vQ2xpZW50TWVzc2FnZSc7XG5pbXBvcnQgeyBNdWx0aU1hcCB9IGZyb20gJ21ldGFsLXN0cnVjdHMnO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBjbGllbnQgcmVxdWVzdCBvYmplY3QuXG4gKiBAZXh0ZW5kcyB7Q2xpZW50TWVzc2FnZX1cbiAqL1xuY2xhc3MgQ2xpZW50UmVxdWVzdCBleHRlbmRzIENsaWVudE1lc3NhZ2Uge1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMucGFyYW1zXyA9IG5ldyBNdWx0aU1hcCgpO1xuXHRcdHRoaXMud2l0aENyZWRlbnRpYWxzXyA9IHRydWU7XG5cdH1cblxuXHQvKipcblx0ICogRmx1ZW50IGdldHRlciBhbmQgc2V0dGVyIGZvciB3aXRoIGNyZWRlbnRpYWxzIG9wdGlvbi5cblx0ICogQHBhcmFtIHtib29sZWFuPX0gb3B0X3dpdGhDcmVkZW50aWFsc1xuXHQgKiBAY2hhaW5hYmxlIENoYWluYWJsZSB3aGVuIHVzZWQgYXMgc2V0dGVyLlxuXHQgKi9cblx0d2l0aENyZWRlbnRpYWxzKG9wdF93aXRoQ3JlZGVudGlhbHMpIHtcblx0XHRpZiAoY29yZS5pc0RlZihvcHRfd2l0aENyZWRlbnRpYWxzKSkge1xuXHRcdFx0dGhpcy53aXRoQ3JlZGVudGlhbHNfID0gISFvcHRfd2l0aENyZWRlbnRpYWxzO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLndpdGhDcmVkZW50aWFsc187XG5cdH1cblxuXHQvKipcblx0ICogRmx1ZW50IGdldHRlciBhbmQgc2V0dGVyIGZvciByZXF1ZXN0IG1ldGhvZC5cblx0ICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfbWV0aG9kIFJlcXVlc3QgbWV0aG9kIHRvIGJlIHNldC4gSWYgbm9uZSBpcyBnaXZlbixcblx0ICogICB0aGUgY3VycmVudCBtZXRob2QgdmFsdWUgd2lsbCBiZSByZXR1cm5lZC5cblx0ICogQHJldHVybiB7IUNsaWVudE1lc3NhZ2V8c3RyaW5nfSBSZXR1cm5zIHJlcXVlc3QgbWV0aG9kIGlmIG5vIG5ldyB2YWx1ZSB3YXNcblx0ICogICBnaXZlbi4gT3RoZXJ3aXNlIHJldHVybnMgdGhlIHtAbGluayBDbGllbnRNZXNzYWdlfSBvYmplY3QgaXRzZWxmLCBzb1xuXHQgKiAgIGNhbGxzIGNhbiBiZSBjaGFpbmVkLlxuXHQgKiBAY2hhaW5hYmxlIENoYWluYWJsZSB3aGVuIHVzZWQgYXMgc2V0dGVyLlxuXHQgKi9cblx0bWV0aG9kKG9wdF9tZXRob2QpIHtcblx0XHRpZiAoY29yZS5pc0RlZihvcHRfbWV0aG9kKSkge1xuXHRcdFx0dGhpcy5tZXRob2RfID0gb3B0X21ldGhvZDtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5tZXRob2RfIHx8IENsaWVudFJlcXVlc3QuREVGQVVMVF9NRVRIT0Q7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIHF1ZXJ5LiBJZiBhIHF1ZXJ5IHdpdGggdGhlIHNhbWUgbmFtZSBhbHJlYWR5IGV4aXN0cywgaXQgd2lsbCBub3Rcblx0ICogYmUgb3ZlcndyaXR0ZW4sIGJ1dCBuZXcgdmFsdWUgd2lsbCBiZSBzdG9yZWQgYXMgd2VsbC4gVGhlIG9yZGVyIGlzIHByZXNlcnZlZC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcblx0ICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdHBhcmFtKG5hbWUsIHZhbHVlKSB7XG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDIpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMnKTtcblx0XHR9XG5cdFx0dGhpcy5wYXJhbXNfLnNldChuYW1lLCB2YWx1ZSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogRmx1ZW50IGdldHRlciBhbmQgc2V0dGVyIGZvciByZXF1ZXN0IHF1ZXJ5c3RyaW5nLlxuXHQgKiBAcGFyYW0ge011bHRpTWFwfE9iamVjdD19IG9wdF9wYXJhbXMgUmVxdWVzdCBxdWVyeXN0cmluZyBtYXAgdG8gYmUgc2V0LlxuXHQgKiAgIElmIG5vbmUgaXMgZ2l2ZW4gdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIHBhcmFtcyB3aWxsIGJlIHJldHVybmVkLlxuXHQgKiBAcmV0dXJuIHshTXVsdGlNYXB8Q2xpZW50TWVzc2FnZX0gUmV0dXJucyBtYXAgb2YgcmVxdWVzdCBxdWVyeXN0cmluZyBpZlxuXHQgKiAgIG5vIG5ldyB2YWx1ZSB3YXMgZ2l2ZW4uIE90aGVyd2lzZSByZXR1cm5zIHRoZSB7QGxpbmsgQ2xpZW50TWVzc2FnZX1cblx0ICogICBvYmplY3QgaXRzZWxmLCBzbyBjYWxscyBjYW4gYmUgY2hhaW5lZC5cblx0ICovXG5cdHBhcmFtcyhvcHRfcGFyYW1zKSB7XG5cdFx0aWYgKGNvcmUuaXNEZWYob3B0X3BhcmFtcykpIHtcblx0XHRcdGlmIChvcHRfcGFyYW1zIGluc3RhbmNlb2YgTXVsdGlNYXApIHtcblx0XHRcdFx0dGhpcy5wYXJhbXNfID0gb3B0X3BhcmFtcztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMucGFyYW1zXy52YWx1ZXMgPSBvcHRfcGFyYW1zO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG9wdF9wYXJhbXM7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLnBhcmFtc187XG5cdH1cblxuXHQvKipcblx0ICogRmx1ZW50IGdldHRlciBhbmQgc2V0dGVyIGZvciByZXF1ZXN0IHVybC5cblx0ICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfdXJsIFJlcXVlc3QgdXJsIHRvIGJlIHNldC4gSWYgbm9uZSBpcyBnaXZlbixcblx0ICogICB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgdXJsIHdpbGwgYmUgcmV0dXJuZWQuXG5cdCAqIEByZXR1cm4geyFDbGllbnRNZXNzYWdlfHN0cmluZ30gUmV0dXJucyByZXF1ZXN0IHVybCBpZiBubyBuZXcgdmFsdWUgd2FzIGdpdmVuLlxuXHQgKiAgIE90aGVyd2lzZSByZXR1cm5zIHRoZSB7QGxpbmsgQ2xpZW50TWVzc2FnZX0gb2JqZWN0IGl0c2VsZiwgc28gY2FsbHMgY2FuIGJlXG5cdCAqICAgY2hhaW5lZC5cblx0ICogQGNoYWluYWJsZSBDaGFpbmFibGUgd2hlbiB1c2VkIGFzIHNldHRlci5cblx0ICovXG5cdHVybChvcHRfdXJsKSB7XG5cdFx0aWYgKGNvcmUuaXNEZWYob3B0X3VybCkpIHtcblx0XHRcdHRoaXMudXJsXyA9IG9wdF91cmw7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMudXJsXztcblx0fVxuXG59XG5cbkNsaWVudFJlcXVlc3QuREVGQVVMVF9NRVRIT0QgPSAnR0VUJztcblxuZXhwb3J0IGRlZmF1bHQgQ2xpZW50UmVxdWVzdDtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IGdsb2JhbHMgZnJvbSAnLi4vZ2xvYmFscy9nbG9iYWxzJztcbmltcG9ydCB7IGNvcmUgfSBmcm9tICdtZXRhbCc7XG5pbXBvcnQgQXV0aCBmcm9tICcuL2F1dGgvQXV0aCc7XG5pbXBvcnQgQXV0aEFwaUhlbHBlciBmcm9tICcuL2F1dGgvQXV0aEFwaUhlbHBlcic7XG5pbXBvcnQgRGF0YUFwaUhlbHBlciBmcm9tICcuL2RhdGEvRGF0YUFwaUhlbHBlcic7XG5pbXBvcnQgQmFzZTY0IGZyb20gJy4uL2NyeXB0L0Jhc2U2NCc7XG5pbXBvcnQgRW1ib2RpZWQgZnJvbSAnLi4vYXBpLXF1ZXJ5L0VtYm9kaWVkJztcbmltcG9ydCBRdWVyeSBmcm9tICcuLi9hcGktcXVlcnkvUXVlcnknO1xuaW1wb3J0IEZpbHRlciBmcm9tICcuLi9hcGktcXVlcnkvRmlsdGVyJztcbmltcG9ydCBUcmFuc3BvcnRGYWN0b3J5IGZyb20gJy4vVHJhbnNwb3J0RmFjdG9yeSc7XG5pbXBvcnQgQ2xpZW50UmVxdWVzdCBmcm9tICcuL0NsaWVudFJlcXVlc3QnO1xuaW1wb3J0IHsgTXVsdGlNYXAgfSBmcm9tICdtZXRhbC1zdHJ1Y3RzJztcbmltcG9ydCBVcmkgZnJvbSAnbWV0YWwtdXJpJztcbmltcG9ydCB7IGFzc2VydFVyaVdpdGhOb1BhdGggfSBmcm9tICcuL2Fzc2VydGlvbnMnO1xuXG5cbnZhciBpbztcblxuLy8gT3B0aW1pc3RpYyBpbml0aWFsaXphdGlvbiBvZiBgaW9gIHJlZmVyZW5jZSBmcm9tIGdsb2JhbCBgZ2xvYmFscy53aW5kb3cuaW9gLlxuaWYgKHR5cGVvZiBnbG9iYWxzLndpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0aW8gPSBnbG9iYWxzLndpbmRvdy5pbztcbn1cblxuLyoqXG4gKiBUaGUgbWFpbiBjbGFzcyBmb3IgbWFraW5nIGFwaSByZXF1ZXN0cy4gU2VuZGluZyByZXF1ZXN0cyByZXR1cm5zIGEgcHJvbWlzZVxuICogdGhhdCBpcyByZXNvbHZlZCB3aGVuIHRoZSByZXNwb25zZSBhcnJpdmVzLiBVc2FnZSBleGFtcGxlOlxuICogYGBgamF2YXNjcmlwdFxuICogV2VEZXBsb3lcbiAqICAgLnVybCgnL2RhdGEvdGFza3MnKVxuICogICAucG9zdCh7ZGVzYzogJ0J1eSBtaWxrbCd9KVxuICogICAudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICogICAgIC8vIEhhbmRsZSByZXNwb25zZSBoZXJlLlxuICogICAgIGNvbnNvbGUubG9nKHJlc3BvbnNlLmJvZHkoKSlcbiAqICAgfSk7XG4gKiBgYGBcbiAqL1xuY2xhc3MgV2VEZXBsb3kge1xuXHQvKipcblx0ICogV2VEZXBsb3kgY29uc3RydWN0b3IgZnVuY3Rpb24uXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIGJhc2UgdXJsLlxuXHQgKiBAcGFyYW0gey4uLnN0cmluZ30gcGF0aHMgQW55IGFtb3VudCBvZiBwYXRocyB0byBiZSBhcHBlbmRlZCB0byB0aGUgYmFzZVxuXHQgKiB1cmwuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0Y29uc3RydWN0b3IodXJsLCAuLi5wYXRocykge1xuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzLCB0cnkgYG5ldyBXZURlcGxveShiYXNlVXJsLCB1cmwpYCcpO1xuXHRcdH1cblxuXHRcdHRoaXMuYXV0aF8gPSBudWxsO1xuXHRcdHRoaXMuYm9keV8gPSBudWxsO1xuXHRcdHRoaXMudXJsXyA9IFVyaS5qb2luUGF0aHModXJsIHx8ICcnLCAuLi5wYXRocyk7XG5cdFx0dGhpcy5oZWFkZXJzXyA9IG5ldyBNdWx0aU1hcCgpO1xuXHRcdHRoaXMucGFyYW1zXyA9IG5ldyBNdWx0aU1hcCgpO1xuXHRcdHRoaXMud2l0aENyZWRlbnRpYWxzXyA9IHRydWU7XG5cblx0XHR0aGlzLmhlYWRlcignQ29udGVudC1UeXBlJywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcblx0XHR0aGlzLmhlYWRlcignWC1SZXF1ZXN0ZWQtV2l0aCcsICdYTUxIdHRwUmVxdWVzdCcpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFN0YXRpYyBmYWN0b3J5IGZvciBjcmVhdGluZyBXZURlcGxveSBkYXRhIGZvciB0aGUgZ2l2ZW4gdXJsLlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9kYXRhVXJsIFRoZSB1cmwgdGhhdCBwb2ludHMgdG8gdGhlIGRhdGEgc2VydmljZXMuXG5cdCAqIEByZXR1cm4gQHJldHVybiB7ZGF0YX0gV2VEZXBsb3kgZGF0YSBpbnN0YW5jZS5cblx0ICovXG5cdHN0YXRpYyBkYXRhKG9wdF9kYXRhVXJsKSB7XG5cdFx0YXNzZXJ0VXJpV2l0aE5vUGF0aChvcHRfZGF0YVVybCwgJ1RoZSBkYXRhIHVybCBzaG91bGQgbm90IGhhdmUgYSBwYXRoJyk7XG5cblx0XHRpZiAoY29yZS5pc1N0cmluZyhvcHRfZGF0YVVybCkpIHtcblx0XHRcdFdlRGVwbG95LmRhdGFVcmxfID0gb3B0X2RhdGFVcmw7XG5cdFx0fVxuXG5cdFx0bGV0IGRhdGEgPSBuZXcgRGF0YUFwaUhlbHBlcihXZURlcGxveSk7XG5cblx0XHRkYXRhLmF1dGgoV2VEZXBsb3kuYXV0aCgpLmN1cnJlbnRVc2VyKTtcblxuXHRcdHJldHVybiBkYXRhO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYXV0aG9yaXphdGlvbiBpbmZvcm1hdGlvbiB0byB0aGlzIHJlcXVlc3QuXG5cdCAqIEBwYXJhbSB7IUF1dGh8c3RyaW5nfSBhdXRoT3JUb2tlbk9yRW1haWwgRWl0aGVyIGFuIHtAbGluayBBdXRofSBpbnN0YW5jZSxcblx0ICogYW4gYXV0aG9yaXphdGlvbiB0b2tlbiwgb3IgdGhlIGVtYWlsLlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9wYXNzd29yZCBJZiBhIGVtYWlsIGlzIGdpdmVuIGFzIHRoZSBmaXJzdCBwYXJhbSxcblx0ICogdGhpcyBzaG91bGQgYmUgdGhlIHBhc3N3b3JkLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRhdXRoKGF1dGhPclRva2VuT3JFbWFpbCwgb3B0X3Bhc3N3b3JkKSB7XG5cdFx0dGhpcy5hdXRoXyA9IGF1dGhPclRva2VuT3JFbWFpbDtcblx0XHRpZiAoISh0aGlzLmF1dGhfIGluc3RhbmNlb2YgQXV0aCkpIHtcblx0XHRcdHRoaXMuYXV0aF8gPSBBdXRoLmNyZWF0ZShhdXRoT3JUb2tlbk9yRW1haWwsIG9wdF9wYXNzd29yZCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFN0YXRpYyBmYWN0b3J5IGZvciBjcmVhdGluZyBXZURlcGxveSBhdXRoIGZvciB0aGUgZ2l2ZW4gdXJsLlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9hdXRoVXJsIFRoZSB1cmwgdGhhdCBwb2ludHMgdG8gdGhlIGF1dGggc2VydmljZS5cblx0ICovXG5cdHN0YXRpYyBhdXRoKG9wdF9hdXRoVXJsKSB7XG5cdFx0aWYgKGNvcmUuaXNTdHJpbmcob3B0X2F1dGhVcmwpKSB7XG5cdFx0XHRXZURlcGxveS5hdXRoVXJsXyA9IG9wdF9hdXRoVXJsO1xuXHRcdH1cblx0XHRpZiAoIVdlRGVwbG95LmF1dGhfKSB7XG5cdFx0XHRXZURlcGxveS5hdXRoXyA9IG5ldyBBdXRoQXBpSGVscGVyKFdlRGVwbG95KTtcblx0XHR9XG5cdFx0cmV0dXJuIFdlRGVwbG95LmF1dGhfO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGJvZHkgdGhhdCB3aWxsIGJlIHNlbnQgd2l0aCB0aGlzIHJlcXVlc3QuXG5cdCAqIEBwYXJhbSB7Kn0gYm9keVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRib2R5KGJvZHkpIHtcblx0XHR0aGlzLmJvZHlfID0gYm9keTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gYm9keSBvYmplY3QgdG8gcXVlcnkgcGFyYW1zLlxuXHQgKiBAcGFyYW0geyFDbGllbnRSZXF1ZXN0fSBjbGllbnRSZXF1ZXN0IENsaWVudCByZXF1ZXN0LlxuXHQgKiBAcGFyYW0geyp9IGJvZHlcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0Y29udmVydEJvZHlUb1BhcmFtc18oY2xpZW50UmVxdWVzdCwgYm9keSkge1xuXHRcdGlmIChjb3JlLmlzU3RyaW5nKGJvZHkpKSB7XG5cdFx0XHRib2R5ID0ge1xuXHRcdFx0XHRib2R5OiBib2R5XG5cdFx0XHR9O1xuXHRcdH0gZWxzZSBpZiAoYm9keSBpbnN0YW5jZW9mIEVtYm9kaWVkKSB7XG5cdFx0XHRib2R5ID0gYm9keS5ib2R5KCk7XG5cdFx0fVxuXHRcdE9iamVjdC5rZXlzKGJvZHkgfHwge30pLmZvckVhY2gobmFtZSA9PiBjbGllbnRSZXF1ZXN0LnBhcmFtKG5hbWUsIGJvZHlbbmFtZV0pKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGNsaWVudCByZXF1ZXN0IGFuZCBlbmNvZGUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2Rcblx0ICogQHBhcmFtIHsqfSBib2R5XG5cdCAqIEByZXR1cm4geyFDbGllbnRSZXF1ZXN0fSBDbGllbnQgcmVxdWVzdC5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0Y3JlYXRlQ2xpZW50UmVxdWVzdF8obWV0aG9kLCBib2R5KSB7XG5cdFx0Y29uc3QgY2xpZW50UmVxdWVzdCA9IG5ldyBDbGllbnRSZXF1ZXN0KCk7XG5cblx0XHRjbGllbnRSZXF1ZXN0LmJvZHkoYm9keSB8fCB0aGlzLmJvZHlfKTtcblxuXHRcdGlmICghY29yZS5pc0RlZkFuZE5vdE51bGwoY2xpZW50UmVxdWVzdC5ib2R5KCkpKSB7XG5cdFx0XHRpZiAodGhpcy5mb3JtRGF0YV8pIHtcblx0XHRcdFx0Y2xpZW50UmVxdWVzdC5ib2R5KHRoaXMuZm9ybURhdGFfKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRjbGllbnRSZXF1ZXN0Lm1ldGhvZChtZXRob2QpO1xuXHRcdGNsaWVudFJlcXVlc3QuaGVhZGVycyh0aGlzLmhlYWRlcnMoKSk7XG5cdFx0Y2xpZW50UmVxdWVzdC5wYXJhbXModGhpcy5wYXJhbXMoKSk7XG5cdFx0Y2xpZW50UmVxdWVzdC51cmwodGhpcy51cmwoKSk7XG5cdFx0Y2xpZW50UmVxdWVzdC53aXRoQ3JlZGVudGlhbHModGhpcy53aXRoQ3JlZGVudGlhbHNfKTtcblxuXHRcdHRoaXMuZW5jb2RlKGNsaWVudFJlcXVlc3QpO1xuXG5cdFx0cmV0dXJuIGNsaWVudFJlcXVlc3Q7XG5cdH1cblxuXHQvKipcblx0ICogRGVjb2RlcyBjbGllbnRSZXNwb25zZSBib2R5LCBwYXJzaW5nIHRoZSBib2R5IGZvciBleGFtcGxlLlxuXHQgKiBAcGFyYW0geyFDbGllbnRSZXNwb25zZX0gY2xpZW50UmVzcG9uc2UgVGhlIHJlc3BvbnNlIG9iamVjdCB0byBiZVxuXHQgKiBkZWNvZGVkLlxuXHQgKiBAcmV0dXJuIHshQ2xpZW50UmVzcG9uc2V9IFRoZSBkZWNvZGVkIHJlc3BvbnNlLlxuXHQgKi9cblx0ZGVjb2RlKGNsaWVudFJlc3BvbnNlKSB7XG5cdFx0aWYgKFdlRGVwbG95LmlzQ29udGVudFR5cGVKc29uKGNsaWVudFJlc3BvbnNlKSkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Y2xpZW50UmVzcG9uc2UuYm9keShKU09OLnBhcnNlKGNsaWVudFJlc3BvbnNlLmJvZHkoKSkpO1xuXHRcdFx0fSBjYXRjaCAoZXJyKSB7fVxuXHRcdH1cblx0XHRyZXR1cm4gY2xpZW50UmVzcG9uc2U7XG5cdH1cblxuXHQvKipcblx0ICogU2VuZHMgbWVzc2FnZSB3aXRoIHRoZSBERUxFVEUgaHR0cCB2ZXJiLlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9ib2R5IENvbnRlbnQgdG8gYmUgc2VudCBhcyB0aGUgcmVxdWVzdCdzIGJvZHkuXG5cdCAqIEByZXR1cm4geyFDYW5jZWxsYWJsZVByb21pc2V9XG5cdCAqL1xuXHRkZWxldGUob3B0X2JvZHkpIHtcblx0XHRyZXR1cm4gdGhpcy5zZW5kQXN5bmMoJ0RFTEVURScsIG9wdF9ib2R5KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBFbmNvZGVzIHRoZSBnaXZlbiB7QGxpbmsgQ2xpZW50UmVxdWVzdH0sIGNvbnZlcnRpbmcgaXRzIGJvZHkgdG8gYW5cblx0ICogYXBwcm9wcmlhdGUgZm9ybWF0IGZvciBleGFtcGxlLlxuXHQgKiBAcGFyYW0geyFDbGllbnRSZXF1ZXN0fSBjbGllbnRSZXF1ZXN0IFRoZSByZXF1ZXN0IG9iamVjdCB0byBlbmNvZGUuXG5cdCAqIEByZXR1cm4geyFDbGllbnRSZXF1ZXN0fSBUaGUgZW5jb2RlZCByZXF1ZXN0LlxuXHQgKi9cblx0ZW5jb2RlKGNsaWVudFJlcXVlc3QpIHtcblx0XHRsZXQgYm9keSA9IGNsaWVudFJlcXVlc3QuYm9keSgpO1xuXG5cdFx0aWYgKGNvcmUuaXNFbGVtZW50KGJvZHkpKSB7XG5cdFx0XHRib2R5ID0gbmV3IEZvcm1EYXRhKGJvZHkpO1xuXHRcdFx0Y2xpZW50UmVxdWVzdC5ib2R5KGJvZHkpO1xuXHRcdH1cblxuXHRcdGJvZHkgPSB0aGlzLm1heWJlV3JhcFdpdGhRdWVyeV8oYm9keSk7XG5cdFx0aWYgKGNsaWVudFJlcXVlc3QubWV0aG9kKCkgPT09ICdHRVQnKSB7XG5cdFx0XHR0aGlzLmNvbnZlcnRCb2R5VG9QYXJhbXNfKGNsaWVudFJlcXVlc3QsIGJvZHkpO1xuXHRcdFx0Y2xpZW50UmVxdWVzdC5yZW1vdmVCb2R5KCk7XG5cdFx0XHRib2R5ID0gbnVsbDtcblx0XHR9XG5cblx0XHRpZiAodHlwZW9mIEZvcm1EYXRhICE9PSAndW5kZWZpbmVkJyAmJiBib2R5IGluc3RhbmNlb2YgRm9ybURhdGEpIHtcblx0XHRcdGNsaWVudFJlcXVlc3QuaGVhZGVycygpLnJlbW92ZSgnY29udGVudC10eXBlJyk7XG5cdFx0fSBlbHNlIGlmIChib2R5IGluc3RhbmNlb2YgRW1ib2RpZWQpIHtcblx0XHRcdGNsaWVudFJlcXVlc3QuYm9keShib2R5LnRvU3RyaW5nKCkpO1xuXHRcdH0gZWxzZSBpZiAoV2VEZXBsb3kuaXNDb250ZW50VHlwZUpzb24oY2xpZW50UmVxdWVzdCkpIHtcblx0XHRcdGNsaWVudFJlcXVlc3QuYm9keShKU09OLnN0cmluZ2lmeShjbGllbnRSZXF1ZXN0LmJvZHkoKSkpO1xuXHRcdH1cblxuXHRcdHRoaXMuZW5jb2RlUGFyYW1zXyhjbGllbnRSZXF1ZXN0KTtcblx0XHR0aGlzLnJlc29sdmVBdXRoZW50aWNhdGlvbl8oY2xpZW50UmVxdWVzdCk7XG5cblx0XHRyZXR1cm4gY2xpZW50UmVxdWVzdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBFbmNvZGVzIHRoZSBwYXJhbXMgZm9yIHRoZSBnaXZlbiByZXF1ZXN0LCBhY2NvcmRpbmcgdG8gdGhlaXIgdHlwZXMuXG5cdCAqIEBwYXJhbSB7IUNsaWVudFJlcXVlc3R9IGNsaWVudFJlcXVlc3Rcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0ZW5jb2RlUGFyYW1zXyhjbGllbnRSZXF1ZXN0KSB7XG5cdFx0bGV0IHBhcmFtcyA9IGNsaWVudFJlcXVlc3QucGFyYW1zKCk7XG5cdFx0cGFyYW1zLm5hbWVzKCkuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG5cdFx0XHRsZXQgdmFsdWVzID0gcGFyYW1zLmdldEFsbChuYW1lKTtcblx0XHRcdHZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xuXHRcdFx0XHRpZiAodmFsdWUgaW5zdGFuY2VvZiBFbWJvZGllZCkge1xuXHRcdFx0XHRcdHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcblx0XHRcdFx0fSBlbHNlIGlmIChjb3JlLmlzT2JqZWN0KHZhbHVlKSB8fCAodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YWx1ZXNbaW5kZXhdID0gdmFsdWU7XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEga2V5L3ZhbHVlIHBhaXIgdG8gYmUgc2VudCB2aWEgdGhlIGJvZHkgaW4gYSBgbXVsdGlwYXJ0L2Zvcm0tZGF0YWAgZm9ybWF0LlxuXHQgKiBJZiB0aGUgYm9keSBpcyBzZXQgYnkgb3RoZXIgbWVhbnMgKGZvciBleGFtcGxlLCB0aHJvdWdoIHRoZSBgYm9keWAgbWV0aG9kKSwgdGhpc1xuXHQgKiB3aWxsIGJlIGlnbm9yZWQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWVcblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0Zm9ybShuYW1lLCB2YWx1ZSkge1xuXHRcdGlmICh0eXBlb2YgRm9ybURhdGEgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2Zvcm0oKSBpcyBvbmx5IGF2YWlsYWJsZSB3aGVuIEZvcm1EYXRhIEFQSSBpcyBhdmFpbGFibGUuJyk7XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLmZvcm1EYXRhXykge1xuXHRcdFx0dGhpcy5mb3JtRGF0YV8gPSBuZXcgRm9ybURhdGEoKTtcblx0XHR9XG5cdFx0dGhpcy5mb3JtRGF0YV8uYXBwZW5kKG5hbWUsIHZhbHVlKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBTZW5kcyBtZXNzYWdlIHdpdGggdGhlIEdFVCBodHRwIHZlcmIuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF9wYXJhbXMgUGFyYW1zIHRvIGJlIGFkZGVkIHRvIHRoZSByZXF1ZXN0IHVybC5cblx0ICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZX1cblx0ICovXG5cdGdldChvcHRfcGFyYW1zKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2VuZEFzeW5jKCdHRVQnLCBvcHRfcGFyYW1zKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgaGVhZGVyLiBJZiB0aGUgaGVhZGVyIHdpdGggdGhlIHNhbWUgbmFtZSBhbHJlYWR5IGV4aXN0cywgaXQgd2lsbFxuXHQgKiBub3QgYmUgb3ZlcndyaXR0ZW4sIGJ1dCBuZXcgdmFsdWUgd2lsbCBiZSBzdG9yZWQuIFRoZSBvcmRlciBpcyBwcmVzZXJ2ZWQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEhlYWRlciBrZXkuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgSGVhZGVyIHZhbHVlLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRoZWFkZXIobmFtZSwgdmFsdWUpIHtcblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMikge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cycpO1xuXHRcdH1cblx0XHR0aGlzLmhlYWRlcnNfLnNldChuYW1lLCB2YWx1ZSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgaGVhZGVycy5cblx0ICogQHJldHVybiB7IU11bHRpTWFwfVxuXHQgKi9cblx0aGVhZGVycygpIHtcblx0XHRyZXR1cm4gdGhpcy5oZWFkZXJzXztcblx0fVxuXG5cdC8qKlxuXHQgKiBXcmFwcyB0aGUgZ2l2ZW4gYEVtYm9kaWVkYCBpbnN0YW5jZSB3aXRoIGEge0BsaW5rIFF1ZXJ5fSBpbnN0YW5jZSBpZiBuZWVkZWQuXG5cdCAqIEBwYXJhbSB7RW1ib2RpZWR9IGVtYm9kaWVkXG5cdCAqIEByZXR1cm4ge0VtYm9kaWVkfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRtYXliZVdyYXBXaXRoUXVlcnlfKGVtYm9kaWVkKSB7XG5cdFx0aWYgKGVtYm9kaWVkIGluc3RhbmNlb2YgRmlsdGVyKSB7XG5cdFx0XHRlbWJvZGllZCA9IFF1ZXJ5LmZpbHRlcihlbWJvZGllZCk7XG5cdFx0fVxuXHRcdHJldHVybiBlbWJvZGllZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgcXVlcnkuIElmIHRoZSBxdWVyeSB3aXRoIHRoZSBzYW1lIG5hbWUgYWxyZWFkeSBleGlzdHMsIGl0IHdpbGwgbm90XG5cdCAqIGJlIG92ZXJ3cml0dGVuLCBidXQgbmV3IHZhbHVlIHdpbGwgYmUgc3RvcmVkLiBUaGUgb3JkZXIgaXMgcHJlc2VydmVkLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBQYXJhbSBrZXkuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgUGFyYW0gdmFsdWUuXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdHBhcmFtKG5hbWUsIHZhbHVlKSB7XG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDIpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMnKTtcblx0XHR9XG5cdFx0dGhpcy5wYXJhbXNfLnNldChuYW1lLCB2YWx1ZSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgcXVlcnkgc3RyaW5ncyBtYXAuXG5cdCAqIEByZXR1cm4geyFNdWx0aU1hcH1cblx0ICovXG5cdHBhcmFtcygpIHtcblx0XHRyZXR1cm4gdGhpcy5wYXJhbXNfO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNlbmRzIG1lc3NhZ2Ugd2l0aCB0aGUgUEFUQ0ggaHR0cCB2ZXJiLlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9ib2R5IENvbnRlbnQgdG8gYmUgc2VudCBhcyB0aGUgcmVxdWVzdCdzIGJvZHkuXG5cdCAqIEByZXR1cm4geyFDYW5jZWxsYWJsZVByb21pc2V9XG5cdCAqL1xuXHRwYXRjaChvcHRfYm9keSkge1xuXHRcdHJldHVybiB0aGlzLnNlbmRBc3luYygnUEFUQ0gnLCBvcHRfYm9keSk7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgV2VEZXBsb3l9IGluc3RhbmNlIGZvciBoYW5kbGluZyB0aGUgdXJsIHJlc3VsdGluZyBpbiB0aGVcblx0ICogdW5pb24gb2YgdGhlIGN1cnJlbnQgdXJsIHdpdGggdGhlIGdpdmVuIHBhdGhzLlxuXHQgKiBAcGFyYW0gey4uLnN0cmluZ30gcGF0aHMgQW55IG51bWJlciBvZiBwYXRocy5cblx0ICogQHJldHVybiB7IVdlRGVwbG95fSBBIG5ldyB7QGxpbmsgV2VEZXBsb3l9IGluc3RhbmNlIGZvciBoYW5kbGluZyB0aGUgZ2l2ZW4gcGF0aHMuXG5cdCAqL1xuXHRwYXRoKC4uLnBhdGhzKSB7XG5cdFx0cmV0dXJuIG5ldyBXZURlcGxveSh0aGlzLnVybCgpLCAuLi5wYXRocykudXNlKHRoaXMuY3VzdG9tVHJhbnNwb3J0Xyk7XG5cdH1cblxuXHQvKipcblx0ICogU2VuZHMgbWVzc2FnZSB3aXRoIHRoZSBQT1NUIGh0dHAgdmVyYi5cblx0ICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfYm9keSBDb250ZW50IHRvIGJlIHNlbnQgYXMgdGhlIHJlcXVlc3QncyBib2R5LlxuXHQgKiBAcmV0dXJuIHshQ2FuY2VsbGFibGVQcm9taXNlfVxuXHQgKi9cblx0cG9zdChvcHRfYm9keSkge1xuXHRcdHJldHVybiB0aGlzLnNlbmRBc3luYygnUE9TVCcsIG9wdF9ib2R5KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZW5kcyBtZXNzYWdlIHdpdGggdGhlIFBVVCBodHRwIHZlcmIuXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X2JvZHkgQ29udGVudCB0byBiZSBzZW50IGFzIHRoZSByZXF1ZXN0J3MgYm9keS5cblx0ICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZX1cblx0ICovXG5cdHB1dChvcHRfYm9keSkge1xuXHRcdHJldHVybiB0aGlzLnNlbmRBc3luYygnUFVUJywgb3B0X2JvZHkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgdGhlIGF1dGhlbnRpY2F0aW9uIGluZm9ybWF0aW9uIHRvIHRoZSByZXF1ZXN0LlxuXHQgKiBAcGFyYW0geyFDbGllbnRSZXF1ZXN0fSBjbGllbnRSZXF1ZXN0XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHJlc29sdmVBdXRoZW50aWNhdGlvbl8oY2xpZW50UmVxdWVzdCkge1xuXHRcdGlmICghdGhpcy5hdXRoXykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAodGhpcy5hdXRoXy5oYXNUb2tlbigpKSB7XG5cdFx0XHRjbGllbnRSZXF1ZXN0LmhlYWRlcignQXV0aG9yaXphdGlvbicsICdCZWFyZXIgJyArIHRoaXMuYXV0aF8udG9rZW4pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zdCBjcmVkZW50aWFscyA9IHRoaXMuYXV0aF8uZW1haWwgKyAnOicgKyB0aGlzLmF1dGhfLnBhc3N3b3JkO1xuXHRcdFx0Y2xpZW50UmVxdWVzdC5oZWFkZXIoJ0F1dGhvcml6YXRpb24nLCAnQmFzaWMgJyArIEJhc2U2NC5lbmNvZGVTdHJpbmcoY3JlZGVudGlhbHMpKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogVXNlcyB0cmFuc3BvcnQgdG8gc2VuZCByZXF1ZXN0IHdpdGggZ2l2ZW4gbWV0aG9kIG5hbWUgYW5kIGJvZHlcblx0ICogYXN5bmNocm9ub3VzbHkuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2QgVGhlIEhUVFAgbWV0aG9kIHRvIGJlIHVzZWQgd2hlbiBzZW5kaW5nIGRhdGEuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBib2R5IENvbnRlbnQgdG8gYmUgc2VudCBhcyB0aGUgcmVxdWVzdCdzIGJvZHkuXG5cdCAqIEByZXR1cm4geyFDYW5jZWxsYWJsZVByb21pc2V9IERlZmVycmVkIHJlcXVlc3QuXG5cdCAqL1xuXHRzZW5kQXN5bmMobWV0aG9kLCBib2R5KSB7XG5cdFx0Y29uc3QgdHJhbnNwb3J0ID0gdGhpcy5jdXN0b21UcmFuc3BvcnRfIHx8IFRyYW5zcG9ydEZhY3RvcnkuaW5zdGFuY2UoKS5nZXREZWZhdWx0KCk7XG5cblx0XHRjb25zdCBjbGllbnRSZXF1ZXN0ID0gdGhpcy5jcmVhdGVDbGllbnRSZXF1ZXN0XyhtZXRob2QsIGJvZHkpO1xuXG5cdFx0cmV0dXJuIHRyYW5zcG9ydC5zZW5kKGNsaWVudFJlcXVlc3QpLnRoZW4odGhpcy5kZWNvZGUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHNvY2tldCB0cmFuc3BvcnRcblx0ICogQHBhcmFtIHtPYmplY3R9IHNvY2tldCBpbXBsZW1lbnRhdGlvbiBvYmplY3QuXG5cdCAqL1xuXHRzdGF0aWMgc29ja2V0KHNvY2tldCkge1xuXHRcdGlvID0gc29ja2V0O1xuXHR9XG5cblx0LyoqXG5cdCAqIFN0YXRpYyBmYWN0b3J5IGZvciBjcmVhdGluZyBXZURlcGxveSBjbGllbnQgZm9yIHRoZSBnaXZlbiB1cmwuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIHVybCB0aGF0IHRoZSBjbGllbnQgc2hvdWxkIHVzZSBmb3Igc2VuZGluZyByZXF1ZXN0cy5cblx0ICovXG5cdHN0YXRpYyB1cmwodXJsKSB7XG5cdFx0cmV0dXJuIG5ldyBXZURlcGxveSh1cmwpLnVzZSh0aGlzLmN1c3RvbVRyYW5zcG9ydF8pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIFVSTCB1c2VkIGJ5IHRoaXMgY2xpZW50LlxuXHQgKi9cblx0dXJsKCkge1xuXHRcdHJldHVybiB0aGlzLnVybF87XG5cdH1cblxuXHQvKipcblx0ICogU3BlY2lmaWVzIHtAbGluayBUcmFuc3BvcnR9IGltcGxlbWVudGF0aW9uLlxuXHQgKiBAcGFyYW0geyFUcmFuc3BvcnR9IHRyYW5zcG9ydCBUaGUgdHJhbnNwb3J0IGltcGxlbWVudGF0aW9uIHRoYXQgc2hvdWxkIGJlXG5cdCAqIHVzZWQuXG5cdCAqL1xuXHR1c2UodHJhbnNwb3J0KSB7XG5cdFx0dGhpcy5jdXN0b21UcmFuc3BvcnRfID0gdHJhbnNwb3J0O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgbmV3IHNvY2tldC5pbyBpbnN0YW5jZS4gVGhlIHBhcmFtZXRlcnMgcGFzc2VkIHRvIHNvY2tldC5pb1xuXHQgKiBjb25zdHJ1Y3RvciB3aWxsIGJlIHByb3ZpZGVkOlxuXHQgKlxuXHQgKiBgYGBqYXZhc2NyaXB0XG5cdCAqIFdlRGVwbG95LnVybCgnaHR0cDovL2RvbWFpbjo4MDgwL3BhdGgvYScpLndhdGNoKHtpZDogJ215SWQnfSwge2ZvbzogdHJ1ZX0pO1xuXHQgKiAvLyBFcXVhbHM6XG5cdCAqIGlvKCdkb21haW46ODA4MC8/dXJsPXBhdGglMkZhJTNGaWQlM0RteUlkJywge2ZvbzogdHJ1ZX0pO1xuXHQgKiBgYGBcblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3Q9fSBvcHRfcGFyYW1zIFBhcmFtcyB0byBiZSBzZW50IHdpdGggdGhlIFNvY2tldCBJTyByZXF1ZXN0LlxuXHQgKiBAcGFyYW0ge09iamVjdD19IG9wdF9vcHRpb25zIE9iamVjdCB3aXRoIFNvY2tldCBJTyBvcHRpb25zLlxuXHQgKiBAcmV0dXJuIHshaW99IFNvY2tldCBJTyByZWZlcmVuY2UuIFNlcnZlciBldmVudHMgY2FuIGJlIGxpc3RlbmVkIG9uIGl0LlxuXHQgKi9cblx0d2F0Y2gob3B0X3BhcmFtcywgb3B0X29wdGlvbnMpIHtcblx0XHRpZiAodHlwZW9mIGlvID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdTb2NrZXQuaW8gY2xpZW50IG5vdCBsb2FkZWQnKTtcblx0XHR9XG5cblx0XHRjb25zdCBjbGllbnRSZXF1ZXN0ID0gdGhpcy5jcmVhdGVDbGllbnRSZXF1ZXN0XygnR0VUJywgb3B0X3BhcmFtcyk7XG5cdFx0Y29uc3QgdXJpID0gbmV3IFVyaShjbGllbnRSZXF1ZXN0LnVybCgpKTtcblx0XHR1cmkuYWRkUGFyYW1ldGVyc0Zyb21NdWx0aU1hcChjbGllbnRSZXF1ZXN0LnBhcmFtcygpKTtcblxuXHRcdG9wdF9vcHRpb25zID0gb3B0X29wdGlvbnMgfHwge1xuXHRcdFx0Zm9yY2VOZXc6IHRydWVcblx0XHR9O1xuXHRcdG9wdF9vcHRpb25zLnF1ZXJ5ID0gJ3VybD0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHVyaS5nZXRQYXRobmFtZSgpICsgdXJpLmdldFNlYXJjaCgpKTtcblx0XHRvcHRfb3B0aW9ucy5wYXRoID0gb3B0X29wdGlvbnMucGF0aCB8fCB1cmkuZ2V0UGF0aG5hbWUoKTtcblxuXHRcdHJldHVybiBpbyh1cmkuZ2V0SG9zdCgpLCBvcHRfb3B0aW9ucyk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtib29sZWFufSBvcHRfd2l0aENyZWRlbnRpYWxzXG5cdCAqL1xuXHR3aXRoQ3JlZGVudGlhbHMod2l0aENyZWRlbnRpYWxzKSB7XG5cdFx0dGhpcy53aXRoQ3JlZGVudGlhbHNfID0gISF3aXRoQ3JlZGVudGlhbHM7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn1cblxuV2VEZXBsb3kuaXNDb250ZW50VHlwZUpzb24gPSBmdW5jdGlvbihjbGllbnRNZXNzYWdlKSB7XG5cdGNvbnN0IGNvbnRlbnRUeXBlID0gY2xpZW50TWVzc2FnZS5oZWFkZXJzKCkuZ2V0KCdjb250ZW50LXR5cGUnKSB8fCAnJztcblx0cmV0dXJuIGNvbnRlbnRUeXBlLmluZGV4T2YoJ2FwcGxpY2F0aW9uL2pzb24nKSA9PT0gMDtcbn07XG5cbldlRGVwbG95LmF1dGhfID0gbnVsbDtcbldlRGVwbG95LmF1dGhVcmxfID0gJyc7XG5XZURlcGxveS5kYXRhXyA9IG51bGw7XG5XZURlcGxveS5kYXRhVXJsXyA9ICcnO1xuXG5leHBvcnQgZGVmYXVsdCBXZURlcGxveTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IGdsb2JhbHMgZnJvbSAnLi4vZ2xvYmFscy9nbG9iYWxzJztcbmltcG9ydCBGaWx0ZXIgZnJvbSAnLi4vYXBpLXF1ZXJ5L0ZpbHRlcic7XG5pbXBvcnQgR2VvIGZyb20gJy4uL2FwaS1xdWVyeS9HZW8nO1xuaW1wb3J0IFdlRGVwbG95IGZyb20gJy4uL2FwaS9XZURlcGxveSc7XG5pbXBvcnQgUXVlcnkgZnJvbSAnLi4vYXBpLXF1ZXJ5L1F1ZXJ5JztcbmltcG9ydCBSYW5nZSBmcm9tICcuLi9hcGktcXVlcnkvUmFuZ2UnO1xuXG5nbG9iYWxzLndpbmRvdy5GaWx0ZXIgPSBGaWx0ZXI7XG5nbG9iYWxzLndpbmRvdy5HZW8gPSBHZW87XG5nbG9iYWxzLndpbmRvdy5RdWVyeSA9IFF1ZXJ5O1xuZ2xvYmFscy53aW5kb3cuUmFuZ2UgPSBSYW5nZTtcbmdsb2JhbHMud2luZG93LldlRGVwbG95ID0gV2VEZXBsb3k7XG5cbmV4cG9ydCB7IEZpbHRlciwgR2VvLCBRdWVyeSwgUmFuZ2UsIFdlRGVwbG95IH07XG5leHBvcnQgZGVmYXVsdCBXZURlcGxveTtcbiJdfQ==
